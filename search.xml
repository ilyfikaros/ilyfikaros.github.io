<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo自带markdown渲染器渲染括号问题</title>
      <link href="/post/ee62c796.html"/>
      <url>/post/ee62c796.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-问题发现"><a class="markdownIt-Anchor" href="#一-问题发现"></a> 一、问题发现</h2><p>Hexo是一个基于Node.js的静态网页博客框架，使用Markdown文档生成网页文章，对程序员比较友好。笔者前段时间使用Hexo搭建博客，使用一段时间后发现其生成的文章，存在括号内的内容为网址时会变成乱码超链接的现象，影响阅读体验。<br />笔者搭建博客时<strong>Node.js</strong>的版本为<em>12.19.0</em>，<strong>hexo-cli</strong>的版本为<em>4.3.0</em>，经过上网搜索和排除博客安装的插件影响后依旧无法解决问题。在重装博客之后，笔者立即进行测试，发现问题依旧存在。笔者之前曾在CSDN和自己Wodrpress网站上发布过相同的Markdown格式的文章，均未出现此类问题，于是怀疑是Hexo自带的Markdown渲染器的问题，在先后尝试修改文章格式和更换Markdown渲染插件等方法后，解决了该问题。</p><h2 id="二-问题描述"><a class="markdownIt-Anchor" href="#二-问题描述"></a> 二、问题描述</h2><p>Hexo原生自带的渲染器为<strong>hexo-renderer-marked</strong>，笔者在重装博客之后，立即进行了如下测试：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;test&quot;    <span class="variable">%新建测试文档test.md，并填入测试内容%</span></span><br><span class="line"></span><br><span class="line">hexo cl; hexo s         <span class="variable">%启动服务器，观察结果%</span></span><br></pre></td></tr></table></figure><p>test.md的正文内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">中文括号：</span><br><span class="line">括号后跟空格（www.baidu.com） 内容为网址</span><br><span class="line">括号后不跟空格（www.baidu.com）内容为网址</span><br><span class="line">括号后跟空格（你好） 内容为文字</span><br><span class="line">括号后不跟空格（你好）内容为文字</span><br><span class="line"></span><br><span class="line">英文括号：</span><br><span class="line">Parentheses followed by spaces(www.bing.com) The content is the URL</span><br><span class="line">The parentheses are not followed by spaces(www.bing.com)The content is the URL</span><br><span class="line">Parentheses followed by spaces(www.bing.com) The content is text</span><br><span class="line">Parentheses are not followed by spaces(www.bing.com)The content is text</span><br></pre></td></tr></table></figure><p>网页显示结果如下：<br /><img src="https://bimg.ilyfikaros.com/img/1.png" alt="" /></p><p>括号内的内容为英文网址时，如果括号直接跟文字，会出现尾部右括号连同文字一起被渲染成乱码超链接的现象。并且在右括号为中文括号的情况下，无论右括号后是否带空格，右括号都会被编入超链接形成乱码网址。</p><h2 id="三-解决方式"><a class="markdownIt-Anchor" href="#三-解决方式"></a> 三、解决方式</h2><h3 id="1修改文章格式禁止渲染不推荐"><a class="markdownIt-Anchor" href="#1修改文章格式禁止渲染不推荐"></a> 1.修改文章格式禁止渲染（不推荐）</h3><p>笔者在网上搜寻解决Markdown渲染问题的信息时，大致找到两种方案，都不太靠谱。<br />一是可以禁止渲染部分Markdown文档的内容。如下图所示，添加一个禁止渲染的代码将出问题的部分给包起来，或者添加双冒号。由于笔者不了解前端，尝试该方法并不奏效；<br /><img src="https://bimg.ilyfikaros.com/img/2.png" alt="" /></p><p>二是参考Hexo官方<a href="https://hexo.io/zh-cn/api/rendering.html">文档</a>，设置博客根目录下的<code>_config.yml</code>配置文件的<code>skip_render</code>参数，使渲染器不渲染指定文章。</p><h3 id="2更换markdown渲染器推荐"><a class="markdownIt-Anchor" href="#2更换markdown渲染器推荐"></a> 2.更换Markdown渲染器（推荐）</h3><p>除了Hexo自带的Markdown渲染器之外，Hexo常用的Markdown渲染器还有hexo-renderer-kramed，hexo-renderer-pandoc，hexo-renderer-markdown-it以及hexo-renderer-markdown-it-plus。笔者经过一番尝试之后选择了hexo-renderer-markdown-it-plus，避免了原始渲染器的问题。<br />更换渲染器方式如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked -—save  <span class="variable">%卸载Hexo自带渲染插件%</span></span><br><span class="line">npm i hexo-renderer-markdown-it-plus -—save <span class="variable">%安装目标插件%</span></span><br></pre></td></tr></table></figure><p>更换渲染器之后，参照该插件的NPM<a href="https://www.npmjs.com/package/hexo-renderer-markdown-it-plus">文档</a>，在本地博客根目录的<code>_config.yml</code>文件底部添加如下参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown_it_plus:</span></span><br><span class="line">    <span class="attr">highlight:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">langPrefix:</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">“”‘’</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">markdown-it-mark</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>更换渲染器插件后，输入<code>hexo cl</code>以及<code>hexo s</code>重启项目，问题解决<br /><img src="https://bimg.ilyfikaros.com/img/3.png" alt="" /></p><h2 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h2><p>Ling星轨迹原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：Ling星轨迹（<a href="http://www.ilyfikaros.com">www.ilyfikaros.com</a>）<br />作者：凌亦零</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务基础</title>
      <link href="/post/ac1033c5.html"/>
      <url>/post/ac1033c5.html</url>
      
        <content type="html"><![CDATA[<h2 id="事务的提出"><a class="markdownIt-Anchor" href="#事务的提出"></a> 事务的提出</h2><p>MySQL事务（transaction）主要用于处理敏感的、复杂度高的数据。处理逻辑为query语句要么一块执行，要么全部回滚。例如网上购物时，只有确认付款之后商品才会到个人账户，在此之前全部过程顾客不持有商品。<br />注意：MySQL事务只有在指定数据库引擎为innodb时可用。</p><h2 id="事务的基本用法"><a class="markdownIt-Anchor" href="#事务的基本用法"></a> 事务的基本用法</h2><p>假设用户A向用户B转账50块钱，则需要将A用户的账户余额减少50块钱，将B用户的账户添加50块钱，操作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;# 开始事务</span><br><span class="line"><span class="keyword">update</span> wallet <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="number">-50</span>;</span><br><span class="line"># query语句错误，未写条件</span><br><span class="line"><span class="keyword">rollback</span>;# 进行回滚，撤回错误<span class="keyword">sql</span>语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">update</span> wallet <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="number">-50</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> wallet <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">50</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;# 提交事务</span><br><span class="line"># 注意：事务开启可以随时<span class="keyword">rollback</span>，一旦<span class="keyword">commit</span>，就不能再<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><p>回滚点rollback to</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;      # 开始事务</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> wallet <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">savepoint</span> four;         # 设置事务回滚点</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> wallet <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">199999</span>);</span><br><span class="line"><span class="keyword">savepoint</span> five;</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> four;</span><br><span class="line"># 回滚到回滚点four之前的事务，回滚点four之后的操作将被丢弃</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h2 id="事务的特性"><a class="markdownIt-Anchor" href="#事务的特性"></a> 事务的特性</h2><p>事务的四大特性，简称ACID</p><ul><li>A：atomicity，原子性，事务的所有操作为一个整体，不可再分，要么全部执行，要么全部不执行。</li><li>C：consistency，一致性，事务开始前或结束后，数据库所有的数据都应该是正确完整。</li><li>I：isolation，隔离性，每个事务都是独立的。</li><li>D：durability，持久性，事务一旦提交，不能再更改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL视图基础</title>
      <link href="/post/1801a1aa.html"/>
      <url>/post/1801a1aa.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是视图"><a class="markdownIt-Anchor" href="#什么是视图"></a> 什么是视图</h2><p>视图相当于从副表中创建的一个虚拟的表，它可以筛选数据，隐藏表的结构，防止有关业务人员看到敏感数据。<br />例如：可以针对社会保险基金表创建视图，显示姓名地址，不显示社会保险号和工资。</p><h2 id="view视图创建-使用"><a class="markdownIt-Anchor" href="#view视图创建-使用"></a> view视图创建、使用</h2><ol><li>创建视图<br />格式：</li></ol><blockquote><p>create view vw_视图名 as<br />query语句</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> vw_stu <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> name, phone <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用视图<br />视图作为虚表，其使用和表的query相同。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vw_stu;</span><br></pre></td></tr></table></figure><ol start="3"><li>显示视图</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;                # 显示数据库中的表或视图</span><br><span class="line"><span class="keyword">desc</span> vw_stu;                # 显示视图结构</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> vw_stu;    # 显示视图的创建过程</span><br><span class="line"></span><br><span class="line"># 显示表格详细属性，一般用不到此语句</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">where</span> comment <span class="operator">=</span> <span class="string">&#x27;view&#x27;</span> <span class="operator">|</span> G;</span><br></pre></td></tr></table></figure><ol start="4"><li>更新和删除视图<br />操作与表操作相当。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改并查看修改后的视图</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> vw_stu <span class="keyword">as</span> <span class="keyword">select</span> name <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vw_stu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> vw_stu;       # 删除视图</span><br></pre></td></tr></table></figure><ol start="5"><li>视图算法<br />应用场景：查询视图用了子查询时;<br />分类：temptable（临时表）, merge（合并）, undefined（缺省值，不使用算法）<br />语法：create algorithm = temptable view as + query语句</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL子查询</title>
      <link href="/post/9da3e761.html"/>
      <url>/post/9da3e761.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是子查询"><a class="markdownIt-Anchor" href="#什么是子查询"></a> 什么是子查询</h2><p>子查询是一条循环中嵌套着一条查询，类似于递归。</p><h2 id="子查询基本语法"><a class="markdownIt-Anchor" href="#子查询基本语法"></a> 子查询基本语法</h2><p>查询学生表中成绩高于85分的学生信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> (<span class="keyword">select</span> stuid <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="operator">&gt;=</span> <span class="number">85</span>)</span><br><span class="line"># 注意：查询条件表达式处用<span class="operator">=</span>时，只能接受子查询中返回一条记录</span><br></pre></td></tr></table></figure><h2 id="子查询常用关键字"><a class="markdownIt-Anchor" href="#子查询常用关键字"></a> 子查询常用关键字</h2><ol><li>in和not in</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id [<span class="keyword">not</span>] <span class="keyword">in</span>(<span class="keyword">select</span> stuid <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="operator">&gt;=</span> <span class="number">85</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>exists和not exists</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> studnet <span class="keyword">where</span> id [<span class="keyword">not</span>] <span class="keyword">exists</span>(<span class="keyword">select</span> stuid <span class="keyword">from</span> scre <span class="keyword">where</span> score <span class="operator">&gt;=</span> <span class="number">85</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL多表查询</title>
      <link href="/post/dc3b805.html"/>
      <url>/post/dc3b805.html</url>
      
        <content type="html"><![CDATA[<p>MySQL多表查询的主要关键字。</p><h2 id="union联合查询"><a class="markdownIt-Anchor" href="#union联合查询"></a> union联合查询</h2><p>作用：在一条查询语句中进行多个查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> age, gender <span class="keyword">from</span> info <span class="keyword">all</span><span class="operator">/</span><span class="keyword">distinct</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;name&#x27;</span>, phone <span class="keyword">from</span> teacher</span><br><span class="line"># <span class="keyword">all</span>默认自带且省略，<span class="keyword">distinct</span>自加，用于去重</span><br></pre></td></tr></table></figure><h2 id="inner-join内连接"><a class="markdownIt-Anchor" href="#inner-join内连接"></a> inner join内连接</h2><p>inner join即内连接，要分清表的主次，主键对应外键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score <span class="keyword">from</span> student innner <span class="keyword">join</span> score <span class="keyword">on</span> student.id <span class="operator">=</span> score.stuid</span><br></pre></td></tr></table></figure><p>inner join注意事项：</p><ol><li>多表查询以相同的公共字段作为基准查询；</li><li>其中一个表没有的则不统计。</li></ol><h2 id="left-join左连接"><a class="markdownIt-Anchor" href="#left-join左连接"></a> left join左连接</h2><p>左连接就是以左表某字段为基准，左边的必须要有，右边的可以为空，类似于军训向……看齐排队。<br />作用：防止空数据不统计。</p><h2 id="right-join右连接"><a class="markdownIt-Anchor" href="#right-join右连接"></a> right join右连接</h2><p>类似于左连接，以右表字段为基准。</p><h2 id="cross-join交叉连接"><a class="markdownIt-Anchor" href="#cross-join交叉连接"></a> cross join交叉连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">cross</span> <span class="keyword">join</span> t3 <span class="keyword">where</span> t1.id  <span class="operator">=</span> t2.id</span><br><span class="line"># 没有<span class="keyword">where</span>及之后内容为笛卡尔积，有相当于内连接</span><br></pre></td></tr></table></figure><h2 id="natural-join自然连接"><a class="markdownIt-Anchor" href="#natural-join自然连接"></a> natural join自然连接</h2><p>select * from t1 natural join t3<br />自然连接会<strong>自动</strong>根据两表的<strong>公共字段</strong>连接（前提：两张表的公共字段（属性）名相同），没有的字段会自动填充。<br />内连接无公共同名字段的自然连接返回笛卡尔积</p><h2 id="using"><a class="markdownIt-Anchor" href="#using"></a> using</h2><p>作用：有多个公共字段时指定以某个字段连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t3 <span class="keyword">using</span>(id)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL单表查询</title>
      <link href="/post/11952da.html"/>
      <url>/post/11952da.html</url>
      
        <content type="html"><![CDATA[<p>MySQL单表查询主要关键字。</p><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;内容/实体&#x27;</span> (<span class="keyword">as</span>) 字段名<span class="operator">/</span>属性#<span class="keyword">as</span> 取别名用</span><br></pre></td></tr></table></figure><h2 id="from"><a class="markdownIt-Anchor" href="#from"></a> from</h2><p>from ???来自哪张表<br />多表查询结果是笛卡尔积</p><h2 id="dual伪表"><a class="markdownIt-Anchor" href="#dual伪表"></a> dual(伪表)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">2</span><span class="operator">*</span><span class="number">7</span> (<span class="keyword">as</span>) res <span class="keyword">from</span> dual;</span><br><span class="line"># 等价于</span><br><span class="line"><span class="keyword">select</span> <span class="number">2</span><span class="operator">*</span><span class="number">7</span> (<span class="keyword">as</span>) res</span><br></pre></td></tr></table></figure><h2 id="where筛选"><a class="markdownIt-Anchor" href="#where筛选"></a> where(筛选)</h2><p>符号：&lt; &lt;= &gt;= = ……</p><h2 id="in"><a class="markdownIt-Anchor" href="#in"></a> in</h2><p>in(‘’), not in(‘’)等价于 = 和!=</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t4 <span class="keyword">where</span> address <span class="keyword">in</span>(<span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Shanghai&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="betweenand"><a class="markdownIt-Anchor" href="#betweenand"></a> between…and</h2><p>where age &gt;= 15 and age &lt;= 20等价于where age between 15 and 20</p><h2 id="is-null"><a class="markdownIt-Anchor" href="#is-null"></a> is null</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h2 id="聚合函数自带函数"><a class="markdownIt-Anchor" href="#聚合函数自带函数"></a> 聚合函数（自带函数）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(chinese) <span class="keyword">from</span> score</span><br></pre></td></tr></table></figure><p>函数：</p><blockquote><p>sum()<br />avg()<br />max()<br />min()<br />count()注意谨慎使用count(*)</p></blockquote><h2 id="like模糊查询"><a class="markdownIt-Anchor" href="#like模糊查询"></a> like模糊查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;高_&#x27;</span>;</span><br><span class="line"># <span class="operator">%</span>匹配多个字符，_匹配单个字符</span><br></pre></td></tr></table></figure><h2 id="order-by排序查询"><a class="markdownIt-Anchor" href="#order-by排序查询"></a> order by排序查询</h2><p>ascend 升华 descend 下降</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> chinese <span class="keyword">asc</span>;   # <span class="keyword">asc</span>升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> chinese <span class="keyword">desc</span>;  # <span class="keyword">desc</span>降序</span><br></pre></td></tr></table></figure><h2 id="group-by分组查询"><a class="markdownIt-Anchor" href="#group-by分组查询"></a> group by分组查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">as</span> <span class="string">&#x27;年龄&#x27;</span>, gender <span class="keyword">as</span> <span class="string">&#x27;性别’ from info group by gender;</span></span><br></pre></td></tr></table></figure><h2 id="group_concat聚合查询信息"><a class="markdownIt-Anchor" href="#group_concat聚合查询信息"></a> group_concat(聚合查询信息)</h2><p>group_concat 将查询结果中同组的name组合在一起</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(name), gender <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br></pre></td></tr></table></figure><h2 id="having"><a class="markdownIt-Anchor" href="#having"></a> having</h2><p>having，在已经筛选的结果中再次筛选</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">as</span> <span class="string">&#x27;年龄&#x27;</span>, address <span class="keyword">as</span> <span class="string">&#x27;地区&#x27;</span> <span class="keyword">from</span> info <span class="keyword">group</span> <span class="keyword">by</span> address <span class="keyword">having</span> age <span class="operator">&gt;</span> <span class="number">24</span>;</span><br></pre></td></tr></table></figure><h2 id="limit"><a class="markdownIt-Anchor" href="#limit"></a> limit</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> info <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">desc</span> limit <span class="number">3</span></span><br><span class="line"># limit x, y x：开始位置，y：长度</span><br><span class="line"># limit x x：开始位置</span><br></pre></td></tr></table></figure><h2 id="distinct去重"><a class="markdownIt-Anchor" href="#distinct去重"></a> distinct(去重)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="keyword">from</span> info</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL数据库操作</title>
      <link href="/post/742c6695.html"/>
      <url>/post/742c6695.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中采用connection和sqlstatement类操作PostgreSQL数据库。</p><p>类的声明文件是freecplus/db/postgresql/_postgresql.h。</p><p>类的定义文件是freecplus/db/postgresql/_postgresql.cpp。</p><p>示例程序位于freecplus/db/postgresql目录中。</p><p>编译规则文件是freecplus/db/postgresql/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍PostgreSQL数据库、SQL语言和C/C<ins>的基础知识，您应该是一个职业的C/C</ins>程序员，在阅读本文之前，您已经掌握了PostgreSQL数据库和SQL语言的基础知识。</p><p>freecplus框架把PostgreSQL提供的库函数封装成了connection和sqlstatement类，采用封装后的类操作PostgreSQL数据库，代码简洁优雅，性能卓越。</p><p>接下来我先列出connection和sqlstatement类的声明，然后通过流程图和示例程序介绍它位的用法。</p><h1 id="三-connection类"><a class="markdownIt-Anchor" href="#三-connection类"></a> 三、connection类</h1><p>PostgreSQL数据库连接connection类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PostgreSQL数据库连接池类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库的连接状态，0-未连接，1-已连接。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 数据库操作的结果或最后一次执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">connection</span>();        <span class="comment">// 构造函数。</span></span><br><span class="line"> ~<span class="built_in">connection</span>();        <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库。</span></span><br><span class="line">  <span class="comment">// connstr：数据库的登录参数，格式：&quot;host= user= password= dbname= port=&quot;,</span></span><br><span class="line">  <span class="comment">// 例如：&quot;host=172.16.0.15 user=qxidc password=qxidcpwd dbname=qxidcdb port=5432&quot;</span></span><br><span class="line">  <span class="comment">// username-登录的用户名，password-登录的密码，dbname-缺省数据库，port-mysql服务的端口。</span></span><br><span class="line">  <span class="comment">// charset：数据库的字符集，如&quot;gbk&quot;，必须与数据库保持一致，否则会出现中文乱码的情况。</span></span><br><span class="line">  <span class="comment">// autocommitopt：是否启用自动提交，0-不启用，1-启用，缺省是不启用。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connecttodb</span><span class="params">(<span class="type">char</span> *connstr,<span class="type">char</span> *charset,<span class="type">unsigned</span> <span class="type">int</span> autocommitopt=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回滚事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与数据库的连接。</span></span><br><span class="line">  <span class="comment">// 注意，断开与数据库的连接时，全部未提交的事务自动回滚。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="comment">// 在connection类中提供了execute方法，是为了方便程序员，在该方法中，也是用sqlstatement类来完成功能。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-sqlstatement类"><a class="markdownIt-Anchor" href="#四-sqlstatement类"></a> 四、sqlstatement类</h1><p>PostgreSQL数据库的SQL语句操作sqlstatement类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作SQL语句类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sqlstatement</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库连接池的绑定状态，0-未绑定，1-已绑定。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sqlstatement</span>();      <span class="comment">// 构造函数。</span></span><br><span class="line">  <span class="built_in">sqlstatement</span>(connection *conn);    <span class="comment">// 构造函数，同时绑定数据库连接池。</span></span><br><span class="line"> ~<span class="built_in">sqlstatement</span>();      <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定数据库连接池。</span></span><br><span class="line">  <span class="comment">// conn：数据库连接池connection对象的地址。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，只要conn参数是有效的，并且数据库的游标资源足够，connect方法不会返回失败。</span></span><br><span class="line">  <span class="comment">// 程序员一般不必关心connect方法的返回值。</span></span><br><span class="line">  <span class="comment">// 注意，每个sqlstatement只需要绑定一次，在绑定新的connection前，必须先调用disconnect方法。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(connection *conn)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消与数据库连接池的绑定。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备SQL语句。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要prepare一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">prepare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输入变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，必须与prepare方法中的SQL的序号一一对应。</span></span><br><span class="line">  <span class="comment">// value：输入变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输入变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindin一次就可以了，2）绑定输入变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输出变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，与SQL的结果集一一对应。</span></span><br><span class="line">  <span class="comment">// value：输出变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输出变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindout一次就可以了，2）绑定输出变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从结果集中获取一条记录。</span></span><br><span class="line">  <span class="comment">// 如果执行的SQL语句是查询语句，调用execute方法后，会产生一个结果集（存放在数据库的缓冲区中）。</span></span><br><span class="line">  <span class="comment">// next方法从结果集中获取一条记录，把字段的值放入已绑定的输出变量中。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，1403-结果集已无记录，其它-失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 返回失败的原因主要有两个：1）与数据库的连接已断开；2）绑定输出变量的内存太小。</span></span><br><span class="line">  <span class="comment">// 每执行一次next方法，m_cda.rpc的值加1。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查next方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-程序流程"><a class="markdownIt-Anchor" href="#五-程序流程"></a> 五、程序流程</h1><p>freecplus框架把对PostgreSQL数据库操作的SQL语句分为两种：有结果集的SQL语句和无结果集的SQL语句。</p><p>如果SQL语句被执行后，有结果集的产生，称为有结果集的SQL，即数据查询语言DQL，以select关键字，各种简单查询，连接查询等都属于DQL。</p><p>如果SQL语句被执行后，没有结果集的产生，称为无结果集的SQL，包括数据定义语言DDL（主要是create、drop和alter）和数据操纵语言DML（insert、update和insert）。</p><p>也可以这么说，查询的SQL语句会产生结果集，其它的SQL语句不会产生结果集。</p><h2 id="1-无结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#1-无结果集sql的程序的流程"></a> 1、无结果集SQL的程序的流程</h2><p>这是一个完程的流程，在实际开发中，如果是执行简单的SQL语句，第6步和第7步可能不需要，如果SQL语句只执行一次，第7步和第8步之间的循环也不需要。</p><h2 id="2-有结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#2-有结果集sql的程序的流程"></a> 2、有结果集SQL的程序的流程</h2><p>这是一个完程的流程，在实际开发中，如果是执行简单的查询语句，第6步、第7步和第8步可能不需要，如果结果集中最多只有一条记录，第10步和第11步之间的循环也不需要。</p><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-创建超女信息表"><a class="markdownIt-Anchor" href="#1-创建超女信息表"></a> 1、创建超女信息表</h2><p><strong>示例（createtable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：createtable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（创建表）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接池。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备创建表的SQL语句。</span></span><br><span class="line">  <span class="comment">// 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    create table girls(id    int,\</span></span><br><span class="line"><span class="string">                       name  varchar(30),\</span></span><br><span class="line"><span class="string">                       weight   numeric(8,2),\</span></span><br><span class="line"><span class="string">                       btime timestamp,\</span></span><br><span class="line"><span class="string">                       memo  text,\</span></span><br><span class="line"><span class="string">                       pic   bytea,\</span></span><br><span class="line"><span class="string">                       primary key (id))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，在postgresql数据库中，创建表也要提交事务，和Oracle、MySQL数据库不同。</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;create table girls ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200313103450414.png" alt="在这里插入图片描述" /></p><h2 id="2-向超女表中插入5条记录"><a class="markdownIt-Anchor" href="#2-向超女表中插入5条记录"></a> 2、向超女表中插入5条记录</h2><p><strong>示例（inserttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：inserttable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（向表中插入5条记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">11</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ssi&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    insert into girls(id,name,weight,btime) \</span></span><br><span class="line"><span class="string">                values(:1,:2,:3,to_date(:4,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>, stgirls.name,<span class="number">10</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟超女数据，向表中插入5条测试信息。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体变量的成员赋值。</span></span><br><span class="line">    stgirls.id=ii;                                 <span class="comment">// 超女编号。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(stgirls.name,<span class="string">&quot;超女%02d&quot;</span>,ii);           <span class="comment">// 超女姓名。</span></span><br><span class="line">    stgirls.weight=ii*<span class="number">2.11</span>;                        <span class="comment">// 超女体重。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stgirls.btime,<span class="string">&quot;2018-03-01 12:25:31&quot;</span>);   <span class="comment">// 报名时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">    <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功插入了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); <span class="comment">// stmt.m_cda.rpc是本次执行SQL影响的记录数。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;insert table girls ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>(); <span class="comment">// 提交数据库事务。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200313103547395.png" alt="在这里插入图片描述" /></p><h2 id="3-更新超女表中的记录"><a class="markdownIt-Anchor" href="#3-更新超女表中的记录"></a> 3、更新超女表中的记录</h2><p><strong>示例（updatetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：updatetable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（修改表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbtime[<span class="number">20</span>];  <span class="comment">// 用于存放超女的报名时间。</span></span><br><span class="line">  <span class="built_in">memset</span>(strbtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strbtime,<span class="string">&quot;2019-12-20 09:45:30&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备更新数据的SQL语句，不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    update girls set btime=to_date(:1,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,strbtime,<span class="number">19</span>);</span><br><span class="line">  <span class="comment">// 如果不采用绑定输入变量的方法，把strbtime的值直接写在SQL语句中也是可以的，如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  stmt.prepare(&quot;\</span></span><br><span class="line"><span class="comment">    update girls set btime=to_date(&#x27;%s&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;,strbtime);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次更新了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103646373.png" alt="在这里插入图片描述" /></p><h2 id="4-查询超女表中的记录"><a class="markdownIt-Anchor" href="#4-查询超女表中的记录"></a> 4、查询超女表中的记录</h2><p><strong>示例（selecttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：selecttable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（查询表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">31</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ss&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iminid,imaxid;  <span class="comment">// 查询条件最小和最大的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    select id,name,weight,to_char(btime,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;iminid);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;imaxid);</span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stgirls.name,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  iminid=<span class="number">2</span>;  <span class="comment">// 指定待查询记录的最小id的值。</span></span><br><span class="line">  imaxid=<span class="number">4</span>;  <span class="comment">// 指定待查询记录的最大id的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 先把结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>() !=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把获取到的记录的值打印出来。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id=%ld,name=%s,weight=%.02f,btime=%s\n&quot;</span>,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103751844.png" alt="在这里插入图片描述" /></p><h2 id="5-查询超女表中的记录数"><a class="markdownIt-Anchor" href="#5-查询超女表中的记录数"></a> 5、查询超女表中的记录数</h2><p><strong>示例（counttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：counttable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（查询表中的记录数）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> icount=<span class="number">0</span>;  <span class="comment">// 用于存放查询结果的记录数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句，把查询条件直接写在SQL语句中，没有采用绑定输入变量的方法。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from girls where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;icount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="comment">// 但是，在本程序中，结果集永远只有一条记录，调用stmt.next()一次就行，不需要循环。</span></span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girls表中符合条件的记录数是%d。\n&quot;</span>,icount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103843434.png" alt="在这里插入图片描述" /></p><h2 id="7-删除超女表中的记录"><a class="markdownIt-Anchor" href="#7-删除超女表中的记录"></a> 7、删除超女表中的记录</h2><p><strong>示例（deletetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：deletetable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（删除表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果不需要绑定输入和输出变量，用stmt.execute()方法直接执行SQL语句，不需要stmt.prepare()。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>(<span class="string">&quot;delete from girls where id&gt;=2 and id&lt;=4&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次从girls表中删除了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103942977.png" alt="在这里插入图片描述" /></p><h2 id="8-与oracle的兼容性处理"><a class="markdownIt-Anchor" href="#8-与oracle的兼容性处理"></a> 8、与Oracle的兼容性处理</h2><p>在封装sqlstatement类的时候，为了与Oracle兼容，做了以下方面的处理：</p><p>1）在PostgreSQL中，绑定输入和输出变量采用的是&quot;$“，Oracle采用的是”:n&quot;（n表示变量的序号），在sqlstatement的prepare方法中，把&quot;:n&quot;替换成了&quot;$&quot;。</p><p>2）在PostgreSQL中，把字符串输换为日期时间的函数是to_timestamp，Oracle是to_date，在sqlstatement的prepare方法中，把to_date替换成to_timestamp。</p><p>4）PostgreSQL的sqlstatement类绑定输入或输出变量的最大数量缺省是256，在&quot;_mysql.h&quot;头文件中定义了MAXPARAMS宏，您可以根据实际需求修改它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行SQL语句前绑定输入或输出变量个数的最大值，256是很大的了，可以根据实际情况调整。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPARAMS  256</span></span><br></pre></td></tr></table></figure><p>5）sqlstatement类绑定输入或输出变量时，如果是字符串，最大长度缺省是2000，在&quot;_postgresql.h&quot;头文件中定义了MAXFIELDLENGTH宏，您可以根据实际需求修改它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果绑定输入或输出变量是字符串，指定字符串的最大长度，不包括字符串的结束符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFIELDLENGTH 2000</span></span><br></pre></td></tr></table></figure><h2 id="9-text和bytea字段的操作"><a class="markdownIt-Anchor" href="#9-text和bytea字段的操作"></a> 9、text和bytea字段的操作</h2><p>PostgreSQL提供的库函数支持对text和bytea字段的操作，本人的技术水平有限，找不到这方面的资料和示例程序，所以还没有封装对text和bytea字段的操作，希望各位能提供技术帮助，通过C语言技术网与我联系，我们共同完善freecplus框架，非常感谢。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>本文提供的示例程序看上去简单，实则很精妙，希望大家多多思考，慢慢体会。</p><p>为了让大家完全掌握connection和sqlstatement类的用法，我将录制freecplus框架的专题视频，请大家多关注C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）发布的内容。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库操作</title>
      <link href="/post/f2cccc89.html"/>
      <url>/post/f2cccc89.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中采用connection和sqlstatement类操作MySQL数据库。</p><p>类的声明文件是freecplus/db/mysql/_mysql.h。</p><p>类的定义文件是freecplus/db/mysql/_mysql.cpp。</p><p>示例程序位于freecplus/db/mysql目录中。</p><p>编译规则文件是freecplus/db/mysql/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍MySQL数据库、SQL语言和C/C<ins>的基础知识，您应该是一个职业的C/C</ins>程序员，在阅读本文之前，您已经掌握了MySQL数据库和SQL语言的基础知识。</p><p>freecplus框架把MySQL提供的库函数封装成了connection和sqlstatement类，采用封装后的类操作MySQL数据库，代码简洁优雅，性能卓越。</p><p>接下来我先列出connection和sqlstatement类的声明，然后通过流程图和示例程序介绍它位的用法。</p><h1 id="三-connection类"><a class="markdownIt-Anchor" href="#三-connection类"></a> 三、connection类</h1><p>MySQL数据库连接connection类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySQL数据库连接池类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库的连接状态，0-未连接，1-已连接。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 数据库操作的结果或最后一次执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">connection</span>();        <span class="comment">// 构造函数。</span></span><br><span class="line"> ~<span class="built_in">connection</span>();        <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库。</span></span><br><span class="line">  <span class="comment">// connstr：数据库的登录参数，格式：&quot;ip,username,password,dbname,port&quot;，</span></span><br><span class="line">  <span class="comment">// 例如：&quot;172.16.0.15,qxidc,qxidcpwd,qxidcdb,3306&quot;。</span></span><br><span class="line">  <span class="comment">// charset：数据库的字符集，如&quot;gbk&quot;，必须与数据库保持一致，否则会出现中文乱码的情况。</span></span><br><span class="line">  <span class="comment">// autocommitopt：是否启用自动提交，0-不启用，1-启用，缺省是不启用。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connecttodb</span><span class="params">(<span class="type">char</span> *connstr,<span class="type">char</span> *charset,<span class="type">unsigned</span> <span class="type">int</span> autocommitopt=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回滚事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与数据库的连接。</span></span><br><span class="line">  <span class="comment">// 注意，断开与数据库的连接时，全部未提交的事务自动回滚。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="comment">// 在connection类中提供了execute方法，是为了方便程序员，在该方法中，也是用sqlstatement类来完成功能。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-sqlstatement类"><a class="markdownIt-Anchor" href="#四-sqlstatement类"></a> 四、sqlstatement类</h1><p>MySQL数据库的SQL语句操作sqlstatement类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作SQL语句类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sqlstatement</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库连接池的绑定状态，0-未绑定，1-已绑定。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sqlstatement</span>();      <span class="comment">// 构造函数。</span></span><br><span class="line">  <span class="built_in">sqlstatement</span>(connection *conn);    <span class="comment">// 构造函数，同时绑定数据库连接池。</span></span><br><span class="line"> ~<span class="built_in">sqlstatement</span>();      <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定数据库连接池。</span></span><br><span class="line">  <span class="comment">// conn：数据库连接池connection对象的地址。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，只要conn参数是有效的，并且数据库的游标资源足够，connect方法不会返回失败。</span></span><br><span class="line">  <span class="comment">// 程序员一般不必关心connect方法的返回值。</span></span><br><span class="line">  <span class="comment">// 注意，每个sqlstatement只需要绑定一次，在绑定新的connection前，必须先调用disconnect方法。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(connection *conn)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消与数据库连接池的绑定。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备SQL语句。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要prepare一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">prepare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输入变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，必须与prepare方法中的SQL的序号一一对应。</span></span><br><span class="line">  <span class="comment">// value：输入变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输入变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindin一次就可以了，2）绑定输入变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输出变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，与SQL的结果集一一对应。</span></span><br><span class="line">  <span class="comment">// value：输出变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输出变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindout一次就可以了，2）绑定输出变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从结果集中获取一条记录。</span></span><br><span class="line">  <span class="comment">// 如果执行的SQL语句是查询语句，调用execute方法后，会产生一个结果集（存放在数据库的缓冲区中）。</span></span><br><span class="line">  <span class="comment">// next方法从结果集中获取一条记录，把字段的值放入已绑定的输出变量中。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，1403-结果集已无记录，其它-失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 返回失败的原因主要有两个：1）与数据库的连接已断开；2）绑定输出变量的内存太小。</span></span><br><span class="line">  <span class="comment">// 每执行一次next方法，m_cda.rpc的值加1。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查next方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-程序流程"><a class="markdownIt-Anchor" href="#五-程序流程"></a> 五、程序流程</h1><p>freecplus框架把对MySQL数据库操作的SQL语句分为两种：有结果集的SQL语句和无结果集的SQL语句。</p><p>如果SQL语句被执行后，有结果集的产生，称为有结果集的SQL，即数据查询语言DQL，以select关键字，各种简单查询，连接查询等都属于DQL。</p><p>如果SQL语句被执行后，没有结果集的产生，称为无结果集的SQL，包括数据定义语言DDL（主要是create、drop和alter）和数据操纵语言DML（insert、update和insert）。</p><p>也可以这么说，查询的SQL语句会产生结果集，其它的SQL语句不会产生结果集。</p><h2 id="1-无结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#1-无结果集sql的程序的流程"></a> 1、无结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/20200309082338243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这是一个完程的流程，在实际开发中，如果是执行简单的SQL语句，第6步和第7步可能不需要，如果SQL语句只执行一次，第7步和第8步之间的循环也不需要。</p><h2 id="2-有结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#2-有结果集sql的程序的流程"></a> 2、有结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/2020030908265352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这是一个完程的流程，在实际开发中，如果是执行简单的查询语句，第6步、第7步和第8步可能不需要，如果结果集中最多只有一条记录，第10步和第11步之间的循环也不需要。</p><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-创建超女信息表"><a class="markdownIt-Anchor" href="#1-创建超女信息表"></a> 1、创建超女信息表</h2><p><strong>示例（createtable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：createtable.cpp，此程序演示freecplus框架操作MySQL数据库（创建表）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备创建表的SQL语句。</span></span><br><span class="line">  <span class="comment">// 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    create table girls(id    bigint(10),\</span></span><br><span class="line"><span class="string">                       name  varchar(30),\</span></span><br><span class="line"><span class="string">                       weight   decimal(8,2),\</span></span><br><span class="line"><span class="string">                       btime datetime,\</span></span><br><span class="line"><span class="string">                       memo  longtext,\</span></span><br><span class="line"><span class="string">                       pic   longblob,\</span></span><br><span class="line"><span class="string">                       primary key (id))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;create table girls ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030908291445.png" alt="在这里插入图片描述" /></p><h2 id="2-向超女表中插入5条记录"><a class="markdownIt-Anchor" href="#2-向超女表中插入5条记录"></a> 2、向超女表中插入5条记录</h2><p><strong>示例（inserttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：inserttable.cpp，此程序演示freecplus框架操作MySQL数据库（向表中插入5条记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">11</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ssi&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    insert into girls(id,name,weight,btime) \</span></span><br><span class="line"><span class="string">              values(:1,:2,:3,str_to_date(:4,&#x27;%%Y-%%m-%%d %%h:%%i:%%s&#x27;))&quot;</span>);</span><br><span class="line">  <span class="comment">// 也可以用以下一行代码代替上面这行代码，兼容oracle数据库。</span></span><br><span class="line">  <span class="comment">//            values(:1,:2,:3,to_date(:4,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;);</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>, stgirls.name,<span class="number">10</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟超女数据，向表中插入5条测试信息。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体变量的成员赋值。</span></span><br><span class="line">    stgirls.id=ii;                                 <span class="comment">// 超女编号。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(stgirls.name,<span class="string">&quot;超女%02d&quot;</span>,ii);           <span class="comment">// 超女姓名。</span></span><br><span class="line">    stgirls.weight=ii*<span class="number">2.11</span>;                        <span class="comment">// 超女体重。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stgirls.btime,<span class="string">&quot;2018-03-01 12:25:31&quot;</span>);   <span class="comment">// 报名时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">    <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功插入了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); <span class="comment">// stmt.m_cda.rpc是本次执行SQL影响的记录数。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;insert table girls ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>(); <span class="comment">// 提交数据库事务。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083127849.png" alt="在这里插入图片描述" /></p><h2 id="3-更新超女表中的记录"><a class="markdownIt-Anchor" href="#3-更新超女表中的记录"></a> 3、更新超女表中的记录</h2><p><strong>示例（updatetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：updatetable.cpp，此程序演示freecplus框架操作MySQL数据库（修改表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbtime[<span class="number">20</span>];  <span class="comment">// 用于存放超女的报名时间。</span></span><br><span class="line">  <span class="built_in">memset</span>(strbtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strbtime,<span class="string">&quot;2019-12-20 09:45:30&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备更新数据的SQL语句，不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    update girls set btime=str_to_date(:1,&#x27;%%Y-%%m-%%d %%h:%%i:%%s&#x27;) where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// 也可以用以下一行代码代替上面这行代码，兼容oracle数据库。</span></span><br><span class="line">  <span class="comment">//  update girls set btime=to_date(:1,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;);</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,strbtime,<span class="number">19</span>);</span><br><span class="line">  <span class="comment">// 如果不采用绑定输入变量的方法，把strbtime的值直接写在SQL语句中也是可以的，如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  stmt.prepare(&quot;\</span></span><br><span class="line"><span class="comment">    update girls set btime=to_date(&#x27;%s&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;,strbtime);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次更新了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083318523.png" alt="在这里插入图片描述" /></p><h2 id="4-查询超女表中的记录"><a class="markdownIt-Anchor" href="#4-查询超女表中的记录"></a> 4、查询超女表中的记录</h2><p><strong>示例（selecttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：selecttable.cpp，此程序演示freecplus框架操作MySQL数据库（查询表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">31</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ss&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iminid,imaxid;  <span class="comment">// 查询条件最小和最大的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    select id,name,weight,date_format(btime,&#x27;%%Y-%%m-%%d %%h:%%i:%%s&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;</span>);</span><br><span class="line">  <span class="comment">// 也可以用以下一行代码代替上面这行代码，兼容oracle数据库。</span></span><br><span class="line">  <span class="comment">// select id,name,weight,to_char(btime,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;);</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;iminid);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;imaxid);</span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stgirls.name,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  iminid=<span class="number">2</span>;  <span class="comment">// 指定待查询记录的最小id的值。</span></span><br><span class="line">  imaxid=<span class="number">4</span>;  <span class="comment">// 指定待查询记录的最大id的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 先把结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>() !=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把获取到的记录的值打印出来。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id=%ld,name=%s,weight=%.02f,btime=%s\n&quot;</span>,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083459644.png" alt="在这里插入图片描述" /></p><h2 id="5-查询超女表中的记录数"><a class="markdownIt-Anchor" href="#5-查询超女表中的记录数"></a> 5、查询超女表中的记录数</h2><p><strong>示例（counttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：counttable.cpp，此程序演示freecplus框架操作MySQL数据库（查询表中的记录数）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> icount=<span class="number">0</span>;  <span class="comment">// 用于存放查询结果的记录数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句，把查询条件直接写在SQL语句中，没有采用绑定输入变量的方法。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from girls where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;icount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="comment">// 但是，在本程序中，结果集永远只有一条记录，调用stmt.next()一次就行，不需要循环。</span></span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girls表中符合条件的记录数是%d。\n&quot;</span>,icount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030908364949.png" alt="在这里插入图片描述" /></p><h2 id="7-删除超女表中的记录"><a class="markdownIt-Anchor" href="#7-删除超女表中的记录"></a> 7、删除超女表中的记录</h2><p><strong>示例（deletetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：deletetable.cpp，此程序演示freecplus框架操作MySQL数据库（删除表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接池。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果不需要绑定输入和输出变量，用stmt.execute()方法直接执行SQL语句，不需要stmt.prepare()。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>(<span class="string">&quot;delete from girls where id&gt;=2 and id&lt;=4&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次从girls表中删除了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083918867.png" alt="在这里插入图片描述" /></p><h2 id="8-与oracle的兼容性处理"><a class="markdownIt-Anchor" href="#8-与oracle的兼容性处理"></a> 8、与Oracle的兼容性处理</h2><p>在封装sqlstatement类的时候，为了与Oracle兼容，做了以下方面的处理：</p><p>1）在MySQL中，绑定输入和输出变量采用的是&quot;?“，Oracle采用的是”:n&quot;（n表示变量的序号），在sqlstatement的prepare方法中，把&quot;:n&quot;替换成了&quot;?&quot;。</p><p>2）在MySQL中，字符串与日期的转换函数是str_to_date和date_format，Oracle的转换函数是to_date和to_char，在sqlstatement的prepare方法中，把to_date替换成str_to_date，把to_char替换成date_format。</p><p>3）MySQL有时间格式是&quot;%Y-%m-%d %h:%i:%s&quot;，Oracle数据库是&quot;yyyy-mm-dd hh24:mi:ss&quot;，在sqlstatement的prepare方法中，把&quot;yyyy-mm-dd hh24:mi:ss&quot;替换成&quot;%Y-%m-%d %h:%i:%s&quot;。目前，只对&quot;%Y-%m-%d %h:%i:%s&quot;和&quot;%Y%m%d%h%i%s&quot;两个格式做了替换，如果需要对更多的格式做替换，请修改sqlstatement的prepare方法中的源代码。</p><p>4）MySQL的sqlstatement类绑定输入或输出变量的最大数量缺省是256，在&quot;_mysql.h&quot;头文件中定义了MAXPARAMS宏，您可以根据实际需求修改它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行SQL语句前绑定输入或输出变量个数的最大值，256是很大的了，可以根据实际情况调整。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPARAMS  256</span></span><br></pre></td></tr></table></figure><h2 id="9-longtext和longblob字段的操作"><a class="markdownIt-Anchor" href="#9-longtext和longblob字段的操作"></a> 9、longtext和longblob字段的操作</h2><p>MySQL提供的库函数支持对longtext和longblob字段的操作，本人的技术水平有限，找不到这方面的资料和示例程序，所以还没有封装对longtext和longblob字段的操作，希望各位能提供技术帮助，通过C语言技术网与我联系，我们共同完善freecplus框架，非常感谢。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>本文提供的示例程序看上去简单，实则很精妙，希望大家多多思考，慢慢体会。</p><p>为了让大家完全掌握connection和sqlstatement类的用法，我将录制freecplus框架的专题视频，请大家多关注C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）发布的内容。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库操作</title>
      <link href="/post/a4264ce.html"/>
      <url>/post/a4264ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中采用connection和sqlstatement类操作Oracle数据库。</p><p>类的声明文件是freecplus/db/oracle/_ooci.h。</p><p>类的定义文件是freecplus/db/oracle/_ooci.cpp。</p><p>示例程序位于freecplus/db/oracle目录中。</p><p>编译规则文件是freecplus/db/oracle/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍Oracle数据库、SQL语言和C/C<ins>的基础知识，您应该是一个职业的C/C</ins>程序员，在阅读本文之前，您已经掌握了Oracle数据库和SQL语言的基础知识。</p><p>Oracle数据库功能强大，性能卓越，无与伦比，并提供了数据访问接口OCI，OCI非常强大，强大到了普通C/C++程序员难以驾驭。</p><p>freecplus框架把OCI（Oracle Call Interface）封装成了connection和sqlstatement类，采用封装后的类操作Oracle数据库，代码简洁优雅，性能卓越。</p><p>接下来我先列出connection和sqlstatement类的声明，然后通过流程图和示例程序介绍它位的用法。</p><h1 id="三-connection类"><a class="markdownIt-Anchor" href="#三-connection类"></a> 三、connection类</h1><p>Oracle数据库连接池connection类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Oracle数据库连接池类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;       <span class="comment">// 与数据库的连接状态，0-未连接，1-已连接。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 数据库操作的结果或最后一次执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">connection</span>();    <span class="comment">// 构造函数。</span></span><br><span class="line"> ~<span class="built_in">connection</span>();    <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库。</span></span><br><span class="line">  <span class="comment">// connstr：数据库的登录参数，格式：username/password@tnsname，username-用户名，password-登录密</span></span><br><span class="line">  <span class="comment">// 码，tnsname-数据库的服务名，在$ORACLE_HOME/network/admin/tnsnames.ora文件中配置。</span></span><br><span class="line">  <span class="comment">// charset：数据库的字符集，必须与数据库保持一致，否则会出现中文乱码的情况。</span></span><br><span class="line">  <span class="comment">// autocommitopt：是否启用自动提交，0-不启用，1-启用，缺省是不启用。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connecttodb</span><span class="params">(<span class="type">char</span> *connstr,<span class="type">char</span> *charset,<span class="type">int</span> autocommitopt=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">commit</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回滚事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与数据库的连接。</span></span><br><span class="line">  <span class="comment">// 注意，断开与数据库的连接时，全部未提交的事务自动回滚。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="comment">// 在connection类中提供了execute方法，是为了方便程序员，在该方法中，也是用sqlstatement类来完成功能。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-sqlstatement类"><a class="markdownIt-Anchor" href="#四-sqlstatement类"></a> 四、sqlstatement类</h1><p>Oracle数据库的SQL语句操作sqlstatement类的声明（程序员不必关心的私有成员和数据结构未列出，对CLOB和BLOB字段操作的方法也未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作SQL语句类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sqlstatement</span></span><br><span class="line">&#123;</span><br><span class="line">  OCI_HANDLE m_handle; <span class="comment">// SQL句柄。</span></span><br><span class="line">  connection *m_conn;  <span class="comment">// 数据库连接池指针。</span></span><br><span class="line">  <span class="type">int</span> m_sqltype;       <span class="comment">// SQL语句的类型，0-查询语句；1-非查询语句。</span></span><br><span class="line">  <span class="type">int</span> m_autocommitopt; <span class="comment">// 自动提交标志，0-关闭；1-开启。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">err_report</span><span class="params">()</span></span>;   <span class="comment">// 错误报告。</span></span><br><span class="line"></span><br><span class="line">  OCILobLocator *m_lob;     <span class="comment">// 指向LOB字段的指针。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">alloclob</span><span class="params">()</span></span>;          <span class="comment">// 初始化lob指针。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">filetolob</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 把文件的内容导入到clob和blob字段中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">lobtofile</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 从clob和blob字段中导出内容到文件中。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">freelob</span><span class="params">()</span></span>;           <span class="comment">// 释放lob指针。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库连接池的绑定状态，0-未绑定，1-已绑定。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sqlstatement</span>();      <span class="comment">// 构造函数。</span></span><br><span class="line">  <span class="built_in">sqlstatement</span>(connection *conn);    <span class="comment">// 构造函数，同时绑定数据库连接池。</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">sqlstatement</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定数据库连接池。</span></span><br><span class="line">  <span class="comment">// conn：数据库连接池connection对象的地址。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，只要conn参数是有效的，并且数据库的游标资源足够，connect方法不会返回失败。</span></span><br><span class="line">  <span class="comment">// 程序员一般不必关心connect方法的返回值。</span></span><br><span class="line">  <span class="comment">// 注意，每个sqlstatement只需要绑定一次，在绑定新的connection前，必须先调用disconnect方法。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(connection *conn)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消与数据库连接池的绑定。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备SQL语句。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要prepare一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">prepare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输入变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，必须与prepare方法中的SQL的序号一一对应。</span></span><br><span class="line">  <span class="comment">// value：输入变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输入变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要bindin一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输出变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，与SQL的结果集一一对应。</span></span><br><span class="line">  <span class="comment">// value：输出变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输出变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要bindout一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从结果集中获取一条记录。</span></span><br><span class="line">  <span class="comment">// 如果执行的SQL语句是查询语句，调用execute方法后，会产生一个结果集（存放在数据库的缓冲区中）。</span></span><br><span class="line">  <span class="comment">// next方法从结果集中获取一条记录，把字段的值放入已绑定的输出变量中。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，1403-结果集已无记录，其它-失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 返回失败的原因主要有两个：1）与数据库的连接已断开；2）绑定输出变量的内存太小。</span></span><br><span class="line">  <span class="comment">// 每执行一次next方法，m_cda.rpc的值加1。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查next方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-程序流程"><a class="markdownIt-Anchor" href="#五-程序流程"></a> 五、程序流程</h1><p>freecplus框架把对Oracle数据库操作的SQL语句分为两种：有结果集的SQL语句和无结果集的SQL语句。</p><p>如果SQL语句被执行后，有结果集的产生，称为有结果集的SQL，即数据查询语言DQL，以select关键字，各种简单查询，连接查询等都属于DQL。</p><p>如果SQL语句被执行后，没有结果集的产生，称为无结果集的SQL，包括数据定义语言DDL（主要是create、drop和alter）和数据操纵语言DML（insert、update和insert）。</p><p>也可以这么说，查询的SQL语句会产生结果集，其它的SQL语句不会产生结果集。</p><h2 id="1-无结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#1-无结果集sql的程序的流程"></a> 1、无结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/20200306173529756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这是一个完程的流程，在实际开发中，如果是执行简单的SQL语句，第6步和第7步可能不需要，如果SQL语句只执行一次，第7步和第8步之间的循环也不需要。</p><h2 id="2-有结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#2-有结果集sql的程序的流程"></a> 2、有结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/20200306173659630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />这是一个完程的流程，在实际开发中，如果是执行简单的查询语句，第6步、第7步和第8步可能不需要，如果结果集中最多只有一条记录，第10步和第11步之间的循环也不需要。</p><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-创建超女信息表"><a class="markdownIt-Anchor" href="#1-创建超女信息表"></a> 1、创建超女信息表</h2><p><strong>示例（createtable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：createtable.cpp，此程序演示freecplus框架操作Oracle数据库（创建表）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备创建表的SQL语句。</span></span><br><span class="line">  <span class="comment">// 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    create table girls(id    number(10),\</span></span><br><span class="line"><span class="string">                       name  varchar2(30),\</span></span><br><span class="line"><span class="string">                       weight   number(8,2),\</span></span><br><span class="line"><span class="string">                       btime date,\</span></span><br><span class="line"><span class="string">                       memo  clob,\</span></span><br><span class="line"><span class="string">                       pic   blob,\</span></span><br><span class="line"><span class="string">                       primary key (id))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;create table girls ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306173800310.png" alt="在这里插入图片描述" /></p><h2 id="2-向超女表中插入5条记录"><a class="markdownIt-Anchor" href="#2-向超女表中插入5条记录"></a> 2、向超女表中插入5条记录</h2><p><strong>示例（inserttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：inserttable.cpp，此程序演示freecplus框架操作Oracle数据库（向表中插入5条记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">11</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ssi&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    insert into girls(id,name,weight,btime) \</span></span><br><span class="line"><span class="string">                values(:1,:2,:3,to_date(:4,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>, stgirls.name,<span class="number">10</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟超女数据，向表中插入5条测试信息。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体变量的成员赋值。</span></span><br><span class="line">    stgirls.id=ii;                                 <span class="comment">// 超女编号。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(stgirls.name,<span class="string">&quot;超女%02d&quot;</span>,ii);           <span class="comment">// 超女姓名。</span></span><br><span class="line">    stgirls.weight=ii*<span class="number">2.11</span>;                        <span class="comment">// 超女体重。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stgirls.btime,<span class="string">&quot;2018-03-01 12:25:31&quot;</span>);   <span class="comment">// 报名时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">    <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功插入了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); <span class="comment">// stmt.m_cda.rpc是本次执行SQL影响的记录数。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;insert table girls ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>(); <span class="comment">// 提交数据库事务。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306174021361.png" alt="在这里插入图片描述" /></p><h2 id="3-更新超女表中的记录"><a class="markdownIt-Anchor" href="#3-更新超女表中的记录"></a> 3、更新超女表中的记录</h2><p><strong>示例（updatetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：updatetable.cpp，此程序演示freecplus框架操作Oracle数据库（修改表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbtime[<span class="number">20</span>];  <span class="comment">// 用于存放超女的报名时间。</span></span><br><span class="line">  <span class="built_in">memset</span>(strbtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strbtime,<span class="string">&quot;2019-12-20 09:45:30&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备更新数据的SQL语句，不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    update girls set btime=to_date(:1,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,strbtime,<span class="number">19</span>);</span><br><span class="line">  <span class="comment">// 如果不采用绑定输入变量的方法，把strbtime的值直接写在SQL语句中也是可以的，如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  stmt.prepare(&quot;\</span></span><br><span class="line"><span class="comment">    update girls set btime=to_date(&#x27;%s&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;,strbtime);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次更新了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><h2 id="在这里插入图片描述4-查询超女表中的记录"><a class="markdownIt-Anchor" href="#在这里插入图片描述4-查询超女表中的记录"></a> <img src="https://img-blog.csdnimg.cn/20200306184713360.png" alt="在这里插入图片描述" /><br />4、查询超女表中的记录</h2><p><strong>示例（selecttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：selecttable.cpp，此程序演示freecplus框架操作Oracle数据库（查询表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">31</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ss&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iminid,imaxid;  <span class="comment">// 查询条件最小和最大的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    select id,name,weight,to_char(btime,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;iminid);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;imaxid);</span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stgirls.name,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  iminid=<span class="number">2</span>;  <span class="comment">// 指定待查询记录的最小id的值。</span></span><br><span class="line">  imaxid=<span class="number">4</span>;  <span class="comment">// 指定待查询记录的最大id的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 先把结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>() !=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把获取到的记录的值打印出来。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id=%ld,name=%s,weight=%.02f,btime=%s\n&quot;</span>,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306184830196.png" alt="在这里插入图片描述" /></p><h2 id="5-查询超女表中的记录数"><a class="markdownIt-Anchor" href="#5-查询超女表中的记录数"></a> 5、查询超女表中的记录数</h2><p><strong>示例（counttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：counttable.cpp，此程序演示freecplus框架操作Oracle数据库（查询表中的记录数）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> icount=<span class="number">0</span>;  <span class="comment">// 用于存放查询结果的记录数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句，把查询条件直接写在SQL语句中，没有采用绑定输入变量的方法。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from girls where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;icount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="comment">// 但是，在本程序中，结果集永远只有一条记录，调用stmt.next()一次就行，不需要循环。</span></span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girls表中符合条件的记录数是%d。\n&quot;</span>,icount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306184934579.png" alt="在这里插入图片描述" /></p><h2 id="7-删除超女表中的记录"><a class="markdownIt-Anchor" href="#7-删除超女表中的记录"></a> 7、删除超女表中的记录</h2><p><strong>示例（deletetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：deletetable.cpp，此程序演示freecplus框架操作Oracle数据库（删除表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果不需要绑定输入和输出变量，用stmt.execute()方法直接执行SQL语句，不需要stmt.prepare()。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>(<span class="string">&quot;delete from girls where id&gt;=2 and id&lt;=4&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次从girls表中删除了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306185024267.png" alt="在这里插入图片描述" /></p><h2 id="8-执行plsql过程"><a class="markdownIt-Anchor" href="#8-执行plsql过程"></a> 8、执行PL/SQL过程</h2><p><strong>示例（execplsql.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：execplsql.cpp，此程序演示freecplus框架操作Oracle数据库（执行PL/SQL过程）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment"> *  说说我个人的看法，我从不在Oracle数据库中创建PL/SQL过程，也很少使用触发器，原因如下：</span></span><br><span class="line"><span class="comment"> *  1、在Oracle数据库中创建PL/SQL过程，程序的调试很麻烦；</span></span><br><span class="line"><span class="comment"> *  2、维护工作很麻烦，因为维护人员要花时间去了解数据库中的存储过程；</span></span><br><span class="line"><span class="comment"> *  3、采用freecplus框架操作Oracle已经是非常简单，没必要去折腾存储过程；</span></span><br><span class="line"><span class="comment"> *  4、PL/SQL过程可移植性不好，如果换成mysql或其它数据库，比较麻烦。</span></span><br><span class="line"><span class="comment"> *  还有，我在C/C++程序中很少用复杂的PL/SQL过程，因为复杂的PL/SQL调试麻烦。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> id=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的PL/SQL语句，先删除girls表中的全部记录，再插入一条记录。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    BEGIN\</span></span><br><span class="line"><span class="string">      delete from girls;\</span></span><br><span class="line"><span class="string">      insert into girls(id,name,weight,btime)\</span></span><br><span class="line"><span class="string">                 values(:1,&#x27;超女过程&#x27;,55.65,to_date(&#x27;2018-01-02 13:00:55&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;));\</span></span><br><span class="line"><span class="string">    END;&quot;</span>);</span><br><span class="line">  <span class="comment">// 注意，PL/SQL中的每条SQL需要用分号结束，END之后还有一个分号。</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为PL/SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;id);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exec PL/SQL ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306185127654.png" alt="在这里插入图片描述" /></p><h2 id="9-clob和blob字段的操作"><a class="markdownIt-Anchor" href="#9-clob和blob字段的操作"></a> 9、CLOB和BLOB字段的操作</h2><p>sqlstatement类还可以操作CLOB和BLOB字段，在实际开发中，这种需求不多，本文就不演示了，如果您在项目开发中有这方面的需求，可以参考demo程序，示例程序位于freecplus/db/oracle目录中，如下：</p><p>filetoclob.cpp：把文本文件存入数据表的CLOB字段。</p><p>clobtofile.cpp：把数据表CLOB字段中的内容导出到文本文件中。</p><p>filetoblob.cpp：把文本文件存入数据表的BLOB字段。</p><p>blobtofile.cpp：把数据表BLOB字段中的内容导出到文本文件中。</p><h1 id="八-应用经验"><a class="markdownIt-Anchor" href="#八-应用经验"></a> 八、应用经验</h1><p>freecplus框架的connection和sqlstatement类把OCI的强大功能充分的发挥了出来，且性能卓越。本文提供的示例程序看上去简单，实则很精妙，希望大家多多思考，慢慢体会。</p><p>为了让大家完全掌握connection和sqlstatement类的用法，我将录制freecplus框架的专题视频，请大家多关注C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）发布的内容。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ftp客户端</title>
      <link href="/post/7d4330a2.html"/>
      <url>/post/7d4330a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的ftp客户端Cftp类。</p><p>Cftp类的声明文件是freecplus/_ftp.h。</p><p>Cftp类的定义文件是freecplus/_ftp.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><p>Cftp类是在ftplib开源库的基础之上做了二次封装，ftplib开源库的头文件是freecplus/ftplib.h，函数定义文件是freecplus/ftplib.c。</p><p>ftplib是C代码，用gcc先编译成lib库文件后，再用g++和_ftp.cpp以及目标文件一起编译。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍ftp协议的基础知识和ftp命令，在阅读本文之前，您必须熟悉ftp协议和命令才能看懂本文的内容。</p><h1 id="三-cftp类"><a class="markdownIt-Anchor" href="#三-cftp类"></a> 三、Cftp类</h1><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cftp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  netbuf *m_ftpconn;   <span class="comment">// ftp连接句柄。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m_size; <span class="comment">// 文件的大小，单位：字节。</span></span><br><span class="line">  <span class="type">char</span> m_mtime[<span class="number">21</span>];    <span class="comment">// 文件的修改时间，格式：yyyymmddhh24miss。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下三个成员变量用于存放login方法登录失败的原因。</span></span><br><span class="line">  <span class="type">bool</span> m_connectfailed;    <span class="comment">// 连接失败。</span></span><br><span class="line">  <span class="type">bool</span> m_loginfailed;      <span class="comment">// 登录失败，用户名和密码不正确，或没有登录权限。</span></span><br><span class="line">  <span class="type">bool</span> m_optionfailed;     <span class="comment">// 设置传输模式失败。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Cftp</span>();  <span class="comment">// 类的构造函数。</span></span><br><span class="line"> ~<span class="built_in">Cftp</span>();  <span class="comment">// 类的析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initdata</span><span class="params">()</span></span>;   <span class="comment">// 初始化m_size和m_mtime成员变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录ftp服务器。</span></span><br><span class="line">  <span class="comment">// host：ftp服务器ip地址和端口，中间用&quot;:&quot;分隔，如&quot;192.168.1.1:21&quot;。</span></span><br><span class="line">  <span class="comment">// username：登录ftp服务器用户名。</span></span><br><span class="line">  <span class="comment">// password：登录ftp服务器的密码。</span></span><br><span class="line">  <span class="comment">// imode：传输模式，FTPLIB_PASSIVE是被动模式，FTPLIB_PORT是主动模式，缺省是被动模式。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">login</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">const</span> <span class="type">char</span> *username,<span class="type">const</span> <span class="type">char</span> *password,<span class="type">const</span> <span class="type">int</span> imode=FTPLIB_PASSIVE)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注销。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">logout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取ftp服务器上文件的时间。</span></span><br><span class="line">  <span class="comment">// remotefilename：待获取的文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：false-失败；true-成功，获取到的文件时间存放在m_mtime成员变量中。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">mtime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取ftp服务器上文件的大小。</span></span><br><span class="line">  <span class="comment">// remotefilename：待获取的文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：false-失败；true-成功，获取到的文件大小存放在m_size成员变量中。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">size</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改变ftp服务器的当前工作目录。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器上的目录名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在ftp服务器上创建目录。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器上待创建的目录名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除ftp服务器上的目录。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器上待删除的目录名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送NLST命令列出ftp服务器的目录和文件名。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器的目录名。</span></span><br><span class="line">  <span class="comment">// listfilename：用于保存从服务器返回的目录和文件名列表。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="comment">// 注意：如果列出的是ftp服务器当前目录，remotedir用&quot;&quot;,&quot;*&quot;,&quot;.&quot;都可以，但是，不规范的ftp服务器可能有差别。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">nlist</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir,<span class="type">const</span> <span class="type">char</span> *listfilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从ftp服务器上获取文件。</span></span><br><span class="line">  <span class="comment">// remotefilename：待获取ftp服务器上的文件名。</span></span><br><span class="line">  <span class="comment">// localfilename：保存到本地的文件名。</span></span><br><span class="line">  <span class="comment">// bCheckMTime：文件传输完成后，是否核对远程文件传输前后的时间，保证文件的完整性。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="comment">// 注意：文件在传输的过程中，采用临时文件命名的方法，即在localfilename后加&quot;.tmp&quot;，在传输</span></span><br><span class="line">  <span class="comment">// 完成后才正式改为localfilename。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename,<span class="type">const</span> <span class="type">char</span> *localfilename,<span class="type">const</span> <span class="type">bool</span> bCheckMTime=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向ftp服务器发送文件。</span></span><br><span class="line">  <span class="comment">// localfilename：本地待发送的文件名。</span></span><br><span class="line">  <span class="comment">// remotefilename：发送到ftp服务器上的文件名。</span></span><br><span class="line">  <span class="comment">// bCheckSize：文件传输完成后，是否核对本地文件和远程文件的大小，保证文件的完整性。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="comment">// 注意：文件在传输的过程中，采用临时文件命名的方法，即在remotefilename后加&quot;.tmp&quot;，在传输</span></span><br><span class="line">  <span class="comment">// 完成后才正式改为remotefilename。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *localfilename,<span class="type">const</span> <span class="type">char</span> *remotefilename,<span class="type">const</span> <span class="type">bool</span> bCheckSize=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除ftp服务器上的文件。</span></span><br><span class="line">  <span class="comment">// remotefilename：待删除的ftp服务器上的文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ftpdelete</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重命名ftp服务器上的文件。</span></span><br><span class="line">  <span class="comment">// srcremotefilename：ftp服务器上的原文件名。</span></span><br><span class="line">  <span class="comment">// dstremotefilename：ftp服务器上的目标文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ftprename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *srcremotefilename,<span class="type">const</span> <span class="type">char</span> *dstremotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以下三个方法如果理解不了就算了，可以不启用。 */</span></span><br><span class="line">  <span class="comment">// 发送LIST命令列出ftp服务器目录中的文件。</span></span><br><span class="line">  <span class="comment">// 参数和返回值与nlist方法相同。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir,<span class="type">const</span> <span class="type">char</span> *listfilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向ftp服务器发送site命令。</span></span><br><span class="line">  <span class="comment">// command：命令的内容。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">site</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取服务器返回信息的最后一条(return a pointer to the last response received)。</span></span><br><span class="line">  <span class="function"><span class="type">char</span> *<span class="title">response</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-准备测试环境"><a class="markdownIt-Anchor" href="#四-准备测试环境"></a> 四、准备测试环境</h1><p>在演示示例程序之前，我认为您已经是一个职业的C/C++程序员，熟悉Linux操作系统、熟悉ftp协议。</p><h2 id="1-创建linux操作系统用户"><a class="markdownIt-Anchor" href="#1-创建linux操作系统用户"></a> 1、创建Linux操作系统用户</h2><p>创建freecplus用户，用户组为bin，用户根目录为/home/freecplus，密码为freecpluspwd</p><h2 id="在这里插入图片描述2-安装配置ftp服务器"><a class="markdownIt-Anchor" href="#在这里插入图片描述2-安装配置ftp服务器"></a> <img src="https://img-blog.csdnimg.cn/20200306170149537.png" alt="在这里插入图片描述" /><br />2、安装配置ftp服务器</h2><p>具体操作请参考C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）的相关文章，或在网上搜索相关的文章。</p><h2 id="3-配置防火墙"><a class="markdownIt-Anchor" href="#3-配置防火墙"></a> 3、配置防火墙</h2><p>具体操作请参考C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）的相关文章，或在网上搜索相关的文章。</p><h2 id="4-准备测试的文件"><a class="markdownIt-Anchor" href="#4-准备测试的文件"></a> 4、准备测试的文件</h2><p>把freecplus框架的源代码复制到/home/freecplus目录，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306170209163.png" alt="在这里插入图片描述" /></p><h1 id="五-示例程序"><a class="markdownIt-Anchor" href="#五-示例程序"></a> 五、示例程序</h1><h2 id="1-获取服务器文件列表-时间和大小"><a class="markdownIt-Anchor" href="#1-获取服务器文件列表-时间和大小"></a> 1、获取服务器文件列表、时间和大小</h2><p><strong>示例（demo50.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo50.cpp，此程序演示采用freecplus框架的Cftp类获取服务器文件列表、时间和大小。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cftp ftp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录远程FTP服务器，请改为您自己服务器的ip地址。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">login</span>(<span class="string">&quot;172.16.0.15:21&quot;</span>,<span class="string">&quot;freecplus&quot;</span>,<span class="string">&quot;freecpluspwd&quot;</span>,FTPLIB_PASSIVE) == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(172.16.0.15:21(freecplus/freecpluspwd)) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取服务器上/home/freecplus/*.h文件列表，保存在本地的/tmp/list/tmp.list文件中。</span></span><br><span class="line">  <span class="comment">// 如果/tmp/list目录不存在，就创建它。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">nlist</span>(<span class="string">&quot;/home/freecplus/*.h&quot;</span>,<span class="string">&quot;/tmp/list/tmp.list&quot;</span>)==<span class="literal">false</span>) </span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.nlist() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;    <span class="comment">// 采用freecplus框架的CFile类来操作list文件。</span></span><br><span class="line">  <span class="type">char</span> strFileName[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  File.<span class="built_in">Open</span>(<span class="string">&quot;/tmp/list/tmp.list&quot;</span>,<span class="string">&quot;r&quot;</span>);  <span class="comment">// 打开list文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)    <span class="comment">// 获取每个文件的时间和大小。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Fgets</span>(strFileName,<span class="number">300</span>,<span class="literal">true</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ftp.<span class="built_in">mtime</span>(strFileName); <span class="comment">// 获取文件时间。</span></span><br><span class="line">    ftp.<span class="built_in">size</span>(strFileName);  <span class="comment">// 获取文件大小。</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;filename=%s,mtime=%s,size=%d\n&quot;</span>,strFileName,ftp.m_mtime,ftp.m_size);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306170253376.png" alt="在这里插入图片描述" /></p><h2 id="2-把文件上传到服务器"><a class="markdownIt-Anchor" href="#2-把文件上传到服务器"></a> 2、把文件上传到服务器</h2><p><strong>示例（demo51.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo51.cpp，此程序演示采用freecplus框架的Cftp类上传文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cftp ftp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录远程FTP服务器，请改为您自己服务器的ip地址。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">login</span>(<span class="string">&quot;172.16.0.15:21&quot;</span>,<span class="string">&quot;freecplus&quot;</span>,<span class="string">&quot;freecpluspwd&quot;</span>,FTPLIB_PASSIVE) == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(172.16.0.15:21(freecplus/freecpluspwd)) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在ftp服务器上创建/home/freecplus/tmp，注意，如果目录已存在，会返回失败。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">mkdir</span>(<span class="string">&quot;/home/freecplus/tmp&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.mkdir() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把ftp服务器上的工作目录切换到/home/freecplus/tmp</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">chdir</span>(<span class="string">&quot;/home/freecplus/tmp&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.chdir() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把本地的demo51.cpp上传到ftp服务器的当前工作目录。</span></span><br><span class="line">  ftp.<span class="built_in">put</span>(<span class="string">&quot;demo51.cpp&quot;</span>,<span class="string">&quot;demo51.cpp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不调用chdir切换工作目录，以下代码也可以直接上传文件。</span></span><br><span class="line">  <span class="comment">// ftp.put(&quot;demo51.cpp&quot;,&quot;/home/freecplus/tmp/demo51.cpp&quot;);</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;put demo51.cpp ok.\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-从服务器下载文件"><a class="markdownIt-Anchor" href="#3-从服务器下载文件"></a> 3、从服务器下载文件</h2><p><strong>示例（demo52.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo52.cpp，此程序演示采用freecplus框架的Cftp类下载文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cftp ftp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录远程FTP服务器，请改为您自己服务器的ip地址。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">login</span>(<span class="string">&quot;172.16.0.15:21&quot;</span>,<span class="string">&quot;freecplus&quot;</span>,<span class="string">&quot;freecpluspwd&quot;</span>,FTPLIB_PASSIVE) == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(172.16.0.15:21(freecplus/freecpluspwd)) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器上的/home/freecplus/tmp/demo51.cpp下载到本地，存为/tmp/test/demo51.cpp。</span></span><br><span class="line">  <span class="comment">// 如果本地的/tmp/test目录不存在，就创建它。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">get</span>(<span class="string">&quot;/home/freecplus/tmp/demo51.cpp&quot;</span>,<span class="string">&quot;/tmp/test/demo51.cpp&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.get() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;get /home/freecplus/tmp/demo51.cpp ok.\n&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除服务上的/home/freecplus/tmp/demo51.cpp文件。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">ftpdelete</span>(<span class="string">&quot;/home/freecplus/tmp/demo51.cpp&quot;</span>)==<span class="literal">false</span>) </span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.ftpdelete() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;delete /home/freecplus/tmp/demo51.cpp ok.\n&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除服务器上的/home/freecplus/tmp目录，如果目录非空，删除将失败。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">rmdir</span>(<span class="string">&quot;/home/freecplus/tmp&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.rmdir() failed.\n&quot;</span>);<span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp网络通信</title>
      <link href="/post/5454c89c.html"/>
      <url>/post/5454c89c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的TCP/IP协议网络通信的函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>freecplus框架对socket通信封装如下：</p><p>CTcpClient类：socket通信的客户端类。</p><p>CTcpServer类：socket通信的服务端类。</p><p>TcpRead函数：接收socket的对端发送过来的数据。</p><p>TcpWrite函数：向socket的对端发送数据。</p><p>Readn函数：从已经准备好的socket中读取数据。</p><p>Writen函数：向已经准备好的socket中写入数据。</p><p>在阅读本文章之前，您必须熟悉TCP/IP协议和socket通信，本文是介绍的是freecplus框架中网络通信的类和函数的用法，不会介绍网络通信的基础知识。</p><h1 id="三-通信的报文格式"><a class="markdownIt-Anchor" href="#三-通信的报文格式"></a> 三、通信的报文格式</h1><p>freecplus框架的socket通信报文格式如下：</p><p><strong>报文长度+报文内容</strong></p><p>报文长度为4字节的整数，表示的是<strong>报文内容</strong>的长度，而不是整个TCP报文的长度，整个TCP报文的长度是<strong>报文内容的长度+4</strong>。</p><p>报文长度是4字节的整数，即int，是以二进制流的方式写入socket，不是ascii码。</p><p>采用CTcpClient类、CTcpServer类、TcpRead函数和TcpWrite函数进行socket通信，可以避免TCP报文<strong>粘包</strong>的问题。</p><h1 id="四-socket通信客户端"><a class="markdownIt-Anchor" href="#四-socket通信客户端"></a> 四、socket通信客户端</h1><p>socket通信的客户端封装在CTcpClient类中。</p><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket通信的客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span>  m_sockfd;    <span class="comment">// 客户端的socket.</span></span><br><span class="line">  <span class="type">char</span> m_ip[<span class="number">21</span>];    <span class="comment">// 服务端的ip地址。</span></span><br><span class="line">  <span class="type">int</span>  m_port;      <span class="comment">// 与服务端通信的端口。</span></span><br><span class="line">  <span class="type">bool</span> m_state;     <span class="comment">// 与服务端的socket连接状态。</span></span><br><span class="line">  <span class="type">bool</span> m_btimeout;  <span class="comment">// 调用Read和Write方法时，失败的原因是否是超时：true-未超时，false-已超时。</span></span><br><span class="line">  <span class="type">int</span>  m_buflen;    <span class="comment">// 调用Read方法后，接收到的报文的大小，单位：字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpClient</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发起连接请求。</span></span><br><span class="line">  <span class="comment">// ip：服务端的ip地址。</span></span><br><span class="line">  <span class="comment">// port：服务端监听的端口。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收服务端发送过来的数据。</span></span><br><span class="line">  <span class="comment">// buffer：接收数据缓冲区的地址，数据的长度存放在m_buflen成员变量中。</span></span><br><span class="line">  <span class="comment">// itimeout：等待数据的超时时间，单位：秒，缺省值是0-无限等待。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时，成员变量m_btimeout的值被设置为true；2）socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> itimeout=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发送数据。</span></span><br><span class="line">  <span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line">  <span class="comment">// ibuflen：待发送数据的大小，单位：字节，缺省值为0，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与服务端的连接</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CTcpClient</span>();  <span class="comment">// 析构函数自动关闭socket，释放资源。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-socket通信的服务端"><a class="markdownIt-Anchor" href="#五-socket通信的服务端"></a> 五、socket通信的服务端</h1><p>socket通信的服务端封装在CTcpServer类中。</p><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket通信的服务端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_socklen;                    <span class="comment">// 结构体struct sockaddr_in的大小。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> m_clientaddr;  <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> m_servaddr;    <span class="comment">// 服务端的地址信息。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span>  m_listenfd;   <span class="comment">// 服务端用于监听的socket。</span></span><br><span class="line">  <span class="type">int</span>  m_connfd;     <span class="comment">// 客户端连接上来的socket。</span></span><br><span class="line">  <span class="type">bool</span> m_btimeout;   <span class="comment">// 调用Read和Write方法时，失败的原因是否是超时：true-未超时，false-已超时。</span></span><br><span class="line">  <span class="type">int</span>  m_buflen;     <span class="comment">// 调用Read方法后，接收到的报文的大小，单位：字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端初始化。</span></span><br><span class="line">  <span class="comment">// port：指定服务端用于监听的端口。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，一般情况下，只要port设置正确，没有被占用，初始化都会成功。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> port)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞等待客户端的连接请求。</span></span><br><span class="line">  <span class="comment">// 返回值：true-有新的客户端已连接上来，false-失败，Accept被中断，如果Accept失败，可以重新Accept。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取客户端的ip地址。</span></span><br><span class="line">  <span class="comment">// 返回值：客户端的ip地址，如&quot;192.168.1.100&quot;。</span></span><br><span class="line">  <span class="function"><span class="type">char</span> *<span class="title">GetIP</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收客户端发送过来的数据。</span></span><br><span class="line">  <span class="comment">// buffer：接收数据缓冲区的地址，数据的长度存放在m_buflen成员变量中。</span></span><br><span class="line">  <span class="comment">// itimeout：等待数据的超时时间，单位：秒，缺省值是0-无限等待。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时，成员变量m_btimeout的值被设置为true；2）socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> itimeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向客户端发送数据。</span></span><br><span class="line">  <span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line">  <span class="comment">// ibuflen：待发送数据的大小，单位：字节，缺省值为0，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭监听的socket，即m_listenfd，常用于多进程服务程序的子进程代码中。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭客户端的socket，即m_connfd，常用于多进程服务程序的父进程代码中。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CTcpServer</span>();  <span class="comment">// 析构函数自动关闭socket，释放资源。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-客户端"><a class="markdownIt-Anchor" href="#1-客户端"></a> 1、客户端</h2><p><strong>示例（demo47.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo47.cpp，此程序演示采用freecplus框架的CTcpClient类实现socket通信的客户端。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpClient TcpClient;   <span class="comment">// 创建客户端的对象。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;172.16.0.15&quot;</span>,<span class="number">5858</span>)==<span class="literal">false</span>) <span class="comment">// 向服务端发起连接请求。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;172.16.0.15\&quot;,5858) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];    <span class="comment">// 存放数据的缓冲区。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)   <span class="comment">// 利用循环，与服务端进行5次交互。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">snprintf</span>(strbuffer,<span class="number">50</span>,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Write</span>(strbuffer)==<span class="literal">false</span>) <span class="keyword">break</span>;    <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Read</span>(strbuffer,<span class="number">20</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;  <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 程序直接退出，析构函数会释放资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-服务端"><a class="markdownIt-Anchor" href="#2-服务端"></a> 2、服务端</h2><p><strong>示例（demo48.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo48.cpp，此程序演示采用freecplus框架的CTcpServer类实现socket通信的服务端。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpServer TcpServer;   <span class="comment">// 创建服务端对象。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5858</span>)==<span class="literal">false</span>) <span class="comment">// 初始化TcpServer的通信端口。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.InitServer(5858) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>()==<span class="literal">false</span>)   <span class="comment">// 等待客户端连接。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.Accept() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端(%s)已连接。\n&quot;</span>,TcpServer.<span class="built_in">GetIP</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];  <span class="comment">// 存放数据的缓冲区。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Read</span>(strbuffer,<span class="number">300</span>)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 接收客户端发过来的请求报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);      <span class="comment">// 在客户端的报文后加上&quot;ok&quot;。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Write</span>(strbuffer)==<span class="literal">false</span>) <span class="keyword">break</span>;     <span class="comment">// 向客户端回应报文。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开。\n&quot;</span>);    <span class="comment">// 程序直接退出，析构函数会释放资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-运行程序前的准备端"><a class="markdownIt-Anchor" href="#3-运行程序前的准备端"></a> 3、运行程序前的准备端</h2><p>我希望您已经学过计算机网络的基础知识，在运行示例程序之前，请确保您的Linux操作系统已开通防火墙。</p><p>在demo47.cpp和demo48.cpp程序中，服务端的ip地址和通信端口是写死在程序中的，请根据您的实际情况修改它们，然后重新编译。</p><h2 id="4-运行程序"><a class="markdownIt-Anchor" href="#4-运行程序"></a> 4、运行程序</h2><p>先启动demo48，然后启动demo47。</p><p><strong>demo47的运行效果如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306164235224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>demo48的运行效果如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306164329299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="七-socket通信的函数"><a class="markdownIt-Anchor" href="#七-socket通信的函数"></a> 七、socket通信的函数</h1><p>采用CTcpClient和CTcpServer类实现socket通信功能非常方便，但是在实际开发中，某些场景中不能只依赖这两个类，例如多程线和异步通信等场景，还必须结合以下将要介绍的几个函数一起使用。</p><h2 id="1-tcpread函数"><a class="markdownIt-Anchor" href="#1-tcpread函数"></a> 1、TcpRead函数</h2><p>接收socket的对端发送过来的数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TcpRead</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">char</span> *buffer,<span class="type">int</span> *ibuflen,<span class="type">const</span> <span class="type">int</span> itimeout=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>sockfd：可用的socket连接。</p><p>buffer：接收数据缓冲区的地址。</p><p>ibuflen：本次成功接收数据的字节数。</p><p>itimeout：接收等待超时的时间，单位：秒，缺省值是0-无限等待。</p><p>返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。</p><p>在CTcpClient和CTcpServer类的Read方法中调用了TcpRead函数。</p><h2 id="2-tcpwrite函数"><a class="markdownIt-Anchor" href="#2-tcpwrite函数"></a> 2、TcpWrite函数</h2><p>向socket的对端发送数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TcpWrite</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>sockfd：可用的socket连接。</p><p>buffer：待发送数据缓冲区的地址。</p><p>ibuflen：待发送数据的字节数，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</p><p>返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</p><p>在CTcpClient和CTcpServer类的Write方法中调用了TcpRead函数。</p><h2 id="3-readn函数"><a class="markdownIt-Anchor" href="#3-readn函数"></a> 3、Readn函数</h2><p>从已经准备好的socket中读取数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Readn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd：已经准备好的socket连接。</p><p>buffer：接收数据缓冲区的地址。</p><p>n：本次接收数据的字节数。</p><p>返回值：成功接收到n字节的数据后返回true，socket连接不可用返回false。</p><p>注意：</p><p>1）sockfd是已经准备好的socket连接，那什么是已经准备好的socket？在这个socket上，已经或马上有n字节的数据一定会到达。</p><p>2）成功接收到n字节的数据后返回true，如果没有n字节的数据怎么办？不会，在1）中已经说明了，一定会有n字节的数据会到达。</p><p>3）如果数据大于n字节怎么办？Readn只读取n个字节的数据，其它的数据属于其它的报文。</p><p>4）socket的对端是采用Writen方法写入的数据。</p><p>在TcpRead函数中，调用了Readn函数。</p><h2 id="4-writen函数"><a class="markdownIt-Anchor" href="#4-writen函数"></a> 4、Writen函数</h2><p>向已经准备好的socket中写入数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Writen</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd：已经准备好的socket连接。</p><p>buffer：待发送数据缓冲区的地址。</p><p>n：待发送数据的字节数。</p><p>返回值：成功发送完n字节的数据后返回true，socket连接不可用返回false。</p><p>在TcpWrite函数中，调用了Writen函数。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加载参数文件</title>
      <link href="/post/898d405.html"/>
      <url>/post/898d405.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中加载参数文件的方法。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-参数文件的意义"><a class="markdownIt-Anchor" href="#二-参数文件的意义"></a> 二、参数文件的意义</h1><p>在项目开发中，一个完整的系统由多个C/C++服务程序组成，这些服务程序有共同的参数，例如数据库的连接参数、日志文件存放的目录、数据文件存放的目录等。</p><p>传统的方法是把参数放在文本文件中，例如hssms.ini，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logpath=/log/hssms              # 日志文件存放的目录。</span><br><span class="line">connstr=hssms/smspwd@hssmszx  # 数据库连接参数。</span><br><span class="line">datapath=/data/hssms            # 数据文件存放的根目录。</span><br><span class="line">serverip=<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>            # 中心服务器的ip地址。</span><br><span class="line">port=<span class="number">5058</span>                         # 中心服务器的通信端口。</span><br><span class="line">online=<span class="literal">true</span>                       # 是否采用长连接。</span><br></pre></td></tr></table></figure><p>现在有更好的方法是把参数放在xml文件中，例如hssms.xml，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;gbk&quot;</span> ?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;!-- 程序运行的日志文件名。 --&gt;</span><br><span class="line">    &lt;logpath&gt;/log/hssms&lt;/logpath&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据库连接参数。 --&gt;</span><br><span class="line">    &lt;connstr&gt;hssms/smspwd@hssmszx&lt;/connstr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据文件存放的根目录。 --&gt;</span><br><span class="line">    &lt;datapath&gt;/data/hssms&lt;/datapath&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 中心服务器的ip地址。 --&gt;</span><br><span class="line">    &lt;serverip&gt;<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>&lt;/serverip&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 中心服务器的通信端口。 --&gt;</span><br><span class="line">    &lt;port&gt;<span class="number">5058</span>&lt;/port&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 是否采用长连接，<span class="literal">true</span>-是；<span class="literal">false</span>-否。 --&gt;</span><br><span class="line">    &lt;online&gt;<span class="literal">true</span>&lt;/online&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>一般来说，一个项目是由多种语言开发完成，xml文件格式比传统的ini文件格式更方便。</p><h1 id="三-cinifile类"><a class="markdownIt-Anchor" href="#三-cinifile类"></a> 三、CIniFile类</h1><p>CIniFile类用于服务程序从参数文件中加载参数。</p><h2 id="1-类的声明"><a class="markdownIt-Anchor" href="#1-类的声明"></a> 1、类的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数文件操作类。</span></span><br><span class="line"><span class="comment">// CIniFile类操作的是xml格式的参数文件，并不是传统的ini文件。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CIniFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 存放参数文件全部的内容，由LoadFile载入到本变量中。</span></span><br><span class="line">  string m_xmlbuffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CIniFile</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把参数文件的内容载入到m_xmlbuffer变量中。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">LoadFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数文件字段的内容。</span></span><br><span class="line">  <span class="comment">// fieldname：字段的标签名。</span></span><br><span class="line">  <span class="comment">// value：传入变量的地址，用于存放字段内容，支持bool、int、insigned int、long、unsigned long、double和char[]。</span></span><br><span class="line">  <span class="comment">// 注意，当value参数的数据类型为char []时，必须保证value数组的内存足够，否则可能发生内存溢出的问题，</span></span><br><span class="line">  <span class="comment">// 也可以用ilen参数限定获取字段内容的长度，ilen的缺省值为0，表示不限定获取字段内容的长度。</span></span><br><span class="line">  <span class="comment">// 返回值：true-获取成功；false-获取失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">bool</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">int</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">char</span> *value,<span class="type">const</span> <span class="type">int</span> ilen=<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-示例程序"><a class="markdownIt-Anchor" href="#2-示例程序"></a> 2、示例程序</h2><p><strong>示例（demo45.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo45.cpp，此程序演示采用freecplus框架的CIniFile类加载参数文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放本程序运行参数的数据结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_args</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> logpath[<span class="number">301</span>];</span><br><span class="line">  <span class="type">char</span> connstr[<span class="number">101</span>];</span><br><span class="line">  <span class="type">char</span> datapath[<span class="number">301</span>];</span><br><span class="line">  <span class="type">char</span> serverip[<span class="number">51</span>];</span><br><span class="line">  <span class="type">int</span>  port;</span><br><span class="line">  <span class="type">bool</span> online;</span><br><span class="line">&#125;stargs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果执行程序时输入的参数不正确，给出帮助信息。</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nusing:/freecplus/demo/demo45 inifile\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;samples:/freecplus/demo/demo45 /freecplus/ini/hssms.xml\n\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载参数文件。</span></span><br><span class="line">  CIniFile IniFile;</span><br><span class="line">  <span class="keyword">if</span> (IniFile.<span class="built_in">LoadFile</span>(argv[<span class="number">1</span>])==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IniFile.LoadFile(%s) failed.\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数，存放在stargs结构中。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;stargs,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_args));</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;logpath&quot;</span>,stargs.logpath,<span class="number">300</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;connstr&quot;</span>,stargs.connstr,<span class="number">100</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;datapath&quot;</span>,stargs.datapath,<span class="number">300</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;serverip&quot;</span>,stargs.serverip,<span class="number">50</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;port&quot;</span>,&amp;stargs.port);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;online&quot;</span>,&amp;stargs.online);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;logpath=%s\n&quot;</span>,stargs.logpath);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;connstr=%s\n&quot;</span>,stargs.connstr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;datapath=%s\n&quot;</span>,stargs.datapath);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;serverip=%s\n&quot;</span>,stargs.serverip);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;port=%d\n&quot;</span>,stargs.port);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;online=%d\n&quot;</span>,stargs.online);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下可以写更多的主程序的代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306161807982.png" alt="在这里插入图片描述" /></p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志文件操作</title>
      <link href="/post/c683fa0a.html"/>
      <url>/post/c683fa0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中日志文件操作的方法。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-日志文件的意义"><a class="markdownIt-Anchor" href="#二-日志文件的意义"></a> 二、日志文件的意义</h1><p>对于C/C++服务程序来说，程序运行在后台，没有操作界面，无人值守，程序运行的状态、数据处理的日志、程序的异常等必须记录在日志文件中，运维人员根据日志文件的内容，查看程序运行和数据处理的情况。</p><h1 id="三-clogfile类"><a class="markdownIt-Anchor" href="#三-clogfile类"></a> 三、CLogFile类</h1><p>CLogFile类用于服务程序记录程序的运行日志。</p><h2 id="1-类的声明"><a class="markdownIt-Anchor" href="#1-类的声明"></a> 1、类的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志文件操作类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLogFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FILE   *m_tracefp;           <span class="comment">// 日志文件指针。</span></span><br><span class="line">  <span class="type">char</span>    m_filename[<span class="number">301</span>];     <span class="comment">// 日志文件名，建议采用绝对路径。</span></span><br><span class="line">  <span class="type">char</span>    m_openmode[<span class="number">11</span>];      <span class="comment">// 日志文件的打开方式，一般采用&quot;a+&quot;。</span></span><br><span class="line">  <span class="type">bool</span>    m_bEnBuffer;         <span class="comment">// 写入日志时，是否启用操作系统的缓冲机制，缺省不启用。</span></span><br><span class="line">  <span class="type">long</span>    m_MaxLogSize;        <span class="comment">// 最大日志文件的大小，单位M，缺省100M。</span></span><br><span class="line">  <span class="type">bool</span>    m_bBackup;           <span class="comment">// 是否自动切换，日志文件大小超过m_MaxLogSize将自动切换，缺省启用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// MaxLogSize：最大日志文件的大小，单位M，缺省100M，最小为10M。</span></span><br><span class="line">  <span class="built_in">CLogFile</span>(<span class="type">const</span> <span class="type">long</span> MaxLogSize=<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开日志文件。</span></span><br><span class="line">  <span class="comment">// filename：日志文件名，建议采用绝对路径，如果文件名中的目录不存在，就先创建目录。</span></span><br><span class="line">  <span class="comment">// openmode：日志文件的打开方式，与fopen库函数打开文件的方式相同，缺省值是&quot;a+&quot;。</span></span><br><span class="line">  <span class="comment">// bBackup：是否自动切换，true-切换，false-不切换，在多进程的服务程序中，如果多个进行共用一个日志文件，bBackup必须为false。</span></span><br><span class="line">  <span class="comment">// bEnBuffer：是否启用文件缓冲机制，true-启用，false-不启用，如果启用缓冲区，那么写进日志文件中的内容不会立即写入文件，缺省是不启用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode=<span class="number">0</span>,<span class="type">bool</span> bBackup=<span class="literal">true</span>,<span class="type">bool</span> bEnBuffer=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果日志文件大于100M，就把当前的日志文件备份成历史日志文件，切换成功后清空当前日志文件的内容。</span></span><br><span class="line">  <span class="comment">// 备份后的文件会在日志文件名后加上日期时间。</span></span><br><span class="line">  <span class="comment">// 注意，在多进程的程序中，日志文件不可切换，多线的程序中，日志文件可以切换。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">BackupLogFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把内容写入日志文件，fmt是可变参数，使用方法与printf库函数相同。</span></span><br><span class="line">  <span class="comment">// Write方法会写入当前的时间，WriteEx方法不写时间。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WriteEx</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭日志文件</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CLogFile</span>();  <span class="comment">// 析构函数会调用Close方法。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-示例程序"><a class="markdownIt-Anchor" href="#2-示例程序"></a> 2、示例程序</h2><p><strong>示例（demo42.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo42.cpp，此程序演示采用freecplus框架的CLogFile类记录程序的运行日志。</span></span><br><span class="line"><span class="comment"> *  本程序修改demo40.cpp把输出的printf语句改为写日志文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CLogFile logfile;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开日志文件，如果&quot;/tmp/log&quot;不存在，就创建它，但是要确保当前用户具备创建目录的权限。</span></span><br><span class="line">  <span class="keyword">if</span> (logfile.<span class="built_in">Open</span>(<span class="string">&quot;/tmp/log/demo42.log&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;logfile.Open(/tmp/log/demo42.log) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo42程序开始运行。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描/tmp/data目录下文件名匹配&quot;surfdata_*.xml&quot;的文件。</span></span><br><span class="line">  <span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(<span class="string">&quot;/tmp/data&quot;</span>,<span class="string">&quot;surfdata_*.xml&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;Dir.OpenDir(/tmp/data) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Dir.<span class="built_in">ReadDir</span>()==<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;处理文件%s...&quot;</span>,Dir.m_FullFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Open</span>(Dir.m_FullFileName,<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">    &#123; logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed.File.Open(%s) failed.\n&quot;</span>,Dir.m_FullFileName); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以插入读取数据文件的内容、解析xml字符串并把数据写入数据库的代码。</span></span><br><span class="line">    <span class="comment">// 读取文本数据用Fgets和FFGETS方法，读取二进制数据用Fread方法。</span></span><br><span class="line">    <span class="comment">// 具体的代码我就不写了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完文件中的数据后，关闭文件指针，并删除文件。</span></span><br><span class="line">    File.<span class="built_in">CloseAndRemove</span>();</span><br><span class="line"></span><br><span class="line">    logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo42程序运行结束。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行demo39程序，在/tmp/data目录中生成几个数据文件，然后运行demo42，将生成日志文件/tmp/log/demo42.log，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306155446889.png" alt="在这里插入图片描述" /></p><h2 id="3-日志文件的切换"><a class="markdownIt-Anchor" href="#3-日志文件的切换"></a> 3、日志文件的切换</h2><p>我们通过一个示例程序的演示日志文件的切换功能，往日志文件中写入一千万数据，让它产生切换。</p><p><strong>示例（demo43.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo43.cpp，此程序演示freecplus框架的CLogFile类的日志文件的切换。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CLogFile logfile;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开日志文件，如果&quot;/tmp/log&quot;不存在，就创建它，但是要确保当前用户具备创建目录的权限。</span></span><br><span class="line">  <span class="keyword">if</span> (logfile.<span class="built_in">Open</span>(<span class="string">&quot;/tmp/log/demo43.log&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;logfile.Open(/tmp/log/demo43.log) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo43程序开始运行。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让程序循环10000000，生成足够大的日志。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">10000000</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;本程序演示日志文件的切换，这是第%010%d条记录。\n&quot;</span>,ii);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo43程序运行结束。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行demo43，将在/tmp/log目录中产生一批日志文件，用ls -l /tmp/log查看如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306155555194.png" alt="在这里插入图片描述" /></p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件操作.md</title>
      <link href="/post/b6f23339.html"/>
      <url>/post/b6f23339.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的文件操作的函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-文件操作函数"><a class="markdownIt-Anchor" href="#二-文件操作函数"></a> 二、文件操作函数</h1><h2 id="1-删除文件"><a class="markdownIt-Anchor" href="#1-删除文件"></a> 1、删除文件</h2><p>删除目录中的文件，类似Linux系统的rm命令。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">REMOVE</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">int</span> times=<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待删除的文件名，建议采用绝对路径的文件名，例如/tmp/root/data.xml。</p><p>times：执行删除文件的次数，缺省是1，建议不要超过3，从实际应用的经验看来，如果删除文件第1次不成功，再尝试2次是可以的，更多次就意义不大了。还有，如果执行删除失败，usleep(100000)后再重试。</p><p>返回值：true-删除成功；false-删除失败，失败的主要原因是权限不足。</p><p>在应用开发中，可以用REMOVE函数代替remove库函数。</p><h2 id="2-文件重命名"><a class="markdownIt-Anchor" href="#2-文件重命名"></a> 2、文件重命名</h2><p>把文件重命名，类似Linux系统的mv命令。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RENAME</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *srcfilename,<span class="type">const</span> <span class="type">char</span> *dstfilename,<span class="type">const</span> <span class="type">int</span> times=<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>srcfilename：原文件名，建议采用绝对路径的文件名。</p><p>destfilename：目标文件名，建议采用绝对路径的文件名。</p><p>times：执行重命名文件的次数，缺省是1，建议不要超过3，从实际应用的经验看来，如果重命名文件第1次不成功，再尝试2次是可以的，更多次就意义不大了。还有，如果执行重命名失败，usleep(100000)后再重试。</p><p>返回值：true-重命名成功；false-重命名失败，失败的主要原因是权限不足或磁盘空间不够，如果原文件和目标文件不在同一个磁盘分区，重命名也可能失败。</p><p>注意，在重命名文件之前，会自动创建destfilename参数中的目录名。</p><p>在应用开发中，可以用RENAME函数代替rename库函数。</p><h2 id="3-复制文件"><a class="markdownIt-Anchor" href="#3-复制文件"></a> 3、复制文件</h2><p>复制文件，类似Linux系统的cp命令。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">COPY</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *srcfilename,<span class="type">const</span> <span class="type">char</span> *dstfilename)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>srcfilename：原文件名，建议采用绝对路径的文件名。</p><p>destfilename：目标文件名，建议采用绝对路径的文件名。</p><p>返回值：true-复制成功；false-复制失败，失败的主要原因是权限不足或磁盘空间不够。</p><p>注意：</p><p>1）在复制名文件之前，会自动创建destfilename参数中的目录名。</p><p>2）复制文件的过程中，采用临时文件命名的方法，复制完成后再改名为destfilename，避免中间状态的文件被读取。</p><p>3）复制后的文件的时间与原文件相同，这一点与Linux系统cp命令不同。</p><h2 id="4-获取文件的大小"><a class="markdownIt-Anchor" href="#4-获取文件的大小"></a> 4、获取文件的大小</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待获取的文件名，建议采用绝对路径的文件名。</p><p>返回值：如果文件不存在或没有访问权限，返回-1，成功返回文件的大小，单位是字节。</p><h2 id="5-获取文件的时间"><a class="markdownIt-Anchor" href="#5-获取文件的时间"></a> 5、获取文件的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FileMTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">char</span> *mtime,<span class="type">const</span> <span class="type">char</span> *fmt=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待获取的文件名，建议采用绝对路径的文件名。</p><p>mtime：用于存放文件的时间，即stat结构体的st_mtime。</p><p>fmt：设置时间的输出格式，与LocalTime函数相同，但缺省是&quot;yyyymmddhh24miss&quot;。</p><p>返回值：如果文件不存在或没有访问权限，返回false，成功返回true。</p><h2 id="6-重置文件的时间"><a class="markdownIt-Anchor" href="#6-重置文件的时间"></a> 6、重置文件的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">UTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *mtime)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待重置的文件名，建议采用绝对路径的文件名。</p><p>stime：字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少。</p><p>返回值：true-成功；false-失败，失败的原因保存在errno中。</p><h2 id="7-示例程序"><a class="markdownIt-Anchor" href="#7-示例程序"></a> 7、示例程序</h2><p><strong>示例（demo34.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo34.cpp，此程序演示freecplus框架的文件操作函数的用法</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 删除文件。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">REMOVE</span>(<span class="string">&quot;/tmp/root/_freecplus.h&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;REMOVE(/tmp/root/_freecplus.h) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重命名文件。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">RENAME</span>(<span class="string">&quot;/tmp/root/_freecplus.cpp&quot;</span>,<span class="string">&quot;/tmp/root/aaa/bbb/ccc/_freecplus.cpp&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RENAME(/tmp/root/_freecplus.cpp) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 复制文件。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">COPY</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>,<span class="string">&quot;/tmp/root/aaa/bbb/ccc/_freecplus.h&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COPY(/freecplus/_freecplus.h) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size=%d\n&quot;</span>,<span class="built_in">FileSize</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置文件的时间。</span></span><br><span class="line">  <span class="built_in">UTime</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>,<span class="string">&quot;2020-01-05 13:37:29&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件的时间。</span></span><br><span class="line">  <span class="type">char</span> mtime[<span class="number">21</span>]; <span class="built_in">memset</span>(mtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(mtime));</span><br><span class="line">  <span class="built_in">FileMTime</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>,mtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mtime=%s\n&quot;</span>,mtime);   <span class="comment">// 输出mtime=2020-01-05 13:37:29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-文件读取函数"><a class="markdownIt-Anchor" href="#三-文件读取函数"></a> 三、文件读取函数</h1><h2 id="1-打开文件"><a class="markdownIt-Anchor" href="#1-打开文件"></a> 1、打开文件</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">FOPEN</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>FOPEN函数调用fopen库函数打开文件，如果文件名中包含的目录不存在，就创建目录。</p><p>FOPEN函数的参数和返回值与fopen函数完全相同。</p><p>在应用开发中，用FOPEN函数代替fopen库函数。</p><h2 id="2-读取文件"><a class="markdownIt-Anchor" href="#2-读取文件"></a> 2、读取文件</h2><p>从文本文件中读取一行。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FGETS</span><span class="params">(<span class="type">const</span> FILE *fp,<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> readsize,<span class="type">const</span> <span class="type">char</span> *endbz=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>fp：已打开的文件指针。</p><p>buffer：用于存放读取的内容。</p><p>readsize：本次打算读取的字节数，如果已经读取到了结束标志，函数返回。</p><p>endbz：行内容结束的标志，缺省为空，表示行内容以&quot;\n&quot;为结束标志。</p><p>返回值：true-成功；false-失败，一般情况下，失败可以认为是文件已结束。</p><h2 id="3-示例程序"><a class="markdownIt-Anchor" href="#3-示例程序"></a> 3、示例程序</h2><p><strong>示例（demo36.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo36.cpp，此程序演示freecplus框架中FOPEN函数的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用FOPEN函数代替fopen库函数，如果目录/tmp/aaa/bbb/ccc不存在，会创建它。</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">FOPEN</span>(<span class="string">&quot;/tmp/aaa/bbb/ccc/tmp.xml&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="number">0</span>)   </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FOPEN(/tmp/aaa/bbb/ccc/tmp.xml) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno)); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向文件中写入两行超女数据。</span></span><br><span class="line">  <span class="built_in">fprintf</span>(fp,<span class="string">&quot;&lt;data&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;妲已&lt;/name&gt;&lt;age&gt;28&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;商朝要亡，关我什么事。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;25&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;1、中国排名第一的美女；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;2、男朋友是范蠡；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;3、老公是夫差，被勾践弄死了。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(fp);  <span class="comment">// 关闭文件。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo36.cpp程序生成了数据文件/tmp/aaa/bbb/ccc/tmp.xml，数据内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306152837752.png" alt="在这里插入图片描述" /></p><p>以上数据文件只有两条有效的记录，但是第二条数据是跨多行的，在memo标签里，文字和换行符都是内容的一部分。</p><p><strong>示例（demo37.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo37.cpp，此程序演示freecplus框架中FGETS函数的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">FOPEN</span>(<span class="string">&quot;/tmp/aaa/bbb/ccc/tmp.xml&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FOPEN(/tmp/aaa/bbb/ccc/tmp.xml) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno)); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strBuffer[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strBuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strBuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FGETS</span>(fp,strBuffer,<span class="number">300</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;     <span class="comment">// 行内容以&quot;\n&quot;结束。</span></span><br><span class="line">    <span class="comment">//if (FGETS(fp,strBuffer,300,&quot;&lt;endl/&gt;&quot;)==false) break; // 行内容以&quot;&lt;endl/&gt;&quot;结束。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strBuffer=%s&quot;</span>,strBuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306152951257.png" alt="在这里插入图片描述" /></p><p>第二条记录的内容不完整，这并不是程序员想要的结果，如果demo37.cpp启用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">FGETS</span>(fp,strBuffer,<span class="number">300</span>,<span class="string">&quot;&lt;endl/&gt;&quot;</span>)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 行内容以&quot;&lt;endl/&gt;&quot;结束。</span></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306153021238.png" alt="在这里插入图片描述" /></p><p>这才是程序员想要的结果。</p><h1 id="四-cfile类"><a class="markdownIt-Anchor" href="#四-cfile类"></a> 四、CFile类</h1><p>CFile类根据实际开发中的应用场景，对常用的文件操作功能做了封装。</p><p>我们来先介绍类的声明，然后再列出常用应用场景的示例。</p><h2 id="1-类的声明"><a class="markdownIt-Anchor" href="#1-类的声明"></a> 1、类的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件操作类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FILE *m_fp;        <span class="comment">// 文件指针</span></span><br><span class="line">  <span class="type">bool</span>  m_bEnBuffer; <span class="comment">// 是否启用缓冲，true-启用；false-不启用，缺省是启用。</span></span><br><span class="line">  <span class="type">char</span>  m_filename[<span class="number">301</span>]; <span class="comment">// 文件名，建议采用绝对路径的文件名。</span></span><br><span class="line">  <span class="type">char</span>  m_filenametmp[<span class="number">301</span>]; <span class="comment">// 临时文件名，在m_filename后加&quot;.tmp&quot;。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数。</span></span><br><span class="line"> ~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsOpened</span><span class="params">()</span></span>;  <span class="comment">// 判断文件是否已打开，返回值：true-已打开；false-未打开。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开文件。</span></span><br><span class="line">  <span class="comment">// filename：待打开的文件名，建议采用绝对路径的文件名。</span></span><br><span class="line">  <span class="comment">// openmode：打开文件的模式，与fopen库函数的打开模式相同。</span></span><br><span class="line">  <span class="comment">// bEnBuffer：是否启用缓冲，true-启用；false-不启用，缺省是启用。</span></span><br><span class="line">  <span class="comment">// 注意：如果待打开的文件的目录不存在，就会创建目录。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode,<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针，并删除文件。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">CloseAndRemove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 专为重命名而打开文件，参数与Open方法相同。</span></span><br><span class="line">  <span class="comment">// 注意：OpenForRename打开的是filename后加&quot;.tmp&quot;的临时文件，所以openmode只能是&quot;a&quot;、&quot;a+&quot;、&quot;w&quot;、&quot;w+&quot;。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">OpenForRename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode,<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 关闭文件指针，并把OpenForRename方法打开的临时文件名重命名为filename。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">CloseAndRename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fprintf向文件写入数据，参数与fprintf库函数相同，但不需要传入文件指针。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从文件中读取以换行符&quot;\n&quot;结束的一行。</span></span><br><span class="line">  <span class="comment">// buffer：用于存放读取的内容。</span></span><br><span class="line">  <span class="comment">// readsize：本次打算读取的字节数，如果已经读取到了结束标志&quot;\n&quot;，函数返回。</span></span><br><span class="line">  <span class="comment">// bdelcrt：是否删除行结束标志，true-删除；false-不删除，缺省值是false。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，一般情况下，失败可以认为是文件已结束。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Fgets</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> readsize,<span class="type">bool</span> bdelcrt=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从文件文件中读取一行。</span></span><br><span class="line">  <span class="comment">// buffer：用于存放读取的内容。</span></span><br><span class="line">  <span class="comment">// readsize：本次打算读取的字节数，如果已经读取到了结束标志，函数返回。</span></span><br><span class="line">  <span class="comment">// endbz：行内容结束的标志，缺省为空，表示行内容以&quot;\n&quot;为结束标志。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，一般情况下，失败可以认为是文件已结束。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">FFGETS</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> readsize,<span class="type">const</span> <span class="type">char</span> *endbz=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从文件中读取数据块。</span></span><br><span class="line">  <span class="comment">// ptr：用于存放读取的内容。</span></span><br><span class="line">  <span class="comment">// size：本次打算读取的字节数。</span></span><br><span class="line">  <span class="comment">// 返回值：本次从文件中成功读取的字节数，如果文件未结束，返回值等于size，如果文件已结束，返回值为实际读取的字节数。</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Fread</span><span class="params">(<span class="type">void</span> *ptr,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向文件中写入数据块。</span></span><br><span class="line">  <span class="comment">// ptr：待写入数据的地址。</span></span><br><span class="line">  <span class="comment">// size：待写入数据的字节数。</span></span><br><span class="line">  <span class="comment">// 返回值：本次成功写入的字节数，如果磁盘空间足够，返回值等于size。</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针，如果存在临时文件，就删除它。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-应用场景示例"><a class="markdownIt-Anchor" href="#2-应用场景示例"></a> 2、应用场景示例</h2><p>在CFile类中，每个成员变量和函数都很容易理解，但不一定能准确的用于应用开发的场景中，我现在列出两个常用的场景。</p><p><strong>场景一：某程序每隔若干时间就会产生一批数据，并把这些数据写入文件中。</strong></p><p>程序的流程如下：</p><p>1）创建数据文件；</p><p>2）往文件中写入数据；</p><p>3）关闭数据文件。</p><p>如果程序这么写，得0分，因为这个流程存在一个严重的问题，那就是在第2）步往文件中写入数据需要时间，从创建文件到写入完成之前，这个文件的内容是不完整的，如果这个不完整的文件被其它程序读取了，怎么办？给文件加锁？用标志位区分？太麻烦。</p><p>假设待写入的数据文件名是/tmp/data/surfdata_20200101123000.txt，修改后的程序流程如下：</p><p>1）创建文件/tmp/data/surfdata_20200101123000.txt.tmp；</p><p>2）往文件中写入数据；</p><p>3）关闭数据文件；</p><p>4）把文件/tmp/data/surfdata_20200101123000.txt.tmp重命名为/tmp/data/surfdata_20200101123000.txt。</p><p><strong>示例（demo39.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo39.cpp，此程序演示freecplus框架中采用CFile类生成数据文件的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strLocalTime[<span class="number">21</span>];   <span class="comment">// 用于存放系统当前的时间，格式yyyymmddhh24miss。</span></span><br><span class="line">  <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line">  <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;yyyymmddhh24miss&quot;</span>);  <span class="comment">// 获取系统当前时间。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 生成绝对路径的文件名，目录/tmp/data，文件名：前缀(surfdata_)+时间+后缀(.xml)。</span></span><br><span class="line">  <span class="type">char</span> strFileName[<span class="number">301</span>];</span><br><span class="line">  <span class="built_in">SNPRINTF</span>(strFileName,<span class="built_in">sizeof</span>(strFileName),<span class="number">300</span>,<span class="string">&quot;/tmp/data/surfdata_%s.xml&quot;</span>,strLocalTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用OpenForRename创建文件，实际创建的文件名例如/tmp/data/surfdata_20200101123000.xml.tmp。</span></span><br><span class="line">  <span class="keyword">if</span> (File.<span class="built_in">OpenForRename</span>(strFileName,<span class="string">&quot;w&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File.OpenForRename(%s) failed.\n&quot;</span>,strFileName); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里可以插入向文件写入数据的代码。</span></span><br><span class="line">  <span class="comment">// 写入文本数据用Fprintf方法，写入二进制数据用Fwrite方法。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向文件中写入两行超女数据。</span></span><br><span class="line">  File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;data&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;妲已&lt;/name&gt;&lt;age&gt;28&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;商要亡，关我什么事。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;25&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;1、中国排名第一的美女；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;2、男朋友是范蠡；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;3、老公是夫差，被勾践弄死了。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">30</span>);   <span class="comment">// 停止30秒，用ls /tmp/data/*.tmp可以看到生成的临时文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针，并把临时文件名改为正式的文件名。</span></span><br><span class="line">  <span class="comment">// 注意，不能用File.Close()，因为Close方法是关闭文件指针，并删除临时文件。</span></span><br><span class="line">  <span class="comment">// CFile类的析构函数调用的是Close方法。</span></span><br><span class="line">  File.<span class="built_in">CloseAndRename</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每运行一次demo39程序，就会在/tmp/data目录下生成一个数据文件，如下：</p><p><img src="https://img-blog.csdnimg.cn/2020030615334735.png" alt="在这里插入图片描述" /></p><p><strong>场景二：从目录中读取场景一生成的数据文件，解析处理后保存到数据库中，然后删除目录中的文件。</strong></p><p>我们利用demo39程序生成的数据来测试。</p><p><strong>示例（demo40.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo40.cpp，此程序演示freecplus框架中采用CDir类和CFile类处理数据文件的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描/tmp/data目录下文件名匹配&quot;surfdata_*.xml&quot;的文件。</span></span><br><span class="line">  <span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(<span class="string">&quot;/tmp/data&quot;</span>,<span class="string">&quot;surfdata_*.xml&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dir.OpenDir(/tmp/data) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Dir.<span class="built_in">ReadDir</span>()==<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理文件%s...&quot;</span>,Dir.m_FullFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Open</span>(Dir.m_FullFileName,<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;failed.File.Open(%s) failed.\n&quot;</span>,Dir.m_FullFileName); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以插入读取数据文件的内容、解析xml字符串并把数据写入数据库的代码。</span></span><br><span class="line">    <span class="comment">// 读取文本数据用Fgets和FFGETS方法，读取二进制数据用Fread方法。</span></span><br><span class="line">    <span class="comment">// 具体的代码我就不写了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完文件中的数据后，关闭文件指针，并删除文件。</span></span><br><span class="line">    File.<span class="built_in">CloseAndRemove</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306153555992.png" alt="在这里插入图片描述" /></p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>目录操作</title>
      <link href="/post/c56c826c.html"/>
      <url>/post/c56c826c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的目录操作函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-创建目录"><a class="markdownIt-Anchor" href="#二-创建目录"></a> 二、创建目录</h1><p>在Linux下，如果想创建一个&quot;/tmp/aaa/bbb/ccc/ddd/data.xml&quot;的文件，必须先创建&quot;/tmp/aaa/bbb/ccc/ddd&quot;，步骤如下：</p><p>1）如果&quot;/tmp&quot;目录不存在，创建&quot;/tmp&quot;。</p><p>2）如果&quot;/tmp/aaa&quot;目录不存在，创建&quot;/tmp/aaa&quot;。</p><p>3）如果&quot;/tmp/aaa/bbb&quot;目录不存在，创建&quot;/tmp/aaa/bbb&quot;。</p><p>4）如果&quot;/tmp/aaa/bbb/ccc&quot;目录不存在，创建&quot;/tmp/aaa/bbb/ccc&quot;。</p><p>5）如果&quot;/tmp/aaa/bbb/ccc/ddd&quot;目录不存在，创建&quot;/tmp/aaa/bbb/ccc/ddd&quot;。</p><p>6）创建&quot;/tmp/aaa/bbb/ccc/ddd/data.xml&quot;文件。</p><p>这些操作虽然没有多少技术含量，但也很烦人。</p><p>MKDIR函数根据绝对路径的文件名或目录名逐级的创建目录。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MKDIR</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathorfilename,<span class="type">bool</span> bisfilename=<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>pathorfilename：绝对路径的文件名或目录名。</p><p>bisfilename：说明pathorfilename的类型，true-pathorfilename是文件名，否则是目录名，缺省值为true。</p><p>返回值：true-创建成功，false-创建失败，如果返回失败，原因有大概有三种情况：1）权限不足；2）pathorfilename参数不是合法的文件名或目录名；3）磁盘空间不足。</p><p><strong>示例（demo30.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo30.cpp，此程序演示freecplus框架中采用MKDIR函数根据绝对路径的文件名或目录名逐级的创建目录。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">MKDIR</span>(<span class="string">&quot;/tmp/aaa/bbb/ccc/ddd&quot;</span>,<span class="literal">false</span>);   <span class="comment">// 创建&quot;/tmp/aaa/bbb/ccc/ddd&quot;目录。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">MKDIR</span>(<span class="string">&quot;/tmp/111/222/333/444/data.xml&quot;</span>,<span class="literal">true</span>);   <span class="comment">// 创建&quot;/tmp/111/222/333/444&quot;目录。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-获取目录下的文件信息"><a class="markdownIt-Anchor" href="#三-获取目录下的文件信息"></a> 三、获取目录下的文件信息</h1><p>freecplus框架把获取某目录及其子目录中的文件列表信息的功能封装成CDir类。</p><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某目录及其子目录中的文件列表信息。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_DirName[<span class="number">301</span>];        <span class="comment">// 目录名，例如：/tmp/root。</span></span><br><span class="line">  <span class="type">char</span> m_FileName[<span class="number">301</span>];       <span class="comment">// 文件名，不包括目录名，例如：data.xml。</span></span><br><span class="line">  <span class="type">char</span> m_FullFileName[<span class="number">301</span>];   <span class="comment">// 文件全名，包括目录名，例如：/tmp/root/data.xml。</span></span><br><span class="line">  <span class="type">int</span>  m_FileSize;              <span class="comment">// 文件的大小，单位：字节。</span></span><br><span class="line">  <span class="type">char</span> m_ModifyTime[<span class="number">21</span>];      <span class="comment">// 文件最后一次被修改的时间，即stat结构体的st_mtime成员。</span></span><br><span class="line">  <span class="type">char</span> m_CreateTime[<span class="number">21</span>];      <span class="comment">// 文件生成的时间，即stat结构体的st_ctime成员。</span></span><br><span class="line">  <span class="type">char</span> m_AccessTime[<span class="number">21</span>];      <span class="comment">// 文件最后一次被访问的时间，即stat结构体的st_atime成员。</span></span><br><span class="line">  <span class="type">char</span> m_DateFMT[<span class="number">21</span>];         <span class="comment">// 文件时间显示格式，由SetDateFMT方法设置。</span></span><br><span class="line"></span><br><span class="line">  vector&lt;string&gt; m_vFileName; <span class="comment">// 存放OpenDir方法获取到的文件名（文件全名，包括目录名）列表。</span></span><br><span class="line">  <span class="type">int</span> m_pos;                  <span class="comment">// 已读取m_vFileName容器的位置，每调用一次ReadDir方法m_pos加1。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CDir</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initdata</span><span class="params">()</span></span>; <span class="comment">// 初始化成员变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置文件时间的格式，支持&quot;yyyy-mm-dd hh24:mi:ss&quot;和&quot;yyyymmddhh24miss&quot;两种，缺省是前者。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetDateFMT</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_DateFMT)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开目录，获取目录中的文件列表信息，存放于m_vFileName容器中。</span></span><br><span class="line">  <span class="comment">// in_DirName，待打开的目录名，采用绝对路径，如/tmp/root。</span></span><br><span class="line">  <span class="comment">// in_MatchStr，待获取文件名的匹配规则，不匹配的文件被忽略。</span></span><br><span class="line">  <span class="comment">// in_MaxCount，获取文件的最大数量，缺省值为10000个。</span></span><br><span class="line">  <span class="comment">// bAndChild，是否打开各级子目录，缺省值为false-不打开子目录。</span></span><br><span class="line">  <span class="comment">// bSort，是否对获取到的文件列表（即m_vFileName容器中的内容）进行排序，缺省值为false-不排序。</span></span><br><span class="line">  <span class="comment">// 返回值：如果in_DirName参数指定的目录不存在，OpenDir方法会创建该目录，如果创建失败，返回false，还有，如果当前用户对in_DirName目录下的子目录没有读取权限也会返回false，其它正常情况下都会返回true。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">OpenDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_DirName,<span class="type">const</span> <span class="type">char</span> *in_MatchStr,<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> in_MaxCount=<span class="number">10000</span>,<span class="type">const</span> <span class="type">bool</span> bAndChild=<span class="literal">false</span>,<span class="type">bool</span> bSort=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是一个递归函数，用于OpenDir()的调用，在CDir类的外部不需要调用它。</span></span><br><span class="line">  <span class="type">bool</span> _OpenDir(<span class="type">const</span> <span class="type">char</span> *in_DirName,<span class="type">const</span> <span class="type">char</span> *in_MatchStr,<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> in_MaxCount,<span class="type">const</span> <span class="type">bool</span> bAndChild);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从m_vFileName容器中获取一条记录（文件名），同时得到该文件的大小、修改时间等信息。</span></span><br><span class="line">  <span class="comment">// 调用OpenDir方法时，m_vFileName容器被清空，m_pos归零，每调用一次ReadDir方法m_pos加1。</span></span><br><span class="line">  <span class="comment">// 当m_pos小于m_vFileName.size()，返回true，否则返回false。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ReadDir</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CDir</span>();  <span class="comment">// 析构函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CDir类的成员变量和函数的说明文字在类的声明中已详细描述。</p><p>我们通过一个应用场景来演示CDir类的用法。</p><p>先执行以下脚本生成测试目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/root</span><br><span class="line">mkdir /tmp/root/aaa</span><br><span class="line">mkdir /tmp/root/bbb</span><br><span class="line">cd freecplus</span><br><span class="line">cp freecplus.* /tmp/root/.</span><br><span class="line">cp demo/demo1* /tmp/root/aaa/.</span><br><span class="line">cp demo/demo2* /tmp/root/bbb/.</span><br><span class="line">cp demo/makefile /tmp/root/bbb/.</span><br></pre></td></tr></table></figure><p>执行以上脚本后，在/tmp/root目录中的目录和文件列表如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306145307408.png" alt="在这里插入图片描述" /></p><p><strong>示例（demo32.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo32.cpp，此程序演示freecplus框架中采用CDir类获取某目录及其子目录中的文件列表信息。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(<span class="string">&quot;/tmp/root&quot;</span>,<span class="string">&quot;*.h,*cpp&quot;</span>,<span class="number">100</span>,<span class="literal">true</span>,<span class="literal">true</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dir.OpenDir(/tmp/root) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(Dir.<span class="built_in">ReadDir</span>()==<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;filename=%s,mtime=%s,size=%d\n&quot;</span>,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306145419165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意事项：</p><p>1）每次调用ReadDir方法后，把CDir类其它成员变量的值输出到屏幕，观察运行效果。</p><p>2）OpenDir方法的in_MatchStr参数非常重要，在实际开发中应用广泛。</p><p>3）如果文件名圆点&quot;.&quot;打头，OpenDir方法将不读取这些文件，如果您希望读取这些文件，可以修改_OpenDir方法中的源代码。</p><p>4）OpendDir方法的in_MaxCount参数设置了每次扫描目录中的文件数量，建议不超过10000，如果取值过大，打开目录的时间会比较长，还会消耗比较多的内存。</p><p>5）OpenDir的bSort参数设置是否对m_vFileName容器进行排序，排序会消耗资源和时间，可以不排序就不排序。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日期、时间和计时器</title>
      <link href="/post/cb3ca34c.html"/>
      <url>/post/cb3ca34c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的时间操作函数。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-计算机时间的表示方法"><a class="markdownIt-Anchor" href="#二-计算机时间的表示方法"></a> 二、计算机时间的表示方法</h1><p>UNIX操作系统根据计算机产生的年代和应用采用1970年1月1日作为UNIX的纪元时间，1970年1月1日0点作为计算机表示时间的是中间点，将从1970年1月1日开始经过的秒数用一个整数存放，这种高效简洁的时间表示方法被称为“Unix时间纪元”，向左和向右偏移都可以得到更早或者更后的时间。</p><p>在实际开发中，对日期和时间的操作场景非常多，例如程序启动和退出的时间，程序执行任务的时间，数据生成的时间，数据处理的各环节的时间等等。</p><p>在Linux系统中，自定义了time_t类型，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">time_t</span>;    <span class="comment">// 时间值time_t为长整型long的别名。</span></span><br></pre></td></tr></table></figure><h1 id="三-获取操作系统的时间"><a class="markdownIt-Anchor" href="#三-获取操作系统的时间"></a> 三、获取操作系统的时间</h1><p>取操作系统的时间，并把整数表示的时间转换为字符串表示的格式。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LocalTime</span><span class="params">(<span class="type">char</span> *out_stime,<span class="type">const</span> <span class="type">char</span> *in_fmt=<span class="number">0</span>,<span class="type">const</span> <span class="type">int</span> in_interval=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>stime：用于存放获取到的时间字符串。</p><p>timetvl：时间的偏移量，单位：秒，0是缺省值，表示当前时间，30表示当前时间30秒之后的时间点，-30表示当前时间30秒之前的时间点。</p><p>fmt：输出时间的格式，fmt每部分的含义：“yyyy”-年份；“mm”-月份；“dd”-日期；“hh24”-小时；“mi”-分钟；“ss”-秒，缺省是&quot;yyyy-mm-dd hh24:mi:ss&quot;，目前支持以下格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span></span><br><span class="line"><span class="string">&quot;yyyymmddhh24miss&quot;</span></span><br><span class="line"><span class="string">&quot;yyyy-mm-dd&quot;</span></span><br><span class="line"><span class="string">&quot;yyyymmdd&quot;</span></span><br><span class="line"><span class="string">&quot;hh24:mi:ss&quot;</span></span><br><span class="line"><span class="string">&quot;hh24miss&quot;</span></span><br><span class="line"><span class="string">&quot;hh24:mi&quot;</span></span><br><span class="line"><span class="string">&quot;hh24mi&quot;</span></span><br><span class="line"><span class="string">&quot;hh24&quot;</span></span><br><span class="line"><span class="string">&quot;mi&quot;</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>1）小时的表示方法是hh24，不是hh，这么做的目的是为了保持与数据库的时间表示方法一致；</p><p>2）以上列出了常用的时间格式，如果不能满足您应用开发的需求，请修改源代码timetostr函数增加更多的格式支持；</p><p>3）调用函数的时候，如果fmt与上述格式都匹配，stime的内容将为空。</p><p><strong>示例（demo24.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo24.cpp，此程序演示freecplus框架中LocalTime时间函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> strtime[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LocalTime</span>(strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">-30</span>);  <span class="comment">// 获取30秒前的时间。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime1=%s\n&quot;</span>,strtime);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LocalTime</span>(strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>);      <span class="comment">// 获取当前时间。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime2=%s\n&quot;</span>,strtime);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LocalTime</span>(strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">30</span>);   <span class="comment">// 获取30秒后的时间。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime3=%s\n&quot;</span>,strtime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-时间转换函数"><a class="markdownIt-Anchor" href="#四-时间转换函数"></a> 四、时间转换函数</h1><h2 id="1-把整数表示的时间转换为字符串表示的时间"><a class="markdownIt-Anchor" href="#1-把整数表示的时间转换为字符串表示的时间"></a> 1、把整数表示的时间转换为字符串表示的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">timetostr</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> ltime,<span class="type">char</span> *stime,<span class="type">const</span> <span class="type">char</span> *fmt=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>ltime：整数表示的时间。</p><p>stime：字符串表示的时间。</p><p>fmt：输出字符串时间stime的格式，与LocalTime函数的fmt参数相同，如果fmt的格式不正确，stime将为空。</p><h2 id="2-把字符串表示的时间转换为整数表示的时间"><a class="markdownIt-Anchor" href="#2-把字符串表示的时间转换为整数表示的时间"></a> 2、把字符串表示的时间转换为整数表示的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">strtotime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *stime)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>stime：字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少。</p><p>返回值：整数表示的时间，如果stime的格式不正确，返回-1。</p><p><strong>示例（demo26.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo26.cpp，此程序演示freecplus框架中整数表示的时间和字符串表示的时间之间的转换。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">time_t</span> ltime;</span><br><span class="line">  <span class="type">char</span> strtime[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strtime,<span class="string">&quot;2020-01-01 12:35:22&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ltime=<span class="built_in">strtotime</span>(strtime);    <span class="comment">// 转换为整数的时间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ltime=%ld\n&quot;</span>,ltime); <span class="comment">// 输出ltime=1577853322</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line">  <span class="built_in">timetostr</span>(ltime,strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>);  <span class="comment">// 转换为字符串的时间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime=%s\n&quot;</span>,strtime);     <span class="comment">// 输出strtime=2020-01-01 12:35:22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-时间的运算"><a class="markdownIt-Anchor" href="#五-时间的运算"></a> 五、时间的运算</h1><p>把字符串表示的时间加上一个偏移的秒数后得到一个新的字符串表示的时间。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AddTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_stime,<span class="type">char</span> *out_stime,<span class="type">const</span> <span class="type">int</span> timetvl,<span class="type">const</span> <span class="type">char</span> *fmt=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>in_stime：输入的字符串格式的时间。</p><p>out_stime：输出的字符串格式的时间。</p><p>timetvl：需要偏移的秒数，正数往后偏移，负数往前偏移。</p><p>fmt：输出字符串时间out_stime的格式，与LocalTime函数的fmt参数相同。</p><p>注意：in_stime和out_stime参数可以是同一个变量的地址，如果调用失败，out_stime的内容会清空。</p><p>返回值：true-成功，false-失败，如果返回失败，可以认为是in_stime的格式不正确。</p><p><strong>示例（demo28.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo28.cpp，此程序演示freecplus框架中采用AddTime进行时间的运算。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">time_t</span> ltime;</span><br><span class="line">  <span class="type">char</span> strtime[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strtime,<span class="string">&quot;2020-01-01 12:35:22&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddTime</span>(strtime,strtime,<span class="number">0</span><span class="number">-1</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">// 减一天。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime=%s\n&quot;</span>,strtime);     <span class="comment">// 输出strtime=2019-12-31 12:35:22</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddTime</span>(strtime,strtime,<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">// 加两天。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime=%s\n&quot;</span>,strtime);     <span class="comment">// 输出strtime=2020-01-02 12:35:22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-计时器"><a class="markdownIt-Anchor" href="#六-计时器"></a> 六、计时器</h1><p>CTimer类是一个精确到微秒的计时器。</p><p>类声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个精确到微秒的计时器。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTimer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> m_start;   <span class="comment">// 开始计时的时间。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> m_end;     <span class="comment">// 计时完成的时间。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始计时。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CTimer</span>();  <span class="comment">// 构造函数中会调用Start方法。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算已逝去的时间，单位：秒，小数点后面是微秒。</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">Elapsed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CTimer创建对象后立即开始计时，每次调用Elapsed方法获取已逝去的时间（单位：秒，小数点后面是微秒），并重新开始计时。</p><p><strong>示例（demo29.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo29.cpp，此程序演示freecplus框架中的CTimer类（计时器）的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTimer Timer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306143720422.png" alt="在这里插入图片描述" /></p><p>从demo29运行的效果上看，好像计时有误差，同样是睡1秒，实际耗时却是1.000126或1.000171，这是因为程序本身执行需要时间，虽然时间很短，那也是需要时间。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xml解析</title>
      <link href="/post/7fe612d8.html"/>
      <url>/post/7fe612d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是采用freecplus框架的解析xml格式字符串函数。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-xml格式字符串介绍"><a class="markdownIt-Anchor" href="#二-xml格式字符串介绍"></a> 二、xml格式字符串介绍</h1><p>xml格式字符串是应用开发中被广泛采用的一种数据格式，简单易懂，容错性和可扩展性非常好，是数据处理、数据通讯和数据交换等应用场景的首选数据格式。</p><p>完整的xml格式比较复杂，但是，在实际开发中，对我们C/C++程序员来说，绝大部分场景下用到的xml数据格式比较简单，例如表示文件列表信息的xml数据集或文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">&lt;filename&gt;_freecplus.h&lt;/filename&gt;&lt;mtime&gt;<span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">35</span>&lt;/mtime&gt;&lt;size&gt;<span class="number">1834</span>&lt;/size&gt;&lt;endl/&gt;</span><br><span class="line">&lt;filename&gt;_freecplus.cpp&lt;/filename&gt;&lt;mtime&gt;<span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">15</span>&lt;/mtime&gt;&lt;size&gt;<span class="number">5094</span>&lt;/size&gt;&lt;endl/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure><p>数据集说明：</p><p>&lt;data&gt;：数据集的开始。</p><p>&lt;/data&gt;：数据集的结束。</p><p>&lt;endl/&gt;：每行数据的结束。</p><p>filename标签：文件名。</p><p>mtime标签：文件最后一次被修改的时间。</p><p>size标签：文件的大小。</p><h1 id="三-xml格式字符串的解析"><a class="markdownIt-Anchor" href="#三-xml格式字符串的解析"></a> 三、xml格式字符串的解析</h1><p>在freecplus框架中，提供了解析以下xml格式字符串的一系函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">bool</span>   *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">int</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">double</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">char</span> *value,<span class="type">const</span> <span class="type">int</span> ilen=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>xmlbuffer：待解析的xml格式字符串的内容。</p><p>fieldname：字段的标签名。</p><p>value：传入变量的地址，用于存放字段内容，支持bool、int、insigned<br />int、long、unsigned long、double和char[]。</p><p>注意，当value参数的数据类型为char []时，必须保证value数组的内存足够，否则可能发生内存溢出的问题，也可以用ilen参数限定获取字段内容的长度，ilen的缺省值为0，表示不限定获取字段内容的长度。</p><p>返回值：true-获取成功；false-获取失败。</p><p><strong>示例（demo22.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo22.cpp，此程序演示调用freecplus框架的GetXMLBuffer函数解析xml字符串。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放足球运动员资料的结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_player</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">char</span> no[<span class="number">6</span>];       <span class="comment">// 球衣号码</span></span><br><span class="line">  <span class="type">bool</span> striker;     <span class="comment">// 场上位置是否是前锋，true-是；false-不是。</span></span><br><span class="line">  <span class="type">int</span>  age;         <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">double</span> weight;    <span class="comment">// 体重，kg。</span></span><br><span class="line">  <span class="type">long</span> sal;         <span class="comment">// 年薪，欧元。</span></span><br><span class="line">  <span class="type">char</span> club[<span class="number">51</span>];    <span class="comment">// 效力的俱乐部</span></span><br><span class="line">&#125;stplayer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;stplayer,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_player));</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">301</span>];  </span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;&lt;name&gt;messi&lt;/name&gt;&lt;no&gt;10&lt;/no&gt;&lt;striker&gt;true&lt;/striker&gt;&lt;age&gt;30&lt;/age&gt;&lt;weight&gt;68.5&lt;/weight&gt;&lt;sal&gt;21000000&lt;/sal&gt;&lt;club&gt;Barcelona&lt;/club&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;name&quot;</span>,stplayer.name,<span class="number">50</span>);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;no&quot;</span>,stplayer.no,<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;striker&quot;</span>,&amp;stplayer.striker);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;age&quot;</span>,&amp;stplayer.age);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;weight&quot;</span>,&amp;stplayer.weight);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;sal&quot;</span>,&amp;stplayer.sal);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;club&quot;</span>,stplayer.club,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,no=%s,striker=%d,age=%d,weight=%.1f,sal=%ld,club=%s\n&quot;</span>,\</span><br><span class="line">         stplayer.name,stplayer.no,stplayer.striker,stplayer.age,\</span><br><span class="line">         stplayer.weight,stplayer.sal,stplayer.club);</span><br><span class="line">  <span class="comment">// 输出结果:name=messi,no=10,striker=1,age=30,weight=68.5,sal=21000000,club=Barcelona</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>对C/C++程序员来说，采用简单的xml字符串表达数据可以提高开发效率，我不建议采用复杂的xml格式，会让程序代码很烦锁。</p><p>如果在实际开发中需要解析更复杂的xml，可以寻找网上的开源库，例如libxml++。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作</title>
      <link href="/post/81a02d9d.html"/>
      <url>/post/81a02d9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的字符串操作函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-字符串复制"><a class="markdownIt-Anchor" href="#二-字符串复制"></a> 二、字符串复制</h1><h2 id="1-strcpy函数"><a class="markdownIt-Anchor" href="#1-strcpy函数"></a> 1、STRCPY函数</h2><p>安全的strcpy函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，不需要初始化，在STRCPY函数中有初始化代码。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：原字符串。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo1.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo1.cpp，此程序演示freecplus框架中STRCPY函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;freecplus&quot;</span>);  <span class="comment">// 待复制的内容没有超过str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=freecplus=</span></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www.freecplus.net&quot;</span>);  <span class="comment">// 待复制的内容超过了str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-strncpy函数"><a class="markdownIt-Anchor" href="#2-strncpy函数"></a> 2、STRNCPY函数</h2><p>安全的strncpy函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，不需要初始化，在STRNCPY函数中有初始化代码。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：原字符串。</p><p>n：待复制的字节数。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo2.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo2.cpp，此程序演示freecplus框架中STRNCPY函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRNCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;freecplus&quot;</span>,<span class="number">5</span>);  <span class="comment">// 待复制的内容没有超过str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=freec=</span></span><br><span class="line">  <span class="built_in">STRNCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www.freecplus.net&quot;</span>,<span class="number">8</span>);  <span class="comment">// 待复制的内容没有超过str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=www.free=</span></span><br><span class="line">  <span class="built_in">STRNCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www.freecplus.net&quot;</span>,<span class="number">17</span>);  <span class="comment">// 待复制的内容超过了str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-字符串拼接"><a class="markdownIt-Anchor" href="#三-字符串拼接"></a> 三、字符串拼接</h1><h2 id="1-strcat函数"><a class="markdownIt-Anchor" href="#1-strcat函数"></a> 1、STRCAT函数</h2><p>安全的strcat函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，注意，如果dest从未使过，那么需要至少一次初始化。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：待追加字符串。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo4.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo4.cpp，此程序演示freecplus框架中STRCAT函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.fr&quot;</span>);  <span class="comment">// str原有的内容加上待追加的内容没有超过str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);        <span class="comment">// 出输结果是str=www.fr=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;eecplus.net&quot;</span>);  <span class="comment">// str原有的内容加上待追加的内容超过了str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);                <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-strncat函数"><a class="markdownIt-Anchor" href="#2-strncat函数"></a> 2、STRNCAT函数</h2><p>安全的strncat函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，注意，如果dest从未使过，那么需要至少一次初始化。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：待追加字符串。</p><p>n：待追加的字节数。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo5.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo5.cpp，此程序演示freecplus框架中STRNCAT函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line">  <span class="built_in">STRNCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.free&quot;</span>,<span class="number">10</span>);  <span class="comment">// str原有的内容加上待追加的内容没有超过str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);              <span class="comment">// 出输结果是str=www.free=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line">  <span class="built_in">STRNCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.freecplus.net&quot;</span>,<span class="number">6</span>);  <span class="comment">// str原有的内容加上待追加的内容没有超过str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);                      <span class="comment">// 出输结果是str=www.freec=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line">  <span class="built_in">STRNCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.freecplus.net&quot;</span>,<span class="number">10</span>); <span class="comment">// str原有的内容加上待追加的内容超过了str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);                      <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-格式化输出到字符串"><a class="markdownIt-Anchor" href="#四-格式化输出到字符串"></a> 四、格式化输出到字符串</h1><h2 id="1-sprintf函数"><a class="markdownIt-Anchor" href="#1-sprintf函数"></a> 1、SPRINTF函数</h2><p>安全的sprintf函数，将可变参数(…)按照fmt描述的格式输出到dest字符串中。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SPRINTF</span><span class="params">(<span class="type">char</span> *dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：输出字符串，不需要初始化，在SPRINTF函数中会对它进行初始化。</p><p>destlen：输出字符串dest占用内存的大小，如果格式化后的字符串内容的长度大于destlen-1，后面的内容将丢弃。</p><p>fmt：格式控制描述。</p><p>…：填充到格式控制描述fmt中的参数。</p><p>返回值：格式化后的内容的长度，程序员一般不关心返回值。</p><p><strong>示例（demo7.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo7.cpp，此程序演示freecplus框架中SPRINTF函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">21</span>];   <span class="comment">// 字符串str的大小是21字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:%s,no:%d&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:messi,no:10=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:%s,no:%d,job:%s&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>,<span class="string">&quot;striker&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:messi,no:10,job=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-snprintf函数"><a class="markdownIt-Anchor" href="#2-snprintf函数"></a> 2、SNPRINTF函数</h2><p>安全的snprintf函数，将可变参数(…)按照fmt描述的格式输出到dest字符串中。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SNPRINTF</span><span class="params">(<span class="type">char</span> *dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">size_t</span> n,<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：输出字符串，不需要初始化，在SNPRINTF函数中会对它进行初始化。</p><p>destlen：输出字符串dest占用内存的大小，如果格式化后的字符串内容的长度大于destlen-1，后面的内容将丢弃。</p><p>n：把格式化后的字符串截取n-1存放到dest中，如果n&gt;destlen，则取destlen-1。</p><p>fmt：格式控制描述。</p><p>…：填充到格式控制描述fmt中的参数。</p><p>返回值：格式化后的内容的长度，程序员一般不关心返回值。</p><p><strong>示例（demo8.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo8.cpp，此程序演示freecplus框架中SNPRINTF函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">26</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SNPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="number">5</span>,<span class="string">&quot;messi&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=mess=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SNPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="number">9</span>,<span class="string">&quot;name:%s,no:%d,job:%s&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>,<span class="string">&quot;striker&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:mes=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SNPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="number">30</span>,<span class="string">&quot;name:%s,no:%d,job:%s&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>,<span class="string">&quot;striker&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:messi,no:10,job:stri=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-删除字符串左-右和两边字符"><a class="markdownIt-Anchor" href="#五-删除字符串左-右和两边字符"></a> 五、删除字符串左、右和两边字符</h1><p>删除字符串左边、右边和两边指定的字符。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> chr)</span></span>;  <span class="comment">// 删除字符串左边指定的字符。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> chr)</span></span>;  <span class="comment">// 删除字符串右边指定的字符。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> chr)</span></span>; <span class="comment">// 删除字符串左右两边指定的字符。</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待处理的字符串。</p><p>chr：需要删除的字符。dest：输出字符串，不需要初始化，在SNPRINTF函数中会对它进行初始化。</p><p><strong>示例（demo10.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo10.cpp，此程序演示freecplus框架中删除字符串左、右、两边指定字符的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;  西施  &quot;</span>);</span><br><span class="line">  <span class="built_in">DeleteLChar</span>(str,<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 删除str左边的空格</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=西施  =</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;  西施  &quot;</span>);</span><br><span class="line">  <span class="built_in">DeleteRChar</span>(str,<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 删除str右边的空格</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=  西施=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;  西施  &quot;</span>);</span><br><span class="line">  <span class="built_in">DeleteLRChar</span>(str,<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 删除str两边的空格</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=西施=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果要删除字符串中间的字符，可以用freecplus框架中的UpdateStr函数，后面的章节中会介绍它。</p><h1 id="六-字符串大小写转换"><a class="markdownIt-Anchor" href="#六-字符串大小写转换"></a> 六、字符串大小写转换</h1><p>把字符串中的小写字母转换成大写，忽略不是字母的字符。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToUpper</span><span class="params">(<span class="type">char</span> *str)</span></span>;   <span class="comment">// 把字符串中的小写字母转换成大写,参数是C语言风格的char []。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToUpper</span><span class="params">(string &amp;str)</span></span>; <span class="comment">// 把字符串中的小写字母转换成大写,参数是C++语言风格的string。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToLower</span><span class="params">(<span class="type">char</span> *str)</span></span>;   <span class="comment">// 把字符串中的大写字母转换成小写,参数是C语言风格的char []。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToLower</span><span class="params">(string &amp;str)</span></span>; <span class="comment">// 把字符串中的大写字母转换成小写,参数是C++语言风格的string。</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待转换的字符串，函数重载了char[]和string两种数据类型。</p><p><strong>示例（demo12.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo12.cpp，此程序演示freecplus框架中字符串大小写转换函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str1[<span class="number">31</span>];   <span class="comment">// C语言风格的字符串。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str1,<span class="built_in">sizeof</span>(str1),<span class="string">&quot;12abz45ABz8西施。&quot;</span>);</span><br><span class="line">  <span class="built_in">ToUpper</span>(str1);      <span class="comment">// 把str1中的小写字母转换为大写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str1=%s=\n&quot;</span>,str1);    <span class="comment">// 出输结果是str1=12ABZ45ABZ8西施。=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str1,<span class="built_in">sizeof</span>(str1),<span class="string">&quot;12abz45ABz8西施。&quot;</span>);</span><br><span class="line">  <span class="built_in">ToLower</span>(str1);      <span class="comment">// 把str1中的大写字母转换为小写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str1=%s=\n&quot;</span>,str1);    <span class="comment">// 出输结果是str1=12abz45abz8西施。=</span></span><br><span class="line"></span><br><span class="line">  string str2;    <span class="comment">// C++语言风格的字符串。</span></span><br><span class="line"></span><br><span class="line">  str2=<span class="string">&quot;12abz45ABz8西施。&quot;</span>;</span><br><span class="line">  <span class="built_in">ToUpper</span>(str2);      <span class="comment">// 把str2中的小写字母转换为大写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str2=%s=\n&quot;</span>,str2.<span class="built_in">c_str</span>());    <span class="comment">// 出输结果是str2=12ABZ45ABZ8西施。=</span></span><br><span class="line"></span><br><span class="line">  str2=<span class="string">&quot;12abz45ABz8西施。&quot;</span>;</span><br><span class="line">  <span class="built_in">ToLower</span>(str2);      <span class="comment">// 把str2中的大写字母转换为小写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str2=%s=\n&quot;</span>,str2.<span class="built_in">c_str</span>());    <span class="comment">// 出输结果是str1=12abz45abz8西施。=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七-字符串替换"><a class="markdownIt-Anchor" href="#七-字符串替换"></a> 七、字符串替换</h1><p>把字符串中的内容替换成其它的内容，在字符串str中，如果存在字符串str1，就替换为字符串str2。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateStr</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> *str1,<span class="type">const</span> <span class="type">char</span> *str2,<span class="type">const</span> <span class="type">bool</span> bLoop=<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待处理的字符串。</p><p>str1：旧的内容。</p><p>str2：新的内容。</p><p>bloop：是否循环执行替换。</p><p>注意：</p><p>1）如果str2比str1要长，替换后str会变长，所以必须保证str有足够的长度，否则内存会溢出。</p><p>2）如果str2中包函了str1的内容，且bloop为true，存在逻辑错误，将不执行任何替换。</p><p><strong>示例（demo14.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo14.cpp，此程序演示freecplus框架中字符串替换UpdateStr函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:messi,no:10,job:striker.&quot;</span>);</span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;:&quot;</span>,<span class="string">&quot;=&quot;</span>);    <span class="comment">// 把冒号替换成等号。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=name=messi,no=10,job=striker.=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:messi,no:10,job:striker.&quot;</span>);</span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;name:&quot;</span>,<span class="string">&quot;&quot;</span>);    <span class="comment">// 把&quot;name:&quot;替换成&quot;&quot;，相当于删除内容&quot;name:&quot;。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi,no:10,job:striker.=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi----10----striker&quot;</span>);  </span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="literal">false</span>);    <span class="comment">// 把两个&quot;--&quot;替换成一个&quot;-&quot;，bLoop参数为false。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi--10--striker=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi----10----striker&quot;</span>);  </span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="literal">true</span>);    <span class="comment">// 把两个&quot;--&quot;替换成一个&quot;-&quot;，bLoop参数为true。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi-10-striker=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi-10-striker&quot;</span>);  </span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="literal">false</span>);    <span class="comment">// 把一个&quot;-&quot;替换成两个&quot;--&quot;，bLoop参数为false。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi--10--striker=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi-10-striker&quot;</span>);  </span><br><span class="line">  <span class="comment">// 以下代码把&quot;-&quot;替换成&quot;--&quot;，bloop参数为true，存在逻辑错误，UpdateStr将不执行替换。</span></span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="literal">true</span>);    <span class="comment">// 把一个&quot;-&quot;替换成两个&quot;--&quot;，bloop参数为true。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi-10-striker=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八-从字符串中提取数字"><a class="markdownIt-Anchor" href="#八-从字符串中提取数字"></a> 八、从字符串中提取数字</h1><p>从一个字符串中提取出数字、符号和小数点，存放到另一个字符串中。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PickNumber</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *src,<span class="type">char</span> *dest,<span class="type">const</span> <span class="type">bool</span> bsigned,<span class="type">const</span> <span class="type">bool</span> bdot)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>src：源字符串。</p><p>dest：目标字符串。</p><p>bsigned：是否包括符号（+和-），true-包括；false-不包括。</p><p>bdot：是否包括小数点的圆点符号，true-包括；false-不包括。</p><p><strong>示例（demo16.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo16.cpp，此程序演示freecplus框架中PickNumber函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">26</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;iab+12.3xy&quot;</span>);</span><br><span class="line">  <span class="built_in">PickNumber</span>(str,str,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=123=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;iab+12.3xy&quot;</span>);</span><br><span class="line">  <span class="built_in">PickNumber</span>(str,str,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=+123=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;iab+12.3xy&quot;</span>);</span><br><span class="line">  <span class="built_in">PickNumber</span>(str,str,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=-12.3=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九-正则表达式"><a class="markdownIt-Anchor" href="#九-正则表达式"></a> 九、正则表达式</h1><p>正则表达式，判断一个字符串是否匹配另一个字符串。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MatchStr</span><span class="params">(<span class="type">const</span> string str,<span class="type">const</span> string rules)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：需要判断的字符串，精确表示的字符串，如文件名&quot;_freecplus.cpp&quot;。</p><p>rules：匹配规则表达式，用星号&quot;*“表示任意字符串，多个字符串之间用半角的逗号分隔，如”*.h,*.cpp&quot;。</p><p>注意，str参数不支持&quot;?“，rules只支持”*&quot;，函数在判断str是否匹配rules的时候，会忽略字母的大小写。</p><p><strong>示例（demo18.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo18.cpp，此程序演示freecplus框架正则表达示MatchStr函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> filename[<span class="number">301</span>];  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(filename,<span class="built_in">sizeof</span>(filename),<span class="string">&quot;_freecplus.h&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 以下代码将输出yes。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">MatchStr</span>(filename,<span class="string">&quot;*.h,*.cpp&quot;</span>)==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码将输出yes。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">MatchStr</span>(filename,<span class="string">&quot;*.H&quot;</span>)==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码将输出no。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">MatchStr</span>(filename,<span class="string">&quot;*.cpp&quot;</span>)==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十-字符串的拆分"><a class="markdownIt-Anchor" href="#十-字符串的拆分"></a> 十、字符串的拆分</h1><p>CCmdStr类用于拆分用分隔符分隔字段内容的字符串。</p><p>字符串的格式为：字段内容1+分隔符+字段内容2+分隔符+字段内容3+分隔符+…+字段内容n。</p><p>例如：“messi,10,striker,30,1.72,68.5,Barcelona”，这是足球运动员梅西的资料，包括姓名、球衣号码、场上位置、年龄、身高、体重和效力的俱乐部，字段之间用半角的逗号分隔开。</p><p>CCmdStr类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CCmdStr类用于拆分用分隔符分隔字段的字符串。</span></span><br><span class="line"><span class="comment">// 字符串的格式为：字段内容1+分隔符+字段内容2+分隔符+字段内容3+分隔符+...+字段内容n。</span></span><br><span class="line"><span class="comment">// 例如：&quot;messi,10,striker,30,1.72,68.5,Barcelona&quot;，这是足球运动员梅西的资料，包括姓名、</span></span><br><span class="line"><span class="comment">// 球衣号码、场上位置、年龄、身高、体重和效力的俱乐部，字段之间用半角的逗号分隔开。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCmdStr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;string&gt; m_vCmdStr;  <span class="comment">// 存放拆分后的字段内容。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CCmdStr</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把字符串拆分到m_vCmdStr容器中。</span></span><br><span class="line">  <span class="comment">// buffer：待拆分的字符串。</span></span><br><span class="line">  <span class="comment">// sepstr：buffer字符串中字段内容的分隔符，注意，分隔符是字符串，如&quot;,&quot;、&quot; &quot;、&quot;|&quot;、&quot;~!~&quot;。</span></span><br><span class="line">  <span class="comment">// bdelspace：是否删除拆分后的字段内容前后的空格，true-删除；false-不删除，缺省删除。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SplitToCmd</span><span class="params">(<span class="type">const</span> string buffer,<span class="type">const</span> <span class="type">char</span> *sepstr,<span class="type">const</span> <span class="type">bool</span> bdelspace=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取拆分后字段的个数，即m_vCmdStr容器的大小。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">CmdCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从m_vCmdStr容器获取字段内容。</span></span><br><span class="line">  <span class="comment">// inum：字段的顺序号，类似数组，从0开始。</span></span><br><span class="line">  <span class="comment">// value：传入变量的地址，用于存放字段内容。</span></span><br><span class="line">  <span class="comment">// 返回值：true-获取成功；false-获取失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">char</span>   *value,<span class="type">const</span> <span class="type">int</span> ilen=<span class="number">0</span>)</span></span>; <span class="comment">// 字符串，ilen缺省值为0。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">int</span>    *value)</span></span>; <span class="comment">// int整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">unsigned</span> <span class="type">int</span> *value)</span></span>; <span class="comment">// unsigned int整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">long</span>   *value)</span></span>; <span class="comment">// long整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>; <span class="comment">// unsigned long整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">double</span> *value)</span></span>; <span class="comment">// 双精度double。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">bool</span>   *value)</span></span>; <span class="comment">// bool型。</span></span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CCmdStr</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>示例（demo20.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo20.cpp，此程序演示freecplus框架拆分字符串的类CCmdStr的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放足球运动员资料的结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_player</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">char</span> no[<span class="number">6</span>];       <span class="comment">// 球衣号码</span></span><br><span class="line">  <span class="type">bool</span> striker;     <span class="comment">// 场上位置是否是前锋，true-是；false-不是。</span></span><br><span class="line">  <span class="type">int</span>  age;         <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">double</span> weight;    <span class="comment">// 体重，kg。</span></span><br><span class="line">  <span class="type">long</span> sal;         <span class="comment">// 年薪，欧元。</span></span><br><span class="line">  <span class="type">char</span> club[<span class="number">51</span>];    <span class="comment">// 效力的俱乐部</span></span><br><span class="line">&#125;stplayer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;stplayer,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_player));</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">301</span>];  </span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;messi,10,true,30,68.5,2100000,Barcelona&quot;</span>);</span><br><span class="line"></span><br><span class="line">  CCmdStr CmdStr;</span><br><span class="line">  CmdStr.<span class="built_in">SplitToCmd</span>(buffer,<span class="string">&quot;,&quot;</span>);        <span class="comment">// 拆分buffer</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">0</span>, stplayer.name,<span class="number">50</span>); <span class="comment">// 获取姓名</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">1</span>, stplayer.no,<span class="number">5</span>);    <span class="comment">// 获取球衣号码</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">2</span>,&amp;stplayer.striker); <span class="comment">// 场上位置</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">3</span>,&amp;stplayer.age);     <span class="comment">// 获取年龄</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">4</span>,&amp;stplayer.weight);  <span class="comment">// 获取体重</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">5</span>,&amp;stplayer.sal);     <span class="comment">// 获取年薪，欧元。</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">6</span>, stplayer.club,<span class="number">50</span>); <span class="comment">// 获取效力的俱乐部</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,no=%s,striker=%d,age=%d,weight=%.1f,sal=%ld,club=%s\n&quot;</span>,\</span><br><span class="line">         stplayer.name,stplayer.no,stplayer.striker,stplayer.age,\</span><br><span class="line">         stplayer.weight,stplayer.sal,stplayer.club);</span><br><span class="line">  <span class="comment">// 输出结果:name=messi,no=10,striker=1,age=30,weight=68.5,sal=21000000,club=Barcelona</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十一-统计字符串的字数"><a class="markdownIt-Anchor" href="#十一-统计字符串的字数"></a> 十一、统计字符串的字数</h1><p>统计字符串的字数，全角的汉字和全角的标点符号算一个字，半角的汉字和半角的标点符号也算一个字。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Words</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待统计的字符串。</p><p>返回值：字符串str的字数。</p><p>注意事项，本函数只适用用于Linux字符集为GBK的情况，在GB18030和Unicode编码中，汉字不一定是两个字节。</p><p><strong>示例（demo21.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo21.cpp，此程序演示freecplus框架的统计字符串字数的函数。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">301</span>];</span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;messi,10,true,30,68.5,2100000,Barcelona。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;words=%d\n&quot;</span>,<span class="built_in">Words</span>(buffer)); <span class="comment">// 输出结果:words=40</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;梅西,10,true,30,68.5,2100000,Barcelona。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;words=%d\n&quot;</span>,<span class="built_in">Words</span>(buffer)); <span class="comment">// 输出结果:words=37</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十二-版权声明"><a class="markdownIt-Anchor" href="#十二-版权声明"></a> 十二、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库开机自启动的配置</title>
      <link href="/post/37b00fb8.html"/>
      <url>/post/37b00fb8.html</url>
      
        <content type="html"><![CDATA[<p>如果服务器断电重启或计划内重启，在服务器的操作系统启动后，需要手工启动数据库实例和监听，本文介绍如何把Oracle数据库的启动和关闭配置成系统服务，在操作系统启动/关闭时，自动启动/关闭Oracle实例和监听。</p><p>假设ORACLE_HOME环境变量的值是/oracle/home。</p><h2 id="1-启动数据库实例的shell脚本"><a class="markdownIt-Anchor" href="#1-启动数据库实例的shell脚本"></a> 1、启动数据库实例的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbstart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="2-重启数据库实例的shell脚本"><a class="markdownIt-Anchor" href="#2-重启数据库实例的shell脚本"></a> 2、重启数据库实例的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbrestart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="3-关闭数据库实例的shell脚本"><a class="markdownIt-Anchor" href="#3-关闭数据库实例的shell脚本"></a> 3、关闭数据库实例的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbshut，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="4-oracle实例的系统服务配置文件脚本"><a class="markdownIt-Anchor" href="#4-oracle实例的系统服务配置文件脚本"></a> 4、oracle实例的系统服务配置文件脚本</h2><p>如果把系统服务命名为oracle，则创建服务配置文件/usr/lib/systemd/system/oracle.service，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle RDBMS</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbstart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbrestart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbshut \&gt;\&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="5-lsnrctl监听的系统服务配置文件脚本"><a class="markdownIt-Anchor" href="#5-lsnrctl监听的系统服务配置文件脚本"></a> 5、lsnrctl监听的系统服务配置文件脚本</h2><p>如果把系统服务命名为lsnrctl，则创建服务配置文件/usr/lib/systemd/system/lsnrctl.service，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle lsnrctl</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/lsnrctl start &gt;&gt; /tmp/lsnrctl.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/lsnrctl reload &gt;&gt; /tmp/lsnrctl.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/lsnrctl stop &gt;&gt; /tmp/lsnrctl.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="6-重新加载服务配置文件"><a class="markdownIt-Anchor" href="#6-重新加载服务配置文件"></a> 6、重新加载服务配置文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="7-启动停止启重oracle和lsnrctl服务"><a class="markdownIt-Anchor" href="#7-启动停止启重oracle和lsnrctl服务"></a> 7、启动/停止/启重oracle和lsnrctl服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start oracle # 启动oracle服务。</span><br><span class="line">systemctl restart oracle # 重启oracle服务。</span><br><span class="line">systemctl stop oracle # 关闭oracle服务。</span><br><span class="line">systemctl start lsnrctl # 启动lsnrctl服务。</span><br><span class="line">systemctl restart lsnrctl # 重启lsnrctl服务。。</span><br><span class="line">systemctl stop lsnrctl # 关闭lsnrctl服务。</span><br></pre></td></tr></table></figure><h2 id="8-把oracle和lsnrctl服务设置为开机关机自启动停止"><a class="markdownIt-Anchor" href="#8-把oracle和lsnrctl服务设置为开机关机自启动停止"></a> 8、把oracle和lsnrctl服务设置为开机/关机自启动/停止</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable oracle # 把Oracle实例服务设置为开机自启动。</span><br><span class="line">systemctl enable lsnrctl # 把Oracle监听服务设置为开机自启动。</span><br></pre></td></tr></table></figure><h2 id="9-查看oracle实例和监听启动停止的日志"><a class="markdownIt-Anchor" href="#9-查看oracle实例和监听启动停止的日志"></a> 9、查看Oracle实例和监听启动/停止的日志。</h2><p>Oracle实例启动的日志在/tmp/oracle.log文件中。</p><p>监听的启动日成在/tmp/lsnrctl.log文件中。</p><p>注意，只有通过systemctl启动/关闭Oracle实例和监听才会写日志，手工执行脚本不写日志。</p><h2 id="10-版权声明"><a class="markdownIt-Anchor" href="#10-版权声明"></a> 10、版权声明</h2><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据字典</title>
      <link href="/post/3fa9fcba.html"/>
      <url>/post/3fa9fcba.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h1><p>Oracle通过数据字典来管理和展现数据库信息，数据字典储存数据库的元数据，是数据库的“数据库”。数据字典由4部分组成：内部RDBMS（X$）表、数据字典表、动态性能视图（V$）和（静态）数据字典视图。</p><p>数据字典系统表，保存在system表空间中。执行以下语句可以查询所有数据字典：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from dictionary;</span><br></pre></td></tr></table></figure><h1 id="二-内部rdbmsx表"><a class="markdownIt-Anchor" href="#二-内部rdbmsx表"></a> 二、内部RDBMS（X$）表</h1><p>X$表示Oracle数据库的核心部分，这些表用于跟踪数据库内部信息，维持数据库的正常运行。X$表是加密命名的，而且Oracle不做文档说明，也不允许sysdba以外的用户直接访问，显示授权不被允许。X$表是Oracle数据库的运行基础，在数据库启动时由Oracle应用程序动态创建。</p><h1 id="三-动态性能视图"><a class="markdownIt-Anchor" href="#三-动态性能视图"></a> 三、动态性能视图</h1><p>动态性能视图记录了数据库运行时信息和统计数据，大部分动态性能视图被实时更新以及反映数据库当前状态。在数据库启动时，Oracle动态创建X$表，在此基础上，Oracle创建了GV$和V$视图，GV$即Global V$，除了一些特例外，每个V$都对应一个GV$。GV$产生是为了OPS/RAC环境的需要，每个V$都是基于GV$的，只是GV$多了INST_ID列来显示实例ID。</p><p>v$database数据库信息</p><p>v$datafile数据文件信息</p><p>v$controlfile控制文件信息</p><p>v$logfile重做日志信息</p><p>v$instance数据库实例信息</p><p>v$log日志组信息</p><p>v$loghist日志历史信息</p><p>v$sga数据库SGA信息</p><p>v$parameter初始化参数信息</p><p>v$process数据库服务器进程信息</p><p>v$bgprocess数据库后台进程信息</p><p>v$controlfile_record_section控制文件记载的各部分信息</p><p>v$thread线程信息</p><p>v$datafile_header数据文件头所记载的信息</p><p>v$archived_log归档日志信息</p><p>v$archive_dest归档日志的设置信息</p><p>v$logmnr_contents归档日志分析的DMLDDL结果信息</p><p>v$logmnr_dictionary日志分析的字典文件信息</p><p>v$logmnr_logs日志分析的日志列表信息</p><p>v$tablespace表空间信息</p><p>v$tempfile临时文件信息</p><p>v$filestat数据文件的I/O统计信息</p><p>v$undostatUndo数据信息</p><p>v$rollname在线回滚段信息</p><p>v$session会话信息</p><p>v$transaction事务信息</p><p>v$rollstat回滚段统计信息</p><p>v$pwfile_users特权用户信息</p><p>v$sqlarea当前查询过的sql语句访问过的资源及相关的信息</p><p>v$sql与v$sqlarea基本相同的相关信息</p><p>v$sysstat数据库系统状态信息</p><h1 id="四-数据字典表"><a class="markdownIt-Anchor" href="#四-数据字典表"></a> 四、数据字典表</h1><p>数据字典表（Data dictionary<br />table）用以存储表、索引、约束以及其它数据库结构的信息，这些对象通常以“$”结尾（例如：TAB$、OBJ$、TS$等），在创建数据库的时候通过运行$ORACLE_HOME/rdbms/admin/sql.bsq脚本来创建。</p><h1 id="五-静态数据字典视图"><a class="markdownIt-Anchor" href="#五-静态数据字典视图"></a> 五、静态数据字典视图</h1><p>由于X$表和数据字典表通常不能直接被用户访问，Oracle创建了静态数据字典视图来提供用户对于数据字典信息的访问，由于这些信息通常相对稳定，不能直接修改，所以又被称为静态数据字典视图。静态数据字典视图在创建数据库时由$ORACLE_HOME/rdbms/admin/catagory.sql脚本创建。</p><p>静态数据字典视图按照前缀的不同通常分成三类，在本质上是为了实现权限控制。在Oracle数据库中，每个用户与方案（Schema）是对应的，Schema是用户所拥有的对象的集合。数据库通过Schema将不同用户的对象隔离开来，用户可以自由的访问自己的对象，但是要访问其他Schema对象就需要相关的授权。</p><h2 id="1-user_用户所拥有的相关对象信息"><a class="markdownIt-Anchor" href="#1-user_用户所拥有的相关对象信息"></a> 1、USER_*（用户所拥有的相关对象信息）</h2><p>user_objects用户对象信息</p><p>user_source数据库用户的所有资源对象信息</p><p>user_segments用户的表段信息</p><p>user_tables用户的表对象信息</p><p>user_tab_columns用户的表列信息</p><p>user_constraints用户的对象约束信息</p><p>user_sys_privs当前用户的系统权限信息</p><p>user_tab_privs当前用户的对象权限信息</p><p>user_col_privs当前用户的表列权限信息</p><p>user_role_privs当前用户的角色权限信息</p><p>user_indexes用户的索引信息</p><p>user_ind_columns用户的索引对应的表列信息</p><p>user_cons_columns用户的约束对应的表列信息</p><p>user_clusters用户的所有簇信息</p><p>user_clu_columns用户的簇所包含的内容信息</p><p>user_cluster_hash_expressions散列簇的信息</p><h2 id="2-all_用于有权限访问的所有对象的信息"><a class="markdownIt-Anchor" href="#2-all_用于有权限访问的所有对象的信息"></a> 2、ALL_*（用于有权限访问的所有对象的信息）</h2><p>all_users数据库所有用户的信息</p><p>all_objects数据库所有的对象的信息</p><p>all_def_audit_opts所有默认的审计设置信息</p><p>all_tables所有的表对象信息</p><p>all_indexes所有的数据库对象索引的信息</p><h2 id="3-dba_数据库所有相关对象的信息"><a class="markdownIt-Anchor" href="#3-dba_数据库所有相关对象的信息"></a> 3、DBA_（数据库所有相关对象的信息）</h2><p>dba_users数据库用户信息</p><p>dba_segments表段信息</p><p>dba_extents数据区信息</p><p>dba_objects数据库对象信息</p><p>dba_tablespaces数据库表空间信息</p><p>dba_data_files数据文件设置信息</p><p>dba_temp_files临时数据文件信息</p><p>dba_rollback_segs回滚段信息</p><p>dba_ts_quotas用户表空间配额信息</p><p>dba_free_space数据库空闲空间信息</p><p>dba_profiles数据库用户资源限制信息</p><p>dba_sys_privs用户的系统权限信息</p><p>dba_tab_privs用户具有的对象权限信息</p><p>dba_col_privs用户具有的列对象权限信息</p><p>dba_role_privs用户具有的角色信息</p><p>dba_audit_trail审计跟踪记录信息</p><p>dba_stmt_audit_opts审计设置信息</p><p>dba_audit_object对象审计结果信息</p><p>dba_audit_session会话审计结果信息</p><p>dba_indexes用户模式的索引信息</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的体系结构</title>
      <link href="/post/9230b8a1.html"/>
      <url>/post/9230b8a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h1><p>Oracle的体系结构是数据库的组成、工作过程，以及数据库中数据的组织和管理机制，包含一系列组件（软件）、用户进程（User process）、服务进程（Server process、PGA）、SGA（共享池、数据缓存、日志缓冲区）、后台进程（SMON、DBWn、PMON、CKPT、LGWR、其它进程）、参数文件（Parameter file）、密码文件（Password）、数据文件（Data files）、控制文件（Control files）、在线重做日志文件（Redo log files）、归档日志文件（Archived log files）。</p><p><img src="https://img-blog.csdnimg.cn/20200313101507515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="二-用户进程和服务进程"><a class="markdownIt-Anchor" href="#二-用户进程和服务进程"></a> 二、用户进程和服务进程</h1><h2 id="1-用户进程"><a class="markdownIt-Anchor" href="#1-用户进程"></a> 1、用户进程</h2><p>用户进程（User process），是指用户通过客户端，比如SQL Plus、PL/SQL Developer、SQL Load、应用程序等工具连接上Oracle数据库而产生的进程。用户进程处理用户输入并与服务器进程通信。用户进程还负责表现用户请求的信息，必要时可以将信息处置成更可用的形式。</p><h2 id="2-服务进程"><a class="markdownIt-Anchor" href="#2-服务进程"></a> 2、服务进程</h2><p>服务进程（Server Process），当客户端发起连接时，Oracle创建一个用户进程来处理这个连接。</p><p>用户进程启动后，Oracle还会创建一个服务进程来处理连接到实例的用户进程提交的请求。用户进程连接到数据库并创建一个会话时，Oracle服务器进程会分配专门用于当前用户会话的内存区，即PGA区，该区域是私有的，当进程创建时分配，进程结束后被释放，只能被一个服务进程使用。</p><p>以客户端执行一条SQL为例：</p><p>1）服务进程接收SQL语句；</p><p>2）服务进程去共享池找SQL和执行计划，如果没找到，则解析SQL；</p><p>3）服务进程根据执行计划去数据缓存中找相关的数据，如没有才到数据文件中取出数据放到数据缓存中，再返给客户端；</p><p>4）若需要修改数据，服务进程把数据读取到数据缓存后再修改数据，修改后返给客户端。</p><p>用户进程与服务器进程可以是一对一的关系（配置为专用服务器模式时）。一个服务器也可连接多个用户进程（配置为多线程服务器时），但这样做会减少对系统资源的占用。</p><h1 id="三-系统全局区sga"><a class="markdownIt-Anchor" href="#三-系统全局区sga"></a> 三、系统全局区SGA</h1><p>系统全局区SGA（System Global Area），是Oracle实例的重要组成部分，在实例启动时分配，是一组包含Oracle数据和控制信息的共享内存。一个SGA只属于一个实例，也就是说，当一个服务器上有多个实例运行时，每个实例都有一个自己的SGA，实例之间不能相互访问。SGA包括共享池（Share pool）、数据缓存（Data buffer cache）和重做日志缓冲区（Redo log buffer），其中共享池又包括Library cache（库缓存）和Data dict cache（数据字典缓存）。</p><h1 id="四-后台进程"><a class="markdownIt-Anchor" href="#四-后台进程"></a> 四、后台进程</h1><p>Oracle后台进程是一组运行于Oracle服务器端的后台程序，也是Oracle实例的重要组成部分。这些后台进程分别完成不同的功能。其中SMON、PMON、DBWR、LGWR和CKPT这5个后台进程必须正常启动，否则数据库实例无法工作。此外，还有很多辅助进程，用于实现辅助的功能，如果这些辅助进程发生问题，只会使某些功能受到影响，数据库实例仍是可用的。</p><p>1）数据写入进程（DBWR）</p><p>数据写入进程的主要任务是负责将内存中的“脏”数据块回写到数据文件中。“脏”数据块是指高速数据缓冲区中的被修改过的数据块，这些数据块的内容与数据文件的数据块内容不一致。但DBWR并不是随时将所有的“脏”数据块都写入数据文件，只有满足一定的条件时，DBWR进程才开始成批量的将“脏”数据块写入数据文件Oracle这样做的目的是为了尽量减少I/O操作，提高Oracle服务器性能。</p><p>2）检查点进程（CKPT）</p><p>检查点进程可以看作一个事件，当检查点事件发生时，CKPT会要求DBWR将某些“脏”数据块回写到数据文件。当用户进程发出数据请求时，Oracle系统从数据文件中读取需要的数据并存放到高速数据缓冲区中，用户对数据的操作时在缓冲区中进行的。当用户操作数据时，就会产生大量的日志信息并存储在重做日志缓冲区，当Oracle系统满足一定条件时，日志写入进程（LGWR）会将日志信息写入到重做日志文件组中，当发生日志切换时（写入操作正要从一个日志文件组切换到另一组时），就会启动检查点进程。</p><p>另外，DBA还可以通过修改初始化参数文件SPFILE中的CHECKPOINT_PROCESS参数为TRUE来启动检查点进程。</p><p>3）日志写入进程（LGWR）</p><p>日志写入进程用于将重做日志缓冲区中的数据写入重做日志文件。Oracle系统将用户所做的修改日志信息写入日志文件，然后将修改结果写入数据文件。</p><p>Oracle实例在运行中会产生大量日志信息，这些日志信息首先被记录在SGA的重做日志缓冲区中，当发生提交命令、或者重做日志缓冲区的信息满1/3、或者日志信息存放超过3秒钟时，LGWR进程就将日志信息从重做日志缓冲区中读出并写入日志文件组中序号较小的文件中，一个日志组写满后接着写另外一组。当LGWR进程将所有䣌日志文件都写过一遍后，它将再次转向第一个日志文件组重新覆盖。</p><p>4）归档进程（ARCH）</p><p>归档进程是一个可选择的进程，只有当Oracle数据库处于归档模式时，该进程才可能起到作用。若Oracle数据库处于归档模式，当各个日志文件组都被写满即将被覆盖之前，先由归档进程（ARCH）把即将覆盖的日志文件中的日志信息读出，然后再把这些“读出的日志信息”写入到归档日志文件中。</p><p>当系统比较繁忙而导致LGWR进程处于等待ARCH进程时，可通过修改LOG_ARCHIVE_MAX_PROCESSES参数启动多个归档进程，从而提高归档写磁盘的速度。</p><p>5）系统监控进程（SMON）</p><p>系统监控进程是在数据库启动时执行恢复工作的强制性进程。比如，在并行服务器模式下，SMON可以恢复另一个处于失败的数据库，使系统切换到另外一台正常的服务器上。</p><p>6）进程监控进程（PMON）</p><p>进程监控进程用于监控其他进程的状态，当有进程启动失败时，PMON会清除失败的用户进程，用于数据不一致时进行恢复工作。</p><p>7）锁定进程（LCKN）</p><p>这是一个可选进程，并行服务器模式下可以出现多个锁定进程以利于数据库通信。</p><p>8）恢复进程（RECO）</p><p>这是在分布式数据库模式下使用的一个可选进程，用于数据不一致时进行恢复工作。</p><p>9）调度进程（DNNN）</p><p>这是一个可选进程，在共享服务器模式下使用，可以启动多个调度进程。</p><p>10）快照进程（SNPN）：</p><p>快照进程用于处理数据库快照的自动刷新，并通过DBMS_JOB包运行预定的数据库存储过程。</p><h1 id="五-存储结构"><a class="markdownIt-Anchor" href="#五-存储结构"></a> 五、存储结构</h1><p>Oracle分为逻辑存储结构和物理存储结构，逻辑存储结构用来描述Oracle内部组织和管理数据的方式，是一种层次结构，是面向用户的；物理存储结构是实际的数据存储单元，就是数据库存放在操作系统上的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200313101809756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="1-逻辑存储结构"><a class="markdownIt-Anchor" href="#1-逻辑存储结构"></a> 1、逻辑存储结构</h2><p>Oracle数据库中的数据文件被分组到一个或多个表空间中。在每个表空间中，逻辑数据库结构（如表和索引）都是片段，被进一步细分为“盘区”（extent）和“块”（block）。这种存储的逻辑细分c让Oracle更有效的控制磁盘。</p><p>1）表空间</p><p>表空间是Oracle数据库的最大逻辑划分区域，常用来存放数据表，索引等数据对象，任何实体对象在创建时必须指定表空间。</p><p>表空间与数据文件相对应，一个表空间由一个或多个数据文件组成，一个数据文件只属于一个表空间。</p><p>Oracle数据的存储空间在逻辑上变现为表空间而在物理上表现为数据文件，表空间相当于文件夹，数据文件相当于文件夹中的文件。</p><p>2）段</p><p>数据库中的下一个逻辑分组级别是段。段是一组盘区，这组盘区组成了被Oracle视为一个单位的数据库对象，如表或索引。因此，段一般是数据库终端用户要处理的最小存储单位。Oracle数据库中可看到4种类型的段：数据段（非分区表和分区表的每个分区）、索引段、临时段和回滚段。</p><p>3）盘区</p><p>它由一个或多个数据库块组成。当扩大数据库对象时，为该对象添加的空间将分配为一个盘区。</p><p>4）块</p><p>数据库块是Oracle数据库最小的存储单位。块的大小是数据库内给定表空间中特定数量的存储字节。默认块大小是8KB。</p><h2 id="2-物理存储结构"><a class="markdownIt-Anchor" href="#2-物理存储结构"></a> 2、物理存储结构</h2><p>1）数据文件</p><p>数据文件用于存储数据库中的所有数据，包含系统数据、数据字典数据、临时数据、索引数据、应用数据等。</p><p>安装Oracle数据库时系统会自动为数据库创建几个数据文件，用户对数据库的操作本质是对数据文件的操作。一个表空间可以对应多个数据文件，一个数据文件只能从属于一个表空间。在逻辑上，数据对象都存放在表空间中，实质上是存放在空间对应的数据文件中。</p><p>2）控制文件</p><p>每个Oracle数据库有一组控制文件(control file)，用于记录和描述数据库的物理存储结构信息，包含数据库名、数据库数据文件和日志文件的名字和位置和数据库的时间戳。</p><p>3）参数文件</p><p>参数文件用于设置数据库启动时的参数初始值。</p><p>4）密码文件：</p><p>用于保存具有SYSDBA、SYSOPER权限的用户名和SYS用户密码。</p><p>5）日志文件</p><p>Oracle以SQL脚本的形式实时记录了数据变化的详细日志，这些日志保存在重做日志文件中。根据重做日志文件，可以对数据库进行备份和恢复。</p><p>日志文件有两种：在线日志和归档日志。</p><p>创建Oracle数据库实例的时候，缺省建立三组在线日志，每组一个日志文件。三组日志中只有一组处于活动状态，这组活动的日志也称为当前日志，数据库不断的往当前日志里写入SQL脚本，当前日志写满后，Oracle会切换到下一组日志，继续写入，就这样循环切换。</p><p>日志组在切换时，如果数据库是归档模式，则将当前日志文件的内容转存为操作系统文件，成为归档日志；若当前数据库是非归档模式，则不进行归档操作，当前日志文件中的内容会被下一次覆盖。</p><p>如果数据库运行在归档模式下，当数据库出现介质失败时，使用备份文件、归档日志和在线日志可以完全恢复数据库。</p><p>6）跟踪文件</p><p>用户记录用户进程、数据库后台进程的运行情况。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle字符集的设置</title>
      <link href="/post/19200837.html"/>
      <url>/post/19200837.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-字符集的概念"><a class="markdownIt-Anchor" href="#一-字符集的概念"></a> 一、字符集的概念</h1><h2 id="1-字符编码character-encoding"><a class="markdownIt-Anchor" href="#1-字符编码character-encoding"></a> 1、字符编码（character encoding）：</h2><p>字符编码是一种法则，在数字与符号之间建立的对应关系。不同的国家有不同的语言，包含的文字、标点符号、图形符号各有不同。例如在ASCII编码中，用数字97表达字符’a’与字符集相对应，常见的字符编码有ASCII，GBK，GB18030，Unicode等。</p><h2 id="2-字符集character-set"><a class="markdownIt-Anchor" href="#2-字符集character-set"></a> 2、字符集（Character set）</h2><p>字符集是字符的集合，字符是文字和符号的总称，用ASCII编码的字符集称之为ASCII字符集，用GBK编码的字符集称之为GBK字符集。</p><h2 id="3-国际编码unicode"><a class="markdownIt-Anchor" href="#3-国际编码unicode"></a> 3、国际编码（Unicode）</h2><p>为了解决传统的字符编码方案的局限，1994年发布了Unicode（国际编码、统一码、万国码、单一码、通用码），它是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 将全世界所有的字符统一化，统一编码，再也不存在字符集不兼容和字符转换的问题。</p><p>Unicode 有以下三种编码方式：</p><p>1）UTF-8：兼容ASCII编码；拉丁文、希腊文等使用两个字节；包括汉字在内的其它常用字符使用三个字节；剩下的极少使用的字符使用四个字节。</p><p>2）UTF-16：对相对常用的60000余个字符使用两个字节进行编码，其余的使用4字节。</p><p>3）UTF-32：固定使用4个字节来表示一个字符，存在空间利用效率的问题。</p><h2 id="4-汉字的编码"><a class="markdownIt-Anchor" href="#4-汉字的编码"></a> 4、汉字的编码</h2><p>支持汉字（简体中文）的编码有GB2312、GB13000、GBK、GB18030和Unicode（UTF-8、UTF-16、UTF-32）。</p><p>1）GB2312</p><p>仅包含大部分的常用简体汉字，但已经不能适应现在的需要。</p><p>2）GB13000</p><p>由于GB2312的局限性，国家标准化委员会制定了GB13000编码；但由于当时的硬件和软件都已经支持了GB2312，而GB13000与GB2312完全不兼容，所以没有能够得到大范围的推广使用。</p><p>3）GBK</p><p>有了GB13000的教训，中国国家标准化委员会制定了GBK标准，并兼容了GB2312标准，同时在GB2312标准的基础上扩展了GB13000包含的字；由于该标准有微软的支持，得到了广泛的应用。</p><p>4）GB18030</p><p>GB18030编码比GBK又新增了几千个汉字，但由于码位不足使用了2byte与4byte混合编码方式，这给软件开发增加了难度。</p><p>5）Unicode</p><p>包含全世界所有国家需要用到的字符，是国际编码，通用性强。</p><h2 id="5-汉字的编码选择"><a class="markdownIt-Anchor" href="#5-汉字的编码选择"></a> 5、汉字的编码选择</h2><p>在操作系统和数据库中，常用的汉字编码有GBK、GB18030和Unicode，GBK和GB18030的优势是占用空间小，Unicode的优势是全球化的支持。</p><p>在应用开发中，如果不考虑全球化，最好的选择是GBK和GB18030。</p><h2 id="6-编码的转换"><a class="markdownIt-Anchor" href="#6-编码的转换"></a> 6、编码的转换</h2><p>GBK和GB18030与Unicode编码之间需要转换，否则会出现汉字乱码。</p><h1 id="二-oracle的字符集"><a class="markdownIt-Anchor" href="#二-oracle的字符集"></a> 二、Oracle的字符集</h1><h2 id="1-字符集和国家字符集"><a class="markdownIt-Anchor" href="#1-字符集和国家字符集"></a> 1、字符集和国家字符集</h2><p>字符集在创建数据库实例时指定，可以指定字符集（CHARACTER SET）和国家字符集（NATIONAL CHARACTER SET）。</p><p>1）字符集（CHARACTER SET）</p><p>用来存储char、varchar2、clob、long等类型数据，还可以用来标识表名、列名以及PL/SQL变量等。</p><p>2）国家字符集（NATIONAL CHARACTER SET）</p><p>用以存储nchar、nvarchar2、nclob等类型数据。国家字符集实质上是为Oracle选择的附加字符集，主要作用是为了增强字符处理能力，因为nchar数据类型可以提供对亚洲使用定长多字节编码的支持，而数据库字符集则不一定能。国家字符集只能在unicode编码中的AF16UTF16和UTF8中选择，默认值是AF16UTF16。</p><h2 id="2-支持中文的字符集"><a class="markdownIt-Anchor" href="#2-支持中文的字符集"></a> 2、支持中文的字符集</h2><p>Oracle支持汉字（简体中文，繁体不介绍）的字符集有多种，常用的有ZHS16GBK、UTF8、AL32UTF8和AL16UTF16。</p><p>1）ZHS16GBK</p><p>表示简体中文，一个字符需要16位比特，采用GBK编码标准。</p><p>2）UTF8</p><p>Oracle从8i版本开始使用的属于UTF-8编码的字符集，采用的Unicode标准为3.0，在11.2版本中，UTF8已经不是推荐字符集列表中的一员了。</p><p>3）AL32UTF8</p><p>与UTF8相比，它采用的Unicode版本更新，在10g版本中使用的是Unicode 4.01标准，而UTF8因为兼容性的考虑，在10g版本中用的是Unicode 3.0标准。</p><p>4）AL16UTF16</p><p>是ORACLE第一种采用UTF-16编码方式的字符集，从ORACLE9开始使用，是作为缺省的国家字符集使用，它不能被用作数据库的字符集。</p><h2 id="3-nls_lang参数"><a class="markdownIt-Anchor" href="#3-nls_lang参数"></a> 3、NLS_LANG参数</h2><p>Oracle数据库字符集最重要的参数是NLS_LANG参数。</p><p>格式: NLS_LANG=‘language_territory.charset’，不区分大小写，例如’ SIMPLIFIED CHINESE_CHINA.ZHS16GBK’。</p><p>它有三个组成部分：语言（language）、地域（territory）和字符集（charset）。</p><p>其中:</p><p>language：数据库服务器提示信息的语言。</p><p>territory：数据库的日期和数字格式，意义不大。</p><p>charset：数据库的字符集。</p><p>真正影响数据库字符集的其实是第三部分charset，两个数据库之间的字符集只要第三部分相同，交换数据时中文不会出现乱码。language影响的只是提示信息是中文还是英文。</p><h1 id="三-服务端的字符集"><a class="markdownIt-Anchor" href="#三-服务端的字符集"></a> 三、服务端的字符集</h1><h2 id="1-查看服务端字符集"><a class="markdownIt-Anchor" href="#1-查看服务端字符集"></a> 1、查看服务端字符集</h2><p>执行以下SQL可以查看服务端的字符集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from NLS_DATABASE_PARAMETERS where parameter like <span class="string">&#x27;%CHARACTERSET%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202003130959481.png" alt="在这里插入图片描述" /></p><p>执行以下SQL也可以查看服务端的字符集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">userenv</span><span class="params">(<span class="string">&#x27;language&#x27;</span>)</span> from dual</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313100103972.png" alt="在这里插入图片描述" /></p><h2 id="2-修改服务端字符集"><a class="markdownIt-Anchor" href="#2-修改服务端字符集"></a> 2、修改服务端字符集</h2><p>Oracle数据库实例创建后，如果没有开始业务运行，可以修改字符集，如果已经业务化运行，不建议修改字符集，会造成数据中的汉字乱码。</p><p>用DBA权限，执行以下步骤修改Oracle数据库的字符集（例如修改为ZHS16GBK）。</p><p>1）修改服务端操作系统的NLS_LANG环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br></pre></td></tr></table></figure><p>2）关闭Oracle数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown immediate;</span><br></pre></td></tr></table></figure><p>3）把数据库启动到mount状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup mount;</span><br></pre></td></tr></table></figure><p>4）把数据库改为restricted模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter system enable restricted session;</span><br><span class="line">alter system set job_queue_processes=<span class="number">0</span>;</span><br><span class="line">alter system set aq_tm_processes=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>5）打开数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database open;</span><br></pre></td></tr></table></figure><p>6）修改数据库的字符集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database character set internal_use ZHS16GBK;</span><br></pre></td></tr></table></figure><p>7）重启数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown immediate;</span><br><span class="line">startup;</span><br></pre></td></tr></table></figure><h1 id="四-客户端的字符集"><a class="markdownIt-Anchor" href="#四-客户端的字符集"></a> 四、客户端的字符集</h1><p>Oracle客户端的字符集必须与服务端相同，否则中文会出现乱码。</p><h2 id="1-linux环境"><a class="markdownIt-Anchor" href="#1-linux环境"></a> 1、Linux环境</h2><p>客户端的字符集由NLS_LANG环境变量控制。</p><p>1）查看NLS_LANG环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env|grep NLS_LANG</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313100327221.png" alt="在这里插入图片描述" /></p><p>2）设置环境变量</p><p>修改环境变量参数文件（系统或用户的profile文件）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-windows环境"><a class="markdownIt-Anchor" href="#2-windows环境"></a> 2、Windows环境</h2><p>打开注册表（ 执行regedit.exe）</p><p>HKEY_LOCAL_MACHINE -&gt; SOFTWARE -&gt; ORACLE -&gt; KEY_OraClient11g_home1</p><p><img src="https://img-blog.csdnimg.cn/2020031310041361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>1）数据库在业务化之前，就应该确定Oracle的字符集，然后不再改变。数据库在业务化后，修改字符集是一件很麻烦的事情，最好别惹这个麻烦。</p><p>2）如果项目没有全球化的需求，数据库字符集建议采用ZHS16GBK，操作系统语言建议采用gbk。</p><p>3）只要把客户端和服务端设置成相同的字符集，就不会有乱码，没什么技术难点。</p><p>4）虽然GB18030字符集比GBK更丰富，但是GB18030中有部分汉字是4字节，这一点让程序员很郁闷，所以，程序员更倾向GBK字符集。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle归档日志管理</title>
      <link href="/post/9e072477.html"/>
      <url>/post/9e072477.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-重做日志"><a class="markdownIt-Anchor" href="#一-重做日志"></a> 一、重做日志</h1><p>Oracle以SQL脚本的形式实时记录了数据变化的详细日志，这些日志保存在重做日志文件中。根据重做日志文件，可以对数据库进行备份和恢复。在下文中，把重做日志简称为日志。</p><p>可以简单的认为，数据库每次在commit之前，会把操作数据的SQL脚本写入日志文件。</p><p>日志文件有两种：在线日志和归档日志。</p><p>创建Oracle数据库实例的时候，缺省建立三组在线日志，每组一个日志文件。三组日志中只有一组处于活动状态，这组活动的日志也称为当前日志，数据库不断的往当前日志里写入SQL脚本，当前日志写满后，Oracle会切换到下一组日志，继续写入，就这样循环切换。</p><p>日志组在切换时，如果数据库是归档模式，则将当前日志文件的内容转存为操作系统文件，成为归档日志；若当前数据库是非归档模式，则不进行归档操作，当前日志文件中的内容会被下一次覆盖。</p><p>如果数据库运行在归档模式下，当数据库出现介质失败时，使用备份文件、归档日志和在线日志可以完全恢复数据库。</p><h1 id="二-日志管理"><a class="markdownIt-Anchor" href="#二-日志管理"></a> 二、日志管理</h1><h2 id="1-查看日志"><a class="markdownIt-Anchor" href="#1-查看日志"></a> 1、查看日志</h2><p>1）查看日志组和日志文件信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group#,type,member from V$LOGFILE order by group#;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093214806.png" alt="在这里插入图片描述" /></p><p>2）查看当前日志组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group#,status,archived from V$LOG order by group#;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093240357.png" alt="在这里插入图片描述" /></p><p>3）查看数据库的日志模式。</p><p>方法一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive log list;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031309331574.png" alt="在这里插入图片描述" /></p><p>方法二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,log_mode from V$DATABASE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093347486.png" alt="在这里插入图片描述" /></p><p>4）查询已归档的日志文件清单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select recid,sequence#,name from V$ARCHIVED_LOG order by sequence#;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093418227.png" alt="在这里插入图片描述" /></p><h2 id="2-日志组和日志文件操作"><a class="markdownIt-Anchor" href="#2-日志组和日志文件操作"></a> 2、日志组和日志文件操作</h2><p>DBA可以增加、删除和移动日志组或日志文件。</p><p>1）增加/删除日志组。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add logfile group 组编号 (<span class="string">&#x27;日志文件名1&#x27;</span>,<span class="string">&#x27;日志文件名2&#x27;</span>,......) size 大小;</span><br><span class="line">alter database drop logfile group 组编号;</span><br></pre></td></tr></table></figure><p>例如，增加日志组编号为4，本组有两个日志文件/oracle/base/oradata/snorcl11g/redo04_1.log和/oracle/base/oradata/snorcl11g/redo04_2.log，两个文件互为备份，大小为256M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add logfile group <span class="number">4</span> (<span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_1.log&#x27;</span>,<span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_2.log&#x27;</span>) size <span class="number">256</span>M;</span><br><span class="line">alter database drop logfile group <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>删除日志组后，要手工的删除磁盘上的日志文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm /oracle/base/oradata/snorcl11g/redo04_1.log</span><br><span class="line">rm /oracle/base/oradata/snorcl11g/redo04_2.log</span><br></pre></td></tr></table></figure><p>2）增加/删除日志文件。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add  logfile member <span class="string">&#x27;日志文件名n&#x27;</span> to group 组编号;</span><br><span class="line">alter database drop logfile member <span class="string">&#x27;日志文件名n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add  logfile member <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_3.log&#x27;</span> to group <span class="number">4</span>;</span><br><span class="line">alter database drop logfile member <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_3.log&#x27;</span>;</span><br></pre></td></tr></table></figure><p>删除日志组后，要手工的删除磁盘上的日志文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /oracle/base/oradata/snorcl11g/redo04_3.log</span><br></pre></td></tr></table></figure><p>3）移动日志文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database rename file <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_2.log&#x27;</span> to <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_4.log&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行该命令之前必须保证该日志文件物理上已经移动到新目录。</p><h2 id="3-修改日志模式"><a class="markdownIt-Anchor" href="#3-修改日志模式"></a> 3、修改日志模式</h2><p>1）关闭数据库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown immediate;</span><br></pre></td></tr></table></figure><p>2）把数据库启动到mount模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup mount;</span><br></pre></td></tr></table></figure><p>3）查看日志模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive log list;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093851838.png" alt="在这里插入图片描述" /></p><p>4）设置归档日志文件存放的目录。</p><p>首先，根据您的实际需求，创建用于存放归档日志文件的目录，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /oracle/archive1</span><br></pre></td></tr></table></figure><p>然后，修改数据库参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system set log_archive_dest_1=<span class="string">&#x27;location=/oracle/archive1&#x27;</span> scope=spfile;</span><br></pre></td></tr></table></figure><p>5）修改归档日志文件的格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system set log_archive_format=<span class="string">&#x27;%T_%S_%r.log&#x27;</span> scope=spfile;</span><br></pre></td></tr></table></figure><p>日志文件名缺省是’%t_%s_%r.dbf’，详细的格式含义如下：</p><p>%s 日志序列号。</p><p>%S 日志序列号，但带前导0。</p><p>%t 日志线程号。</p><p>%T 日志线程号，但带前导0。</p><p>%a 活动ID号。</p><p>%d 数据库ID号。</p><p>%r resetlogs的ID值。</p><p>6）启用日志归档模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database archivelog;</span><br></pre></td></tr></table></figure><p>7）修改参数后，需要<strong>重启数据库到正常模式</strong>，确认修改后参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive log list;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313094016359.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter log_archive_format;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313094309689.png" alt="在这里插入图片描述" /></p><p>8）手工切换在线日志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system <span class="keyword">switch</span> logfile;</span><br></pre></td></tr></table></figure><p>用DBA执行以上命令，不管当前日志是否写懣，都立即归档。</p><p><img src="https://img-blog.csdnimg.cn/2020031309433983.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200313094350917.png" alt="在这里插入图片描述" /></p><p>9）禁用日志归档模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database noarchivelog;</span><br></pre></td></tr></table></figure><h2 id="4-归档日志的清理"><a class="markdownIt-Anchor" href="#4-归档日志的清理"></a> 4、归档日志的清理</h2><p>如果Oracle启用了日志归档模式，必须保证有足够的磁盘空间存放归档日志文件，如果空间不足，在线日志不能归档，也不会切换，数据库将暂停运行，错误代码为ORA-00257。</p><p>所以，归档日志文件要定期清理，运维人员经常用shell脚本加crontab任务的方法清理归档日志文件，但是，对我们程序员来，写程序清理是最好的方法。归档日志文件切换频率由数据库事务操作的繁忙程度决定的，只保留最近n个文件，其它的全部清理。</p><h1 id="三-归档非归档模式优缺点"><a class="markdownIt-Anchor" href="#三-归档非归档模式优缺点"></a> 三、归档/非归档模式优缺点</h1><h2 id="1-归档模式的优点"><a class="markdownIt-Anchor" href="#1-归档模式的优点"></a> 1、归档模式的优点</h2><p>1）可以进行完全、不完全恢复</p><p>由于对数据库所做的全部改动都记录在日志文件中，如果发生硬盘故<br />障等导致数据文件丢失的话，则可以利用物理备份和归档日志完全恢复数据库，不会丢失任何数据。</p><p>2）可以进行联机热备</p><p>所谓联机热备，就是在数据库运行状态下，对数据库进行备份。备份时用户对数据库的使用不受任何影响。</p><p>3）可以实施 Data Guard</p><p>可以部署 1 个或多个备用数据库，从而最大限度地提供灾难保护手段。</p><p>4）可以实施 Stream</p><p>利用 Stream 技术，可以实现最简单的单向复制到复杂的双向复制、多向复制，提供更加灵活的数据冗余方案。</p><p>5）表空间可以脱机</p><p>可以备份部分数据库，比如重要的表空间。</p><p>6）能够增量备份</p><p>只需做一次完全备份，以后只备份发生改变的数据，可以提高备份速度。</p><p>7）更多的优化选项</p><p>随着 Oracle 版本升级，在联机热备方面不断有新的优化策略出现。</p><h2 id="2-归档模式的缺点"><a class="markdownIt-Anchor" href="#2-归档模式的缺点"></a> 2、归档模式的缺点</h2><p>1）需要更多的磁盘空间保存归档日志；</p><p>2）DBA会有更多的管理工作，包括维护归档空间、备份归档日志。</p><h2 id="3-非归档模式的优点"><a class="markdownIt-Anchor" href="#3-非归档模式的优点"></a> 3、非归档模式的优点</h2><p>1）DBA 的管理工作减少，因为非归档模式不产生归档日志，因此 DBA 不用考虑对归档的管理；</p><p>2）性能会有微弱的提升。</p><h2 id="4-非归档模式的缺点"><a class="markdownIt-Anchor" href="#4-非归档模式的缺点"></a> 4、非归档模式的缺点</h2><p>1）只能进行脱机备份，也就是所谓的“ 冷备份”，和联机备份的“ 热备份”<br />相对应，数据库必须完全 关闭后备份，在备份过程中数据库不可用；</p><p>2）必须备份整个数据库，不能只备份部分数据库；</p><p>3）不能增量备份，对于 TB 级数据库（VLDB） ，这是一个非常大的缺点；</p><p>4）只能部分恢复，如果数据文件丢失需要恢复，DBA 只能恢复最后一次的完全备份，而之后的所有 数据库改变全部丢失。</p><p>非归档模式不生成归档日志，从数据安全角度来说，这种模式缺点是主要的，而优点可以忽略不计。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据备份和恢复</title>
      <link href="/post/a6591160.html"/>
      <url>/post/a6591160.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库的备份和恢复有很多种方法，是一个很大的话题，足可以写一本书，但是，本文只介绍采用exp和imp进行数据备份和恢复，这也是程序员最常用的方法。</p><p>本文涉及的备份与恢复的其它概念都是狭义的，不完整的或不完全准确的，仅供参考。</p><h1 id="一-备份与恢复的概念"><a class="markdownIt-Anchor" href="#一-备份与恢复的概念"></a> 一、备份与恢复的概念</h1><h2 id="1-什么是备份"><a class="markdownIt-Anchor" href="#1-什么是备份"></a> 1、什么是备份</h2><p>备份就是把数据库中的数据复制到存储设备的过程，存储设备包括磁盘、磁带、光盘等，随着存储技术的发展，磁带和光盘已经很少使用。</p><h2 id="2-备份的方法"><a class="markdownIt-Anchor" href="#2-备份的方法"></a> 2、备份的方法</h2><p>1）物理备份</p><p>对数据库操作系统的物理文件（数据文件，控制文件和日志文件）的备份。物理备份又可以分为脱机备份（冷备份）和联机备份（热备份），前者是在关闭数据库的时候进行的，后者是以归档日志的方式对运行的数据库进行备份。可以使用oracle的恢复管理器（rman）或操作系统命令进行数据库的物理备份。</p><p>2）逻辑备份</p><p>对数据库逻辑组件（如表和存储过程等数据库对象）的备份。逻辑备份的手段很多，如传统的exp，数据泵（expdp），数据库闪回技术等第三方工具，都可以进行数据库的逻辑备份。</p><h2 id="3-备份的策略"><a class="markdownIt-Anchor" href="#3-备份的策略"></a> 3、备份的策略</h2><p>1）完全备份</p><p>每次对数据库进行完整备份，当发生数据丢失的灾难时，完全备份无需依赖其他信息即可实现100%的数据恢复，其恢复时间最短且操作最方便。</p><p>2）增量备份</p><p>只有那些在上次完全备份或增量备份后被修改的文件才会被备份。优点是备份数据量小，需要的时间短，缺点是恢复的时候需要依赖以前备份记录，出问题的风险较大。</p><p>3）差异备份</p><p>备份那些自从上次完全备份之后被修改过的文件。从差异备份中恢复数据的时间较短，只需要最后一次完整备份和最后一次差异备份的数据，缺点是每次备份需要的时间较长。</p><h2 id="4-什么是恢复"><a class="markdownIt-Anchor" href="#4-什么是恢复"></a> 4、什么是恢复</h2><p>恢复就是发生故障后，利用已备份的数据文件或控制文件，重新建立一个完整的数据库。</p><h2 id="5-恢复分类"><a class="markdownIt-Anchor" href="#5-恢复分类"></a> 5、恢复分类</h2><p>1）实例恢复</p><p>当oracle实例出现失败后，oracle自动进行的恢复。</p><p>2）介质恢复</p><p>当存放数据库的介质出现故障时所作的恢复，介质恢复又分为完全恢复和不完全恢复。</p><p>完全恢复：将数据库恢复到数据库失败时的状态。这种恢复是通过装载数据库备份并应用全部的重做日志做到的。</p><p>不完全恢复：将数据库恢复到数据库失败前的某一时刻的状态。这种恢复是通过装载数据库备份并应用部分的重做日志做到的。进行不完全恢复后，必须在启动数据库时用resetlogs选项重设联机重做日志。</p><h1 id="二-逻辑备份和恢复"><a class="markdownIt-Anchor" href="#二-逻辑备份和恢复"></a> 二、逻辑备份和恢复</h1><p>Oracle逻辑备份和恢复的工具是exp（导出）和imp（导入），我根据应用场景来介绍这两个命令使用方法。</p><h2 id="1-exp命令"><a class="markdownIt-Anchor" href="#1-exp命令"></a> 1、exp命令</h2><p>在shell下输入<code>exp -help或exp help=y</code>获取exp命令帮助，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">exp -help</span><br><span class="line"></span><br><span class="line">Export: Release <span class="number">11.2</span><span class="number">.0</span><span class="number">.4</span><span class="number">.0</span> - Production on 星期四 <span class="number">2</span>月 <span class="number">6</span> <span class="number">10</span>:<span class="number">04</span>:<span class="number">26</span> <span class="number">2020</span></span><br><span class="line"><span class="built_in">Copyright</span> (c) <span class="number">1982</span>, <span class="number">2011</span>, Oracle <span class="keyword">and</span>/<span class="keyword">or</span> its affiliates.  All rights reserved.</span><br><span class="line"></span><br><span class="line">通过输入 EXP 命令和您的用户名/口令, 导出</span><br><span class="line">操作将提示您输入参数:</span><br><span class="line"></span><br><span class="line"> 例如: EXP SCOTT/TIGER</span><br><span class="line"></span><br><span class="line">或者, 您也可以通过输入跟有各种参数的 EXP 命令来控制导出</span><br><span class="line">的运行方式。要指定参数, 您可以使用关键字:</span><br><span class="line"></span><br><span class="line"> 格式:  EXP KEYWORD=value 或 KEYWORD=(value1,value2,...,valueN)</span><br><span class="line"> 例如: EXP SCOTT/TIGER GRANTS=Y TABLES=(EMP,DEPT,MGR)</span><br><span class="line">           或 TABLES=(T1:P1,T1:P2), 如果 T1 是分区表</span><br><span class="line"></span><br><span class="line">USERID 必须是命令行中的第一个参数。</span><br><span class="line"></span><br><span class="line">关键字   说明 (默认值)         关键字      说明 (默认值)</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">USERID   用户名/口令           FULL        导出整个文件 (N)</span><br><span class="line">BUFFER   数据缓冲区大小        OWNER        所有者用户名列表</span><br><span class="line">FILE     输出文件 (EXPDAT.DMP)  TABLES     表名列表</span><br><span class="line">COMPRESS  导入到一个区 (Y)   RECORDLENGTH   IO 记录的长度</span><br><span class="line">GRANTS    导出权限 (Y)          INCTYPE     增量导出类型</span><br><span class="line">INDEXES   导出索引 (Y)         RECORD       跟踪增量导出 (Y)</span><br><span class="line">DIRECT    直接路径 (N)         TRIGGERS     导出触发器 (Y)</span><br><span class="line">LOG      屏幕输出的日志文件    STATISTICS    分析对象 (ESTIMATE)</span><br><span class="line">ROWS      导出数据行 (Y)        PARFILE      参数文件名</span><br><span class="line">CONSISTENT 交叉表的一致性 (N)   CONSTRAINTS  导出的约束条件 (Y)</span><br><span class="line">OBJECT_CONSISTENT    只在对象导出期间设置为只读的事务处理 (N)</span><br><span class="line">FEEDBACK             每 x 行显示进度 (<span class="number">0</span>)</span><br><span class="line">FILESIZE             每个转储文件的最大大小</span><br><span class="line">FLASHBACK_SCN        用于将会话快照设置回以前状态的 SCN</span><br><span class="line">FLASHBACK_TIME       用于获取最接近指定时间的 SCN 的时间</span><br><span class="line">QUERY                用于导出表的子集的 select 子句</span><br><span class="line">RESUMABLE            遇到与空格相关的错误时挂起 (N)</span><br><span class="line">RESUMABLE_NAME       用于标识可恢复语句的文本字符串</span><br><span class="line">RESUMABLE_TIMEOUT    RESUMABLE 的等待时间</span><br><span class="line">TTS_FULL_CHECK       对 TTS 执行完整或部分相关性检查</span><br><span class="line">VOLSIZE              写入每个磁带卷的字节数</span><br><span class="line">TABLESPACES          要导出的表空间列表</span><br><span class="line">TRANSPORT_TABLESPACE 导出可传输的表空间元数据 (N)</span><br><span class="line">TEMPLATE             调用 iAS 模式导出的模板名</span><br></pre></td></tr></table></figure><h2 id="2-imp命令"><a class="markdownIt-Anchor" href="#2-imp命令"></a> 2、imp命令</h2><p>在shell下输入<code>imp -help 或 imp help=y</code>获取imp命令帮助，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">imp -help</span><br><span class="line"></span><br><span class="line">Import: Release <span class="number">11.2</span><span class="number">.0</span><span class="number">.4</span><span class="number">.0</span> - Production on 星期四 <span class="number">2</span>月 <span class="number">6</span> <span class="number">10</span>:<span class="number">06</span>:<span class="number">42</span> <span class="number">2020</span></span><br><span class="line"><span class="built_in">Copyright</span> (c) <span class="number">1982</span>, <span class="number">2011</span>, Oracle <span class="keyword">and</span>/<span class="keyword">or</span> its affiliates.  All rights reserved.</span><br><span class="line"></span><br><span class="line">通过输入 IMP 命令和您的用户名/口令, 导入</span><br><span class="line">操作将提示您输入参数: </span><br><span class="line"></span><br><span class="line">     例如: IMP SCOTT/TIGER</span><br><span class="line"></span><br><span class="line">或者, 可以通过输入 IMP 命令和各种参数来控制导入</span><br><span class="line">的运行方式。要指定参数, 您可以使用关键字: </span><br><span class="line"></span><br><span class="line"> 格式:  IMP KEYWORD=value 或 KEYWORD=(value1,value2,...,valueN)</span><br><span class="line"> 例如: IMP SCOTT/TIGER IGNORE=Y TABLES=(EMP,DEPT) FULL=N</span><br><span class="line">           或 TABLES=(T1:P1,T1:P2), 如果 T1 是分区表</span><br><span class="line"></span><br><span class="line">USERID 必须是命令行中的第一个参数。</span><br><span class="line"></span><br><span class="line">关键字   说明 (默认值)        关键字      说明 (默认值)</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">USERID   用户名/口令           FULL       导入整个文件 (N)</span><br><span class="line">BUFFER   数据缓冲区大小        FROMUSER    所有者用户名列表</span><br><span class="line">FILE     输入文件 (EXPDAT.DMP)  TOUSER     用户名列表</span><br><span class="line">SHOW     只列出文件内容 (N)     TABLES      表名列表</span><br><span class="line">IGNORE   忽略创建错误 (N)    RECORDLENGTH  IO 记录的长度</span><br><span class="line">GRANTS   导入权限 (Y)          INCTYPE     增量导入类型</span><br><span class="line">INDEXES   导入索引 (Y)         COMMIT       提交数组插入 (N)</span><br><span class="line">ROWS     导入数据行 (Y)        PARFILE      参数文件名</span><br><span class="line">LOG     屏幕输出的日志文件    CONSTRAINTS    导入限制 (Y)</span><br><span class="line">DESTROY                覆盖表空间数据文件 (N)</span><br><span class="line">INDEXFILE              将表/索引信息写入指定的文件</span><br><span class="line">SKIP_UNUSABLE_INDEXES  跳过不可用索引的维护 (N)</span><br><span class="line">FEEDBACK               每 x 行显示进度 (<span class="number">0</span>)</span><br><span class="line">TOID_NOVALIDATE        跳过指定类型 ID 的验证 </span><br><span class="line">FILESIZE               每个转储文件的最大大小</span><br><span class="line">STATISTICS             始终导入预计算的统计信息</span><br><span class="line">RESUMABLE              在遇到有关空间的错误时挂起 (N)</span><br><span class="line">RESUMABLE_NAME         用来标识可恢复语句的文本字符串</span><br><span class="line">RESUMABLE_TIMEOUT      RESUMABLE 的等待时间 </span><br><span class="line">COMPILE                编译过程, 程序包和函数 (Y)</span><br><span class="line">STREAMS_CONFIGURATION  导入流的一般元数据 (Y)</span><br><span class="line">STREAMS_INSTANTIATION  导入流实例化元数据 (N)</span><br><span class="line">DATA_ONLY              仅导入数据 (N)</span><br><span class="line">VOLSIZE                磁带的每个文件卷上的文件的字节数</span><br><span class="line"></span><br><span class="line">下列关键字仅用于可传输的表空间</span><br><span class="line">TRANSPORT_TABLESPACE 导入可传输的表空间元数据 (N)</span><br><span class="line">TABLESPACES 将要传输到数据库的表空间</span><br><span class="line">DATAFILES 将要传输到数据库的数据文件</span><br><span class="line">TTS_OWNERS 拥有可传输表空间集中数据的用户</span><br></pre></td></tr></table></figure><h2 id="3-数据库实例导出和导入"><a class="markdownIt-Anchor" href="#3-数据库实例导出和导入"></a> 3、数据库实例导出和导入</h2><p>导出数据库实例需要DBA权限，包括Oracle系统和全部的用户、索引、存储过程、权限等。应用场景极少，不建议。</p><p>1）导出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp scott/tiger file=/tmp/expdata.dmp full=y</span><br></pre></td></tr></table></figure><p>2）导入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp scott/tiger file=/tmp/expdata.dmp full=y</span><br></pre></td></tr></table></figure><h2 id="4-用户的导出和导入"><a class="markdownIt-Anchor" href="#4-用户的导出和导入"></a> 4、用户的导出和导入</h2><p>导出/导入某用户全部的对象。普通用户只能操作本用户，DBA用户可以操作其他用户。</p><p>1）用scott/tiger登录数据库，导出scott用户，数据保存在/tmp/expscott.dmp文件中，日志保存在/tmp/expscott.log文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp scott/tiger owner=scott file=/tmp/expscott.dmp log=/tmp/expscott.log</span><br></pre></td></tr></table></figure><p>2）用scott/tiger登录数据库，从/tmp/expscott.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到scott用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp scott/tiger file=/tmp/expscott.dmp fromuser=scott touser=scott</span><br></pre></td></tr></table></figure><p>3）用system/systempwd登录数据库（system具有DBA权限），，从/tmp/expscott.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到girl用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/systempwd file=/tmp/expscott.dmp fromuser=scott touser=girl</span><br></pre></td></tr></table></figure><h2 id="5-表的导出和导入"><a class="markdownIt-Anchor" href="#5-表的导出和导入"></a> 5、表的导出和导入</h2><p>导出/导入某用户全部的表。普通用户只能操作本用户的表，DBA用户可以操作其他用户的表。如果要导出多个表，需要把表名写在括号中，括号需要用\转义。</p><p>1）用scott/tiger登录数据库，导出EMP和DEPT表，数据保存在/tmp/empdept.dmp文件中，日志保存在/tmp/empdtpe.log文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp scott/tiger file=/tmp/empdept.dmp log=/tmp/empdept.log tables=\(EMP,DEPT\)</span><br></pre></td></tr></table></figure><p>2）用scott/tiger登录数据库，从/tmp/empdept.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到scott用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp scott/tiger file=/tmp/empdept.dmp fromuser=scott touser=scott</span><br></pre></td></tr></table></figure><p>3）用system/systempwd登录数据库（system具有DBA权限），，从/tmp/expscott.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到girl用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/systempwd file=empdept.dmp fromuser=scott touser=girl</span><br></pre></td></tr></table></figure><h2 id="6-注意事项"><a class="markdownIt-Anchor" href="#6-注意事项"></a> 6、注意事项</h2><p>1）exp和imp的参数比较多，但用到的却很少，您可以多尝试。</p><p>2）exp和imp的时候，如果没有任何警告和错误，会出现<code>成功终止导出/导入,没有出现警告</code>。</p><p>3）log参数很重要，把导出/导入的信息写在日志文件中，您可以用程序来判断导出是否成功。备份工作很重要，必须保证成功。</p><p>4）owner参数支持多个用户名的书写，要用括号，括号前加\转义。</p><p>5）tables参数支持多个表名的书写，要用括号，括号前加\转义。</p><p>6）rows参数很重要，如果rows=n，则只导出/导入表结构，不导出数据。</p><p>7）imp的ignore参数很重要，如果ignore=n，导入数据的时候，如果表已存在，就报错并且不会向表中导入数据，如果ignore=y，导入数据的时候，如果表已存在，会报错但是仍会向表中导入数据。</p><p>8）增量导出功能看上去很棒，但是可操作性很差。</p><p>9）其它的参数看看就行，了解了解。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>重要的业务系统一定会有非常完善的备份方案，由DBA去执行。</p><p>对程序员来说，采用exp/imp的场景主要有：</p><p>1）对一些数据量比较小的系统做备份，例如备份某数据库用户；</p><p>2）只备份数据库对象（不备份数据），缩短故障恢复的时间；</p><p>3）用于表的数据迁移；</p><p>4）程序员还可能自己编写程序来备份数据。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的启动和关闭</title>
      <link href="/post/95482dc7.html"/>
      <url>/post/95482dc7.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库的启用和关闭需要DBA权限，本文介绍的全部操作由sysdba来执行。</p><p>在运行数据库实例的操作系统的shell里执行以下命令就可以获得sysdba权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312165652366.png" alt="在这里插入图片描述" /></p><h1 id="一-数据库的启动"><a class="markdownIt-Anchor" href="#一-数据库的启动"></a> 一、数据库的启动</h1><p>Oracle数据库实例的启动要经历三个阶段。</p><p>1）nomount：启动实例（Start an instance）。</p><p>2）mount：装载数据库（Mount the database）。</p><p>3）open：打开数据库（Open the database）。</p><h2 id="1-启动实例"><a class="markdownIt-Anchor" href="#1-启动实例"></a> 1、启动实例</h2><p>执行以下命令启动数据库实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup nomount;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031216573183.png" alt="在这里插入图片描述" /></p><p>nomount状态启动Oracle的可执行程序，初始化数据库实例，包括以三步骤：</p><p>1）读取参数文件pfile或spfile，pfile是文本文件，spfile是二进制文件，它们的内容相同，只是格式不一样，oracle推荐使用spfile。spfile存放在$ORACLE_HOME/dbs目录下，默认名字是spfile$ORACLE_SID.ora，如/oracle/home/dbs/spfilesnorcl11g.ora。</p><p>2）根据参数文件中的参数，分配系统全局区SGA；</p><p>3）启动后台进程，包括数据库写入进程DBWR，日志写入进程LGWR，检查点进程CKPT，系统监控进程SMON，进程监控进程PMON，归档进程ARCH等。</p><p>SGA和后台进程组合起来组成实例（Oracle Instance）。</p><p>执行以下SQL查询实例的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select instance_name,status from V$INSTANCE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170018457.png" alt="在这里插入图片描述" /></p><h2 id="2-装载数据库"><a class="markdownIt-Anchor" href="#2-装载数据库"></a> 2、装载数据库</h2><p>执行以下命令装载数据库：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database mount;</span><br></pre></td></tr></table></figure><p>装载数据库时打开控制文件（Control File）从控制文件中获得数据文件（Data File）和联机日志文件（Redo Log File）信息把实例和数据库关联起来。</p><p>mount状态一般用于DBA对数据库进行维护（如数据恢复），对于普通用户，数据库还是不可访问。</p><p>执行以下SQL查询实例和数据库的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select instance_name,status from V$INSTANCE;</span><br><span class="line">select db_unique_name,open_mode from V$DATABASE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170100139.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200312170110767.png" alt="在这里插入图片描述" /></p><h2 id="3-打开数据库"><a class="markdownIt-Anchor" href="#3-打开数据库"></a> 3、打开数据库</h2><p>执行以下命令打开数据库：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database open;</span><br></pre></td></tr></table></figure><p>Oracle打开数据文件(Data Files)和联机日志文件(Redo Log File)。这时候数据库可以使用，普通用户可以登录数据库，对数据库进行操作。</p><p>执行以下SQL查询实例和数据库的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select instance_name,status from V$INSTANCE;</span><br><span class="line">select db_unique_name,open_mode from V$DATABASE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170148174.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200312172710257.png" alt="在这里插入图片描述" /></p><h2 id="4-直接启动数据库"><a class="markdownIt-Anchor" href="#4-直接启动数据库"></a> 4、直接启动数据库</h2><p>执行startup open命令直接启动数据库，相当于以上三个步骤，open可以省略不写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup open;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170218495.png" alt="在这里插入图片描述" /></p><h1 id="二-数据库状态切换"><a class="markdownIt-Anchor" href="#二-数据库状态切换"></a> 二、数据库状态切换</h1><h2 id="1-从open切换到mounted状态"><a class="markdownIt-Anchor" href="#1-从open切换到mounted状态"></a> 1、从open切换到mounted状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database close;</span><br></pre></td></tr></table></figure><h2 id="2-从mounted切换到started状态"><a class="markdownIt-Anchor" href="#2-从mounted切换到started状态"></a> 2、从mounted切换到started状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database dismount;</span><br></pre></td></tr></table></figure><h2 id="3-把数据库启动到限制模式restrict"><a class="markdownIt-Anchor" href="#3-把数据库启动到限制模式restrict"></a> 3、把数据库启动到限制模式（Restrict）</h2><p>在限制模式下，只有create session和restricted session权限的用户可以访问数据库。</p><p>1）如果数据库是关闭的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup restrict;</span><br></pre></td></tr></table></figure><p>2）如果数据库是开启的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system enable restricted session;</span><br></pre></td></tr></table></figure><h2 id="4-以只读模式read-only打开数据库"><a class="markdownIt-Anchor" href="#4-以只读模式read-only打开数据库"></a> 4、以只读模式（Read Only）打开数据库</h2><p>1）如果数据库是关闭的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup open read only;</span><br></pre></td></tr></table></figure><p>2）如果数据库是mount状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database open read only;</span><br></pre></td></tr></table></figure><p>在直读模式下，数据文件和日志文件都禁止写操作，整个数据库是只读的。但是允许数据库恢复（Database Recovery）及其他不会产生事务的操作。</p><h2 id="5-把数据库启动到恢复模式recover"><a class="markdownIt-Anchor" href="#5-把数据库启动到恢复模式recover"></a> 5、把数据库启动到恢复模式（Recover）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup open recover;</span><br></pre></td></tr></table></figure><h1 id="三-关闭数据库"><a class="markdownIt-Anchor" href="#三-关闭数据库"></a> 三、关闭数据库</h1><h2 id="1-数据库关闭的过程"><a class="markdownIt-Anchor" href="#1-数据库关闭的过程"></a> 1、数据库关闭的过程</h2><p>Oracle的关闭也要经历<strong>关闭数据库</strong>、<strong>卸载数据库</strong>和<strong>关闭实例</strong>三个阶段。</p><p>1）关闭数据库（Close the database）</p><p>Oracle首先把SGA中的数据写到数据文件和日志文件中，然后再关闭数据文件和联机日志文件。</p><p>2）卸载数据库（Dismount the database）</p><p>数据库关闭完成之后，Oracle将分离数据库和实例之间的联系，这个阶段叫做“卸载数据库”或者叫“Dismount数据库”。</p><p>3）关闭实例（Shut down the instance）</p><p>这个阶段Oracle将从释放SGA占用的内存，终止全部的后台服务进程。</p><h2 id="2-shutdown-immediate"><a class="markdownIt-Anchor" href="#2-shutdown-immediate"></a> 2、shutdown immediate</h2><p><img src="https://img-blog.csdnimg.cn/20200312170947376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>使用immediate方式关闭数据库时：</p><p>1）新的用户不能登录数据库；</p><p>2）未提交的事务将会被回滚；</p><p>3）Oracle不会等待所有的用户（连接）退出数据库。</p><p>特点：</p><p>1）这种关闭方式可能会造成数据丢失；</p><p>2）数据库重启时不需要实例恢复。</p><p>推荐使用immediate方式关闭数据库。</p><h2 id="3-shutdown-transactional"><a class="markdownIt-Anchor" href="#3-shutdown-transactional"></a> 3、shutdown transactional</h2><p>以transactional方式关闭数据库时：</p><p>1）不允许新的用户登录数据库；</p><p>2）不允许建立新的事务；</p><p>3）所有的事务完成以后才关闭数据库；</p><p>4）一个用户（会话）执行完当前的事务后将被强行断开与数据库的连接。</p><p>特点：</p><p>1）这种关闭方式不会造成数据丢失；</p><p>2）数据库重启时不需要实例恢复；</p><p>3）这是最安全的关闭方式。</p><h2 id="4-shutdown-abort"><a class="markdownIt-Anchor" href="#4-shutdown-abort"></a> 4、shutdown abort</h2><p>以abort方式关闭数据库时：</p><p>1）不允许建立新的连接和新的事务；</p><p>2）客户端的SQL语句立刻终止；</p><p>3）未提交的事务不被回滚；</p><p>4）Oracle立刻终止所有连接（会话）。</p><p>特点：</p><p>1）只有数据库出现问题时候，才使用这种方式关闭数据库；</p><p>2）这是一种最不安全的关闭方式，数据库重启时需要实例恢复。</p><h2 id="5-shutdown-normal"><a class="markdownIt-Anchor" href="#5-shutdown-normal"></a> 5、shutdown normal</h2><p>使用normal方式关闭数据库时：</p><p>（1）允许新的用户注登录数据库；</p><p>（2）要等所有的用户自动退出Oracle以后，Oracle才关闭数据库。如果有未退出的用户，那么Oracle就一直等待，直到这个用户退出才关闭数据库。</p><p>normal是最慢的数据库关闭方式，不推荐。</p><h2 id="6-重启数据库reset"><a class="markdownIt-Anchor" href="#6-重启数据库reset"></a> 6、重启数据库（Reset）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup force;</span><br></pre></td></tr></table></figure><p>相当于shutdown abort和startup。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle表空间和数据文件</title>
      <link href="/post/1d4455be.html"/>
      <url>/post/1d4455be.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-表空间的概念"><a class="markdownIt-Anchor" href="#一-表空间的概念"></a> 一、表空间的概念</h1><p>Oracle数据库的数据存放在表空间中，表空间是一个逻辑的概念，它是由数据文件组成，表空间大小由数据文件的数量和大小决定。</p><p>表空间有三种：Permanent Tablespaces（永久表空间）、Temporary Tablespaces（临时表空间）、Undo Tablespaces（回滚表空间），Oracle在创建数据库实例的时候，默认会创建三个永久表空间（SYSTEM、SYSAUX、USERS），一个临时表空间（TEMP），一个回滚表空间（UNDOTBS1）。</p><h2 id="1-system表空间"><a class="markdownIt-Anchor" href="#1-system表空间"></a> 1、SYSTEM表空间</h2><p>SYSTEM表空间主要用于存放Oracle数据库内部的数据字典，它是Oracle数据库最重要的表空间，在创建数据库实例时被最先创建，包含了数据库的元数据，对于数据库来说生死攸关。</p><h2 id="2-sysaux表空间"><a class="markdownIt-Anchor" href="#2-sysaux表空间"></a> 2、SYSAUX表空间</h2><p>SYSAUX表空间是SYSTEM表空间的辅助表空间，主要用于存储数据字典以外的其他数据对象，它在一定程度上降低了SYSTEM表空间的负荷。</p><h2 id="3-undotbs1表空间"><a class="markdownIt-Anchor" href="#3-undotbs1表空间"></a> 3、UNDOTBS1表空间</h2><p>UNDO是回滚表空间，主要有四方面的用途，分别是：事物回滚、数据库恢复、读一致性、闪回查询。</p><p>1）事物回滚：当事物执行失败或用户执行回滚操作（rollback）时，Oracle会利用保存在回退段中的信息将数据恢复到原来的值。</p><p>2）数据库恢复：当数据库实例出现了意外，在重启恢复时，Oracle先利用重做日志文件的信息对数据库进行恢复，再利用回滚段中的信息回滚未提交的事务。</p><p>3）读一致性：当一个用户对数据进行修改时，会预先将其原始值保存到回退段中，这时，如果有其它用户访问该数据，则访问回退段中的信息，使当前用户未提交的修改其他用户无法看到，保证了数据的一致性。</p><p>4）闪回查询：通过保留在回退段中的信息，用户可以查询某个数据在过去某个时刻的状态。</p><h2 id="4-temp表空间"><a class="markdownIt-Anchor" href="#4-temp表空间"></a> 4、TEMP表空间</h2><p>临时表空间用来管理数据库排序以及用于存储临时表和索引、中间结果等临时对象。当Oracle的内存不够时，会把数据放在临时表空间中，当操作完成后，系统会自动清理临时表空间中的临时对象，自动释放空间。这里的释放只是标记为空闲、可以重用，占用的磁盘空间并没有真正释放。这也是临时表空间有时会不断增大却不见减少的原因。</p><h2 id="5-users表空间"><a class="markdownIt-Anchor" href="#5-users表空间"></a> 5、USERS表空间</h2><p>USERS表空间用于存放普通用户的表和索引，一般情况下，它是用户的缺省表空间。</p><h2 id="6-查看表空间"><a class="markdownIt-Anchor" href="#6-查看表空间"></a> 6、查看表空间</h2><p>用DBA登录数据库，执行以下SQL可以查看数据库全部的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from v$tablespace;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312154751355.png" alt="在这里插入图片描述" /></p><h1 id="二-管理表空间"><a class="markdownIt-Anchor" href="#二-管理表空间"></a> 二、管理表空间</h1><p>企业级的Oracle数据系统的存储一般是采用ASM（自动存储管理），ASM是Oracle 10g R2中为了简化Oracle数据库的管理而推出来的一项新功能，这是Oracle自己提供的卷管理器，替代了操作系统所提供的LVM，它不仅支持单实例，同时对RAC的支持也是非常好。</p><p>管理表空间的任务一般是由DBA来执行，涉及的知识比较多，本文介绍用文件系统作为Oracle的存储空间，合适程序员学习。不管是ASM还是文件系统，逻辑上是一样的，作为一个程序员，并不一定要掌握Oralce存储系统的管理和配置，理解它的原理和使用就可以了。</p><h2 id="1-创建表空间"><a class="markdownIt-Anchor" href="#1-创建表空间"></a> 1、创建表空间</h2><p>创建表空间是使用create tablespace命令完成的，建立表空间是特权用户或是DBA来执行的，如果用其它用户来创建表空间，则用户必须要具有create tablespace的系统权限。create tablespace命令的选项比较多，本文只介绍常用的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace 表空间名 datafile <span class="string">&#x27;数据文件名&#x27;</span> size 大小;</span><br></pre></td></tr></table></figure><p><strong>在创建数据库实列后，为了方便管理，最好再创建一个专用于存放数据表空间和一个专用于存放索引表空间。</strong></p><p>示例：</p><p>1）创建数据表空间DATA，同时创建数据文件/oracle/base/oradata/snorcl11g/data01.dbf，数据文件的大小是128M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace DATA datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data01.dbf&#x27;</span> size <span class="number">128</span>M;</span><br></pre></td></tr></table></figure><p>2）创建索引表空间INDEXS，同时创建数据文件/oracle/base/oradata/snorcl11g/indexs01.dbf，数据文件的大小是128M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace INDEXS datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/indexs01.dbf&#x27;</span> size <span class="number">128</span>M;</span><br></pre></td></tr></table></figure><p>创建表空间时，可以指定多个数据文件，但致少要指定一个数据文件，数据文件由Oracle自动创建，不需要事先在磁盘上手工的创建文件。</p><p><img src="https://img-blog.csdnimg.cn/20200312154948579.png" alt="在这里插入图片描述" /></p><h2 id="2-使用表空间"><a class="markdownIt-Anchor" href="#2-使用表空间"></a> 2、使用表空间</h2><p>1）创建数据库用户时，指定用户的对象缺省使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user girl identified by pwdgirl <span class="keyword">default</span> tablespace DATA;</span><br></pre></td></tr></table></figure><p>2）创建表时，指定表使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null    -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> tablespace DATA</span>;</span><br></pre></td></tr></table></figure><p>3）创建主键时，指定主键使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span> <span class="keyword">using</span> index tablespace INDEXS</span>;</span><br></pre></td></tr></table></figure><p>4）创建索引时，指定索引使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create index IDX_GIRL_1 on <span class="title">T_GIRL</span><span class="params">(name)</span> tablespace INDEXS</span>;</span><br></pre></td></tr></table></figure><h2 id="3-删除表空间"><a class="markdownIt-Anchor" href="#3-删除表空间"></a> 3、删除表空间</h2><p>一般情况下，由特权用户或是DBA来操作，如果是其它用户操作，那么要求用户具有drop<br />tablespace系统权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop tablespace 表空间名 including contents <span class="keyword">and</span> datafiles;</span><br></pre></td></tr></table></figure><p>Including contents表示删除表空间，同时删除该表空间全部的数据库对象，而datafiles表示将数据库文件也删除。</p><p>示例：</p><p>删除DATA和INDEXS表空间，和该表空间全部的数据库对象以及数据文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop tablespace DATA including contents <span class="keyword">and</span> datafiles;</span><br><span class="line">drop tablespace INDEXS including contents <span class="keyword">and</span> datafiles;</span><br></pre></td></tr></table></figure><h2 id="4-向表空间中添加数据文件"><a class="markdownIt-Anchor" href="#4-向表空间中添加数据文件"></a> 4、向表空间中添加数据文件</h2><p>表空间的大小是由数据文件的数据和大小决定的，向表空间中添加数据文件，扩展表空间的容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter tablesapce 表空间名 add datafile <span class="string">&#x27;数据文件名&#x27;</span> size 大小</span><br><span class="line">      [reuse]</span><br><span class="line">      [autoextend [on/off] next 大小]</span><br><span class="line">      [maxsize [unlimited|大小]];</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><code>size 大小</code>：数据文件的初始大小，单位：K|M|G|T|P|E。</p><p><code>[reuse]</code>：如果操作系统上已经存在数据文件，加reuse参数表示覆盖它，否则会提示错误，建议一般不要启用reuse选项，容易产生误操作，如果磁盘上已存在同名的数据文件，可以先手工的删除它。</p><p><code>[autoextend [on/off] next 大小]</code>：数据文件是否自动扩展，如果为on，next参数指定每次扩展的大小。</p><p><code>[maxsize [unlimited|大小]]</code>：如果数据文件可以自动扩展，maxsize参数可以限制文件的最大值，unlimited表示无限制。</p><p>示例：</p><p>1）向DATA表空间添加数据文件，大小100M，可重用，可自动扩展，每次扩展10M，最大200M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA add datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> </span><br><span class="line">      size <span class="number">100</span>M reuse autoextend on next <span class="number">10</span>M maxsize <span class="number">200</span>M;</span><br></pre></td></tr></table></figure><p>2）向DATA表空间添加数据文件，大小100M，可重用，可自动扩展，每次扩展10M，无最大限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA add datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data03.dbf&#x27;</span> </span><br><span class="line">      size <span class="number">100</span>M reuse autoextend on next <span class="number">10</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure><p>3）向DATA表空间添加数据文件，大小200M，不可重用，不能自动扩展。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA add datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data04.dbf&#x27;</span> </span><br><span class="line">      size <span class="number">100</span>M autoextend off;</span><br></pre></td></tr></table></figure><h2 id="6-修改表空间的状态"><a class="markdownIt-Anchor" href="#6-修改表空间的状态"></a> 6、修改表空间的状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace 表空间名 [online] [offline] [read only|write];</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）把DATA表空间的状态改为offline（离线）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA offline;</span><br></pre></td></tr></table></figure><p>2）把DATA表空间的状态改为read onley（只读）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA read only;</span><br></pre></td></tr></table></figure><p>3）把DATA表空间的状态改为read write（可读写）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA read write;</span><br></pre></td></tr></table></figure><p>4）把DATA表空间的状态改为offline（在线）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA online;</span><br></pre></td></tr></table></figure><h2 id="7-修改数据文件状态"><a class="markdownIt-Anchor" href="#7-修改数据文件状态"></a> 7、修改数据文件状态</h2><p>修改数据文件的命令是alter database datafile。</p><p>示例：</p><p>1）先把表空间offline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA offline;</span><br></pre></td></tr></table></figure><p>2）把数据文件的状态改为offline（离线），必须先把表空间offline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> offline;</span><br></pre></td></tr></table></figure><p>3）把数据文件的状态改为online（在线）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> online;</span><br></pre></td></tr></table></figure><p>4）删除数据文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> offline drop;</span><br></pre></td></tr></table></figure><p>5）再把表空间online。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA online;</span><br></pre></td></tr></table></figure><h2 id="8-修改数据文件大小"><a class="markdownIt-Anchor" href="#8-修改数据文件大小"></a> 8、修改数据文件大小</h2><p>修改数据文件的大小可以在线操作，关联的表空间无需offline，对业务运行也没有影响。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;数据文件名&#x27;</span></span><br><span class="line">      [ [resize 大小| [autoextend [on/off] next 大小] [maxsize [unlimited|大小]] ];</span><br></pre></td></tr></table></figure><p>1）把数据文件改为200M，前提是该数据文件已使用空间小于200M，否则提示错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> resize <span class="number">200</span>M;</span><br></pre></td></tr></table></figure><p>2）禁用数据文件自动扩展的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> autoextend off;</span><br></pre></td></tr></table></figure><p>3）启用数据文件自动扩展的属性，无最大限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> </span><br><span class="line">      autoextend on next <span class="number">10</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure><h2 id="9-移动数据文件"><a class="markdownIt-Anchor" href="#9-移动数据文件"></a> 9、移动数据文件</h2><p>移动数据文件非常重要，例如存放数据文件的磁盘空间不足，增加了新的磁盘空间后，需要把数据文件迁移到新的磁盘。</p><p>移动数据文件有两种方法：alter tablespace和alter database。</p><p>示例：</p><p>1）把表空间offline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA offline;</span><br></pre></td></tr></table></figure><p>2）执行操作系统命令，迁移数据文件，cp和mv都可以，注意，cp和mv是操作系统的命令，不是sqlplus中Oracle的命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv data01.dbf data03.dbf</span><br><span class="line">mv data02.dbf data04.dbf</span><br></pre></td></tr></table></figure><p>3）执行alter tablespace或alter database修改数据库文件名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA rename datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data01.dbf&#x27;</span> to <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data03.dbf&#x27;</span>;</span><br><span class="line">alter database rename file <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> to <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data04.dbf&#x27;</span>;</span><br></pre></td></tr></table></figure><p>4）把表空间online。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA online;</span><br></pre></td></tr></table></figure><h1 id="三-查看表空间和数据文件"><a class="markdownIt-Anchor" href="#三-查看表空间和数据文件"></a> 三、查看表空间和数据文件</h1><h2 id="1-查看当前用户的缺省表空间"><a class="markdownIt-Anchor" href="#1-查看当前用户的缺省表空间"></a> 1、查看当前用户的缺省表空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username,default_tablespace from user_users;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312162523541.png" alt="在这里插入图片描述" /></p><h2 id="2-查看数据文件"><a class="markdownIt-Anchor" href="#2-查看数据文件"></a> 2、查看数据文件</h2><p>数据文件存放在数据字典DBA_DATA_FILES中，用DBA权限执行以下SQL查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select file_name,file_id,tablespace_name,bytes,status,autoextensible,</span><br><span class="line">       maxbytes,user_bytes,online_status</span><br><span class="line">  from DBA_DATA_FILES order by tablespace_name,file_name;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312162903267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-查看表空间使用情况"><a class="markdownIt-Anchor" href="#3-查看表空间使用情况"></a> 3、查看表空间使用情况</h2><p>从数据字典DBA_FREE_SPACE和DBA_DATA_FILES中可以查询表空间使用情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select a.tablespace_name <span class="string">&quot;表空间名&quot;</span>,total <span class="string">&quot;表空间大小&quot;</span>,</span><br><span class="line">       (total - free) <span class="string">&quot;已使用大小&quot;</span>,free <span class="string">&quot;表空间剩余大小&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>(total/(<span class="number">1024</span>*<span class="number">1024</span>)) <span class="string">&quot;表空间大小(M)&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>((total-free)/(<span class="number">1024</span>*<span class="number">1024</span>)) <span class="string">&quot;已使用大小(M)&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>(free/(<span class="number">1024</span>*<span class="number">1024</span>)) <span class="string">&quot;表空间剩余大小(M)&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>((total-free)/total,<span class="number">4</span>)*<span class="number">100</span> <span class="string">&quot;使用率%&quot;</span></span><br><span class="line">  <span class="built_in">from</span></span><br><span class="line">(select tablespace_name,<span class="built_in">sum</span>(bytes) free from DBA_FREE_SPACE group by tablespace_name) a,</span><br><span class="line">(select tablespace_name,<span class="built_in">sum</span>(bytes) total from DBA_DATA_FILES group by tablespace_name) b</span><br><span class="line"> where a.tablespace_name = b.tablespace_name;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312162946650.png" alt="在这里插入图片描述" /></p><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>表空间和数据文件的管理，看上去就是几个命令，但是在实际应用中并不会这么简单。</p><p>如果让您在一片空地上设计规划一座新的城市，想怎么设计就怎么设计，想怎么修改就怎么修改，但是，如果城市一旦建好，想改就没那么容易了，要考虑拆迁问题，补偿问题，还有对交通影响，对人们日常生活的影响等等。</p><p>表空间和数据文件的管理也是一样的道理，如果您新建的表空间和数据文件还没有被使用，您想怎么改就怎么改，一旦投入了业务运行，需要考虑的问题就多了。</p><p>所以，表空间和数据文件最好是一开始就规划和设计好。如果要修改业务运行中的表空间和数据文件（扩展数据文件除外），风险非常大，建议让专业的DBA来操作，或者在操作之前做好业务数据的备份。如果操作不慎造成了数据的丢失或影响业务系统的运行，您会懊悔不已。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle用户和权限管理</title>
      <link href="/post/6724a9ad.html"/>
      <url>/post/6724a9ad.html</url>
      
        <content type="html"><![CDATA[<p>当创建一个新数据库实例时，Oracle会创建sys、system和scott数据库用户。sys和system是管理员用户，它们的密码在创建数据库时指定。scott是示范用户（用于学习），里面包括了一些测试数据（DEPT、EMP、BONUS和SALGRADE表），scott用户缺省是锁定状态。</p><h1 id="一-数据库管理员"><a class="markdownIt-Anchor" href="#一-数据库管理员"></a> 一、数据库管理员</h1><p>数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统的相关工作人员的统称，属于运维工程师的一个分支，主要负责数据库的设计、部署、运维和管理，侧重于运维管理。</p><p>DBA的核心目标是保证数据库系统的稳定性、安全性、完整性和高性能，保证数据库服务7*24小时的稳定高效运转。</p><p>数据库实例创建后，<strong>在数据库服务器上</strong>，用 <code>sqlplus / as sysdba</code> 可以以DBA身份登录数据库，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200312151958968.png" alt="在这里插入图片描述" /></p><h1 id="二-用户管理"><a class="markdownIt-Anchor" href="#二-用户管理"></a> 二、用户管理</h1><h2 id="1-创建用户"><a class="markdownIt-Anchor" href="#1-创建用户"></a> 1、创建用户</h2><p>创建用户的命令是 <code>create user</code>，它的选项非常多，在这里我介绍一些常用的选项。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create user 用户名 identified by 密码</span><br><span class="line">       [<span class="keyword">default</span> tablespace 表空间名]</span><br><span class="line">       [temporary tablespace 表空间名]</span><br><span class="line">       [quota 大小 on 表空间名]</span><br><span class="line">       [profile 用户配置文件];</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><code>create user 用户名 identified by 密码</code>：指定登录数据库的用户名和密码。</p><p><code>[default tablespace 表空间名]</code>：指定用户的永久表空间，该用户全部的数据库对象（表、索引）将存放在该表空间中。</p><p><code>[temporary tablespace 表空间名]</code>：指定用户的临时表空间，临时表空间主要用于排序、运算、管理索引、存放临时数据等，当任务完成之后系统会自动清理。</p><p><code>[quota 大小 on 表空间名]</code>：表空间配额，用户使用表空间的大小，单位有[K|M|G|T|P|E]，缺省是unlimited，无限制。</p><p><code>[profile 用户配置文件]</code>：用户的配置文件，它是密码限制，资源限制的命名集合，利用profile<br />可以对数据库用户进行基本的资源管理，密码管理，缺省是default profile，无限制。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create user girl</span><br><span class="line">  identified by girlpwd</span><br><span class="line">  <span class="keyword">default</span> tablespace users</span><br><span class="line">  temporary tablespace temp</span><br><span class="line">  quota <span class="number">20</span>M on users;</span><br></pre></td></tr></table></figure><p>创建一个用户名为girl的新用户，密码是pwdgirl，缺省表空间是users（可使用20M的空间），临时表空间是temp。</p><p>注意，创建用户时，如果不指定default tablespace/ temporary tablespace选项，则使用系统缺省的永久/临时表空间，用以下SQL可以查看系统缺省的永久/临时表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select property_value from DATABASE_PROPERTIES where </span></span><br><span class="line"><span class="function">property_name <span class="title">in</span> <span class="params">(<span class="string">&#x27;DEFAULT_PERMANENT_TABLESPACE&#x27;</span>,<span class="string">&#x27;DEFAULT_TEMP_TABLESPACE&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312152433247.png" alt="在这里插入图片描述" /></p><h2 id="2-修改用户的密码"><a class="markdownIt-Anchor" href="#2-修改用户的密码"></a> 2、修改用户的密码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 identified by 新密码;</span><br></pre></td></tr></table></figure><p>普通用户只能修改自已的密码，DBA可以修改其它用户的密码。</p><h2 id="3-锁定解锁用户"><a class="markdownIt-Anchor" href="#3-锁定解锁用户"></a> 3、锁定/解锁用户</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 account lock;</span><br><span class="line">alter user 用户名 account unlock;</span><br></pre></td></tr></table></figure><p>锁定/解锁用户需要DBA权限。</p><h2 id="4-修改用户表空间配额"><a class="markdownIt-Anchor" href="#4-修改用户表空间配额"></a> 4、修改用户表空间配额</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 quota 大小 on 表空间;</span><br></pre></td></tr></table></figure><p>修改用户表空间配额需要DBA权限。</p><h2 id="5-删除用户"><a class="markdownIt-Anchor" href="#5-删除用户"></a> 5、删除用户</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user 用户名 [cascade];</span><br></pre></td></tr></table></figure><p>drop user 只有在用户下没有任何数据库对象的时候才能删除用户，否则会提示错误。</p><p>采用cascade选项删除用户以及用户下全部的数据库对象，包括表、视图、函数、同义词、过程等。</p><p>删除用户需要DBA权限。</p><h1 id="三-权限管理"><a class="markdownIt-Anchor" href="#三-权限管理"></a> 三、权限管理</h1><p>权限是指用户执行特定命令或操作数据库对象的权利。Oracle的用户权限分系统权限和对象权限。</p><h2 id="1-系统权限"><a class="markdownIt-Anchor" href="#1-系统权限"></a> 1、系统权限</h2><p>系统权限针对的是系统安全性，执行数据库操作，如登录、创建表、创建函数等，通过查询SYSTEM_PRIVILEGE_MAP数据字典可以看到Oracle的两百多种系统权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from SYSTEM_PRIVILEGE_MAP;</span><br></pre></td></tr></table></figure><p>以下是几种常用的系统权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create session       创建会话。</span><br><span class="line">create/drop user     创建/删除用户。</span><br><span class="line">create/drop sequence 创建/删除序列。</span><br><span class="line">create/drop synonym  创建/删除同名对象。</span><br><span class="line">create/drop table    创建/删除表。</span><br><span class="line">create/drop view     创建/删除视图。</span><br></pre></td></tr></table></figure><h2 id="2-对象权限"><a class="markdownIt-Anchor" href="#2-对象权限"></a> 2、对象权限</h2><p>对象权限针对的是数据安全性，对某一特定对象（如表，视图、序列、存储过程等）执行的特定操作，对象的权限分类如下：。</p><p>1）select权限</p><p>对表而言，允许对表执行select语句；对序列而言，允许对序列获取下一个值（nextval）和当前值（currnvl）。</p><p>2）insert权限</p><p>允许向表和视图中插入记录。</p><p>3）update权限</p><p>允许在表或视图中执行update语句，update权限必须随同select权限授予，否则被授权用户不能够选择行。</p><p>4）delete权限</p><p>允许在表或视图中执行delete语句，delete权限必须随同select权限授予，否则被授权用户不能够选择行。</p><p>5）alter权限</p><p>对表而言，允许对表执行alter table语句；对序列而言，允许对序列alter sequence语句。</p><p>6）execute权限</p><p>执行存储过程、函数和包的权限。</p><p>7）index权限</p><p>允许在表上创建索引。</p><p>8）reference权限</p><p>允许在表上创建完整性约束，如外键。</p><p>9）all</p><p>对象的全部权限（上面列出的全部权限）。</p><p>以下是Oracle数据库对象与权限的对照表。</p><table><thead><tr><th>对象权限</th><th>表</th><th>视图</th><th>序列</th><th>过程（函数和包）</th><th>备注</th></tr></thead><tbody><tr><td>select</td><td>是</td><td>是</td><td>是</td><td></td><td>常用。</td></tr><tr><td>insert</td><td>是</td><td>是</td><td></td><td></td><td>常用。</td></tr><tr><td>update</td><td>是</td><td>是</td><td></td><td></td><td>常用。</td></tr><tr><td>delete</td><td>是</td><td>是</td><td></td><td></td><td>常用。</td></tr><tr><td>alter</td><td>是</td><td></td><td>是</td><td></td><td>不常用。</td></tr><tr><td>execute</td><td></td><td></td><td></td><td>是</td><td>不常用。</td></tr><tr><td>index</td><td>是</td><td></td><td></td><td></td><td>不常用。</td></tr><tr><td>references</td><td>是</td><td></td><td></td><td></td><td>不常用。</td></tr></tbody></table><h2 id="3-角色"><a class="markdownIt-Anchor" href="#3-角色"></a> 3、角色</h2><p>由于Oracle提供的权限非常之多，日常操作时我们不可能将所需权限一一赋予用户，此时引进角色概念。角色是一组相关权限的命名集合，使用角色最主要的目的是简化权限管理。将一组权限打包到角色中，将角色赋予用户就是把角色下得全部权限都赋给了用户，简化了赋权操作。</p><p>Oracle提供三种标准的三种角色：</p><p>1）connect角色</p><p>connect是最基本的用户权限，拥有connect权限的用户只可以登录Oracle（仅具有创建SESSION的权限），不可以创建实体，不可以创建数据库结构。</p><p>2）resource角色</p><p>拥有resource权限的用户可以创建数据库对象，和对本用户的数据库对象拥有全部的操作权限。</p><p>3）DBA角色</p><p>DBA角色，拥有全部特权，是系统最高权限。</p><h2 id="4-授于收回权限"><a class="markdownIt-Anchor" href="#4-授于收回权限"></a> 4、授于/收回权限</h2><p>Oracle采用grant命令授于权限，revoke命令收回权限。</p><p>grant命令非常复杂，在实际应用中远远没有那么复杂，所以本文只介绍grant的常用方法。</p><p><strong>1）将对象权限授于用户和角色，revoke收回。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant 对象权限列表 on 对象名 to &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br><span class="line">revoke对象权限列表 on 对象名 from &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的select和insert权限授于girl和scott用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select,insert on scott.T_GIRL to girl,scott;</span><br><span class="line">revoke select,insert on scott.T_GIRL from girl,scott;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的全部权限授于girl和scott用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all on scott.T_GIRL to girl,scott;</span><br><span class="line">revoke all on scott.T_GIRL from girl,scott;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的全部权限授于全部用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on scott.T_GIRL to <span class="keyword">public</span>;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的全部权限授于resource角色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on scott.T_GIRL to resource;</span><br></pre></td></tr></table></figure><p><strong>2）将系统权限和角色权限授于用户，revoke收回。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant &#123; 系统权限 | 角色 &#125;, …… to &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br><span class="line">revoke &#123; 系统权限 | 角色 &#125;, …… from &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br></pre></td></tr></table></figure><p>一般情况下，在新建数据库用户后，都会习惯性的给用户授权connect角色和resource角色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant connect,resource to 用户名;</span><br></pre></td></tr></table></figure><p>将select any table权限授于全部用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select any table to <span class="keyword">public</span>;</span><br><span class="line">revoke select any table from <span class="keyword">public</span>;</span><br></pre></td></tr></table></figure><p>将select any table权限授于connect角色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select any table to connect;</span><br></pre></td></tr></table></figure><p>将select any table和insert any table权限授于girl和scott用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select any table,insert any table to girl,scott;</span><br><span class="line">revoke select any table,insert any table from girl,scott;</span><br></pre></td></tr></table></figure><p>将connect、resource权限授于girl用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant connect,resource to girl;</span><br></pre></td></tr></table></figure><h2 id="5-查询权限"><a class="markdownIt-Anchor" href="#5-查询权限"></a> 5、查询权限</h2><p>从数据字典中可以查询当前用户拥有的权限和角色。</p><p>1）查询当前用户拥有的角色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from USER_ROLE_PRIVS;</span><br></pre></td></tr></table></figure><p>2）查询当前用户拥有的系统权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from USER_SYS_PRIVS;</span><br></pre></td></tr></table></figure><p>3）查询当前用户拥有的对象权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from USER_TAB_PRIVS;</span><br></pre></td></tr></table></figure><h2 id="6-注意事项"><a class="markdownIt-Anchor" href="#6-注意事项"></a> 6、注意事项</h2><p>在Oracle中没有其他数据库系统中的数据库的概念，对象都是创建在用户下。当前用户具有当前用户下全部对象的全部权限无论该对象是否是当前用户所创建。举个简单例子，创建了girl用户并授予connect和resource权限，然后管理员在girl用户下创建一张表，girl用户可以删除管理员在girl用户下创建的表。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle union多表查询</title>
      <link href="/post/2ca87e18.html"/>
      <url>/post/2ca87e18.html</url>
      
        <content type="html"><![CDATA[<p>union就是把两个结果集合并起来，被合并的两个结果集的字段数量要相同，数据类型要相似（兼容）。</p><p>union在合并两个结果集的时候，会自动去除重复的数据。</p><p>union all在合并两个结果集的时候，只是简单的将两个结果集中的数据进行连接，不会去除重复的数据。</p><p>我通过一些示例来向大家介绍子查询的常用方法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><h2 id="1-创建超女基本信息历史表t_girl_his"><a class="markdownIt-Anchor" href="#1-创建超女基本信息历史表t_girl_his"></a> 1、创建超女基本信息历史表（T_GIRL_HIS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL_HIS</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key (id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-创建超女基本信息表t_girl"><a class="markdownIt-Anchor" href="#2-创建超女基本信息表t_girl"></a> 2、创建超女基本信息表（T_GIRL）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-测试数据说明"><a class="markdownIt-Anchor" href="#3-测试数据说明"></a> 3、测试数据说明</h2><p><img src="https://img-blog.csdnimg.cn/20200312151059988.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200312151108676.png" alt="在这里插入图片描述" /></p><p>超女基本信息历史表（T_GIRL_HIS）中有4条记录，超女基本信息表（T_GIRL）中有3条记录，两个表中有相交的记录（‘0103’、‘0104’），在图中已用方框圈了出来。</p><h1 id="二-union示例"><a class="markdownIt-Anchor" href="#二-union示例"></a> 二、union示例</h1><h2 id="1-union去重复记录的联合"><a class="markdownIt-Anchor" href="#1-union去重复记录的联合"></a> 1、union（去重复记录的联合）</h2><p>union在合并两个结果集的时候，会自动去除重复的数据。T_GIRL和T_GIRL_HIS用union联合后的结果集有5条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,weight,height,birthday,memo from T_GIRL</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="title class_">select</span> id,name,yz,sc,weight,height,birthday,memo from T_GIRL_HIS;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312151147607.png" alt="在这里插入图片描述" /></p><h2 id="2-union-all不去复记录的重联合"><a class="markdownIt-Anchor" href="#2-union-all不去复记录的重联合"></a> 2、union all（不去复记录的重联合）</h2><p>union all在合并两个结果集的时候，只是简单的将两个结果集中的数据进行连接，不会去除重复的数据。T_GIRL和T_GIRL_HIS用union all联合后的结果集有7条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,weight,height,birthday,memo from T_GIRL</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">all</span> </span><br><span class="line">select id,name,yz,sc,weight,height,birthday,memo from T_GIRL_HIS;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312151232404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-从联合后的结果集中查询"><a class="markdownIt-Anchor" href="#3-从联合后的结果集中查询"></a> 3、从联合后的结果集中查询</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select distinct id,name,yz,sc,weight,height,birthday,<span class="function">memo <span class="title">from</span> </span></span><br><span class="line"><span class="function">  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    select id,name,yz,sc,weight,height,birthday,memo from T_GIRL</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">union</span> all</span></span></span><br><span class="line"><span class="params"><span class="function">    select id,name,yz,sc,weight,height,birthday,memo from T_GIRL_HIS</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span> order by id</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312151311625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>以上SQL的功能相当于union去重复记录的联合查询。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>union在进行结果集联合后会筛选掉重复的记录，所以在表联合后会对所产生的结果集进行排序，删除重复的记录后再返回结果。</p><p>而union all只是简单的将两个结果集合并后就返回，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据。</p><p>从效率上讲，union all要比union快很多，所以，如果可以确定合并的两个结果集中不会包含重复的数据，就应该使用union all。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle join多表查询</title>
      <link href="/post/98513a74.html"/>
      <url>/post/98513a74.html</url>
      
        <content type="html"><![CDATA[<p>join（连接）是一个查询，它将来自两个或多个表、视图的数据组合在一起。</p><p>我通过一些示例来向大家介绍join的常用方法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><h2 id="1-创建超女基本信息历史表t_girl_his"><a class="markdownIt-Anchor" href="#1-创建超女基本信息历史表t_girl_his"></a> 1、创建超女基本信息历史表（T_GIRL_HIS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL_HIS</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施_H&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅_H&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已_H&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐_H&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-创建超女基本信息表t_girl"><a class="markdownIt-Anchor" href="#2-创建超女基本信息表t_girl"></a> 2、创建超女基本信息表（T_GIRL）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-测试数据说明"><a class="markdownIt-Anchor" href="#3-测试数据说明"></a> 3、测试数据说明</h2><p><img src="https://img-blog.csdnimg.cn/20200312145445301.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200312145508158.png" alt="在这里插入图片描述" /></p><p>超女基本信息历史表（T_GIRL_HIS）中有4条记录，为了方便测试，每条记录的姓名后面加了_H的标志，超女基本信息表（T_GIRL）中有3条记录，姓名后没有加_H。</p><p>T_GIRL_HIS和T_GIRL通过id列关联起来，两个表中有相交的记录（‘0103’、‘0104’）。</p><h1 id="二-join示例"><a class="markdownIt-Anchor" href="#二-join示例"></a> 二、join示例</h1><p>连接（join）分为五种，内连接（inner join），左连接（left join），右连接（right join）、全连接（full join）和笛卡儿乘积（cross join），常用的是内连接和左连接，其它的极少使用。</p><h2 id="1-内连接inner-join"><a class="markdownIt-Anchor" href="#1-内连接inner-join"></a> 1、内连接（inner join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312145649634.png" alt="在这里插入图片描述" /></p><p>列出多个表或记录连接字段的匹配记录，即A表和B表的交集。</p><p>内连接有三种写法，这三种写法的效果相同。</p><p>1）标准的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL inner join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>2）省略inner，和第1）种写法相比，只是省略了一个单词而已，没什么特别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>3）还有一种写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS where T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312145817523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-左连接left-join"><a class="markdownIt-Anchor" href="#2-左连接left-join"></a> 2、左连接（left join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312145829487.png" alt="在这里插入图片描述" /><br />列出左边（A）表全部的，及右边（B）表符合条件的，不符合条件的以空值代替，记录总数为A表的记录数。</p><p>左连接有两种写法，这两种写法的效果相同。</p><p>1）标准的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL left join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>2）采用(+)，Oracle特有的写法，其它数据库不支持，注意(+)的位置，在右边字段后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS where T_GIRL.id=T_GIRL_HIS.<span class="built_in">id</span>(+);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312145920895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-右连接right-join"><a class="markdownIt-Anchor" href="#3-右连接right-join"></a> 3、右连接（right join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312145932583.png" alt="在这里插入图片描述" /></p><p>列出右边（B）表全部的，及左边（A）表符合条件的，不符合条件的以空值代替，记录总数为B表的记录数。</p><p>右连接有两种写法，这两种写法的效果相同。</p><p>1）标准的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL right join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>2）采用(+)，Oracle特有的写法，其它数据库不支持，注意(+)的位置，在左边字段后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS where T_GIRL.<span class="built_in">id</span>(+)=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031215003169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>右连接其实就是把左连接换个顺序书写，和左连接没有任何本质的区别。</p><h2 id="4-全连接full-join"><a class="markdownIt-Anchor" href="#4-全连接full-join"></a> 4、全连接（full join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312150045120.png" alt="在这里插入图片描述" /></p><p>列出右边（B）表全部的，及左边（A）表全部的，不符合条件的以空值代替，记录总数为A表与B表的记录数之和再减相交的记录数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL full join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312150113904.png" alt="在这里插入图片描述" /></p><h2 id="5-笛卡儿乘积cross-join"><a class="markdownIt-Anchor" href="#5-笛卡儿乘积cross-join"></a> 5、笛卡儿乘积（cross join）</h2><p>笛卡儿乘积连接，不加任何条件，记录总数为两个表相乘。</p><p>笛卡儿乘积连接有两种写法，这两种写法的效果相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL cross join T_GIRL_HIS;</span><br><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312150140541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>在实际开发中，内连接（inner join）和左连接（left join）经常使用，右连接（right join）和左连接本质上是同一回事，全连接（full join）和笛卡儿乘积（cross join）极少使用。</p><h2 id="1-尽可能简单化sql语句"><a class="markdownIt-Anchor" href="#1-尽可能简单化sql语句"></a> 1、尽可能简单化SQL语句</h2><p>SQL语句非常强大，强大到很容易把人搞晕，例如多表操作，有经验的程序员也很难应用自如。我极力反对过于复杂的SQL语句，复杂的SQL语句并不见得能体现程序员的水平，更像给自己和别人挖坑，合理的表结构设计不会让查询的SQL太复杂。</p><h2 id="2-子查询与join"><a class="markdownIt-Anchor" href="#2-子查询与join"></a> 2、子查询与join</h2><p>1）join和子查询都可以操作多个表，join和子查询的区别是：join可以合并多个表的数据，而子查询的数据只能来自一个表，子查询的结果集用于嵌入SQL中。</p><p>2）有的查询语句既可以使用子查询，也可以使用join。如果使用子查询，可以将一个复杂的查询分解为一系列的步骤，条理清晰；但使用join有执行速度快的优点。</p><p>3）用join能实现的功能用子查询都可以实现，但不是所有子查询都能用join替换，子查询比较灵活，方便，形式多样，而join更适合查询多表的数据。</p><p>4）如果表的数据量比较小，建议采用子查询，如果数据量比较大，建议采用join，但是具体情况具体分析，多尝试用PL/SQL Developer软件提供的explain plan分析SQL语句的性能。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle子查询</title>
      <link href="/post/5261b851.html"/>
      <url>/post/5261b851.html</url>
      
        <content type="html"><![CDATA[<p>如果SQL语句中包含了另一个select语句的时候，就称为子查询，子查询在select、insert、update或delete命令中都可以包含子查询，子查询还可以包含在另外一个子查询中，以便完成更为复杂的查询。</p><p>我通过一些示例来向大家介绍子查询的常用方法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><h2 id="1-颜值参数表"><a class="markdownIt-Anchor" href="#1-颜值参数表"></a> 1、颜值参数表</h2><table><thead><tr><th>编号（主键）</th><th>颜值描述</th><th>显示顺序</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>倾国倾城</td><td>1</td><td>第一等美女。</td></tr><tr><td>2</td><td>风华绝代</td><td>2</td><td>第二等美女。</td></tr><tr><td>3</td><td>迷倒众生</td><td>3</td><td>第三等美女。</td></tr><tr><td>4</td><td>漂亮</td><td>4</td><td>普通美女。</td></tr><tr><td>5</td><td>一般</td><td>5</td><td></td></tr><tr><td>6</td><td>猪扒</td><td>6</td><td></td></tr></tbody></table><h2 id="2-身材参数表"><a class="markdownIt-Anchor" href="#2-身材参数表"></a> 2、身材参数表</h2><table><thead><tr><th>编号（主键）</th><th>身材描述</th><th>显示顺序</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>火辣</td><td>1</td><td>前凸后翘。</td></tr><tr><td>2</td><td>丰满</td><td>2</td><td>体态丰腴。</td></tr><tr><td>3</td><td>苗条</td><td>3</td><td>风姿绰约。</td></tr><tr><td>4</td><td>一般</td><td>4</td><td></td></tr><tr><td>5</td><td>膘肥体壮</td><td>5</td><td>强悍无比。</td></tr></tbody></table><h2 id="3-超女基本信息表"><a class="markdownIt-Anchor" href="#3-超女基本信息表"></a> 3、超女基本信息表</h2><table><thead><tr><th>编号 （主键）</th><th>姓名</th><th>颜值代码 （外键）</th><th>身材代码 （外键）</th><th>身高</th><th>备注</th></tr></thead><tbody><tr><td>0101</td><td>西施</td><td>2</td><td>4</td><td>170</td><td>这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。</td></tr><tr><td>0102</td><td>貂禅</td><td>1</td><td>2</td><td>168</td><td>王允真不是男人，干不过董卓就把美人往火坑里推，无能。</td></tr><tr><td>0103</td><td>妲已</td><td>1</td><td></td><td>172</td><td>如果商真的因我而亡，您们男人做什么去了？</td></tr><tr><td>0104</td><td>芙蓉姐姐</td><td>6</td><td>5</td><td>166</td><td>如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。</td></tr><tr><td>0105</td><td>神密猫女</td><td></td><td>2</td><td>171</td><td>不知道是什么人，她脸上有一个%符号，很神密。</td></tr></tbody></table><h2 id="4-表之间的关系图"><a class="markdownIt-Anchor" href="#4-表之间的关系图"></a> 4、表之间的关系图</h2><p><img src="https://img-blog.csdnimg.cn/20200312143356608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-生成测试数据"><a class="markdownIt-Anchor" href="#5-生成测试数据"></a> 5、生成测试数据</h2><p>运行以下脚本，生成测试数据；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Table: 颜值参数表   */</span></span><br><span class="line"><span class="function">create table <span class="title">T_YZCODE</span>  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   yzid               number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   yzname             varchar2(<span class="number">10</span>)                    <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   orderby            number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   memo               varchar2(<span class="number">300</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_YZCODE add constraint PK_YZCODE primary <span class="title">key</span><span class="params">(yzid)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;倾国倾城&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;第一等美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">2</span>,<span class="string">&#x27;风华绝代&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;第二等美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">3</span>,<span class="string">&#x27;迷倒众生&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;第三等美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">4</span>,<span class="string">&#x27;漂亮&#x27;</span>,<span class="number">4</span>,<span class="string">&#x27;普通美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;一般&#x27;</span>,<span class="number">5</span>,null)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">6</span>,<span class="string">&#x27;猪扒&#x27;</span>,<span class="number">6</span>,null)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Table: 身材参数表   */</span></span><br><span class="line"><span class="function">create table <span class="title">T_SCCODE</span>  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   scid               number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   scname             varchar2(<span class="number">10</span>)                    <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   orderby            number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   memo               varchar2(<span class="number">300</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_SCCODE add constraint PK_SCCODE primary <span class="title">key</span><span class="params">(scid)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;火辣&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;前凸后翘。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">2</span>,<span class="string">&#x27;丰满&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;体态丰腴。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">3</span>,<span class="string">&#x27;苗条&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;风姿绰约。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">4</span>,<span class="string">&#x27;一般&#x27;</span>,<span class="number">4</span>,null)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;强悍无比。&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Table: 超女基本信息表   */</span></span><br><span class="line"><span class="function">create table <span class="title">T_GIRL</span>  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   id                 <span class="type">char</span>(<span class="number">4</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   name               varchar2(<span class="number">10</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   scid               number(<span class="number">2</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   yzid               number(<span class="number">2</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   height             number(<span class="number">3</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   memo               varchar2(<span class="number">300</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint FK_GIRL_SC foreign <span class="title">key</span><span class="params">(scid)</span> references <span class="title">T_SCCODE</span><span class="params">(scid)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint FK_GIRL_YZ foreign <span class="title">key</span><span class="params">(yzid)</span> references <span class="title">T_YZCODE</span><span class="params">(yzid)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，无能。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="number">1</span>,null,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,<span class="number">2</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>各表中的数据如下：</p><p><img src="https://img-blog.csdnimg.cn/20200312143552395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200312143602876.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200312143611787.png" alt="在这里插入图片描述" /></p><h1 id="二-表名限定"><a class="markdownIt-Anchor" href="#二-表名限定"></a> 二、表名限定</h1><p>在SQL语句中，列是指表（视图、结果集）的列，可以在列名前加表名限定，也可以用表的别名限定，例如：</p><p>1）不加表名限定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,scid,yzid,height,memo from T_GIRL;</span><br></pre></td></tr></table></figure><p>2）用表名限定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.scid,T_GIRL.yzid,T_GIRL.height,T_GIRL.memo from T_GIRL;</span><br></pre></td></tr></table></figure><p>3）用表的别名限定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select aa.id,aa.name,aa.scid,aa.yzid,aa.height,aa.memo from T_GIRL aa;</span><br></pre></td></tr></table></figure><p><strong>以上三条SQL语句只操作了一个表，列名可以不用表名限定，但是，在子查询中，如果这多个表中有相同的列名，则必须在列名前面加表名限定，以避免歧义。</strong></p><h1 id="三-子查询示例"><a class="markdownIt-Anchor" href="#三-子查询示例"></a> 三、子查询示例</h1><h2 id="1-在字段列表中使用子查询"><a class="markdownIt-Anchor" href="#1-在字段列表中使用子查询"></a> 1、在字段列表中使用子查询</h2><p>查询T_GIRL表，并从T_SCCODE表中获取身材的中文，从T_YZCODE表中获取颜值的中文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height,memo,</span><br><span class="line">       (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span><br><span class="line">       (select yzname from T_YZCODE where yzid=T_GIRL.yzid) yzname</span><br><span class="line">  from T_GIRL;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312143752685.png" alt="在这里插入图片描述" /></p><p>在上面的SQL语句中，T_GIRL和T_SCCODE表都有相同的列名scid，在子查询</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select scname from T_SCCODE where scid=T_GIRL.scid)</span><br></pre></td></tr></table></figure><p>中，第一个scid不需要加T_SCCODE表名的限定，第二个scid要加T_GIRL表名的限定。</p><h2 id="2-在where子句中使用子查询"><a class="markdownIt-Anchor" href="#2-在where子句中使用子查询"></a> 2、在where子句中使用子查询</h2><p>子查询可以作为where子句条件的值，如果用的是in比较运算符，子查询可以是多行的结果集，其它比较运算符是单行的结果集。</p><p>1）条件的值是单行的结果集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height,memo,</span><br><span class="line">      (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span><br><span class="line">      (select yzname from T_YZCODE where yzid=T_GIRL.yzid) yzname</span><br><span class="line"> from T_GIRL</span><br><span class="line">where yzid=(select yzid from T_YZCODE where yzname=<span class="string">&#x27;风华绝代&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031214394391.png" alt="在这里插入图片描述" /></p><p>2）条件的值是多行的结果集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height,memo,</span><br><span class="line">      (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span><br><span class="line">      (select yzname from T_YZCODE where yzid=T_GIRL.yzid) <span class="function">yzname</span></span><br><span class="line"><span class="function"> from T_GIRL</span></span><br><span class="line"><span class="function">where yzid <span class="title">in</span> <span class="params">(select yzid from T_YZCODE where yzname in (<span class="string">&#x27;风华绝代&#x27;</span>,<span class="string">&#x27;倾国倾城&#x27;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144017137.png" alt="在这里插入图片描述" /></p><h2 id="3-从结果集中查询"><a class="markdownIt-Anchor" href="#3-从结果集中查询"></a> 3、从结果集中查询</h2><p>从结果集中查询也称之为select的嵌套，注意，里层的select的列该用别名的地方要用别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yzname,scname,<span class="function">memo <span class="title">from</span></span></span><br><span class="line"><span class="function">       <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        select id,name,height,memo,</span></span></span><br><span class="line"><span class="params"><span class="function">               (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span></span></span><br><span class="line"><span class="params"><span class="function">               (select yzname from T_YZCODE where yzid=T_GIRL.yzid) yzname</span></span></span><br><span class="line"><span class="params"><span class="function">          from T_GIRL</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> T_MYGIRL</span></span><br><span class="line"><span class="function"> where  yzname</span>=<span class="string">&#x27;倾国倾城&#x27;</span> <span class="keyword">or</span> scname=<span class="string">&#x27;丰满&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144054292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="4-在insert中使用子查询"><a class="markdownIt-Anchor" href="#4-在insert中使用子查询"></a> 4、在insert中使用子查询</h2><p>1）创建一个临时表TT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">TT</span><span class="params">(id <span class="type">char</span>(<span class="number">4</span>),name varchar2(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>2）在TT中插入多条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into TT select id,name from T_GIRL;</span><br></pre></td></tr></table></figure><p>3）在TT中插入一条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into TT <span class="title">values</span><span class="params">(<span class="string">&#x27;1088&#x27;</span>,(select name from T_GIRL where id=<span class="string">&#x27;0102&#x27;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144147442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-在delete中使用子查询"><a class="markdownIt-Anchor" href="#5-在delete中使用子查询"></a> 5、在delete中使用子查询</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delete</span> from TT where id <span class="title">in</span> <span class="params">(select id from T_GIRL)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="6-在update中使用子查询"><a class="markdownIt-Anchor" href="#6-在update中使用子查询"></a> 6、在update中使用子查询</h2><p>1）在T_GIRL增加一个列（yzname颜值中文），用于测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add yzname <span class="title">varchar2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2）用T_YZCODE表中的yzname更新T_GIRL表的yzname。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update T_GIRL</span><br><span class="line">   set yzname=(select yzname from T_YZCODE where T_YZCODE.yzid= T_GIRL.yzid);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144317512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="7-在create-table中使用子查询"><a class="markdownIt-Anchor" href="#7-在create-table中使用子查询"></a> 7、在create table中使用子查询</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 新表名 as 子查询</span><br></pre></td></tr></table></figure><p>例如用T_GIRL的结构创建T_MYGIRL表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table T_MYGIRL as select * from T_GIRL where yzid <span class="title">in</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144404413.png" alt="在这里插入图片描述" /></p><p>如果想创建一张空的表，可以用where 1=2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table T_MYGIRL as select * from T_GIRL where <span class="number">1</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>注意一个问题，用以上方法创建的表只有基本的结构，没有主键、没有索引、没有表约束，没有列约束。</p><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>在SQL语句中，可以把子查询当成表达式或结果集（单行和多行），只要逻辑正确，子查询可用于SQL语句的任何地方。</p><p>SQL非常强大，您能想到的需求它都能支持，本文只介绍了常用子查询的用法，有些我也没有想到。</p><p>所以，大家要放开思路，大胆的想，大胆的尝试。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的主键和外键</title>
      <link href="/post/8bcdd547.html"/>
      <url>/post/8bcdd547.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-表的主键"><a class="markdownIt-Anchor" href="#一-表的主键"></a> 一、表的主键</h1><p>在现实世界中，很多数据具有唯一的特性，例如身份证号码，在国家人口基本信息表中，一定不会存在多个人用同一个身份证号码的情况，再例如手机号码、QQ号码、银行帐号等等，还有学生管理系统，学生的年级、班级和学号三个字段组合起来是唯一的标识。</p><p>如果表中一个字段或多个字段组合起来的值是唯一的，就可以作为表的主键，在创建或修改表时用primay key关键字来指定主键。一个表只能有一个主键，而且组成主键的每个字段值都不能为空。</p><p>主键的作用：</p><p>1）体现数据结构设计的合理性。</p><p>2）提升数据操作的速度。</p><p>3）保证数据的完整性，在表中添加或修改记录时，数据库会检查该记录主键的值，不允许与其它记录主键的值重复，这种做法有个专业的名词：主键约束。</p><p>例如超女基本信息表，编号的字段名是id，在超女选秀活动中，每个超女的编号肯定是唯一的，不可能存在两个编号相同的超女，否则会引起混乱，我们可以把id字段设置为T_GIRL表的主键，后面的工作交给数据库，如果试图往表中插入多条id相同的记录，数据库将拒绝。</p><p>指定表的主建有两种方法。</p><p>1）在create table时指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 指定id为表的主键</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>2）修改已经建好的表，增加主键约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 主键名 <span class="function">primary <span class="title">key</span><span class="params">(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n)</span></span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br></pre></td></tr></table></figure><p>在Oracle数据库中，虽然主键不是必需的，但是最好为每个表都设置一个主键，不管是单字段主键还是多字段主键（复合主键），它的存在代表了表结构的完整性，主键还可以用于其他表的外键关联，外键的知识下面再介绍。</p><h1 id="二-表的外键"><a class="markdownIt-Anchor" href="#二-表的外键"></a> 二、表的外键</h1><h2 id="1-外键的概念"><a class="markdownIt-Anchor" href="#1-外键的概念"></a> 1、外键的概念</h2><p>外键（foreign key）是用于表达两个表数据之间的关系，将表中主键字段添加到另一个表中，再创建两个表之间的约束关系，这些字段就成为第二个表的外键。</p><p>超女选秀活动有两个数据表：</p><p>1）赛区参数表</p><p>赛区代码，赛区名称，……。</p><p>2）超女基本信息表</p><p>赛区代码、超女编号、姓名、颜值、身材、身高、体重、……。</p><p>录入超女基本信息的时候要选择赛区，为了保证数据的有效，要求录入赛区代码时，必须保证赛区参数表中有这个赛区代码，否则数据是不一致的，为了保证数据的完整性，必须在程序中判断数据的合法性。针对这种情况，在表结构设计中采用外键来约束这两个表的赛区代码字段。</p><p>对赛区参数表来说，赛区代码是该表的主键。</p><p>对超女基本信息表来说，赛区代码是该表的外键。</p><p>赛区参数表也称为<strong>主表</strong>，超女基本信息表也称为<strong>从表</strong>。</p><h2 id="2-外键的作用"><a class="markdownIt-Anchor" href="#2-外键的作用"></a> 2、外键的作用</h2><p>合理的数据结构设计，表中的数据一定有一致性约束，使用外键，让数据库去约束数据的一致，不给任何人出错的机会。不用外键会怎样？不用也不会怎么样，如果不用外键，在程序中要写代码进行判断，手工操作数据时也必须处处小心。</p><h2 id="3-外键约束"><a class="markdownIt-Anchor" href="#3-外键约束"></a> 3、外键约束</h2><p><strong>1）当对从表进行操作时，数据库会：</strong></p><p>a）向从表插入新记录时，如果外键值在主表中不存在，阻止插入。</p><p>b）修改从表的记录时，如果外键的值在主表中不存在，阻止修改。</p><p><strong>2）当对主表进行修改操作时，数据库会：</strong></p><p>a）主表修改主键值时，旧值在从表里存在便阻止修改。</p><p><strong>3）当对主表进行删除操作时，数据库会（三选一）：</strong></p><p>a）主表删除行时，其主键值在从表里存在便阻止删除。</p><p>b）主表删除行时，连带从表的相关行一起删除。</p><p>c）主表删除行时，把从表相关行的外键字段置为null。</p><h2 id="4-创建外键"><a class="markdownIt-Anchor" href="#4-创建外键"></a> 4、创建外键</h2><p>创建外键的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table 从表名</span><br><span class="line">   add constraint 外键名 <span class="function">foreign <span class="title">key</span> <span class="params">(从表字段列表)</span></span></span><br><span class="line"><span class="function">      references 主表名 <span class="params">(主表字段列表)</span></span></span><br><span class="line"><span class="function">      [on <span class="keyword">delete</span> cascade|set null]</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>外键名，Oracle的标识符，建议采用<strong>FK_从表名_主表名</strong>的方式命名。</p><p>主表执行删除行时，其主键值在从表里存在便阻止删除，如果on delete cascade，连带从表的相关行一起删除；如果on delete set null，把从表相关行的外键字段置为null。</p><h2 id="5-删除外键"><a class="markdownIt-Anchor" href="#5-删除外键"></a> 5、删除外键</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 从表名 drop constraint 外键名;</span><br></pre></td></tr></table></figure><h2 id="6-示例脚本"><a class="markdownIt-Anchor" href="#6-示例脚本"></a> 6、示例脚本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建赛区参数表。 */</span></span><br><span class="line"><span class="function">create table <span class="title">T_AREACODE</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  areaid   number(<span class="number">2</span>)   <span class="keyword">not</span> null,    -- 赛区代码，非空。</span></span></span><br><span class="line"><span class="params"><span class="function">  areaname varchar(<span class="number">20</span>) <span class="keyword">not</span> null,    -- 赛区名称，非空。</span></span></span><br><span class="line"><span class="params"><span class="function">  memo     varchar(<span class="number">300</span>),            -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(areaid)               -- 创建主健。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建超女基本信息表。 */</span></span><br><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)        null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  areaid    number(<span class="number">2</span>)           null,   -- 赛区代码</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 创建主健。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下三种创建外键的方式只能三选一  */</span></span><br><span class="line"><span class="comment">/* 为T_GIRL创建外键，无on delete选项。 */</span></span><br><span class="line"><span class="function">alter table T_GIRL</span></span><br><span class="line"><span class="function">   add constraint FK_GIRL_AREACODE foreign <span class="title">key</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      references <span class="title">T_AREACODE</span><span class="params">(areaid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为T_GIRL创建外键，采用on delete cascade选项。 */</span></span><br><span class="line"><span class="function">alter table T_GIRL</span></span><br><span class="line"><span class="function">   add constraint FK_GIRL_AREACODE foreign <span class="title">key</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      references <span class="title">T_AREACODE</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      on <span class="keyword">delete</span> cascade</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为T_GIRL创建外键，采用on delete set null选项。 */</span></span><br><span class="line"><span class="function">alter table T_GIRL</span></span><br><span class="line"><span class="function">   add constraint FK_GIRL_AREACODE foreign <span class="title">key</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      references <span class="title">T_AREACODE</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      on <span class="keyword">delete</span> set null</span>;</span><br></pre></td></tr></table></figure><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的distinct关键字</title>
      <link href="/post/d6978e08.html"/>
      <url>/post/d6978e08.html</url>
      
        <content type="html"><![CDATA[<p>distinct关键字用于从查询的结果集中筛选出唯一值的记录。</p><p>我们通过示例来介绍distinct关键字的用法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-distinct示例"><a class="markdownIt-Anchor" href="#二-distinct示例"></a> 二、distinct示例</h1><p>从T_GIRL表中查出全部的颜值信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select yz from T_GIRL;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312110201737.png" alt="在这里插入图片描述" /></p><p>如果我想知道颜值有哪些取值，所以希望从结果集中去掉重复的记录，加上distinct关键字，位置在select和字段列表之间。</p><p><img src="https://img-blog.csdnimg.cn/20200312110226878.png" alt="在这里插入图片描述" /></p><p>distinct是从结果集中筛选出唯一值的记录，上面示例的结果集只有一个字段，也可以多个字段，多个字段组合的值唯一。</p><p>未加distinct关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select yz,sc from T_GIRL; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031211031576.png" alt="在这里插入图片描述" /></p><p>加了distinct关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct yz,sc from T_GIRL; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312110350993.png" alt="在这里插入图片描述" /></p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的别名</title>
      <link href="/post/2f52b857.html"/>
      <url>/post/2f52b857.html</url>
      
        <content type="html"><![CDATA[<p>在SQL语句中，可以给表和列起别名，这是临时的别名，与同义词不一样，同义词是永久的别名。</p><p>别名是多表查询和嵌套查询语句的基础知识，本文只介绍别名的语法，不涉及别名的应用技巧，大家在学习的时候可能觉得别名没什么意义，其实不然。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-表和列的别名"><a class="markdownIt-Anchor" href="#二-表和列的别名"></a> 二、表和列的别名</h1><p>我们先来看一个SQL语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312104958171.png" alt="在这里插入图片描述" /></p><p>select语句返回结果集的列标题是列名，如果对列用了函数就是函数的文本。</p><p>试试别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id 编号,name 姓名,yz 颜值,sc 身材,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) 生日</span><br><span class="line">  from T_GIRL 超女基本信息表;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031210505256.png" alt="在这里插入图片描述" /></p><h2 id="1-列的别名"><a class="markdownIt-Anchor" href="#1-列的别名"></a> 1、列的别名</h2><p>列的别名有两种写法：</p><p>1）直接在列后面加空格写别名，例如：name 姓名。</p><p>2）使用as在列后面再写别名，例如：name as 姓名。</p><p>别名可以直接书写，如果别名中有特殊字符，如数字、单引号和空格，就用双引号将别名括起来。</p><h2 id="2-表的别名"><a class="markdownIt-Anchor" href="#2-表的别名"></a> 2、表的别名</h2><p>表的别名与列的别名不同的地方就是表的别名不能用as。</p><h1 id="三-注意事项"><a class="markdownIt-Anchor" href="#三-注意事项"></a> 三、注意事项</h1><h2 id="1-列的别名-2"><a class="markdownIt-Anchor" href="#1-列的别名-2"></a> 1、列的别名</h2><p>列的别名这种说法不准确，准确的说法是结果集的列的别名，以下用示例来证明。</p><p>1）列的别名不能用在where子句中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id 编号,name 姓名 from T_GIRL where id=<span class="string">&#x27;0101&#x27;</span>;</span><br><span class="line">select id 编号,name 姓名 from T_GIRL where 编号=<span class="string">&#x27;0101&#x27;</span>;</span><br></pre></td></tr></table></figure><p>以上两条SQL语句，第一条是正确的，第二条会报错。</p><p>2）列的别名可以用于order by关键字中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id 编号,name 姓名 from T_GIRL order by id;</span><br><span class="line">select id 编号,name 姓名 from T_GIRL order by 编号;</span><br></pre></td></tr></table></figure><p>以上两条SQL语句都是正确的。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle同义词</title>
      <link href="/post/aeab5e37.html"/>
      <url>/post/aeab5e37.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-同义词的概念"><a class="markdownIt-Anchor" href="#一-同义词的概念"></a> 一、同义词的概念</h1><p>同义词（synonym）就是数据库对象的别名，这里的数据库对象包括表、视图、序列、存储过程、包等。</p><p>同义词有两方面的意义：1）简化了数据库对象名称的书写；2）提高了数据库对象的安全性（因为只知道对象的别名，不知道它的真名）。</p><p>Oracle的dual虚表其实就是一个公用的同义词。</p><h1 id="二-创建同义词"><a class="markdownIt-Anchor" href="#二-创建同义词"></a> 二、创建同义词</h1><h2 id="1-创建同义词的权限"><a class="markdownIt-Anchor" href="#1-创建同义词的权限"></a> 1、创建同义词的权限</h2><p>用dba权限登录数据库，授于用户create synonym和create public synonym权限。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant create synonym to 用户名;</span><br><span class="line">grant create <span class="keyword">public</span> synonym to 用户名;</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200312094747768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-创建synonym的命令"><a class="markdownIt-Anchor" href="#2-创建synonym的命令"></a> 2、创建synonym的命令</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">public</span>] synonym 同义词名 <span class="keyword">for</span> [用户名.]数据库对象名;</span><br></pre></td></tr></table></figure><p>说明：</p><p>public：同义词的类型，缺省是当前用户私有的，只有当前用户可以使用该同义词，如果加上public选项，表示公用同义词，所有的数据库用户都可以使用。</p><p>用户名：数据库对象所属的用户，缺省是当前用户。</p><p>数据对象名：常用的是表、视图和序列，其它的不常用。</p><p>注意，如果对其它用户的对象创建同义词，当前用户必须具备对其它用户对象的权限，否则同义词无法使用。</p><p>示例：</p><p>1）为当前用户的dept表创建同义词mydept。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create synonym mydept <span class="keyword">for</span> dept;</span><br></pre></td></tr></table></figure><p>2）为scott用户的emp表创建同义词myemp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create synonym myemp <span class="keyword">for</span> scott.emp;</span><br></pre></td></tr></table></figure><p>3）为远程数据库的scott用户的emp表创建同义词remoteemp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create synonym remoteemp <span class="keyword">for</span> scott.emp@dblink_01;</span><br></pre></td></tr></table></figure><p>4）测试效果。</p><p><img src="https://img-blog.csdnimg.cn/20200312094923950.png" alt="在这里插入图片描述" /></p><h1 id="三-删除同义词"><a class="markdownIt-Anchor" href="#三-删除同义词"></a> 三、删除同义词</h1><p>删除当前用户私有的同义词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop synonym 同义词名;</span><br></pre></td></tr></table></figure><p>删除公用的同义词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop <span class="keyword">public</span> synonym 公用同义词名;</span><br></pre></td></tr></table></figure><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库链路</title>
      <link href="/post/55aff1ac.html"/>
      <url>/post/55aff1ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-数据库链路的概念"><a class="markdownIt-Anchor" href="#一-数据库链路的概念"></a> 一、数据库链路的概念</h1><p>数据库链路（database link），简称dblink，它是一个通道，是本地数据库与远程数据库之间的通道，通过dblink，在本地数据库中可以直接访问远程数据库的对象。</p><p>dblink不是应用程序与数据库之间的通道，而是数据库之间的通道。</p><h1 id="二-创建dblink"><a class="markdownIt-Anchor" href="#二-创建dblink"></a> 二、创建dblink</h1><h2 id="1-创建dblink的权限"><a class="markdownIt-Anchor" href="#1-创建dblink的权限"></a> 1、创建dblink的权限</h2><p>用dba权限登录数据库，授于用户create database link和create public database link权限。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant create database link to 用户名;</span><br><span class="line">grant create <span class="keyword">public</span> database link to 用户名;</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200312092903405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-创建dblink的命令"><a class="markdownIt-Anchor" href="#2-创建dblink的命令"></a> 2、创建dblink的命令</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">public</span>] database link 数据库链路名称</span><br><span class="line">connect to 用户名</span><br><span class="line">identified by 密码</span><br><span class="line"><span class="keyword">using</span> <span class="string">&#x27;远程数据库参数&#x27;</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>public：dblink的类型，缺省是当前用户私有的，只有当前用户可以使用该dblink，如果加上public选项，表示公用dblink，所有的数据库用户都可以使用。</p><p>数据库链路名称：给dblink起个名字。</p><p>用户名：远程数据库登录的用户名。</p><p>密码：远程数据库登录的用户的密码。</p><p>远程数据库参数：该参数的配置有两种方法：1）远程数据库的服务名，也就是本地数据库服务器上$ORACLE_HOME/network/admin/tnsnames.ora中配置的数据库服务名；2）不采用tnsnames.ora中的配置，直接指定远程数据库的参数。</p><h2 id="3-用数据库服务名创建dblink"><a class="markdownIt-Anchor" href="#3-用数据库服务名创建dblink"></a> 3、用数据库服务名创建dblink</h2><p>1）配置远程数据库服务名</p><p>远程数据库服务名在$ORACLE_HOME/network/admin/tnsnames.ora文件中配置，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">snorcl11g_198 =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = <span class="number">118.89</span><span class="number">.50</span><span class="number">.198</span>)(PORT = <span class="number">1521</span>))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SID = snorcl11g)</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>2）测试远程数据库登录参数</p><p><img src="https://img-blog.csdnimg.cn/20200312093034967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>3）创建dblink</p><p>用远程数据库服务名创建dblink，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database link dblink_01 connect to shqx identified by pwdidc <span class="keyword">using</span> <span class="string">&#x27;snorcl11g_198&#x27;</span>;</span><br></pre></td></tr></table></figure><p>4）测试dblink</p><p>通过dblink获取远程数据库的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200312093115617.png" alt="在这里插入图片描述" /></p><h2 id="4-不用数据库服务名创建dblink"><a class="markdownIt-Anchor" href="#4-不用数据库服务名创建dblink"></a> 4、不用数据库服务名创建dblink</h2><p>如果不用数据库服务创建dblink，就不需要配置tnsnames.ora文件。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create database link dblink_02 connect to shqx identified by pwdidc <span class="keyword">using</span></span><br><span class="line"><span class="string">&#x27;(DESCRIPTION =</span></span><br><span class="line"><span class="string">   (ADDRESS_LIST =</span></span><br><span class="line"><span class="string">     (ADDRESS = (PROTOCOL = TCP)(HOST = 118.89.50.198)(PORT = 1521))</span></span><br><span class="line"><span class="string">   )</span></span><br><span class="line"><span class="string">   (CONNECT_DATA =</span></span><br><span class="line"><span class="string">     (SID = snorcl11g)</span></span><br><span class="line"><span class="string">     (SERVER = DEDICATED)</span></span><br><span class="line"><span class="string">   )</span></span><br><span class="line"><span class="string"> )&#x27;</span>;</span><br></pre></td></tr></table></figure><p>dblink_01和dblink_02完全一样。</p><h1 id="三-dblink的使用"><a class="markdownIt-Anchor" href="#三-dblink的使用"></a> 三、dblink的使用</h1><p>如果要访问远程数据库的表或视图，在表和视图名之后附加@dblinkname就可以了。</p><p>访问远程数据库的dual表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sysdate from dual@dblink_01;</span><br></pre></td></tr></table></figure><p>访问远程数据库的scott.emp表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from scott.emp@dblink_02;</span><br></pre></td></tr></table></figure><h1 id="四-删除dblink"><a class="markdownIt-Anchor" href="#四-删除dblink"></a> 四、删除dblink</h1><p>删除当前用户私有的dblink：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database link 数据库链路名;</span><br></pre></td></tr></table></figure><p>删除公用的dblink：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop <span class="keyword">public</span> database link 公用数据库链路名;</span><br></pre></td></tr></table></figure><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>dblink的知识很容易掌握，用dblink访问远程数据库的对象很方便，但是，如果在程序中采用dblink对远程数据库的表进行增、删、改、查操作时一定要遵守一个原则：<strong>尽可能不要产生远程事务，因为数据库对远程的事务难以控制</strong>，也就是说，尽可能不要对远程数据库的表进行增、删、改操作，查询是没有问题的。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle视图</title>
      <link href="/post/7b0aedda.html"/>
      <url>/post/7b0aedda.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-视图的概念"><a class="markdownIt-Anchor" href="#一-视图的概念"></a> 一、视图的概念</h1><p>视图是基于一个或者多个表上的预定义查询，这些表称为基表，从视图中查询数据的方法与从基表中查询数据的方法相同。视图是一个查看数据的窗口，是查询语句模板，视图本身没有数据，在数据库中只保存了视图的定义。</p><p>视图具有以下优点：</p><p>1）可以向数据访问者只开放访问视图的权限，屏蔽基表信息。</p><p>2）可以将复杂的查询语句保存为视图，简化了SQL语句的编写。</p><p>3）创建视图的时候，可以限制只访问基表中的部分列或者部分行的数据，这样可以实现一定的安全性。</p><p>4）简化用户权限的管理，只授予用户使用视图的权限。</p><p>5）从基表中按一定的业务逻辑抽出用户关心的部分数据创建视图，简化了业务逻辑。</p><h1 id="二-创建视图"><a class="markdownIt-Anchor" href="#二-创建视图"></a> 二、创建视图</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] [&#123;force|noforce&#125;] view 视图名</span><br><span class="line">as</span><br><span class="line">select查询语句</span><br><span class="line">[with read only]</span><br></pre></td></tr></table></figure><p>语法解析：</p><p><strong>or replace</strong>：如果视图已经存在，则替换旧视图。</p><p><strong>force</strong>：即使基表不存在，也可以创建该视图，但是该视图不能正常使用，当基表创建成功后，视图才能正常使用。</p><p><strong>noforce</strong>：如果基表不存在，无法创建视图，该项是默认选项。</p><p><strong>with read only</strong>：默认可以通过视图对基表执行增删改操作，with read only强调这是只读视图，不能通过该视图进行增删改操作。现实开发中，基本上不通过视图对表中的数据进行增删改操作。</p><p>示例一，在超女表中创建一个简单的视图V_GIRL，只提取编号、姓名、身材和颜值字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace noforce view V_GIRL</span><br><span class="line">as</span><br><span class="line">select id,name,sc,yz from T_GIRL</span><br><span class="line">with read only;</span><br></pre></td></tr></table></figure><p>从V_GIRL视图中查询数据：</p><p><img src="https://img-blog.csdnimg.cn/20200312091011810.png" alt="在这里插入图片描述" /></p><p>示例二，连接EMP表和DEPT表创建视图V_EMPDETAIL，隐藏了工资（sal）和备注（comm）字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace view V_EMPDETAIL</span><br><span class="line">as</span><br><span class="line">select empno,ename,job,hiredate,EMP.deptno,dname</span><br><span class="line">  from EMP join DEPT on EMP.deptno=DEPT.deptno</span><br><span class="line">with read only;</span><br></pre></td></tr></table></figure><p>从V_EMPDETAIL视图中查询数据：</p><p><img src="https://img-blog.csdnimg.cn/20200312091101971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-视图的状态"><a class="markdownIt-Anchor" href="#三-视图的状态"></a> 三、视图的状态</h1><p>当创建视图后，Oracle会验证视图的有效性，如修改了基本表，可能会导致视图的不可用，数据字典的USER_OBJECTS的status字段中记录了视图的状态（VALID-有效；INVALID-失效）。</p><p><img src="https://img-blog.csdnimg.cn/20200312091123230.png" alt="在这里插入图片描述" /></p><p>我们来做一个测试。</p><p>1）删除T_GIRL表的name字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL drop column name;</span><br></pre></td></tr></table></figure><p>2）执行一次查询视图，出现了错误。</p><p><img src="https://img-blog.csdnimg.cn/20200312091201901.png" alt="在这里插入图片描述" /></p><p>3）查询视图的状态，成了INVALID。</p><p><img src="https://img-blog.csdnimg.cn/20200312091212810.png" alt="在这里插入图片描述" /></p><p>4）在T_GIRL表中增加name字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add name <span class="title">varchar2</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>5）查询视图的状态，还是INVALID，数据结构已恢复，但视图的状态未恢复。</p><p><img src="https://img-blog.csdnimg.cn/20200312091429875.png" alt="在这里插入图片描述" /></p><p>6）执行一次查询，视图已恢复正常。</p><p><img src="https://img-blog.csdnimg.cn/20200312091445369.png" alt="在这里插入图片描述" /></p><p>7）再查询视图的状态，恢复成了VALID。</p><p><img src="https://img-blog.csdnimg.cn/20200312091502346.png" alt="在这里插入图片描述" /></p><p>在上面的测试中，我们发现基表数据结构的改变导致了视图无效，数据结构恢复后，视图能自动恢复正常（中间有一点曲折）。</p><h1 id="四-删除视图"><a class="markdownIt-Anchor" href="#四-删除视图"></a> 四、删除视图</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view V_GIRL;</span><br></pre></td></tr></table></figure><h1 id="五-视图的其它知识"><a class="markdownIt-Anchor" href="#五-视图的其它知识"></a> 五、视图的其它知识</h1><p>视图还有两个方面的知识，大家可以了解一下：</p><p>1）本文只介绍了只读视图，对视图只会执行select操作，其实视图还可以进行增、删、改操作，但应用场景极少，二十年来，我从未见过。</p><p>2）本文介绍的视图是查询数据的窗口、是虚拟表、是SQL模板，视图本身没有数据，但是，有一种视图叫物化视图，是有数据的，但是，物化视图的应用也非常少。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle索引</title>
      <link href="/post/f435c111.html"/>
      <url>/post/f435c111.html</url>
      
        <content type="html"><![CDATA[<p><strong>对于初学者来说，在学习的过程中，创建表的数据量非常有限，感受不到索引的重要性，但是，我希望您把本章节的内容记在心里，等实际工作中遇到问题的时候能立即想到解决问题的方案。</strong></p><p><strong>总的来说，Oracle数据库非常强大，如果您的数据库性能较低或执行SQL语句的效率很低，最主要原因应该是索引设计不合理或使用索引不合理。</strong></p><p><strong>所谓的SQL优化，主要的内容就是如何设计索引和如何利用索引。</strong></p><h1 id="一-索引的概念"><a class="markdownIt-Anchor" href="#一-索引的概念"></a> 一、索引的概念</h1><p>如果一本书只有几页，读者随便翻翻就能很快的找到具体的内容，根本不需要目录，如果一本书有几百页、几千页，没有目录，查找内容的将需要更长的时间，书越厚，耗时越长。</p><p>索引，即表的索引，它对表的重要性就像目录对书一样重要，索引可以大幅提升数据查找的效率。</p><h2 id="1-索引的特点"><a class="markdownIt-Anchor" href="#1-索引的特点"></a> 1、索引的特点</h2><p>1）索引是表的一部分，是可选的，表可以没有索引，就像书可以没有目录一样，数据库不做强制要求。</p><p>2）合理的索引可以提高数据查找的效率，减少磁盘I/O。</p><p>3）唯一索引可以约束表数据的完整性。</p><p>4）索引也是数据，需要存储空间。</p><p>5）数据库自动维护索引的内容，当对表的记录进行了增、删、改的操作时，数据库会自动更新索引。</p><p>6）索引虽然可以提高数据查找的效率，但对表进行增、删、改操作时，数据库除了维护表中的数据，还要维护索引，所以，索引会让增、删、改操作的效率下降。</p><p>7）索引提升了数据查找的效率，降低了数据操作的效率，在设计表和索引的时候，要根据实际情况在两者之间权衡。</p><h2 id="2-索引的分类"><a class="markdownIt-Anchor" href="#2-索引的分类"></a> 2、索引的分类</h2><p>索引可分为普通索引、唯一索引、反向键索引、位图索引和基于函数的索引，常用的是普通索引和唯一索引，其它三种极少使用，我也不建议使用。</p><p>本文只介绍普通索引和唯一索引。</p><h1 id="二-创建索引"><a class="markdownIt-Anchor" href="#二-创建索引"></a> 二、创建索引</h1><p>我们先来创建超女基本信息表T_GIRL。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  keyid     number(<span class="number">8</span>)       <span class="keyword">not</span> null   -- 记录编号,从序列SEQ_GIRL中获取。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="1-普通索引"><a class="markdownIt-Anchor" href="#1-普通索引"></a> 1、普通索引</h2><p>创建普通索引的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......,字段名n);</span><br></pre></td></tr></table></figure><p>索引名是标识符，从语法上来说，索引名只要符合Oracle的规定就行了，但是，在实际开发中，我会以IDX_打头，加表名和索引编号，例如超女基本信息表T_GIRL的索引，命名将会是IDX_GIRL_1、IDX_GIRL_2、IDX_GIRL_3、IDX_GIRL_n。</p><p>例如为超女信息表T_GIRL的姓名字段创建索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create index IDX_GIRL_1 on <span class="title">T_GIRL</span><span class="params">(name)</span></span>;</span><br></pre></td></tr></table></figure><p>例如为超女信息表T_GIRL的颜值和身材两个字段创建索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create index IDX_GIRL_2 on <span class="title">T_GIRL</span><span class="params">(yz,sc)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-唯一索引"><a class="markdownIt-Anchor" href="#2-唯一索引"></a> 2、唯一索引</h2><p>如果表中的列没有重复的值，是唯一的，就可以创建唯一索引，唯一索引的效率比普通索引要高很多。</p><p>创建普通索引的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index 索引名 on 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......,字段名n);</span><br></pre></td></tr></table></figure><p>例如超女基本信息表T_GIRL的keyid字段，其值是从序列SEQ_GIRL中获取的，肯定是个唯一的值，可以创建唯一索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create unique index IDX_GIRL_3 on <span class="title">T_GIRL</span><span class="params">(keyid)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-主建是唯一索引"><a class="markdownIt-Anchor" href="#3-主建是唯一索引"></a> 3、主建是唯一索引</h2><p>不要为表的主建创建索引，因为Oracle自动为表的主建字段创建唯一索引。</p><p><img src="https://img-blog.csdnimg.cn/20200311180842124.png" alt="在这里插入图片描述" /></p><h1 id="三-删除索引"><a class="markdownIt-Anchor" href="#三-删除索引"></a> 三、删除索引</h1><p>当表被删除时，表的索引会被自动删除，也可以采用drop index命令删除索引。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index 索引名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop index IDX_GIRL_1;</span><br><span class="line">drop index IDX_GIRL_2;</span><br><span class="line">drop index IDX_GIRL_3;</span><br></pre></td></tr></table></figure><p>注意，drop index无法删除用于强制唯一/主键的索引，删除主键要用以下语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop constraint 主键名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL drop constraint PK_GIRL;</span><br></pre></td></tr></table></figure><h1 id="四-修改索引"><a class="markdownIt-Anchor" href="#四-修改索引"></a> 四、修改索引</h1><p>修改索引的操作比较多，这些的工作一般由管理员（DBA）来执行。</p><h2 id="1-重建索引"><a class="markdownIt-Anchor" href="#1-重建索引"></a> 1、重建索引</h2><p>重建索引可以减少硬盘碎片和提高数据库系统的性能。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 rebuild;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 rebuild;</span><br></pre></td></tr></table></figure><h2 id="2-整理碎片"><a class="markdownIt-Anchor" href="#2-整理碎片"></a> 2、整理碎片</h2><p>对索引的无用空间进行合并，减少硬盘碎片和提高数据库系统的性能。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 coalesce;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 coalesce;</span><br></pre></td></tr></table></figure><h2 id="3-修改索引名"><a class="markdownIt-Anchor" href="#3-修改索引名"></a> 3、修改索引名</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 rename to 新索引名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 rename to IDX_GIRL_NAME;</span><br></pre></td></tr></table></figure><h2 id="4-禁用索引"><a class="markdownIt-Anchor" href="#4-禁用索引"></a> 4、禁用索引</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 unusable;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 unusable;</span><br></pre></td></tr></table></figure><p>索引被禁用后，如果要启用，需要用rebuild重建。</p><h1 id="五-索引的存储空间"><a class="markdownIt-Anchor" href="#五-索引的存储空间"></a> 五、索引的存储空间</h1><p>每个数据库用户有一个缺省表空间，创建的表、主键和索引存放在缺省表空间中，也可以指定其它的表空间。</p><p><strong>在实际应用中，会把表和索引的存储空间分开到不同的表空间，减少磁盘的竞争，提升I/O的性能。</strong></p><h2 id="1-查看当前用户的缺省表空间"><a class="markdownIt-Anchor" href="#1-查看当前用户的缺省表空间"></a> 1、查看当前用户的缺省表空间</h2><p>从数据字典USER_USERS中可以查看当前用户的缺省表空间。</p><p><img src="https://img-blog.csdnimg.cn/20200311200323448.png" alt="在这里插入图片描述" /></p><h2 id="2-指定索引的表空间"><a class="markdownIt-Anchor" href="#2-指定索引的表空间"></a> 2、指定索引的表空间</h2><p>指定索引的表空间的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 ...... tablespace 表空间名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create unique index IDX_GIRL_3 on <span class="title">T_GIRL</span><span class="params">(keyid)</span> tablespace INDEXS</span>;</span><br></pre></td></tr></table></figure><p>索引还有其它与存储相关的选项，但应用场景比较少，本文就不介绍了。</p><h1 id="六-索引的优化"><a class="markdownIt-Anchor" href="#六-索引的优化"></a> 六、索引的优化</h1><p>索引的优化体现在SQL语句的where条件中，如果where条件中的字段列表没有创建索引，SQL语句的性能将会很低。</p><p>在设计索引的时候，必须考虑在常用的where条件，在编写SQL语句的时候，也必须清楚表上创建了哪些索引。</p><h2 id="1-索引的查看"><a class="markdownIt-Anchor" href="#1-索引的查看"></a> 1、索引的查看</h2><p>在PL/SQL Developer软件中可以查看表的索引。</p><p><img src="https://img-blog.csdnimg.cn/20200311200554698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-sql语句的执行计划"><a class="markdownIt-Anchor" href="#2-sql语句的执行计划"></a> 2、SQL语句的执行计划</h2><p>利用PL/SQL Developer软件可以查看SQL语句详细的执行计划。</p><p><img src="https://img-blog.csdnimg.cn/2020031120063131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-sql语句的执行步骤"><a class="markdownIt-Anchor" href="#3-sql语句的执行步骤"></a> 3、SQL语句的执行步骤</h2><p><img src="https://img-blog.csdnimg.cn/2020031120064554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>SQL语句的执行顺序是从未级节点往根级节点看的，上图中的SQL语句执行的顺序如下：</p><p><strong>INDEX RANGE SCAN-&gt;TABLE ACCESS BY INDEX ROWID-&gt;SELECT STATEMENT,GOAL=ALL_ROWS</strong></p><h2 id="4-执行计划的含义"><a class="markdownIt-Anchor" href="#4-执行计划的含义"></a> 4、执行计划的含义</h2><p>在执行计划中，我们重点关注访问表（TABLE ACCESS BY ……  ）的方式，常见的有三种：</p><p>1）TABLE ACCESS BY USER ROWID（通过ROWID的表存取）</p><p>rowid的值是行的物理位置，通过rowid可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/2020031120071450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2） TABLE ACCESS FULL（全表扫描）</p><p>Oracle读取表中全部的行，并检查每一行是否满足SQL语句中where的条件。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200311200729708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>数据量太大的表不能使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的5%~10%<br />或以上。</p><p><strong>全表扫描会让数据库的性能大幅下降，程序员一定要避免这种情况的发生，除非您知道自己在做什么。</strong></p><p>3） TABLE ACCESS BY INDEX SCAN（索引扫描）</p><p>在索引中，存储了每个索引的键值和行的rowid，所以索引扫描其实是先扫描索引得到对应的rowid，然后再通过rowid定位到具体的行。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200311200744138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>索引扫描又分五种：</p><p>a）INDEX UNIQUE SCAN，索引唯一扫描，效率最高。</p><p>b）INDEX RANGE SCAN，索引范围扫描，效率较高。</p><p>c）INDEX FULL SCAN，索引全扫描，效率较低。</p><p>d）INDEX FAST FULL SCAN，索引快速扫描，效率一般。</p><p>e）INDEX SKIP SCAN，索引跳跃扫描，效率还行。</p><p><strong>在Object name中显示了SQL语句使用的索引名，是索引优化的重要依据。</strong></p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle伪列</title>
      <link href="/post/d241424a.html"/>
      <url>/post/d241424a.html</url>
      
        <content type="html"><![CDATA[<p>Oracle有两个常用的伪列rowid和rownum，对伪列的操作类似于表中的列，你可以对其进行查询操作，但是你却不能对其进行增加、修改或者是删除。</p><h1 id="一-rowid伪列"><a class="markdownIt-Anchor" href="#一-rowid伪列"></a> 一、rowid伪列</h1><h2 id="1-rowid的原理"><a class="markdownIt-Anchor" href="#1-rowid的原理"></a> 1、rowid的原理</h2><p>Oracle数据库表中的每一行在数据库中有一个存放的位置，即rowid（row identification），rowid的长度是10个字节，显示的结果是18字节的字符串，该值表明了行在Oracle数据库中存放的物理具体位置，是唯一的，Oracle内部通常使用它来访问数据。</p><p>我们从超女表中查询每行的rowid。</p><p><img src="https://img-blog.csdnimg.cn/20200311170044763.png" alt="在这里插入图片描述" /></p><p>rowid虽然不是表的字段，但是，在Oracle数据库的内部，保存了每行数据的rowid。</p><p>rowid使用base64编码行的物理地址，编码字符包含A-Z, a-z, 0-9, +, 和/，由四部分组成：OOOOOOOFFFBBBBBBRRR，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200311170207433.png" alt="在这里插入图片描述" /></p><p>1）对象编号：行所属数据库对象的编号，每个数据库对象在创建的时候都被分配一个唯一的编号，六位显示。</p><p>2）文件编号：行所在数据文件的编号，每一个文件标号也是唯一的，三位显示。</p><p>3）块编号：行所在数据文件的数据块的位置，六位显示。</p><p>4）行编号：行目录中的具体位置，三位显示。</p><p>Oracle正是根据rowid可以准确的定位存放行数据的物理位置。</p><h2 id="2-rowid数据类型"><a class="markdownIt-Anchor" href="#2-rowid数据类型"></a> 2、rowid数据类型</h2><p>在Oracle数据库中，用rowid数据类型存放rowid的值，长度是10个字节，为了方便查看和书写，Oracle可以把10字节的rowid类型和18字节的字符串自动转换。</p><p>对程序员来说，把rowid当成18字节的字符串就行了。</p><p><img src="https://img-blog.csdnimg.cn/20200311170744306.png" alt="在这里插入图片描述" /></p><h1 id="二-rowid的应用"><a class="markdownIt-Anchor" href="#二-rowid的应用"></a> 二、rowid的应用</h1><p>我以一个程序员的视角来向大家介绍rowid的应用场景。</p><h2 id="1-记录表数据的变化"><a class="markdownIt-Anchor" href="#1-记录表数据的变化"></a> 1、记录表数据的变化</h2><p>例如我希望把超女基本信息表T_GIRL的操作日志（增加、修改和删除）记录下来。</p><p>1）创建一个SQL日志表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_SQL_LOG</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  tname    varchar2(<span class="number">30</span>),        -- 原表的表名。</span></span></span><br><span class="line"><span class="params"><span class="function">  srcrowid rowid,               -- 原表rowid。</span></span></span><br><span class="line"><span class="params"><span class="function">  sqltype  number(<span class="number">1</span>),           -- SQL语句的类型：<span class="number">1</span>-insert、<span class="number">2</span>-update、<span class="number">3</span>-<span class="keyword">delete</span>。</span></span></span><br><span class="line"><span class="params"><span class="function">  crttime  date <span class="keyword">default</span> sysdate -- 操作时间。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>2）在原表中创建触发器</p><p>在超女基本信息表T_GIRL上创建触发器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace trigger TR_GIRL_LOG</span></span><br><span class="line"><span class="function">       after insert <span class="keyword">or</span> update <span class="keyword">or</span> <span class="keyword">delete</span></span></span><br><span class="line"><span class="function">       on T_GIRL <span class="keyword">for</span> each row</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> inserting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">1</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> updating then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">2</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> deleting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:old.rowid,<span class="number">3</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>3）测试效果</p><p>如果对T_GIRL表插入了四条记录，在T_SQL_LOG中记录的内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200311171945795.png" alt="在这里插入图片描述" /></p><p>4）应用经验</p><p>T_SQL_LOG日志表中可以找到原表数据变化的情况，这种处理技巧在数据审计和数据同步中经常用到。</p><h2 id="2-用于where的条件"><a class="markdownIt-Anchor" href="#2-用于where的条件"></a> 2、用于where的条件</h2><p>rowid是记录了数据存放的物理位置，用rowid作为where的条件的效率永远是最高的，远远超过任何索引，利用这个特点可以提高数据操作的效率。</p><h2 id="3-rowid的缺点"><a class="markdownIt-Anchor" href="#3-rowid的缺点"></a> 3、rowid的缺点</h2><p>rowid的效率虽然很高，在实际开发中经常用到，但也有缺点，主要有两方面：</p><p>1）兼容性不好，rowid是Oracle数据库特有的，其它数据库没有，如果你的应用程序需要迁移到其它数据库，就不能用rowid了。</p><p>2）rowid记录的是数据存放的物理位置，这个值在数据整理、数据迁移和数据备份的时候会变化。</p><h1 id="三-rownum伪列"><a class="markdownIt-Anchor" href="#三-rownum伪列"></a> 三、rownum伪列</h1><p>首先，rowid和rownum都是oracle的伪列，但原理和用法完全不同，没有任何关联和可比性，不要用学习rowid的经验来学习rownum。</p><p>rownum（row number）是Oralce为查询结果集的行分配的顺序号，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200311172035348.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/2020031117205541.png" alt="在这里插入图片描述" /></p><p>再说一次，rownum很简单，就是Oralce为查询结果集的行分配的顺序号。</p><p>rownum在数据库中没有存储空间，从以上的两个查询可以看出，在第一个查询结果中，妲已的rownum是3，在第二个查询结果集中，妲已的rownum是1。</p><p>如果你还不明白，我再解释一次，rownum是Oralce为查询结果集的行分配的顺序号。</p><h1 id="四-rownum的应用"><a class="markdownIt-Anchor" href="#四-rownum的应用"></a> 四、rownum的应用</h1><h2 id="1-限制数据库大事务和长事务"><a class="markdownIt-Anchor" href="#1-限制数据库大事务和长事务"></a> 1、限制数据库大事务和长事务</h2><p>用delete删除表中数据的时候，如果数据记录比较多，会产生大事务和长事务，为了避免对数据库的冲击，可以用rownum限制每次delete数据的记录数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> from 表名 where 待删除数据的条件 <span class="keyword">and</span> rownum&lt;=<span class="number">100000</span> ;</span><br></pre></td></tr></table></figure><p>以上delete语句一次删除100000条记录，这种用法适用于update语句。</p><h2 id="2-用于筛选查询结果集的记录"><a class="markdownIt-Anchor" href="#2-用于筛选查询结果集的记录"></a> 2、用于筛选查询结果集的记录</h2><p>筛选查询结果集的记录的用法对C/C++程序员意义不大，但对java程序员来说非常重要，主要用于查询结果的分页，各位有兴趣可以看一下。</p><p>1）rownum 对于等于某值的查询条件</p><p>如果希望找到超女表中第一条超女的信息，可以使用rownum=1作为条件。但是想找到超女表中第二条超女的信息，使用rownum=2结果查不到数据。因为rownum都是从1开始，但是1以上的自然数在rownum做等于判断是时认为都是false条件，所以无法查到rownum = n（n&gt;1的自然数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,name from T_GIRL where rownum=<span class="number">1</span>; --有记录</span><br><span class="line">select rownum,id,name from T_GIRL where rownum=<span class="number">2</span>; --无记录</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311172446366.png" alt="在这里插入图片描述" /></p><p>2）rownum对于大于某值的查询条件</p><p>如果想找到从第二行记录以后的记录，当使用rownum&gt;2是查不出记录的，可以使用以下的子查询方法来解决。注意子查询中的rownum必须要有别名，否则还是不会查出记录来，这是因为rownum不是某个表的列，如果不起别名的话，无法知道rownum是子查询的列还是主查询的列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select * <span class="title">from</span> <span class="params">(select rownum no,id,name from T_GIRL)</span> where no&gt;2</span>;      -- 有记录</span><br><span class="line"><span class="function">select * <span class="title">from</span> <span class="params">(select rownum   ,id,name from T_GIRL)</span> where rownum&gt;2</span>;  -- 无记录</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311172615297.png" alt="在这里插入图片描述" /><br />3）rownum对于小于某值的查询条件</p><p>如果想找到第三条记录以前的记录，当使用rownum&lt;3是能得到两条记录的。显然rownum对于rownum1的自然数）的条件认为是成立的，所以可以找到记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,name from T_GIRL where rownum&lt;<span class="number">3</span>; -- 有记录</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311172723798.png" alt="在这里插入图片描述" /></p><p>4）rownum排序</p><p>Oracle中的rownum的是在从数据库中取数据的时候产生的序号，所以想对指定排序的数据去指定的rowmun行数据就必须注意了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,name from T_GIRL order by name;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311173230798.png" alt="在这里插入图片描述" /></p><p>可以看出，rownum并不是按照name列来生成的序号。系统是按照记录从数据库取出的顺序给记录排的号，为了解决这个问题，必须使用子查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,<span class="function">name <span class="title">from</span> <span class="params">(select * from T_GIRL order by name)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311173306818.png" alt="在这里插入图片描述" /></p><h1 id="五-小结"><a class="markdownIt-Anchor" href="#五-小结"></a> 五、小结</h1><p>rownum和rowid都是伪列，但两者的原理是不同的，rownum是根据SQL查询出来的结果给每行分配一个临时编号，不同的SQL会导致rownum不同。rowid是物理存在的，在每条记录insert到数据库时，就会有一个唯一的物理位置，记录了在数据库中的位置ID，只要记录没被搬动过，rowid是不变的。</p><p>rownum常用于分页查询，rowid常用于提高数据操作的效率，在某些场景中，还会把rowid当成主建来使用。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle触发器</title>
      <link href="/post/171b244.html"/>
      <url>/post/171b244.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-触发器的概念"><a class="markdownIt-Anchor" href="#一-触发器的概念"></a> 一、触发器的概念</h1><p>触发器是Oracle数据库的对象，类似存储过程和函数。存储过程和函数需要用户显示调用才执行，而触发器是由一个事件来触发运行，当某个事件发生时会自动地隐式运行，不能被显示的调用。</p><p>触发器的本质是存储过程，发生特定事件时Oracle会执行触发器中的代码，它的组成可以分为三个部分：1）触发器执行的条件，即触发器被触发的事件；2）执行触发器的时间，发生事件之前（before）或发生事件之后（after）；3）触发器要做的事情，就是触发器被触发以后具体想执行的任务（PL/SQL语句块）。</p><p>Oracle的触发器分为DML触发器、DDL触发器、替代触发器和系统触发器。</p><h1 id="二-dml触发器"><a class="markdownIt-Anchor" href="#二-dml触发器"></a> 二、DML触发器</h1><p>基于DML操作的触发器，细分又可以分为行触发器和语句触发器。</p><h2 id="1-语句触发器"><a class="markdownIt-Anchor" href="#1-语句触发器"></a> 1、语句触发器</h2><p>DML操作（insert、delete、update），不管SQL语句影响的记录是多少行，触发器只触发一次。</p><h2 id="2-行级触发器"><a class="markdownIt-Anchor" href="#2-行级触发器"></a> 2、行级触发器</h2><p>DML操作（insert、delete、update），SQL语句影响了多少行记录，触发器就触发多少次。</p><p>行级触发器用for each row关键字。</p><h2 id="3-dml触发器语法"><a class="markdownIt-Anchor" href="#3-dml触发器语法"></a> 3、DML触发器语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] trigger 用户名.触发器名</span><br><span class="line">       &#123;before|after&#125;       </span><br><span class="line">       &#123;<span class="keyword">delete</span>|insert|update|[of列名]&#125;</span><br><span class="line">       on 表名</span><br><span class="line">       [<span class="keyword">for</span> each row [when 条件]]</span><br><span class="line">declare</span><br><span class="line">  定义变量。</span><br><span class="line">begin</span><br><span class="line">  PL/SQL语句块。                          </span><br><span class="line">end;</span><br><span class="line">参数说明：</span><br></pre></td></tr></table></figure><p><code>&#123;before|after&#125;</code>：指定触发器是在对表的操作发生之前触发还是之后触发。</p><p><code>&#123;delete|insert|update|[of列名]&#125;</code>：触发在动作，可以指定多个动作，例如：insert or update。如果是update，update of 指定一个或多个字段，仅在这些字段被更新时才会触发。update of的应用场景极少。</p><p><code>[for each row]</code>：表示是行级触发器。</p><p><code>[when 条件]</code>：只有满足when指定的条件，才会执行触发体中的代码，应用场景极少。</p><h2 id="4-触发器谓词"><a class="markdownIt-Anchor" href="#4-触发器谓词"></a> 4、触发器谓词</h2><p>1）创建超女基本信息表T_GIRL，插入5条测试数据。</p><p>old谓词：执行前的字段的值的名称，比如update一个表时，使用:old.columnname是指执行update操作之前的列的值。</p><p>new谓词：执行后的字段的值的名称，比如update一个表时，使用:new.columnname是指执行update操作之后的列的值。</p><p>可以在触发器体的语句块中使用 inserting、updating、deleting谓词，这些谓词会返回相应的DML操作的布尔值，如果为true，则表示执行了相应的insert、update、delete操作。</p><h2 id="5-示例"><a class="markdownIt-Anchor" href="#5-示例"></a> 5、示例</h2><p>1）准备测试数据，创建超女基本信息表T_GIRL，插入5条测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">drop table T_GIRL;</span><br><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 指定id为表的主键</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2）创建SQL日志表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drop table T_SQL_LOG;</span><br><span class="line"><span class="function">create table <span class="title">T_SQL_LOG</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  tname    varchar2(<span class="number">10</span>),        -- 原表的表名。</span></span></span><br><span class="line"><span class="params"><span class="function">  srcrowid rowid,               -- 原表rowid。</span></span></span><br><span class="line"><span class="params"><span class="function">  sqltype  number(<span class="number">1</span>),           -- SQL语句的类型：<span class="number">1</span>-insert、<span class="number">2</span>-update、<span class="number">3</span>-<span class="keyword">delete</span>。</span></span></span><br><span class="line"><span class="params"><span class="function">  trname  varchar2(<span class="number">10</span>)          -- 触发器名。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>3）创建语触发器TR_GIRL_1，如果对T_GIRL表做了insert、update和delete操作，把操作记录在T_SQL_LOG表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace trigger TR_GIRL_1</span></span><br><span class="line"><span class="function">  before update <span class="keyword">or</span> <span class="keyword">delete</span> <span class="keyword">or</span> insert</span></span><br><span class="line"><span class="function">  on T_GIRL</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> inserting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,null,<span class="number">1</span>,<span class="string">&#x27;TR_GIRL_1&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> updating then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,null,<span class="number">2</span>,<span class="string">&#x27;TR_GIRL_1&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> deleting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,null,<span class="number">3</span>,<span class="string">&#x27;TR_GIRL_1&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>4）创建行级语触发器TR_GIRL_2，如果对T_GIRL表做了insert、update和delete操作，把每一行的操作记录在T_SQL_LOG表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace trigger TR_GIRL_2</span></span><br><span class="line"><span class="function">  before update <span class="keyword">or</span> <span class="keyword">delete</span> <span class="keyword">or</span> insert</span></span><br><span class="line"><span class="function">  on T_GIRL <span class="keyword">for</span> each row</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> inserting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">1</span>,<span class="string">&#x27;TR_GIRL_2&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> updating then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">2</span>,<span class="string">&#x27;TR_GIRL_2&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> deleting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:old.rowid,<span class="number">3</span>,<span class="string">&#x27;TR_GIRL_2&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>5）执行一条delete语句，从T_GIRL表中删除两行记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delete</span> from T_GIRL where id <span class="title">in</span> <span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;0102&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>6）查看T_SQL_LOG表中的结果。</p><p><img src="https://img-blog.csdnimg.cn/20200311161439586.png" alt="在这里插入图片描述" /></p><h1 id="三-ddl触发器"><a class="markdownIt-Anchor" href="#三-ddl触发器"></a> 三、DDL触发器</h1><p>当执行DDL语句时会被触发。按照作用范围，分为schema trigger,database trigger。schema trigger作用在一个用户上，database trigger作用在整个数据库所有用户上。</p><p>常用的DDL操作有：grant（授权），revoke（撤销授权），create（创建），drop（删除），alter（修改），comment（注释），audit（审核），rename（重命名）等。</p><h2 id="1-ddl触发器语法"><a class="markdownIt-Anchor" href="#1-ddl触发器语法"></a> 1、DDL触发器语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] trigger 用户名.触发器名</span><br><span class="line">       &#123;before|after&#125; &#123;DDL事件&#125; on &#123;database|schema&#125;</span><br><span class="line">       [when 条件]</span><br><span class="line">declare</span><br><span class="line">  定义变量。</span><br><span class="line">begin</span><br><span class="line">  PL/SQL语句块。</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><code>&#123;before|after&#125;</code>：触发器是在DDL事件之前、之后触发。</p><p><code>&#123;database|schema&#125;</code>：作用在一个用户上，还是全部的用户。</p><p><code>[when 条件]</code>：只有满足when指定的条件，才会执行触发体中的代码，应用场景极少。</p><h2 id="2-ddl事件"><a class="markdownIt-Anchor" href="#2-ddl事件"></a> 2、DDL事件</h2><table><thead><tr><th>DDL事件</th><th>触发时机</th></tr></thead><tbody><tr><td>DDL</td><td>列表中所用的事件都会触发。</td></tr><tr><td>ALTER</td><td>对数据库中的任何一个对象使用SQL的ALTER命令时触发。</td></tr><tr><td>ANALYZE</td><td>对数据库中的任何一个对象使用SQL的ANALYZE命令时触发。</td></tr><tr><td>ASSOCIATE STATISTICS</td><td>统计数据关联到数据库对象时触发。</td></tr><tr><td>AUDIT</td><td>通过SQL的AUDIT命令打开审计时触发。</td></tr><tr><td>COMMENT</td><td>对数据库对象做注释时触发。</td></tr><tr><td>CREATE</td><td>通过SQL的CREATE命令创建数据库对象时触发。</td></tr><tr><td>DISASSOCIATE STATISTICS</td><td>去掉统计数据和数据库对象的关联时触发。</td></tr><tr><td>DROP</td><td>通过SQL的DROP命令删除数据库对象时触发。</td></tr><tr><td>GRANT</td><td>通过SQL的GRANT命令赋权时触发。</td></tr><tr><td>NOAUDIT</td><td>通过SQL的NOAUDIT关闭审计时触发。</td></tr><tr><td>RENAME</td><td>通过SQL的RENAME命令对对象重命名时触发。</td></tr><tr><td>REVOKE</td><td>通过SQL的REVOKE语句撤销授权时触发。</td></tr><tr><td>TRUNCATE</td><td>通过SQL的TRUNCATE语句截断表时触发。</td></tr></tbody></table><h2 id="3-可用属性"><a class="markdownIt-Anchor" href="#3-可用属性"></a> 3、可用属性</h2><table><thead><tr><th>函数名</th><th>返回值</th></tr></thead><tbody><tr><td>ORA_CLIENT_IP_ADDRESS</td><td>客户端IP地址。</td></tr><tr><td>ORA_DATABASE_NAME</td><td>数据库名称。</td></tr><tr><td>ORA_DES_ENCRYPTED_PASSWORD</td><td>当前用户的DES算法加密后的密码。</td></tr><tr><td>ORA_DICT_OBJ_NAME</td><td>触发DDL的数据库对象名称。</td></tr><tr><td>ORA_DICT_OBJ_NAME_LIST</td><td>受影响的对象数量和名称列表。</td></tr><tr><td>ORA_DICT_OBJ_OWNER</td><td>触发DDL的数据库对象属主。</td></tr><tr><td>ORA_DICT_OBJ_OWNER_LIST</td><td>受影响的对象数量和名称列表。</td></tr><tr><td>ORA_DICT_OBJ_TYPE</td><td>触发DDL的数据库对象类型。</td></tr><tr><td>ORA_GRANTEE</td><td>被授权人数量。</td></tr><tr><td>ORA_INSTANCE_NUM</td><td>数据库实例数量。</td></tr><tr><td>ORA_IS_ALTER_COLUMN</td><td>如果操作的参数column_name指定的列，返回true,否则false。</td></tr><tr><td>ORA_IS_CREATING_NESTED_TABLE</td><td>如果正在创建一个嵌套表则返回true,否则false。</td></tr><tr><td>ORA_IS_DROP_COLUMN</td><td>如果删除的参数column_name指定的列，返回true,否则false。</td></tr><tr><td>ORA_LOGIN_USER</td><td>触发器所在的用户名。</td></tr><tr><td>ORA_PARTITION_POS</td><td>SQL命令中可以正确添加分区子句位置。</td></tr><tr><td>ORA_PRIVILEGE_LIST</td><td>授予或者回收的权限的数量。</td></tr><tr><td>ORA_REVOKEE</td><td>被回收者的数量。</td></tr><tr><td>ORA_SQL_TXT</td><td>触发了触发器的SQL语句的行数。</td></tr><tr><td>ORA_SYSEVENT</td><td>导致DDL触发器被触发的时间。</td></tr><tr><td>ORA_WITH_GRANT_OPTION</td><td>如果授权带有grant选项，返回true。否则false。</td></tr></tbody></table><h2 id="4-示例"><a class="markdownIt-Anchor" href="#4-示例"></a> 4、示例</h2><p>限制scott用户的DLL操作，创建数据库对象时发出警告，删除数据库对象时阻止。</p><p>1）创建触发器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace trigger scott.no_drop</span><br><span class="line">  before ddl on schema</span><br><span class="line">begin</span><br><span class="line">  <span class="keyword">if</span> ora_sysevent=<span class="string">&#x27;CREATE&#x27;</span> then</span><br><span class="line">    dbms_output.<span class="built_in">put_line</span>(<span class="string">&#x27;Warning !!! You have created a &#x27;</span>||</span><br><span class="line">                         ORA_DICT_OBJ_TYPE||<span class="string">&#x27; called &#x27;</span>||</span><br><span class="line">                         ORA_DICT_OBJ_NAME|| <span class="string">&#x27;; UserName:&#x27;</span>||</span><br><span class="line">                         ORA_DICT_OBJ_OWNER||<span class="string">&#x27;; IP:&#x27;</span>||</span><br><span class="line">                         ORA_CLIENT_IP_ADDRESS||<span class="string">&#x27;; event:&#x27;</span>||</span><br><span class="line">                         ORA_SYSEVENT);</span><br><span class="line">  elsif ora_sysevent=<span class="string">&#x27;DROP&#x27;</span> then</span><br><span class="line">    <span class="built_in">RAISE_APPLICATION_ERROR</span>(<span class="number">-20000</span>,<span class="string">&#x27;Cannot drop the &#x27;</span>||</span><br><span class="line">                            ORA_DICT_OBJ_TYPE||<span class="string">&#x27; named &#x27;</span>||</span><br><span class="line">                            ORA_DICT_OBJ_NAME ||<span class="string">&#x27; as requested by &#x27;</span>||</span><br><span class="line">                            ORA_DICT_OBJ_OWNER);</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>2）测试触器（创建表），用scott用户登录。</p><p>在上面创建的触发器中用到了dbms_output，在sqlplus中要先执行set serveroutput on;才能输出内容。</p><p><img src="https://img-blog.csdnimg.cn/2020031116163427.png" alt="在这里插入图片描述" /></p><p>3）测试删除表，用scott用户登录。</p><p><img src="https://img-blog.csdnimg.cn/20200311161713243.png" alt="在这里插入图片描述" /></p><p>4）测试删除表，用DBA用户登录，no_drop触发器只限scott用户，不限制其它用户。</p><p><img src="https://img-blog.csdnimg.cn/20200311161723233.png" alt="在这里插入图片描述" /></p><h1 id="四-替代触发器"><a class="markdownIt-Anchor" href="#四-替代触发器"></a> 四、替代触发器</h1><p>DML触发器只能应用在表上。而替代触发器只能定义在视图上。当对一个不能修改的视图进行数据的修改时，或者要修改视图中的某个嵌套表时，可以使用替代触发器。</p><p>替代触发器，又称为instead of触发器，它会替代原来的数据操作语句的执行，更改为使用在触发器中定义的语句来执行数据操作。一些简单的单表视图，可以直接insert、update，但如果要对复杂的视图进行insert、update，可以通过替代触发器，将这些DML语句对视图的更改替换为对基表的DML操作。</p><p>替代触发器的应用场景极少，我个人认为完全没有必要这么麻烦，所以就只介绍一下它的概念。</p><h1 id="五-系统触发器"><a class="markdownIt-Anchor" href="#五-系统触发器"></a> 五、系统触发器</h1><p>系统触发器是由Oracle数据库系统事件所触发的触发器，共有六个数据库事件触发器：startup、shutdown、logon、logoff、servererror 和 db_role_change。</p><p>如果我们需要记录用户登陆系统的信息，或在系统启动或用户登陆后对数据库进行一些设置，可以用系统触发器来实现。</p><p>创建系统触发器的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] trigger 用户名.触发器名</span><br><span class="line">       &#123;before|after&#125; &#123;数据事件&#125;</span><br><span class="line">       on &#123;database|schema&#125;</span><br><span class="line">declare</span><br><span class="line">  定义变量。</span><br><span class="line">begin</span><br><span class="line">  PL/SQL语句块。</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h2 id="1-数据库启动startup"><a class="markdownIt-Anchor" href="#1-数据库启动startup"></a> 1、数据库启动（startup）</h2><p>数据库打开时（alter database open）触发，没有before startup触发器。</p><h2 id="2-数据库关闭shutdown"><a class="markdownIt-Anchor" href="#2-数据库关闭shutdown"></a> 2、数据库关闭（shutdown）</h2><p>数据库正常关闭时触发，没有after shutdown 触发器。</p><p>只有在正常关闭情况下，shutdown nomal或者shutdown immediate时触发，非正常关闭shutdown abort不能触发。</p><h2 id="3-新建会话logon"><a class="markdownIt-Anchor" href="#3-新建会话logon"></a> 3、新建会话（logon）</h2><p>当开始一个数据库会话时触发，没有before logon触发器。</p><h2 id="4-注销会话logoff"><a class="markdownIt-Anchor" href="#4-注销会话logoff"></a> 4、注销会话（logoff）</h2><p>当一个数据库会话正常终止时触发，没有after logoff触发器。</p><h2 id="5-servererror"><a class="markdownIt-Anchor" href="#5-servererror"></a> 5、servererror</h2><p>当数据库发生错误时触发，没有before servererror触发器。</p><h2 id="6-db_role_change"><a class="markdownIt-Anchor" href="#6-db_role_change"></a> 6、db_role_change</h2><p>当主数据库和备用数据库切换时触发，用于dataguard。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle存储过程</title>
      <link href="/post/6fb0b350.html"/>
      <url>/post/6fb0b350.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-存储过程的概念"><a class="markdownIt-Anchor" href="#一-存储过程的概念"></a> 一、存储过程的概念</h1><p>存储过程（stored procedure）是Oracle数据库中为了完成某功能的PL/SQL代码集，就像没有返回值的自定义函数。</p><h1 id="二-存储过程的创建-调用和权限"><a class="markdownIt-Anchor" href="#二-存储过程的创建-调用和权限"></a> 二、存储过程的创建、调用和权限</h1><h2 id="1-创建存储过程"><a class="markdownIt-Anchor" href="#1-创建存储过程"></a> 1、创建存储过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace procedure 存储过程名(参数<span class="number">1</span> 模式 数据类型,......)</span><br><span class="line">as/is</span><br><span class="line">  -- 定义局部变量</span><br><span class="line">  变量<span class="number">1</span> 数据类型;</span><br><span class="line">  ......</span><br><span class="line">begin</span><br><span class="line">  -- 实现存储过程功能的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">  exception</span><br><span class="line">  -- 异常处理的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>1）参数的模式有三种：</p><p><strong>in</strong>：只读模式，在函数中，参数只能被引用/读取，不能改变它的值。</p><p><strong>out</strong>：只写模式，参数只能被赋值，不能被引用/读取。</p><p><strong>in out</strong>：可读可写。</p><p>参数的模式可以不写，缺省为in，out和in out两种模式极少使用。</p><p>2）as/is二选一，在这里没有区别。</p><p>3）可以不定义局部变量。</p><p>4）可以没有异常（exception）处理代码段。</p><p>示例：</p><p>1）生成测试数据，脚本如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2）创建存储过程girlinfo，传入超女id参数，显示超女的基本信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace procedure <span class="title">girlinfo</span><span class="params">(in_id varchar2)</span></span></span><br><span class="line"><span class="function">is</span></span><br><span class="line"><span class="function">  s_name      <span class="title">varchar2</span><span class="params">(<span class="number">30</span>)</span></span>;   -- 姓名</span><br><span class="line">  <span class="function">s_yz        <span class="title">varchar2</span><span class="params">(<span class="number">20</span>)</span></span>;   -- 颜值</span><br><span class="line">  <span class="function">s_height    <span class="title">number</span><span class="params">(<span class="number">3</span>)</span></span>;      -- 身高</span><br><span class="line">begin</span><br><span class="line">  select name,yz,height into s_name,s_yz,s_height from T_GIRL where id=in_id;</span><br><span class="line">  dbms_output.<span class="built_in">put_line</span>(<span class="string">&#x27;姓名：&#x27;</span>||s_name||<span class="string">&#x27;颜值：&#x27;</span>||s_yz||<span class="string">&#x27;身高：&#x27;</span>||s_height);</span><br><span class="line">  exception                           </span><br><span class="line">  when others then</span><br><span class="line">  dbms_output.<span class="built_in">put_line</span>(<span class="string">&#x27;输入的id（&#x27;</span>||in_id||<span class="string">&#x27;）不正确，查询无结果。&#x27;</span>);</span><br><span class="line">end;                           </span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311154427466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-存储过程的调用"><a class="markdownIt-Anchor" href="#2-存储过程的调用"></a> 2、存储过程的调用</h2><p>1）直接执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec 存储过程名(参数,……);</span><br><span class="line">execute 存储过程名(参数,……);</span><br></pre></td></tr></table></figure><p>例如：</p><p>在上面创建的存储过程中用到了dbms_output，在sqlplus中要先执行set serveroutput on;才能输出内容。</p><p><img src="https://img-blog.csdnimg.cn/20200311154457646.png" alt="在这里插入图片描述" /></p><p>2）在PL/SQL过程中调用</p><p><img src="https://img-blog.csdnimg.cn/20200311154508430.png" alt="在这里插入图片描述" /></p><h2 id="3-存储过程的权限"><a class="markdownIt-Anchor" href="#3-存储过程的权限"></a> 3、存储过程的权限</h2><p>存储过程是数据库对象，Oracle对它权限管理方式与其它数据库对象相同。</p><p>如果getinfo函数是用scott用户创建的，其它用户调用时需要加scott用户名前缀，并且具备相应的权限，否则会出现“<code>PLS-00201:必须声明标识符 'GIRLINFO'</code>”的错误。</p><h1 id="三-删除存储过程"><a class="markdownIt-Anchor" href="#三-删除存储过程"></a> 三、删除存储过程</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure 存储过程名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure girlinfo;</span><br></pre></td></tr></table></figure><h1 id="四-plsql语言"><a class="markdownIt-Anchor" href="#四-plsql语言"></a> 四、PL/SQL语言</h1><p>PL/SQL是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）包括一整套的数据类型、条件结构、循环结构和异常处理结构，PL/SQL可以执行SQL语句，SQL语句中也可以使用PL/SQL函数。</p><p>PL/SQL是Oracle数据库对SQL语句的扩展，在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。</p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>关于存储过程的优缺点，本人查找了一些资料，以下文字来源于百度百科。</p><h2 id="1-存储过程的优点"><a class="markdownIt-Anchor" href="#1-存储过程的优点"></a> 1、存储过程的优点</h2><p>1）重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</p><p>2）存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</p><p>3）参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程，提高了安全性。</p><p>4）存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</p><h2 id="2-存储过程的缺点"><a class="markdownIt-Anchor" href="#2-存储过程的缺点"></a> 2、存储过程的缺点</h2><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="3-我的看法"><a class="markdownIt-Anchor" href="#3-我的看法"></a> 3、我的看法</h2><p>1）存储过程不会有任何性能的优势。</p><p>2）调用远程存储过程减少网络流量的说活太牵强，并且，调用远程存储过程的风险很大。</p><p>3）存储过程不能减少开发的工作量，PL/SQL也是一种开发语言，对开发者来说，要付出学习成本。</p><p>4）存储过程的调试、重新编译、兼容、维护等问题，任何一项都是很麻烦。</p><p>存储过程没有任何优点，作为一个程序员，我从来不用存储过程，大家对于这方面的知识了解即可，不必深入学习。</p><h1 id="六-oracle的包"><a class="markdownIt-Anchor" href="#六-oracle的包"></a> 六、Oracle的包</h1><p>PL/SQL为了满足程序模块化的需要，引入了包的构造，把存储过程、函数组合起来就成了包，通过使用包就可以分类管理存储过程和函数。有点类似C++中的命名空间。存储过程的应用场景已经很少，包就更少了。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle自定义函数</title>
      <link href="/post/32c920a8.html"/>
      <url>/post/32c920a8.html</url>
      
        <content type="html"><![CDATA[<p>在Oracle数据库中，为了实现特定的功能，可以自定义函数，就像C/C++语言，除了系统的库函数，程序员还会编写很多自定义的函数。</p><h1 id="一-函数的创建-调用和权限"><a class="markdownIt-Anchor" href="#一-函数的创建-调用和权限"></a> 一、函数的创建、调用和权限</h1><h2 id="1-创建函数"><a class="markdownIt-Anchor" href="#1-创建函数"></a> 1、创建函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace function 函数名(参数<span class="number">1</span> 模式 数据类型,......) <span class="keyword">return</span> 数据类型</span><br><span class="line">as</span><br><span class="line">  -- 定义局部变量。</span><br><span class="line">  变量<span class="number">1</span> 数据类型;</span><br><span class="line">  ......</span><br><span class="line">begin</span><br><span class="line">  -- 实现函数功能的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">  exception</span><br><span class="line">  -- 异常处理的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>1）参数的模式有三种：</p><p><strong>in</strong>：只读模式，在函数中，参数只能被引用/读取，不能改变它的值。</p><p><strong>out</strong>：只写模式，参数只能被赋值，不能被引用/读取。</p><p><strong>in out</strong>：可读可写。</p><p>参数的模式可以不写，缺省为in，out和in out两种模式极少使用。</p><p>2）as/is二选一，在这里没有区别。</p><p>3）可以不定义局部变量。</p><p>4）可以没有异常（exception）处理代码段。</p><p>示例，创建自定义函数maxvalue，用于比较两个数字的大小，返回较大值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace function <span class="title">maxvalue</span><span class="params">(val1 number,val2 number)</span> <span class="keyword">return</span> number</span></span><br><span class="line"><span class="function">as</span></span><br><span class="line"><span class="function">  val number</span>;   -- 定义局部变量，存放返回值。</span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(val1&gt;val2)</span> then    -- 判断传入参数的大小。</span></span><br><span class="line"><span class="function">      val:=</span>val1;         -- 赋值是<span class="string">&quot;:=&quot;</span>，不是<span class="string">&quot;=&quot;</span>。</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      val:=val2;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> val;  -- 返回</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311151802685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-函数的调用"><a class="markdownIt-Anchor" href="#2-函数的调用"></a> 2、函数的调用</h2><p>自定义函数的调用与Oracle数据库自带的函数调用的方法相同。</p><p><img src="https://img-blog.csdnimg.cn/20200311151816763.png" alt="在这里插入图片描述" /></p><h2 id="3-函数的权限"><a class="markdownIt-Anchor" href="#3-函数的权限"></a> 3、函数的权限</h2><p>自定义函数是数据库对象，Oracle对它权限管理方式与其它数据库对象相同。</p><p>如果maxvalue函数是用scott用户创建的，其它用户调用时需要加scott用户名前缀，并且具备相应的权限，否则会出现“<code>ORA-00904:&quot;MAXVALUE&quot;: 标识符无效</code>”的错误。</p><h1 id="二-删除自定义函数"><a class="markdownIt-Anchor" href="#二-删除自定义函数"></a> 二、删除自定义函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop function maxvalue;</span><br></pre></td></tr></table></figure><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>数据库的自定义函数不会像编程语言的函数那样广泛的应用，和编程语言相比，数据库的自定义函数实在太麻烦，很啰嗦，难以调试，数据库自定义函数能做到的功能编程语言都能做到。</p><p>我使用自定义函数的目的只有一个，就是解决不同数据库的兼容性问题，例如序列生成器，Oracle、MySQL和PostgreSQL的调用方法各不同，那么我们可以编写自定义函数，在不同的数据库中，函数名和参数完全相同，函数体代码不同，这样就可以解决软件的兼容性问题。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle常用函数</title>
      <link href="/post/316fbd2.html"/>
      <url>/post/316fbd2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-oracle的函数"><a class="markdownIt-Anchor" href="#一-oracle的函数"></a> 一、Oracle的函数</h1><p>Oracle提供了很多函数用于数据的处理、统计和转换，这些函数增强了SQL语言的功能。</p><p>Oracle的函数分为单行函数、聚合函数和分析函数三大类。</p><h2 id="1-单行函数"><a class="markdownIt-Anchor" href="#1-单行函数"></a> 1、单行函数</h2><p>单行函数应用于SQL语句中时，只能输入一个数据，返回一个结果，常用的单行函数包括字符串函数、数字函数、日期函数、转换函数。</p><h2 id="2-聚合函数"><a class="markdownIt-Anchor" href="#2-聚合函数"></a> 2、聚合函数</h2><p>聚合函数应用于SQL语句中时，同时对多行数据进行操作，返回一个结果，例如求结果集的记录数、最小值、最大值、平均值、统计值等。</p><h2 id="3-分析函数"><a class="markdownIt-Anchor" href="#3-分析函数"></a> 3、分析函数</h2><p>分析函数用于计算基于分组的某种聚合值，它和聚合函数的不同之处是对于每个组返回多行，而聚合函数对于每个组只返回一行。</p><p>分析函数的应用场景比较少，概念难以理解，本文就不介绍了。</p><h1 id="二-字符串函数"><a class="markdownIt-Anchor" href="#二-字符串函数"></a> 二、字符串函数</h1><p>字符串函数接受字符串参数，参数可以是表中的列名，也可以是字符串表达式或字符串常量。</p><h2 id="1-ascii码转换ascii和chr"><a class="markdownIt-Anchor" href="#1-ascii码转换ascii和chr"></a> 1、ASCII码转换ascii和chr</h2><p><strong>ascii(str)</strong>：返回字符串str第一个字符的ASCII码值。</p><p><strong>chr(ii)</strong>：返回ASCII码为数字ii的字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311141701184.png" alt="在这里插入图片描述" /></p><h2 id="2-字符串拼接concat"><a class="markdownIt-Anchor" href="#2-字符串拼接concat"></a> 2、字符串拼接concat</h2><p><strong>concat(str1,str2)</strong>：把字符串str1和str2拼接成一个字符串，在实际应用中，我们更愿意用||拼接字符串，因为||可以拼接多个字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200311141721326.png" alt="在这里插入图片描述" /></p><h2 id="3-字符串查找instr"><a class="markdownIt-Anchor" href="#3-字符串查找instr"></a> 3、字符串查找instr</h2><p><strong>instr(str1,str2,start,n)</strong>：在字符串str1中查找str2。</p><p>start：从str1的哪个位置开始查找，可选参数，缺省为1。如果start为正数，从左到右查找，如果start为负数，从右到左查找。</p><p>n表示要查找第几次出现的str2，可选参数，缺省为1，如果为负数系统会报错。</p><p><img src="https://img-blog.csdnimg.cn/20200311141809581.png" alt="在这里插入图片描述" /></p><h2 id="4-字符串的长度length"><a class="markdownIt-Anchor" href="#4-字符串的长度length"></a> 4、字符串的长度length</h2><p><strong>length (str)</strong>：返回字符串str的长度。</p><p><img src="https://img-blog.csdnimg.cn/20200311141901793.png" alt="在这里插入图片描述" /></p><h2 id="5-字符串大小写转换lower和upper"><a class="markdownIt-Anchor" href="#5-字符串大小写转换lower和upper"></a> 5、字符串大小写转换lower和upper</h2><p><strong>lower (str)</strong>：把字符串str转换为小写，忽略不是字母的字符。</p><p><strong>upper (str)</strong>：把字符串str转换为大写，忽略不是字母的字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311141917260.png" alt="在这里插入图片描述" /></p><h2 id="6-截去字符串ltrim-rtrim和trim"><a class="markdownIt-Anchor" href="#6-截去字符串ltrim-rtrim和trim"></a> 6、截去字符串ltrim、rtrim和trim</h2><p><strong>ltrim(str1,str2)</strong>：从字符串str1的左边截去字符串str2，str2是可选参数，缺省为空格。</p><p><strong>rtrim(str1,str2)</strong>：从字符串str1的右边截去字符串str2，str2是可选参数，缺省为空格。</p><p><strong>trim(leading|trailing|both chr from str)</strong>：从str中截去 <strong>左侧|右侧|两侧</strong>的chr字符，缺省是both（两侧），注意，chr是单个字符，不是字符串，缺省是空格。</p><p><img src="https://img-blog.csdnimg.cn/20200311141932899.png" alt="在这里插入图片描述" /></p><h2 id="7-字符串替换replace"><a class="markdownIt-Anchor" href="#7-字符串替换replace"></a> 7、字符串替换replace</h2><p><strong>replace(str,old,new)</strong>：把字符串str中的old字符串替换成new字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200311141947490.png" alt="在这里插入图片描述" /></p><h2 id="8-字符串截取substr"><a class="markdownIt-Anchor" href="#8-字符串截取substr"></a> 8、字符串截取substr</h2><p><strong>substr(str,start,len)</strong>：从字符串str的start位置开始，截取len个字符，如果len不填就截取start之后全部的字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311142137950.png" alt="在这里插入图片描述" /></p><h2 id="9-字符串补齐lpad的rpad"><a class="markdownIt-Anchor" href="#9-字符串补齐lpad的rpad"></a> 9、字符串补齐lpad的rpad</h2><p>lpad(str,len,[chr])，从左边补齐。</p><p>rpad(str,len,[chr])，从右边补齐。</p><p>str：待补齐的原字符串。</p><p>len：最终返回的字符串的长度，如果最终返回的字符串的长度比源字符串的小，那么此函数将对源串进行截断处理。</p><p>chr：用于填充的字符，缺省为空字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311142155572.png" alt="在这里插入图片描述" /></p><h1 id="三-数字函数"><a class="markdownIt-Anchor" href="#三-数字函数"></a> 三、数字函数</h1><p>数字函数接受数字参数，参数可以是表中的列名，也可以是数字表达式或数字常量。</p><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>abs(x)</td><td>x绝对值。</td><td>abs(-10)=10</td></tr><tr><td>cos(x)</td><td>余弦。</td><td>cos(1)= 0.540302306</td></tr><tr><td>acos(x)</td><td>x的反余弦。</td><td>acos(1)=0</td></tr><tr><td>ceil(x)</td><td>大于或等于x的最小整数。</td><td>ceil(3.14)=4</td></tr><tr><td>floor(x)</td><td>小于或等于x的最大整数。</td><td>floor(3.14)=3</td></tr><tr><td>log(x,y)</td><td>x为底y的对数。</td><td>log(2,4)=2</td></tr><tr><td>mod(x,y)</td><td>x除以y的余数。</td><td>mod(7,3)=1</td></tr><tr><td>power(x,y)</td><td>x的y次幂。</td><td>power(2,4)=16</td></tr><tr><td>round(x,y)</td><td>x在第y小数位四舍五入。</td><td>round(3.1415,3)=3.142</td></tr><tr><td>sign(x)</td><td>判断x的值，大于0返回1，等于0返回0，小于0返回-1。</td><td>sign(100)=1、sign(0)=0、sign(-100)=-1</td></tr><tr><td>sqrt(x)</td><td>x的平方根。</td><td>sqrt(9)=3</td></tr><tr><td>trunc(x,y)</td><td>x在第y位截断。</td><td>trunc(3.14159,3)=3.141</td></tr></tbody></table><p>补充说明：</p><p>1）round函数</p><p>round(x[,y])，四舍五入函数。</p><p>y的缺省值0，例如：round(3.14)=3、round(3.56)=4。</p><p>y是正整数，四舍五入到小数点后y位，例如：round(3.14159,3)=3.142。</p><p>y是负整数，四舍五入到小数点左边y位，round(314.159,-2)=300。</p><p>2）trunc函数</p><p>trunc(x[,y])，直接截断，不四舍五入。</p><p>y的缺省值0，例如：trunc(3.14)=3。</p><p>y是正整数，小数点y位后截断，trunc(3.141592,3)=3.141。</p><p>y是负整数，小数点y位前截断。trunc(314.159,-2)=300。</p><h1 id="四-日期函数"><a class="markdownIt-Anchor" href="#四-日期函数"></a> 四、日期函数</h1><p>Oracle的日期函数极其重要，在《Oracle日期函数》文章中有详细的说明。</p><h1 id="五-转换函数"><a class="markdownIt-Anchor" href="#五-转换函数"></a> 五、转换函数</h1><p>Oracle的数据类型转换主要有三种：1）日期与字符串；2）rowid与字符串；3）数字与字符串。</p><h2 id="1-日期和字符串之间的转换"><a class="markdownIt-Anchor" href="#1-日期和字符串之间的转换"></a> 1、日期和字符串之间的转换</h2><p>日期与字符串的转换用to_date和to_char函数完成，在《Oracle日期函数》文章中有详细的说明。</p><h2 id="2-rowid和字符串之间的转换"><a class="markdownIt-Anchor" href="#2-rowid和字符串之间的转换"></a> 2、rowid和字符串之间的转换</h2><p>Oracle数据库能隐式的在rowid和字符串之间的转换。</p><h2 id="3-数字和字符串之间的转换"><a class="markdownIt-Anchor" href="#3-数字和字符串之间的转换"></a> 3、数字和字符串之间的转换</h2><p>Oracle数据库能隐式的在数字和字符串之间的转换，但是要注意几个问题：</p><p>1）任意数字都可以转换成字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200311142342179.png" alt="在这里插入图片描述" /></p><p>2）只有包含了合法数字的字符串才能转换为数字，否则提示错误。</p><p><img src="https://img-blog.csdnimg.cn/20200311142403500.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200311142413441.png" alt="在这里插入图片描述" /></p><p>3）空字符串转换为数字后是null，不是0，这个特点太棒了。</p><p><img src="https://img-blog.csdnimg.cn/20200311142451680.png" alt="在这里插入图片描述" /></p><p>还有，Oracle提供了to_number函数把字符串转换为数字，to_number支持多种格式，用法比较复杂，不建议使用。</p><h1 id="六-其它的单行函数"><a class="markdownIt-Anchor" href="#六-其它的单行函数"></a> 六、其它的单行函数</h1><h2 id="1-nvl函数"><a class="markdownIt-Anchor" href="#1-nvl函数"></a> 1、nvl函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NVL2</span>(x,value)</span><br></pre></td></tr></table></figure><p>如果x为空，返回value，否则返回x。</p><p>示例，运行以下脚本生成测试数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span><span class="params">(name varchar2(<span class="number">20</span>),age number(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;杨玉环&#x27;</span>,null)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(null,<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">select <span class="title">nvl</span><span class="params">(name,<span class="string">&#x27;匿名美女&#x27;</span>)</span>,<span class="title">nvl</span><span class="params">(age,<span class="number">0</span>)</span> from tt</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311142608633.png" alt="在这里插入图片描述" /></p><h2 id="2-decode函数"><a class="markdownIt-Anchor" href="#2-decode函数"></a> 2、decode函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decode</span>(条件,值<span class="number">1</span>,返回值<span class="number">1</span>,值<span class="number">2</span>,返回值<span class="number">2</span>,......,值n,返回值n,缺省值)</span><br></pre></td></tr></table></figure><p>该函数的含义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件==值<span class="number">1</span>) <span class="keyword">return</span> 返回值<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件==值<span class="number">2</span>) <span class="keyword">return</span> 返回值<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件==值<span class="number">3</span>) <span class="keyword">return</span> 返回值<span class="number">3</span>;</span><br><span class="line">  ......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> 缺省值;</span><br></pre></td></tr></table></figure><p>示例，运行以下脚本生成测试数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span><span class="params">(name varchar2(<span class="number">20</span>),yz number(<span class="number">1</span>),sc number(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;杨玉环&#x27;</span>,<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;夏姬&#x27;</span>,<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">select name,<span class="built_in">decode</span>(yz,<span class="number">1</span>,<span class="string">&#x27;漂亮&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;可爱&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;狐媚&#x27;</span>,<span class="string">&#x27;不合格&#x27;</span>),<span class="built_in">decode</span>(sc,<span class="number">1</span>,<span class="string">&#x27;丰满&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;火辣&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;苗条&#x27;</span>,<span class="string">&#x27;不及格&#x27;</span>) from tt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311142730243.png" alt="在这里插入图片描述" /></p><h2 id="3-userenv函数"><a class="markdownIt-Anchor" href="#3-userenv函数"></a> 3、userenv函数</h2><p>userenv(string)，获取当前用户会话的信息。</p><p>string的取值如下：</p><p>isdba，如果用户已经被认证为DBA或者是通过操作系统或口令文件具有DBA特权的，返回TRUE，否则返回FALSE。</p><p>language，返回数据库当前会话的语言、地域和字符集。</p><p>lang，返回ISO缩写语言名称，一个比现有的“语言”参数较短的形式。</p><p>sid ，返回数据库会话ID。</p><p>terminal，返回当前会话的终端操作系统的标识符。在分布式SQL语句，此参数返回了标识符为本地会话。在分布式环境中，此参数只支持远程SELECT语句，不用于远程INSERT，UPDATE或DELETE操作。</p><p>sessionid，返回审计会话标识符，在分布式SQL语句不能指定此参数。</p><p>client_info，返回最高可达64个字节存储的用户会话信息，可由应用程序使用DBMS_APPLICATION_INFO包。</p><p>entryid，返回当前审计条目编号，审计的EntryID序列细粒度的审计记录和定期审计记录之间共享，在分布式SQL语句不能使用这个属性。</p><p>测试一下比较常用的几个参数：</p><p><img src="https://img-blog.csdnimg.cn/20200311142754952.png" alt="在这里插入图片描述" /></p><h2 id="4-user函数"><a class="markdownIt-Anchor" href="#4-user函数"></a> 4、user函数</h2><p>查看当前会话的用户名。<br /><img src="https://img-blog.csdnimg.cn/20200311142819234.png" alt="在这里插入图片描述" /></p><h1 id="七-聚合函数"><a class="markdownIt-Anchor" href="#七-聚合函数"></a> 七、聚合函数</h1><p>聚合函数也叫分组函数或集合函数，它对多行记录中的某个列执行计算并返回一个值。</p><p>聚合函数经常与 select 语句的 group<br />by 子句一同使用，所以有的时候也把它称之为分组函数。</p><h2 id="1-分组函数"><a class="markdownIt-Anchor" href="#1-分组函数"></a> 1、分组函数</h2><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>min(x)</td><td>求最小值。</td><td>select min(sal) from EMP;</td></tr><tr><td>max(x)</td><td>求最大值。</td><td>select max(sal) from EMP;</td></tr><tr><td>avg(x)</td><td>求平均值。</td><td>select avg(sal) from EMP;</td></tr><tr><td>sum(x)</td><td>求合计值。</td><td>select sum(sal) from EMP;</td></tr><tr><td>count(*)</td><td>求记录数。</td><td>select count(*) from EMP;</td></tr><tr><td>stddev(x)</td><td>求标准差。</td><td>select stddev(sal) from EMP;</td></tr><tr><td>variance(x)</td><td>求协方差。</td><td>select variance(sal) from EMP;</td></tr><tr><td>median(x)</td><td>求中位数。</td><td>select median(sal) from EMP;</td></tr></tbody></table><p>stddev(x)、variance(x)、median(x)这三个函数极少使用。</p><h2 id="2-空值处理"><a class="markdownIt-Anchor" href="#2-空值处理"></a> 2、空值处理</h2><p>有一点需要注意的是，除了count函数，其它的分组函数均会忽略值为null的列，这个特点极其重要，一定要记住它。</p><p>我们来测试一下，先生成测试数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span><span class="params">(cc number(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(null)</span></span>;</span><br><span class="line"><span class="function">select <span class="title">min</span><span class="params">(cc)</span>,<span class="title">max</span><span class="params">(cc)</span>,<span class="title">avg</span><span class="params">(cc)</span>,<span class="title">sum</span><span class="params">(cc)</span>,<span class="title">count</span><span class="params">(*)</span> from tt</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143059478.png" alt="在这里插入图片描述" /></p><p>注意，表中一共有三条数据，两条非空记录，一条空记录，avg函数得到的结果是(10+20)/2=15，忽略了空值记录，min、max、sum函数表面看不出来，但我们知道它们会忽略空值。</p><p>count函数不会忽略空值记录，除非指定列名，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200311143207208.png" alt="在这里插入图片描述" /></p><h2 id="3-group-by子句"><a class="markdownIt-Anchor" href="#3-group-by子句"></a> 3、group by子句</h2><p>group by子句的意思就是按一定的规则进行分组，把数据集划分成若干个子集，然后针对若干个子集进行数据统计，group by子句要与分组函数结合使用，否则没有意义。</p><p>1）对全部的员工进行统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">min</span><span class="params">(sal)</span>,<span class="title">max</span><span class="params">(sal)</span>,<span class="title">avg</span><span class="params">(sal)</span>,<span class="title">sum</span><span class="params">(sal)</span>,<span class="title">count</span><span class="params">(*)</span> from EMP</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143239452.png" alt="在这里插入图片描述" /></p><p>2）按部门分类（组）统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">min</span>(sal),<span class="built_in">max</span>(sal),<span class="built_in">avg</span>(sal),<span class="built_in">sum</span>(sal),<span class="built_in">count</span>(*) from EMP group by deptno;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143309281.png" alt="在这里插入图片描述" /></p><p>在上面的示例中，select的字段列表中有deptno，那么在group by后面一定也要有deptno，否则会出现语法错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">min</span>(sal),<span class="built_in">max</span>(sal),<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) from EMP;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143411802.png" alt="在这里插入图片描述" /></p><p>但是，在group by中有deptno，select的字段列表中可以没有deptno，不会出现语法错误，但这种用法很少。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">min</span><span class="params">(sal)</span>,<span class="title">max</span><span class="params">(sal)</span>,<span class="title">avg</span><span class="params">(sal)</span>,<span class="title">sum</span><span class="params">(sal)</span>,<span class="title">count</span><span class="params">(*)</span> from EMP group by deptno</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143505550.png" alt="在这里插入图片描述" /></p><p>3）按部门和职位分类（组）统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,job,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) from EMP group by deptno,job;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143759516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>4）where子句一定要在group by子句之前，where子句中不能使用分组函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP where deptno <span class="title">in</span> <span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span> group by deptno</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143927800.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP group by deptno where deptno <span class="title">in</span> <span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144002914.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP where <span class="title">avg</span><span class="params">(sal)</span>&gt;1000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144033763.png" alt="在这里插入图片描述" /></p><h2 id="4-having子句"><a class="markdownIt-Anchor" href="#4-having子句"></a> 4、having子句</h2><p>having 子句对 group by统计出来的结果进行筛选，语法与 where 类似，但 having可以包含分组函数。</p><p>1）先按部门分组统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) from EMP group by deptno;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144114208.png" alt="在这里插入图片描述" /></p><p>2）从统计结果中筛选人数&gt;=5的记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP group by deptno having <span class="title">count</span><span class="params">(*)</span>&gt;</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144232805.png" alt="在这里插入图片描述" /></p><p>3）从统计结果中筛选平均公司超过两千并且部门代码等于20的记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP group by deptno having <span class="title">avg</span><span class="params">(sal)</span>&gt;2000 <span class="keyword">and</span> deptno</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144257633.png" alt="在这里插入图片描述" /></p><h1 id="八-应用经验"><a class="markdownIt-Anchor" href="#八-应用经验"></a> 八、应用经验</h1><p>本文介绍了Oracle常用的函数和用法，还有少部分的函数没有介绍，并不是我偷懒，而是没有必要。</p><p>数据库提供函数的目的是为了增强SQL语言的功能，但是我的看法有些不同，从一个程序员的视角，说说我的看法：</p><p>1）手工处理数据的时候，在SQL中使用函数确实可以扩展SQL的功能，我也经常这么做；</p><p>2）不同数据库提供的函数名、参数和功能有差异，从软件项目的兼容性方面考虑，应用程序中能不用函数就不用函数。</p><p>3）在实际开发中，日期转换函数（to_date和to_char）不得不用，但是，我在freecplus框架中已做了兼容性处理。</p><p>4）分组函数也得不用，包括min、max、avg、sum、count，幸运的是不同的数据库基本上兼容，只是细节上也有点差别，不兼容功能的不建议使用。</p><p>所以，大家在学习函数的时候，了解一些常用的、不同数据库能通用的函数即可，不要花太多的时间和精力去研究那些生辟和不通用的函数。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle日期函数</title>
      <link href="/post/1ae6cc41.html"/>
      <url>/post/1ae6cc41.html</url>
      
        <content type="html"><![CDATA[<p>Oracle采用date类型表示日期时间，这是一个7字节的固定宽度的数据类型，有7个属性，包括：世纪、世纪中哪一年、月份、月中的哪一天、小时、分钟和秒。本文中把date类型称为日期时间类型，简称日期。</p><p>对编程语言来说，日期是用字符串来显示和书写的，如果设置了NLS_DATE_FORMAT环境变量，Oracle可以自动的对日期和字符串进行转换，但是，程序员更多的是采用to_char和to_date两个函数对日期和字符串进行转换。</p><h1 id="一-把日期转换为字符串"><a class="markdownIt-Anchor" href="#一-把日期转换为字符串"></a> 一、把日期转换为字符串</h1><p>to_char函数把日期转换成字符串，一般用于 select 和 from 之间的字段列表中的日期输出，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">to_char</span>(日期,格式)</span><br></pre></td></tr></table></figure><p>日期格式用字符串来表达，格式控制标识如下，加粗显示的是常用的格式：</p><p>d：一周中的星期几。</p><p>day：天的名字，使用空格填充到9个字符。</p><p><strong>dd：月中的第几天。</strong></p><p>ddd：年中的第几天。</p><p>dy：天的简写名。</p><p>iw：ISO标准的年中的第几周。</p><p>iyyy：ISO标准的四位年份。</p><p><strong>yyyy：四位年份。</strong></p><p>yyy,yy,y：年份的最后三位，两位，一位。</p><p>hh：小时，按12小时计。</p><p><strong>hh24：小时，按24小时计。</strong></p><p><strong>mi：分。</strong></p><p><strong>ss：秒。</strong></p><p><strong>mm：月。</strong></p><p>mon：月份的简写。</p><p>month：月份的全名。</p><p>w：该月的第几个星期。</p><p>ww：年中的第几个星期。</p><p>举例：</p><p><img src="https://img-blog.csdnimg.cn/20200311093723237.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200311093734968.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311093748155.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311093758239.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311093807249.png" alt="在这里插入图片描述" /></p><h1 id="二-把字符串转换日期"><a class="markdownIt-Anchor" href="#二-把字符串转换日期"></a> 二、把字符串转换日期</h1><p>to_date函数把字符串转换成日期，一般用于insert、update和where之后的条件中的日期输入，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">to_date</span>(字符串表示的日期,格式)</span><br></pre></td></tr></table></figure><p>日期格式用字符串来表达，与to_char函数相同。</p><p>先创建一个用于测试的表tt。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span> <span class="params">( c1 date)</span></span>;</span><br></pre></td></tr></table></figure><p>举列：</p><p><img src="https://img-blog.csdnimg.cn/202003110938454.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/2020031109390665.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/2020031109391937.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200311093952496.png" alt="在这里插入图片描述" /></p><p>在update语句中把字符串转换为日期。</p><p><img src="https://img-blog.csdnimg.cn/20200311100719158.png" alt="在这里插入图片描述" /></p><p>在where条件中把字符串转换为日期。</p><p><img src="https://img-blog.csdnimg.cn/20200311100730350.png" alt="在这里插入图片描述" /></p><h1 id="三-日期运算"><a class="markdownIt-Anchor" href="#三-日期运算"></a> 三、日期运算</h1><p>Oracle数据库提供了多种对日期加减的计算方法。</p><p>为了方便日期的显示，先设置好NLS_DATE_FORMAT环境变量，这个环境变量的用法在本文的“四、日期环境变量”章节中介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_DATE_FORMAT=<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span></span><br></pre></td></tr></table></figure><h2 id="1-直接加减"><a class="markdownIt-Anchor" href="#1-直接加减"></a> 1、直接加减</h2><p>可以在日期上进行加减一个小数（单位是天）得到一个新的时间。</p><p>1）取当前时间和一天后的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311100927909.png" alt="在这里插入图片描述" /></p><p>2）取当前时间和一小时后的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311101234725.png" alt="在这里插入图片描述" /></p><p>3）获取当前时间和一秒后的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311101242961.png" alt="在这里插入图片描述" /></p><h2 id="2-add_months函数"><a class="markdownIt-Anchor" href="#2-add_months函数"></a> 2、add_months函数</h2><p>对日期直接加减的方式不用于月的加减，因为每月的天数不一样，例如2020-01-01，加上30天之后是2020-01-31，不是2020-02-01。如果希望把日期加上一个完整的月（不论月的大小），可以用add_months函数。</p><p><img src="https://img-blog.csdnimg.cn/20200311101327721.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101336789.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101343985.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101356353.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101405524.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-df8b7N0G-1583890413413)(media/d5b79b4d06097b5768b3a66c6c0ce668.png)" /></p><p>从上面的例子可以看出，月有大有小：1）如果下月的天小于本月的天，add_months后取下月的最后一天；2）本月的最后一天加上一个月，就是下个月的最后一天。</p><h2 id="3-last_day函数"><a class="markdownIt-Anchor" href="#3-last_day函数"></a> 3、last_day函数</h2><p>last_day函数得到日期所属月份最后一天的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311101430425.png" alt="在这里插入图片描述" /></p><h2 id="4-其它的日期函数"><a class="markdownIt-Anchor" href="#4-其它的日期函数"></a> 4、其它的日期函数</h2><p>Oracle还提供了其它的日期计算的函数，如months_between、next_day、<a href="https://www.cnblogs.com/xyz0601/p/4417165.html">numtodsinterval和numtoyminterval</a>等，在我看来，这些函数很烦人，实在没有意义，就不介绍了。</p><h1 id="四-日期环境变量"><a class="markdownIt-Anchor" href="#四-日期环境变量"></a> 四、日期环境变量</h1><p>NLS_DATE_FORMAT环境变量指定日期的输入和输入格式，如果字符串的格式与NLS_DATE_FORMAT指定的格式相同，Oracle可以自动转换，不需要to_char和to_date函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_DATE_FORMAT=<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311102139300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_DATE_FORMAT=<span class="string">&quot;yyyymmddhh24miss&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311102226516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>从上图的运行结果看出，修改NLS_DATE_FORMAT环境变量后，如果输入的日期格式不符，Oracle无法识别。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle序列生成器</title>
      <link href="/post/539e49a0.html"/>
      <url>/post/539e49a0.html</url>
      
        <content type="html"><![CDATA[<p>在实际开发中，设计数据表的时候会把某些字段定义成一个自动增长的、唯一的流水号，例如记录编号、日志编号等，MySQL和SQL Server采用的是自增字段，Oracle和PostgreSQL采用了更灵活的序列生成器。在本文中，把序列生成器简称为序列。</p><h1 id="一-创建序列"><a class="markdownIt-Anchor" href="#一-创建序列"></a> 一、创建序列</h1><p>创建序列的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create sequence 序列名</span><br><span class="line">       [minvalue n]</span><br><span class="line">       [maxvalue n]</span><br><span class="line">       [increment by n]</span><br><span class="line">       [start with n]</span><br><span class="line">       [cache n|nocache]</span><br><span class="line">       [order|noorder]</span><br><span class="line">       [cycle|nocycle];</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>Oracle的序列分为递增序列和递减序列，递减序列极少使用（二十年我从未用过），为了方便介绍，本文假设序列是递增序列。</p><p><code>序列名</code>：序列名是标志符，建议以SEQ_打头，例如为T_OPERLOG表的logid字段创建一个序列，可以把它命名为SEQ_OPERLOG（或SEQ_OPERLOG_LOGID），增加数据结构的可读性，这是我的个人经验，并不是Oracle数据库的要求。</p><p><code>[minvalue n]</code>：序列的最小值，缺省值是1。</p><p><code>[maxvalue n]</code>：序列的最大值，缺省值是9999999999999999999999999999。</p><p><code>[increment by n]</code>：序列递增的步长，缺省值是1。</p><p><code>[start with n]</code>：序列的起始值，缺省值是minvalue，如果n小于minvalue，创建序列会报语法错误。</p><p><code>[cache n|nocache]</code>：是否采用缓存机制，nocache不采用缓存，缺省cache 20，数据库每次会生成20个值放在缓存中，如果缓存中有数据，就不需要再查数据库了，采用缓存机制可以提升效率。</p><p><code>[order|noorder</code>]：获取序列的时候是否按顺序给值，如果多用户一起获取序列的值，使用order可以保证序列值的顺序按访问序列的事件排序，缺省是noorder。</p><p><code>[cycle|nocycle]</code>：是否循环，缺省不循环，如果不循环，序列值到了maxvalue后将不可用。</p><h1 id="二-序列的使用"><a class="markdownIt-Anchor" href="#二-序列的使用"></a> 二、序列的使用</h1><h2 id="1-创建最简单的序列"><a class="markdownIt-Anchor" href="#1-创建最简单的序列"></a> 1、创建最简单的序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create sequence SEQ_GIRL;</span><br></pre></td></tr></table></figure><p>执行以上SQL语句会在数据库中生成一个名字为SEQ_GIRL的序列，除了序列名，其它的参数都采用缺省值，相当于以下SQL：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create sequence SEQ_GIRL </span><br><span class="line">       minvalue <span class="number">1</span> </span><br><span class="line">       maxvalue <span class="number">9999999999999999999999999999</span> </span><br><span class="line">       increment by <span class="number">1</span> </span><br><span class="line">       start with <span class="number">1</span> </span><br><span class="line">       cache <span class="number">20</span> </span><br><span class="line">       noorder  </span><br><span class="line">       nocycle ;</span><br></pre></td></tr></table></figure><h2 id="2-在dual虚表使用序列"><a class="markdownIt-Anchor" href="#2-在dual虚表使用序列"></a> 2、在dual虚表使用序列</h2><p>序列创建后，用<code>序列名.nextval</code>获取序列的下一个值，用<code>序列名.currval</code>来查看当前值。</p><p>在新的会话中，必须先使用nextval来产生一个值后才可以使用currval进行查看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select SEQ_GIRL.nextval from dual;     -- 获取序列SEQ_GIRL的下一个值。</span><br><span class="line">select SEQ_GIRL.currval from dual;     -- 获取序列SEQ_GIRL的当前值</span><br></pre></td></tr></table></figure><h2 id="3-在sql语句中使用序列"><a class="markdownIt-Anchor" href="#3-在sql语句中使用序列"></a> 3、在SQL语句中使用序列</h2><p>我们先创建一个简单的表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  name    varchar2(<span class="number">10</span>),     -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  keyid   number(<span class="number">10</span>)        -- 记录编号</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>1）在insert语句中使用序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>  ,SEQ_GIRL.nextval)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;妲已&#x27;</span>  ,SEQ_GIRL.nextval)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;杨玉环&#x27;</span>,SEQ_GIRL.nextval)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;李师师&#x27;</span>,SEQ_GIRL.nextval)</span></span>;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200311090638957.png" alt="在这里插入图片描述" /></p><p>2）在update语句中使用序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T_GIRL set keyid=SEQ_GIRL.nextval+<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200311090850471.png" alt="在这里插入图片描述" /></p><h1 id="三-序列裂缝"><a class="markdownIt-Anchor" href="#三-序列裂缝"></a> 三、序列裂缝</h1><h2 id="1-序列不产生事务"><a class="markdownIt-Anchor" href="#1-序列不产生事务"></a> 1、序列不产生事务</h2><p>序列的nextval方法不会产生事务，事务回滚命令rollback不会恢复序列的值，我们来做一个测试。</p><p>1）先获取序列的当前值。</p><p><img src="https://img-blog.csdnimg.cn/20200311091004304.png" alt="在这里插入图片描述" /></p><p>2）执行一条不会成功的SQL语句。</p><p><img src="https://img-blog.csdnimg.cn/20200311091014476.png" alt="在这里插入图片描述" /></p><p>3）再获取序列的当前值。</p><p><img src="https://img-blog.csdnimg.cn/20200311091109676.png" alt="在这里插入图片描述" /></p><h2 id="2-序列裂缝"><a class="markdownIt-Anchor" href="#2-序列裂缝"></a> 2、序列裂缝</h2><p>如果用序列的值作为表中某个字段的值，这个字段的值可能会出现不连续的情况。因为序列的值不连续，有裂缝。</p><p>序列在下列情况下出现裂缝：</p><p>1）执行SQL语句失败；</p><p>2）事务回滚；</p><p>3）序列缓存；</p><p>4）多个表同时使用同一序列；</p><p>5）其它异常。</p><h1 id="四-修改序列"><a class="markdownIt-Anchor" href="#四-修改序列"></a> 四、修改序列</h1><p>修改序列的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alter sequence 序列名</span><br><span class="line">     [minvalue n]</span><br><span class="line">     [maxvalue n]</span><br><span class="line">     [increment by n]</span><br><span class="line">     [start with n]</span><br><span class="line">     [cache n|nocache]</span><br><span class="line">     [order|noorder]</span><br><span class="line">     [cycle|nocycle];</span><br></pre></td></tr></table></figure><p>修改序列的参数与创建序列的参数相同，不同的是，修改序列时没有缺省值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter sequence SEQ_GIRL increment by <span class="number">10</span> cycle</span><br></pre></td></tr></table></figure><h1 id="五-删除序列"><a class="markdownIt-Anchor" href="#五-删除序列"></a> 五、删除序列</h1><p>删除序列的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop sequence 序列名;</span><br></pre></td></tr></table></figure><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle虚表</title>
      <link href="/post/a671fb61.html"/>
      <url>/post/a671fb61.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库中存在一个特别的表dual，它是一个虚拟表，用来构成select的语法规则。Oracle对dual虚表的操作做了一些特别的处理，保证dual表里面永远只有一条记录。dual虚表存在给程序员带来了一些方便。</p><h1 id="一-测试dual虚表"><a class="markdownIt-Anchor" href="#一-测试dual虚表"></a> 一、测试dual虚表</h1><p>dual虚表只有一个字段，有一条记录。</p><h2 id="1-dual虚表的结构"><a class="markdownIt-Anchor" href="#1-dual虚表的结构"></a> 1、dual虚表的结构</h2><p><img src="https://img-blog.csdnimg.cn/2020031108521581.png" alt="在这里插入图片描述" /></p><h2 id="2-查询dual虚表中的记录"><a class="markdownIt-Anchor" href="#2-查询dual虚表中的记录"></a> 2、查询dual虚表中的记录</h2><p><img src="https://img-blog.csdnimg.cn/20200311085226794.png" alt="在这里插入图片描述" /></p><h2 id="3-对dual虚表做增-删-改操作"><a class="markdownIt-Anchor" href="#3-对dual虚表做增-删-改操作"></a> 3、对dual虚表做增、删、改操作</h2><p>普通用户对dual虚表只有查询权限，没有增、删、改的权限。DBA对dual虚表有全部的权限，但是，我不建议采用DBA对dual虚表进行操作，没什么意义，大家可以玩玩，但是，<strong>某些操作（删除表）可能造成数据库无法启动，请慎重，一定不能在生产环境中折腾。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200311085243304.png" alt="在这里插入图片描述" /></p><h1 id="二-dual虚表的用途"><a class="markdownIt-Anchor" href="#二-dual虚表的用途"></a> 二、dual虚表的用途</h1><p>利用dual虚表可以调用Oracle的函数和获取序列生成器的值，虽然还可以用来做一些其它的事情，比如说计算，但是对程序员来说利用dual虚表做计算毫无意义。</p><h2 id="1-执行oracle的函数"><a class="markdownIt-Anchor" href="#1-执行oracle的函数"></a> 1、执行Oracle的函数</h2><p>1）查看当前登录用户。</p><p><img src="https://img-blog.csdnimg.cn/2020031108530394.png" alt="在这里插入图片描述" /></p><p>2、获取数据库的日期时间</p><p><img src="https://img-blog.csdnimg.cn/20200311085314122.png" alt="在这里插入图片描述" /></p><h2 id="2-获取序列生成器的值"><a class="markdownIt-Anchor" href="#2-获取序列生成器的值"></a> 2、获取序列生成器的值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create sequence SEQ_FREECPLUS;         -- 创建序列生成器SEQ_FREECPLUS。</span><br><span class="line">select SEQ_FREECPLUS.nextval from dual;  -- 从序列SEQ_FREECPLUS获取下一个值。</span><br><span class="line">select SEQ_FREECPLUS.currval from dual;  -- 从序列SEQ_FREECPLUS获取当前值。</span><br></pre></td></tr></table></figure><p>细心的读者可能会思考一个问题，在insert和update语句中，可以把序列生成器直接填写到SQL语句中，不需要dual虚表。不一定，在实际开发中，可能要把序列生成器的值取出来，比如说参与运算。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的order by关键字</title>
      <link href="/post/45d3eb99.html"/>
      <url>/post/45d3eb99.html</url>
      
        <content type="html"><![CDATA[<p>order by关键字用于对查询的结果集进行排序。</p><p>我们通过示例来介绍order by关键字的用法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-order-by的语法"><a class="markdownIt-Anchor" href="#二-order-by的语法"></a> 二、order by的语法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n from 表名 order by 字段名<span class="number">1</span> asc,字段名<span class="number">2</span> desc,......;</span><br></pre></td></tr></table></figure><p>order by关键字用于对结果集按一个或者多个字段进行排序，默认是升序asc（从小到大），如果需要按降序对记录进行排序，可以用desc。</p><p>如果排序字段有多个，可以对每个字段指定asc或desc。</p><p>1）从T_GIRL表中查出全部的记录，按身高降序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL order by height desc;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310205125368.png" alt="在这里插入图片描述" /></p><p>2）从T_GIRL表中查出全部的记录，按身材（降）和身高（升）排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL order by sc desc,height;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310205157451.png" alt="在这里插入图片描述" /></p><p>3）注意，order by排序的字段可以不在select的字段列表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL order by id desc;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310205249310.png" alt="在这里插入图片描述" /></p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的where子句</title>
      <link href="/post/58b283b4.html"/>
      <url>/post/58b283b4.html</url>
      
        <content type="html"><![CDATA[<p>where子句用于从表中或临时数据集中查找满足指定条件的记录，可用于select、update和delete语句中的条件。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，你们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-where子句的语法"><a class="markdownIt-Anchor" href="#二-where子句的语法"></a> 二、where子句的语法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n from 表名 where 字段名 比较运算符 值;</span><br><span class="line">select * from 表名 where 字段名 比较运算符 值;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL where id=<span class="string">&#x27;0101&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175112748.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL where height=<span class="number">172</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175137839.png" alt="在这里插入图片描述" /></p><p>以上的示例展示了where子句最简单的用法，接下来我再介绍Oracle的逻辑运算符和比较运算符，以增强where子句的功能。</p><h1 id="三-逻辑运算符"><a class="markdownIt-Anchor" href="#三-逻辑运算符"></a> 三、逻辑运算符</h1><table><thead><tr><th>运算符</th><th>备注</th></tr></thead><tbody><tr><td>and</td><td>双值运算符，如果左右两个条件都为真，则得到的值就为真。</td></tr><tr><td>or</td><td>双值运算符，只要左右两个条件有一个为真，则得到的值就为真。</td></tr><tr><td>not</td><td>单指运算符，如果原条件为真，则得到真，如果元条件为假，反之如果原条件为假，则结果为真。not一般比较运算符中的in、like、null一起使用。</td></tr></tbody></table><p>逻辑运算符有优先级，但我不想介绍它，在实际应用中，用括号解决全部的优先级问题。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="keyword">and</span> sc=<span class="string">&#x27;火辣&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175217121.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="built_in">and</span> (sc=<span class="string">&#x27;火辣&#x27;</span> <span class="keyword">or</span> sc=<span class="string">&#x27;苗条&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175247973.png" alt="在这里插入图片描述" /></p><p>看看not的效果，但是很少这么用。</p><p><img src="https://img-blog.csdnimg.cn/20200310175257745.png" alt="在这里插入图片描述" /></p><h1 id="四-比较运算符"><a class="markdownIt-Anchor" href="#四-比较运算符"></a> 四、比较运算符</h1><p><img src="https://img-blog.csdnimg.cn/20200310175953389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意几个问题：</p><p>1）比较运算符都可以和not一起使用，但是在实际应用中，in、like和is null与not结合很常用，其它的比较运算符很少与not结合使用，感觉别扭。</p><p>2）使用like的时候，用百分号%匹配多个字符，下划线_匹配一个字符，但是如果我们希望把%和_当成普通字符，可以采用转义字符的方法，转义字符的用法如下：</p><p>在C语言中，采用反斜线\转义，在Oracle中，用escape关键字定义转义符。</p><p>escape 'chr’定义转义字符，当转义符置于通配符之前时，该通配符就解释为普通字符，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_GIRL where memo like <span class="string">&#x27;%人%/%%&#x27;</span> escape <span class="string">&#x27;/&#x27;</span>;</span><br></pre></td></tr></table></figure><p>第一、第二和第四个%作为通配符，第三个%是普通字符。</p><p><img src="https://img-blog.csdnimg.cn/20200310180121518.png" alt="在这里插入图片描述" /></p><h1 id="五-where子句的高级用法"><a class="markdownIt-Anchor" href="#五-where子句的高级用法"></a> 五、where子句的高级用法</h1><p>where子句条件的值可以是常量（固定的值）或表达式，也可以是函数的返回值或select语句的结果集。</p><p>如果是in比较运算符，条件的值可以是多行的结果集，其它的比较运算符必须是单行记录的结果集。</p><p>1）条件的值是表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where height&gt;<span class="number">100</span>+<span class="number">68</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180202411.png" alt="在这里插入图片描述" /></p><p>2）条件的值是函数和表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where birthday&gt;sysdate-(<span class="number">30</span>*<span class="number">365</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180236527.png" alt="在这里插入图片描述" /></p><p>3）条件的值是单行的结果集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select empno,ename,job,sal from EMP</span><br><span class="line"> where deptno=(select deptno from DEPT where dname=<span class="string">&#x27;ACCOUNTING&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180314482.png" alt="在这里插入图片描述" /></p><p>如果条件的值是多行，在逻辑上存在问题，将提示错误。</p><p><img src="https://img-blog.csdnimg.cn/20200310180332484.png" alt="在这里插入图片描述" /></p><p>4）比较运算符in后面条件的值支持多行的结果集。</p><p><img src="https://img-blog.csdnimg.cn/20200310180341226.png" alt="在这里插入图片描述" /></p><h1 id="六-对where子句的列使用运算和函数"><a class="markdownIt-Anchor" href="#六-对where子句的列使用运算和函数"></a> 六、对where子句的列使用运算和函数</h1><p>在where子句中，对列可以进行运算和使用函数。</p><h2 id="1-对列进行运算"><a class="markdownIt-Anchor" href="#1-对列进行运算"></a> 1、对列进行运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height from T_GIRL where height<span class="number">-170</span>&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180424113.png" alt="在这里插入图片描述" /></p><h2 id="2-对列使用函数"><a class="markdownIt-Anchor" href="#2-对列使用函数"></a> 2、对列使用函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) <span class="function">from T_GIRL</span></span><br><span class="line"><span class="function"> where <span class="title">to_char</span><span class="params">(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>)</span></span>=<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180507253.png" alt="在这里插入图片描述" /></p><h2 id="3-存在的问题"><a class="markdownIt-Anchor" href="#3-存在的问题"></a> 3、存在的问题</h2><p>以上第一个SQL对height列进行了运算，第二个SQL是对birthday列使用了to_char函数，这两种写法得零分。<strong>因为在where子句中，如果对列使用函数或运算，SQL语句的无法利用索引（函数索引除外），性能很低（采用了table scan），程序员一定不能犯这种低级错误。</strong></p><p>正确的写法是对条件的值进行运算或使用函数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height from T_GIRL where height&gt;<span class="number">170</span>;</span><br><span class="line">select id,name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL</span><br><span class="line"> where birthday=<span class="built_in">to_date</span>(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>);</span><br></pre></td></tr></table></figure><p>补充说明一下，对select关键字后的列名进行运算和使用函数对SQL语句的性能没有任何影响。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle事务</title>
      <link href="/post/b80388aa.html"/>
      <url>/post/b80388aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-事务的基本概念"><a class="markdownIt-Anchor" href="#一-事务的基本概念"></a> 一、事务的基本概念</h1><p>在数据库中事务是工作的逻辑任务，一个事务是由一个或一组SQL语句组成，通过事务机制确保这一组SQL语句的操作要么全部成功执行成功，完成整个工作任务，如果任何一条SQL执行失败，对数据表所做的操作全部撤销。</p><p>事务的目的就是为了保证数据的完整性，以银行转换业务为例：</p><p>A用户向B转账1000元，步骤如下：</p><p>1）A用户账户余额减少1000元；</p><p>2）B用户账户余额增加1000元；</p><p>3）记录A用户的交易日志。</p><p>4）记录B用户的交易日志。</p><p>一笔转帐交易将产生四次数据库操作，要么全部都成功，如果有一个失败，其它操作也应该全部被撤销。</p><p>转账交易有四次数据库操作，即四条SQL语句，第一条SQL执行的时候是事务的开始，如果全部的SQL语句执行成功，提交事务，如果有任何一条SQL语句执行失败，回滚事务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit;     -- 提交事务。</span><br><span class="line">rollback;     -- 回滚事务。</span><br></pre></td></tr></table></figure><h1 id="二-事务的特征"><a class="markdownIt-Anchor" href="#二-事务的特征"></a> 二、事务的特征</h1><p>对一组SQL语句操作构成的事务，数据库系统必须保证这些操作的原子性、一致性、隔离性和持久性，即ACID原则。</p><h2 id="1-原子性atomicity"><a class="markdownIt-Anchor" href="#1-原子性atomicity"></a> 1、原子性（Atomicity）</h2><p>事务的原子性是指事务中包含的所有操作要么全做，要么不做，也就是说所有的操作在数据库中要么全部生效，要么全部不生效。</p><h2 id="2-一致性consistency"><a class="markdownIt-Anchor" href="#2-一致性consistency"></a> 2、一致性（Consistency）</h2><p>事务的一致性是指数据库在事务操作前和事务处理后，数据都是一致的。</p><h2 id="3-隔离性isolation"><a class="markdownIt-Anchor" href="#3-隔离性isolation"></a> 3、隔离性（Isolation）</h2><p>隔离性是指数据库允许多个并发的事务同时对数据进行读写或修改，即使出现了SQL语句叉操作数据的情况，也不会导致数据不一致。</p><h2 id="4-持久性durability"><a class="markdownIt-Anchor" href="#4-持久性durability"></a> 4、持久性（Durability）</h2><p>事务的持久性是指在事务处理结束后，它对数据的修改应该是永久的。通俗的理解就是事务结束后立即把数据写入硬盘中。</p><h1 id="三-事务控制"><a class="markdownIt-Anchor" href="#三-事务控制"></a> 三、事务控制</h1><p><strong>事务控制语句中最重要的两个指令，提交（commit）和回滚（rollback），可以满足99%的应用需求。</strong></p><p>本文接下来介绍事务控制的更多知识，大家了解一下就可以了，不必深入研究。</p><h2 id="1-设置事物属性"><a class="markdownIt-Anchor" href="#1-设置事物属性"></a> 1、设置事物属性</h2><p>set transaction可以用来设置事务的各种状态，比如只读、读/写、隔离级别，为事务分配名称或将事务分配回滚段等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set transaction [read only|read write]</span><br><span class="line">                [isolation level [serialize|read commited]]</span><br><span class="line">                [use rollback segment <span class="string">&#x27;segment_name&#x27;</span>]</span><br><span class="line">                [name <span class="string">&#x27;transaction_name&#x27;</span>];</span><br></pre></td></tr></table></figure><p><code>read only</code>：将事务设置为只读事务。</p><p><code>read write</code>：将事务设置为读/写事务。</p><p><code>isolation level</code>：如果指定，它有两个选项：（1）<code>serialize</code>：如果事务尝试更新由另一个事务更新并未提交的资源，则事务将失败。（2）<code>read commited</code>：如果事务需要另一个事务持有的行锁，则事务将等待，直到行锁被释放。</p><p><code>use rollback segment</code>：如果指定，它将事务分配给由’segment_name’标识的回退段，该段是用单引号括起来的段名称。</p><p><code>name</code>：为事务分配一个名称’transaction_name’，该名称是用单引号括起来。</p><p>注意：</p><p>1）set transaction是事务处理的第一条语句，也就是说，必须在任何insert、update、delete语句以及其他的事务处理之前。</p><p>2）在使用set transaction语句设置事务的属性时，很少指定回滚段，对于命名事务也非常简单，只有在分布式事务处理中才会体现出事务命名的用途。</p><h2 id="2-数据异常"><a class="markdownIt-Anchor" href="#2-数据异常"></a> 2、数据异常</h2><p>事务的隔离性定义了一个事务与其它事务的隔离程度，为了更好的理解隔离层，首先讨论一下并发事务对同一个数据库进行访问可能发生的情况，在并发事务中总体来说会发生如下3种情况：</p><p><strong>错读|脏读</strong></p><p><strong>非重复读取|不可重复读</strong></p><p><strong>假读|幻读</strong></p><p><strong>错读|脏读</strong>：当一个事务修改数据时，另一事务读取了该数据，但是第一事务由于某种原因取消对数据修改，使数据返回了原状态，这是第二个事务读取的数据与数据库中数据不一致，这就叫错读。</p><p><strong>非重复读取</strong>：是指一个事务读取数据库中的数据后，另一个事务则更新了数据，当第一个事务再次读取其中的数据时，就会发现数据已经发生了改变,这就是非重复读取。非重复读取所导致的结果就是一个事务前后两次读取的数据不相同。</p><p><strong>假读</strong>：如果一个事务基于某个条件读取数据后，另一个事务则更新了同一个表中的数据，这时第一个事务再次读取数据时，根据搜索的条件返回了不同的行，这就是假读。</p><p>事务中遇到的这些异常与事务的隔离性设置有关，事务的隔离性设置越多，异常就出现的越少，但并发效果就越低，事务的隔离性设置越少，异常出现的越多，并发效果越高。</p><h2 id="3-选择隔离层"><a class="markdownIt-Anchor" href="#3-选择隔离层"></a> 3、选择隔离层</h2><p>针对上文中读取的数据时产生的不一致现象，在ANSI SQL标准92中定义了4个事务的隔离级别，如下图所示：</p><table><thead><tr><th>隔离层</th><th>错读|脏读</th><th>非重复读取|不可重复读</th><th>假读|幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（非提交读）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ COMMITTED（提交读）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Repeatable READ（可重复读）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>Serializable（串行读）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>Oracle支持上述四种隔离层中的两种：read committed 和serializable，除此之外oralce中还定义read only 和 read write隔离层。<br />read committed：这是oracle默认的隔离层。<br />serializable：事务与事务之间完全隔开，事务以串行的方式执行，这并不是说一个事务必须结束才能启动另外一个事务，而是说这些事务的执行的结果于一次执行的事务的结果一致。<br />read only和 read write 当使用read only时，事务中不能有任何修改数据库中数据的操作语句，这包括 insert、update、delete、create语句。read only是serializable的一个子集，区别是read only 只读，而serialzable可以执行DML操作。read write它是默认设置，该选项表示在事务中可以有访问语句和修改语句，但很少使用。</p><h2 id="4-保存点"><a class="markdownIt-Anchor" href="#4-保存点"></a> 4、保存点</h2><p>保存点（savepoint）是在数据库事务处理中实现“子事务”（subtransaction），也称为嵌套事务的方法，事务可以回滚到<br />savepoint 而不影响 savepoint 创建前的变化，不需要放弃整个事务。</p><p>rollback回滚的用法可以设置保留点<br />savepoint，执行多条SQL操作时，回滚到想要的那条SQL之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">savepoint savepoint_name;    -- 声明一个savepoint。</span><br><span class="line">rollback to savepoint_name;   -- 回滚到savepoint。</span><br></pre></td></tr></table></figure><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的表</title>
      <link href="/post/a04113c8.html"/>
      <url>/post/a04113c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-表的概念"><a class="markdownIt-Anchor" href="#一-表的概念"></a> 一、表的概念</h1><p>表是数据库最基本的逻辑结构，一切数据都存放在表中，其它数据库对象（索引、视图、同义词等）都是为了更方便的操作表中的数据。Oracle数据库是由若干个表组成，每个表由列和行组成，如下表所示。</p><table><thead><tr><th>编号</th><th>姓名</th><th>颜值</th><th>身材</th><th>体重</th><th>身高</th><th>出生时间</th><th>备注</th></tr></thead><tbody><tr><td>0101</td><td>西施</td><td>漂亮</td><td>火辣</td><td>48.5</td><td>170</td><td>2000-01-01 01:12:35</td><td>这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。</td></tr><tr><td>0102</td><td>貂禅</td><td>漂亮</td><td>火辣</td><td>45.2</td><td>168</td><td>1997-08-02 12:20:38</td><td>王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。</td></tr><tr><td>0103</td><td>妲已</td><td>漂亮</td><td>丰满</td><td>53.6</td><td>172</td><td>1998-03-03 10:50:33</td><td>如果商真的因我而亡，您们男人做什么去了？</td></tr><tr><td>0104</td><td>芙蓉 姐姐</td><td>猪扒</td><td>膘肥 体壮</td><td>85.8</td><td>171</td><td>1980-05-05 10:11:55</td><td>如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。</td></tr><tr><td>0105</td><td>神密 猫女</td><td></td><td></td><td>48.5</td><td>171</td><td>1989-12-08 12:10:35</td><td>不知道是什么人，她脸上有一个%符号，很神密。</td></tr></tbody></table><h2 id="1-表的列"><a class="markdownIt-Anchor" href="#1-表的列"></a> 1、表的列</h2><p>表的结构是由列组成，习惯上把列也称之为字段，字段的基本属性如下：</p><p>1）字段名：字段的名称。</p><p>2）数据类型：该字段存放数据的类型和长度。</p><p>3）是否允许空值：该字段是否为必填，如果不是必填，表示可以为空。</p><h2 id="2-列的数据类型"><a class="markdownIt-Anchor" href="#2-列的数据类型"></a> 2、列的数据类型</h2><p>表的每个列一定会有它的数据类型，表示该列存放的是什么数据，常用的数据类型如下：</p><p>1）字符串类型：char和varchar2，可表达任何字符串。</p><p>2）数字类型：number(m,n)，可表达任何数字，m是数字的总长度，n是小数点后的位数，如果n为0则表示是存放整数。</p><p>3）日期类型：date，存放日期和时间，包括年（yyyy）、月（mm）、日（dd）、小时（hh24）、分（mi）、秒（ss）。</p><p>4）clob类型，存放单字节字符串或多字节字符数据，如文本文件、xml文件。</p><p>5）blob类型，存放非结构化的二进制数据，如图片、音频、视频、office文档等。</p><p>6）rowid类型，存放表中记录在数据库中的物理地址。</p><p>更详细的介绍请阅读《Oracle数据类型》文章。</p><h2 id="3-表的行"><a class="markdownIt-Anchor" href="#3-表的行"></a> 3、表的行</h2><p>表中的数据是由行组成的，每一行就是一条数据，也称之为记录，数据越多，记录就越多。</p><h1 id="二-创建表"><a class="markdownIt-Anchor" href="#二-创建表"></a> 二、创建表</h1><h2 id="1-创建表"><a class="markdownIt-Anchor" href="#1-创建表"></a> 1、创建表</h2><p>Oracle数据库创建表是用create table命令来完成的，我们通过创建T_GIRL表（超女基本信息表）来讲解create table 命令的使用。</p><p>建表命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名</span><br><span class="line">(</span><br><span class="line">  字段名<span class="number">1</span> 数据类型 null,</span><br><span class="line">  字段名<span class="number">2</span> 数据类型 <span class="keyword">not</span> null,</span><br><span class="line">  ......,</span><br><span class="line">  字段名n 数据类型 null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表名是标识符，从语法上来说，表名只要符合Oracle的规定就行了，但是，在实际开发中，我会遵守两个原则：1）表名以T_打头，可读性比较好；2）表名尽可能有意义，用完整的英文单词或简写、或中文拼音都可以，方便理解和记忆就好。</p><p>创建超女基本信息表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：1）在Oracle数据库的SQL命令中，关键字、表名和字段名都不区分大小写，CREATE和create没有区别，表名T_GIRL和t_girl也没有区别，字段名ID和id也没有区别；2）两根短线“--”是说明文字，就像C/C++语言中的“//”。</p><h2 id="2-创建表的主键"><a class="markdownIt-Anchor" href="#2-创建表的主键"></a> 2、创建表的主键</h2><p>在现实世界中，很多数据具有唯一的特性，例如身份证号码，在国家人口基本信息表中，一定不会存在多个人用同一个身份证号码的情况，再例如手机号码、QQ号码、银行帐号等等，还有学生管理系统，学生的年级、班级和学号三个字段组合起来是唯一的标识。</p><p>如果表中一个字段或多个字段组合起来的值是唯一的，就可以作为表的主键，在创建或修改表时用primay key关键字来指定主键。一个表只能有一个主键，而且组成主键的每个字段值都不能为空。</p><p>主键的作用：</p><p>1）体现数据结构设计的合理性。</p><p>2）提升数据操作的速度。</p><p>3）保证数据的完整性，在表中添加或修改记录时，数据库会检查该记录主键的值，不允许与其它记录主键的值重复，这种做法有个专业的名词：主键约束。</p><p>例如超女基本信息表，编号的字段名是id，在超女选秀活动中，每个超女的编号肯定是唯一的，不可能存在两个编号相同的超女，否则会引起混乱，我们可以把id字段设置为T_GIRL表的主键，后面的工作交给数据库，如果试图往表中插入多条id相同的记录，数据库将拒绝。</p><p>指定表的主建有两种方法。</p><p>1）在create table时指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 指定id为表的主键</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>2）修改已经建好的表，增加主键约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 主键名 <span class="function">primary <span class="title">key</span><span class="params">(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n)</span></span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br></pre></td></tr></table></figure><p>在Oracle数据库中，虽然主键不是必需的，但是最好为每个表都设置一个主键，不管是单字段主键还是多字段主键（复合主键），它的存在代表了表结构的完整性，主键还可以用于其他表的外键关联，外键的知识以后再介绍。</p><h1 id="三-表记录的插入-修改和删除"><a class="markdownIt-Anchor" href="#三-表记录的插入-修改和删除"></a> 三、表记录的插入、修改和删除</h1><h2 id="1-向表中插入记录"><a class="markdownIt-Anchor" href="#1-向表中插入记录"></a> 1、向表中插入记录</h2><p>insert into命令用于向表中插入记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>,...... 字段名n) <span class="built_in">values</span> (字段<span class="number">1</span>的值, 字段<span class="number">2</span>的值,..... 字段n的值);</span><br></pre></td></tr></table></figure><p>注意，表名后的字段名列表与values后面字段值列表必须一一对应。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在上面的insert语句中，字段的值如果是字符串，要用单引号包含起来，日期字段要用to_date函数转换，数字直接书写。</p><p>插入数据的SQL语句还有一种写法，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 <span class="built_in">values</span> (字段<span class="number">1</span>的值, 字段<span class="number">2</span>的值,..... 字段n的值);</span><br></pre></td></tr></table></figure><p>这种写法省略了字段名列表，但是，这种写法一定不能出现在程序中，因为只要表结构发生改变，或字段的位置改变，SQL语句就会出错。</p><h2 id="2-查询表中的记录"><a class="markdownIt-Anchor" href="#2-查询表中的记录"></a> 2、查询表中的记录</h2><p>insert into命令用于从表中查询记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n from 表名 where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br><span class="line">select * from 表名 where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="keyword">and</span> sc=<span class="string">&#x27;火辣&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在select关键字之后，可以用星号表示全部的字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="keyword">and</span> sc=<span class="string">&#x27;火辣&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在上面的SQL语句中，用星号*表示列出全部的字段，这种写法一定不能出现在程序中，因为只要表结构发生改变，或字段的位置改变，程序就会出现混乱。</p><p>where关键字后面的条件表达式涉及的知识非常多，以后再详细介绍。</p><h2 id="3-修改表中的记录"><a class="markdownIt-Anchor" href="#3-修改表中的记录"></a> 3、修改表中的记录</h2><p>update命令用于修改表中的记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名<span class="number">1</span>=值<span class="number">1</span>,字段名<span class="number">2</span>=值<span class="number">2</span>,......字段名n=值n where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br></pre></td></tr></table></figure><p>在set关键字之后把需要修改的字段名和新的值一一列出来。</p><p>where关键字后面是条件表达式，如果没有条件表达式，就会更新表中全部的记录。</p><p>超女选秀活动开始后，芙蓉姐姐体重反弹了3公斤，像个大恐龙，出生日期也有隐瞒，组委会修改了她的基本资料，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T_GIRL set weight=<span class="number">89.5</span>,yz=<span class="string">&#x27;恐龙&#x27;</span>,birthday=<span class="built_in">to_date</span>(<span class="string">&#x27;1978-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) where name=<span class="string">&#x27;芙蓉姐姐&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="4-删除表中的记录"><a class="markdownIt-Anchor" href="#4-删除表中的记录"></a> 4、删除表中的记录</h2><p>delete命令用于删除表中的记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> from 表名 where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br></pre></td></tr></table></figure><p>where关键字后面是条件表达式，如果没有条件表达式，就删除表中全部的记录。</p><p>随着超女选秀活动的继续，芙蓉姐姐的体重在持续反弹中，组委会实在受不了了，决定把芙蓉姐姐除名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> from T_GIRL where name=<span class="string">&#x27;芙蓉姐姐&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="四-表的约束"><a class="markdownIt-Anchor" href="#四-表的约束"></a> 四、表的约束</h1><p>表的约束有非空约束、唯一性约束、检查约束、主建约束和外键约束四种，主键约束和外键约束涉及到数据结构方面的知识，以后再介绍。</p><h2 id="1-非空约束"><a class="markdownIt-Anchor" href="#1-非空约束"></a> 1、非空约束</h2><p>创建表的时候，可以指定字段的值是否允许为空，缺省是null允许为空（表示是可选字段），not null不允许为空（表示是必填字段）。</p><p>例示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span> <span class="params">(c1 varchar2(<span class="number">10</span>),c2 varchar2(<span class="number">10</span>) <span class="keyword">not</span> null)</span></span>;</span><br></pre></td></tr></table></figure><p>创建表tt，c1字段允许为空，c2字段不允许为空。</p><p><img src="https://img-blog.csdnimg.cn/20200310165554927.png" alt="在这里插入图片描述" /></p><h2 id="2-唯一性约束"><a class="markdownIt-Anchor" href="#2-唯一性约束"></a> 2、唯一性约束</h2><p>唯一性约束有两种，一种是表的主键，另一种是表的唯一索引，唯一索引以后再介绍。</p><p>表的主键字段不允许存在值相同的记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span> <span class="params">(id varchar2(<span class="number">10</span>),name varchar2(<span class="number">10</span>),primary key(id))</span></span>;</span><br></pre></td></tr></table></figure><p>创建表tt，id字段是主键。</p><p><img src="https://img-blog.csdnimg.cn/20200310165653992.png" alt="在这里插入图片描述" /></p><h2 id="3-检查约束"><a class="markdownIt-Anchor" href="#3-检查约束"></a> 3、检查约束</h2><p>检查约束是指检查字段的值是否合法。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">TT</span>  </span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   c1   number(<span class="number">6</span>) constraint CKC_C1_TT check (c1 &gt;= <span class="number">10</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">   c2   number(<span class="number">6</span>) constraint CKC_C2_TT check (c2 &lt;= <span class="number">20</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">   c3   number(<span class="number">6</span>) constraint CKC_C3_TT check (c3 in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>创建表TT，c1字段的最小值是10，c2字段的最大值是20，C3字段的取值必须在(1,2,3)中取其一。</p><p><img src="https://img-blog.csdnimg.cn/2020031016574632.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310165755162.png" alt="在这里插入图片描述" /></p><h1 id="五-字段的缺省值"><a class="markdownIt-Anchor" href="#五-字段的缺省值"></a> 五、字段的缺省值</h1><p>在创建表的时候，可以为字段指定缺省值。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">TT</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   name     varchar2(<span class="number">10</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   crttime  date         <span class="keyword">default</span> sysdate <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   rsts     number(<span class="number">1</span>)    <span class="keyword">default</span> <span class="number">1</span> <span class="keyword">not</span> null constraint CKC_RSTS_TT check (rsts in (<span class="number">1</span>,<span class="number">2</span>))</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>创建表，字段crttime的缺省值是sysdate（当前时间），rsts的缺省值是1。</p><p><img src="https://img-blog.csdnimg.cn/20200310165843154.png" alt="在这里插入图片描述" /></p><h1 id="六-表的存储空间"><a class="markdownIt-Anchor" href="#六-表的存储空间"></a> 六、表的存储空间</h1><p>每个数据库用户有一个缺省表空间，创建的表、主键和索引存放在缺省表空间中，也可以指定其它的表空间。</p><h2 id="1-查看当前用户的缺省表空间"><a class="markdownIt-Anchor" href="#1-查看当前用户的缺省表空间"></a> 1、查看当前用户的缺省表空间</h2><p>从数据字典USER_USERS中可以查看当前用户的缺省表空间。</p><p><img src="https://img-blog.csdnimg.cn/20200310165907549.png" alt="在这里插入图片描述" /></p><h2 id="2-指定表的表空间"><a class="markdownIt-Anchor" href="#2-指定表的表空间"></a> 2、指定表的表空间</h2><p>指定表空间的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table 表名</span><br><span class="line">(</span><br><span class="line">  ......   -- 字段列表</span><br><span class="line">) tablespace 表空间名;</span><br></pre></td></tr></table></figure><p>例如创建T_GIRL表，指定使用USERS表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> tablespace USERS</span>;</span><br></pre></td></tr></table></figure><p>表还有其它与存储相关的选项，但应用场景比较少，本文就不介绍了。</p><h1 id="七-修改表结构"><a class="markdownIt-Anchor" href="#七-修改表结构"></a> 七、修改表结构</h1><p>Oracle修改表的命令是alter table，它的选项非常多，本文只介绍修改表结构的相关知识。</p><h2 id="1-增加字段"><a class="markdownIt-Anchor" href="#1-增加字段"></a> 1、增加字段</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 字段名 数据类型 其它选项;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add address <span class="title">varchar2</span><span class="params">(<span class="number">50</span>)</span> null</span>;</span><br><span class="line"><span class="function">alter table T_GIRL add rsts <span class="title">number</span><span class="params">(<span class="number">1</span>)</span> constraint CKC_RSTS_GIRL <span class="title">check</span> <span class="params">(rsts in (<span class="number">1</span>,<span class="number">2</span>))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-修改字段的属性"><a class="markdownIt-Anchor" href="#2-修改字段的属性"></a> 2、修改字段的属性</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 字段名 数据类型 其它选项;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL modify address <span class="title">varchar2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL modify address <span class="title">varchar2</span><span class="params">(<span class="number">100</span>)</span> <span class="keyword">not</span> null</span>;</span><br><span class="line">alter table T_GIRL drop constraint CKC_RSTS_GIRL;</span><br><span class="line"><span class="function">alter table T_GIRL modify rsts constraint CKC_RSTS_GIRL <span class="title">check</span> <span class="params">(rsts in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>修改字段属性的时候要注意一个问题，如果表中已存在数据，修改可能会失败，包括但不限于以下的情况：</p><p>1）把字段由null改为not null时，表中记录存在null的情况。</p><p>2）把字段的取值范围由较大（例如number(10)）改较小（例如number(5)），表中记录存在大于较小取值范围的情况，例如已经存在123456的值，如果把数据类型改为number(5)，无法存放123456。</p><p>3）把字段的数据类型时，表中存在记录并且新旧数据类型不兼容的情况。例如原来的数据类型是varchar2(10)，表中存在记录的值是’freecplus’，如果要修改为number(10)，Oracle无法把’freecplus’转换为number(10)。</p><h2 id="3-修改字段名"><a class="markdownIt-Anchor" href="#3-修改字段名"></a> 3、修改字段名</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename column 列名 to 新列名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL rename column memo to remark;</span><br></pre></td></tr></table></figure><h2 id="4-删除字段"><a class="markdownIt-Anchor" href="#4-删除字段"></a> 4、删除字段</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 dorp column 字段名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL drop column rsts;</span><br><span class="line">alter table T_GIRL drop column address;</span><br></pre></td></tr></table></figure><h1 id="八-修改表名"><a class="markdownIt-Anchor" href="#八-修改表名"></a> 八、修改表名</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename to 新表名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL rename to T_BEAUTY;</span><br></pre></td></tr></table></figure><p>注意，如果修改了表名，表的约束、索引、主键的名称不会改变。</p><h1 id="九-删除表"><a class="markdownIt-Anchor" href="#九-删除表"></a> 九、删除表</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table T_GIRL;</span><br></pre></td></tr></table></figure><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据类型</title>
      <link href="/post/2b739d38.html"/>
      <url>/post/2b739d38.html</url>
      
        <content type="html"><![CDATA[<p>Oracle的数据类型有二十多种，包括字符串类型、数字类型、日期类型、LOB类型、LONG RAW&amp; RAW类型、ROWID &amp; UROWID类型。太多的数据类型很容易让初学者感到迷茫，在本文中，我将以程序员的视角，结合实际开发的需求来介绍Oracle的数据类型。</p><p>Oracle的数据类型虽然很多，但实用的只有以下几种：</p><p>1）字符串类型：char和varchar2，可表达任何字符串。</p><p>2）数字类型：number(m,n)，可表达任何数字，m是数字的总长度，n是小数点后的位数，如果n为0则表示是一个整数。</p><p>3）日期类型：date，存放日期和时间，包括年（yyyy）、月（mm）、日（dd）、小时（hh24）、分（mi）、秒（ss）。</p><p>4）clob类型，存放单字节字符串或多字节字符串数据，如文本文件、xml文件。</p><p>5）blob类型，存放非结构化的二进制数据，如图片、音频、视频、office文档等。</p><p>6）rowid类型，存放表中记录在数据库中的物理地址。</p><h1 id="一-字符串类型"><a class="markdownIt-Anchor" href="#一-字符串类型"></a> 一、字符串类型</h1><p>在C/C++语言中用，字符串用双引号包含起来，在Oracle数据库中，字符串用单引号包含起来的，如下：</p><p>‘<a href="http://www.freecplus.net">www.freecplus.net</a>’</p><p>‘码农有道’</p><p>'一只傻傻鸟 ’</p><h2 id="1-固定长度的字符串"><a class="markdownIt-Anchor" href="#1-固定长度的字符串"></a> 1、固定长度的字符串</h2><p>固定长度字符串用char表示，当存入数据内容的长度不够时，Oracle将在数据内容后面自动填充空格以达到其固定的长度，例如char(10)总是包含10字节信息。</p><p>char字段最多可以存储2000字节的内容。</p><h2 id="2-变长度的字符串"><a class="markdownIt-Anchor" href="#2-变长度的字符串"></a> 2、变长度的字符串</h2><p>变长度字符串用varchar2表示，与char类型不同，Oracle不会在数据内容后面填充任何内容。</p><p>varchar2字段最多可以存储4000字节的内容，从Oracle 12c版本开始，可以存储32767字节的内容。</p><h2 id="3-char和varchar2的比较"><a class="markdownIt-Anchor" href="#3-char和varchar2的比较"></a> 3、char和varchar2的比较</h2><p>char(10)，如果存入’freecplus’，在数据库中将存储’freecplus '，在最后补了一个空格。</p><p>varchar2(10)，如果存入’freecplus’，在数据库中将存储’freecplus’，什么也不会补。</p><p>在实际应用中，我们并不希望Oracle给字符串后面补空格，那么是不是可以弃用char类型呢？不是，我们一般用char类型存放固定大小的数据内容，例如身份证号码，固定是18位的，用char(18)就非常合适，能用varchar2(18)可以存放身份证号码吗？当然可以，但是，char(18)的效率比varchar2(18)的效率要高很多。</p><p>总结一下，如果确定、肯定、一定、保证存入字符串的长度是固定不变的，例如性别、身份证号码、手机号码，用char类型，否则用varchar2类型，例如姓名、学历、地址、兴趣爱好等，char虽然死板，但是效率高。</p><h2 id="4-汉字的存储"><a class="markdownIt-Anchor" href="#4-汉字的存储"></a> 4、汉字的存储</h2><p>每个汉字占多少字节要看具体的编码方式，如UTF-8（1-3字节）、GB2312（2字节）、GBK（2字节）、GB18030（1、2、4字节）。</p><h1 id="二-数字类型"><a class="markdownIt-Anchor" href="#二-数字类型"></a> 二、数字类型</h1><p>Oracle用number类型来存放数字，该类型能存储精度最多达38位，远远高于编程语言中常规的 long int和double类型。</p><p>number( m,n)，m表示总长度，n表示小数位的精度，如果存入的数据的小数位的精度超过了n，则取四舍五入后的值。</p><p>例如：number(10,3)，10是总长度，3是小数后的位数，如123.456。</p><p>如果存入123.4567，实际际将是123.457。</p><p>如果存入12345679.899，总长度超出了10，Oracle将提示错误。</p><p>如果打算存入整数，用number(m)就可以了，m表示可以存入数据的最大位数。</p><h1 id="三-日期类型"><a class="markdownIt-Anchor" href="#三-日期类型"></a> 三、日期类型</h1><p>Oracle采用date类型表示日期和时间，这是一个7字节的固定宽度的数据类型，有7个属性，包括：世纪、世纪中哪一年、月份、月中的哪一天、小时、分钟和秒。</p><p>对编程语言来说，日期和时间是用字符串来显示和书写的，Oracle提供了to_date和to_char两个函数在date类型和字符串类型之间转换。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,birthday)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>))</span></span>;</span><br><span class="line">select name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL where name=<span class="string">&#x27;西施&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="四-clob和blob类型"><a class="markdownIt-Anchor" href="#四-clob和blob类型"></a> 四、clob和blob类型</h1><p>clob类型，变长的字符串大对象，最长可达4GB，clob可以存储单字节字符串或多字节字符串数据，clob被认为是一个更大的字符串。当数据库的字符集发生转换时，clob类型会受到影响。</p><p>blob类型，变长的二进制大对象，最长可达4GB，blob主要用于保存带格式的非结构化数据，如图片、音频、视频、Office文档等。当数据库的字符集发生转换时，blob类型不会受到影响，Oracle数据库不关心存放的是什么内容。</p><h1 id="五-rowid类型"><a class="markdownIt-Anchor" href="#五-rowid类型"></a> 五、rowid类型</h1><p>Oracle数据库中每个表的每行记录都有一个存储的物理位置，即表的rowid伪列，采用rowid作为where条件的访问效率最高。</p><p>rowid的访问效率虽然是最高的，但是，在实际应用中要谨慎，需要注意两个问题：</p><p>1）rowid存放的是表记录的物理位置，在数据整理、数据备份和迁移的时候，记录的物理位置会发生改变；</p><p>2）rowid是Oracle数据库专有的数据类型，与其它的数据库不兼容。</p><h1 id="六-其它数据类型"><a class="markdownIt-Anchor" href="#六-其它数据类型"></a> 六、其它数据类型</h1><p>在上面的内容中，介绍了Oracle最常用的数据类型，可以满足99%以上的应用场景。</p><p>Oracle提供了22中不同的SQL数据类型，其它的数据类型不一定实用，但我还是把它们全部列出来，大家了解一下，不必深入研究。二十年来，其它的数据类型我从未使用过。</p><p>char：定长字符串，会用空格填充来达到最大长度。非null的char(10)包含10个字节信息。char字段最多可以存储2000个字节信息。</p><p>nchar：包含unicode格式数据的定长字符串。nchar字段最多可存储2000字节的信息。</p><p>varchar2：是varchar的同义词。这是一个变长字符串，与char类型不同，它不会用空格将字段或变量填充至最大长度。varchar(10)可能包含0~10字节的信息，最多可存储4000字节信息。从12c起，可以存储32767字节信息。</p><p>nvarchar2：包含unicode格式数据的变长字符串。最多可存储4000字节信息。从12c起，可以存储32767字节信息。</p><p>raw：一种变长二进制数据类型，采用这种数据类型存储的数据不会发生字符集转换。</p><p>number：能存储精度最多高达38位的数字。这种类型的数据会以变长方式来存储，长度在0~22字节。</p><p>binary_float：32位单精度浮点数，可以支持至少6位精度，占用磁盘上5个字节的存储空间。</p><p>binary_double：64位双精度浮点数，可以支持至少15位精度，占用磁盘上9个字节的存储空间。</p><p>long：这种类型能存储最多2GB的字符数据</p><p>long raw：long raw类型能存储多达2GB的二进制信息</p><p>date：这是一个7字节的定宽日期/时间数据类型，其中包含7个属性：世纪、世纪中的哪一年、月份、月中的哪一天、小时、分钟、秒。</p><p>timestamp：这是一个7字节或11字节的定宽日期/时间数据类型，它包含小数秒。</p><p>timestamp with time zone：这是一个13字节的timestamp，提供了时区支持。</p><p>timestamp with local time zone：这是一个7字节或11字节的定宽日期/时间数据类型，在数据的插入和读取时会发生时区转换。</p><p>interval year to month：这是一个5字节的定宽数据类型，用于存储一个时段。</p><p>interval day to second：这是一个11字节的定宽数据类型，用于存储一个时段。将时段存储为天/小时/分钟/秒数，还可以有9位小数秒。</p><p>blob：这种类型能够存储最多4GB的数据。</p><p>clob：这种类型能够存储最多4GB的数据。当字符集发生转换时，这种类型会受到影响。</p><p>nclob：这种类型能够存储最多4GB的数据。当字符集发生转换时，这种类型会受到影响。</p><p>bfile：这种数据类型可以在数据库列中存储一个oracle目录对象和一个文件名，我们可以通过它来读取这个文件。</p><p>rowid：实际上是数据库表中行的地址，它有10字节长。</p><p>urowid：是一个通用的rowid，没有固定的rowid的表。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle环境变量</title>
      <link href="/post/283c6f87.html"/>
      <url>/post/283c6f87.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-oracle环境变量"><a class="markdownIt-Anchor" href="#一-oracle环境变量"></a> 一、Oracle环境变量</h1><p>Oracle数据库的安装和运行都需要环境变量，常用的Oracle环境变量如下。</p><h2 id="1-oracle_home"><a class="markdownIt-Anchor" href="#1-oracle_home"></a> 1、ORACLE_HOME</h2><p>Oracle软件安装的根目录，存放了Oracle的可执行程序、管理工具、函数库、java虚拟机、帮助文档、示例代码等。</p><h2 id="2-oracle_base"><a class="markdownIt-Anchor" href="#2-oracle_base"></a> 2、ORACLE_BASE</h2><p>Oracle实例（数据库）的根目录，存放了实例的控制文件、数据文件、日志文件、审计日志、错误报告等。</p><h2 id="3-oracle_sid"><a class="markdownIt-Anchor" href="#3-oracle_sid"></a> 3、ORACLE_SID</h2><p>Oracle的实例名。</p><h2 id="4-nls_lang"><a class="markdownIt-Anchor" href="#4-nls_lang"></a> 4、NLS_LANG</h2><p>Oracle客户端的字符集，必须与服务端的Oracle实例保持一致，否则会出现中文乱码。</p><h2 id="5-path"><a class="markdownIt-Anchor" href="#5-path"></a> 5、PATH</h2><p>PATH是Linux操作系统的环境变量（可执行程序的搜索目录），在PATH中增加$ORACLE_HOME/bin是为了方便执行Oracle的应用程序。</p><h2 id="6-ld_library_path"><a class="markdownIt-Anchor" href="#6-ld_library_path"></a> 6、LD_LIBRARY_PATH</h2><p>LD_LIBRARY_PATH是Linux操作系统的环境变量（动态链接库文件的搜索目录），在LD_LIBRARY_PATH中增加$ORACLE_HOME/lib。只有C/C++程序员才关心LD_LIBRARY_PATH环境变量。</p><h2 id="7-classpath"><a class="markdownIt-Anchor" href="#7-classpath"></a> 7、CLASSPATH</h2><p>CLASSPATH是Linux操作系统的环境变量，在CLASSPATH中增加$ORACLE_HOME/jdk/jre:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib，只有java程序员才关心CLASSPATH环境变量。</p><h2 id="8-其它环境变量"><a class="markdownIt-Anchor" href="#8-其它环境变量"></a> 8、其它环境变量</h2><p>Oracle其它的环境变量意义不大，一般不必设置，如TNS_ADMIN、ORACLE_OWNER、ORACLE_TERM等。</p><h1 id="二-oracle环境的配置"><a class="markdownIt-Anchor" href="#二-oracle环境的配置"></a> 二、Oracle环境的配置</h1><p>在Linux中，配置Oracle环境变量有多种方法，假设环境变量的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ORACLE_HOME=/oracle/home</span><br><span class="line"><span class="keyword">export</span> ORACLE_BASE=/oracle/base</span><br><span class="line"><span class="keyword">export</span> ORACLE_SID=snorcl11g</span><br><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin:.</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib:.</span><br><span class="line">CLASSPATH=$ORACLE_HOME/jdk/jre:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib:.</span><br><span class="line"><span class="keyword">export</span> CLASSPATH</span><br></pre></td></tr></table></figure><h2 id="1-在oracle用户的bash_profile中配置"><a class="markdownIt-Anchor" href="#1-在oracle用户的bash_profile中配置"></a> 1、在oracle用户的.bash_profile中配置</h2><p>如果在oracle用户的.bash_profile中配置Oracle的环境变量，只对oracle一个用户生效。</p><h2 id="2-在etcprofile中配置"><a class="markdownIt-Anchor" href="#2-在etcprofile中配置"></a> 2、在/etc/profile中配置</h2><p>在/etc/profile文件中配置Oracle的环境变量，可以对全部的用户生效。</p><p>但是，/etc/profile文件开始几行的内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310151646483.png" alt="在这里插入图片描述" /></p><p>Linux不建议在/etc/profile文件中配置环境变量。</p><h2 id="3-在etcprofiled中配置"><a class="markdownIt-Anchor" href="#3-在etcprofiled中配置"></a> 3、在/etc/profile.d中配置</h2><p>在/etc/profile.d目录中增加环境变量配置文件，<a href="http://xn--oracle-hh4k.sh">如oracle.sh</a>。</p><p>如果把Oracle环境变量的配置文件放在/etc/profile.d中，可以对全部的用户生效。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle11g客户端安装配置</title>
      <link href="/post/4464eb0c.html"/>
      <url>/post/4464eb0c.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库管理员和开发者一定希望在自己台式电脑的Windows系统中搭建Oracle客户端工作环境。</p><p>Oracle客户端工作环境主要包括两个部分：1）Oracle数据库客户端软件，提供了Oracle客户端驱动和配置工具；2）PL/SQL<br />Developer软件，在该软件中，可以很方便的查看和管理Oracle数据库对象，编写、调试和运行SQL语句。</p><h1 id="一-oracle数据库客户端的安装"><a class="markdownIt-Anchor" href="#一-oracle数据库客户端的安装"></a> 一、Oracle数据库客户端的安装</h1><h2 id="1-下载软件安装包"><a class="markdownIt-Anchor" href="#1-下载软件安装包"></a> 1、下载软件安装包</h2><p>Oracle数据库客户端软件包名是 win64_11gR2_client.zip ，可以从Oracle公司的官网下载，链接如下：</p><p><a href="https://www.oracle.com/database/technologies/112010-win64soft.html">https://www.oracle.com/database/technologies/112010-win64soft.html</a></p><p>或者登录C语言技术网，在资源下载栏目中可以下载。</p><p>安装Oracle数据库客户端软件不需要软件授权license，不存在破解版的说法。</p><h2 id="2-解压运行安装程序"><a class="markdownIt-Anchor" href="#2-解压运行安装程序"></a> 2、解压运行安装程序</h2><p><strong>1）运行安装程序。</strong></p><p>点击sertup运行后，会弹出一个DOS窗口，可能需要等几十秒。</p><p><img src="https://img-blog.csdnimg.cn/20200310144744705.png" alt="在这里插入图片描述" /></p><p><strong>2）如果出现了以下窗口，选“是(Y)”继续。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144759484.png" alt="在这里插入图片描述" /></p><p><strong>3）安装类型选择“管理员”。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144811400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>4）语言选择“简体中文”和“英语”。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144826435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>5）指定Oracle的基目录和软件安装位置，可以用缺省值，也可以如下图。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144836311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>6）执行先决条件检查。</strong></p><p>如果出现了“执行先决条件检查”失败，勾选“全部忽略”后再下一步。</p><p><img src="https://img-blog.csdnimg.cn/20200310144850859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>7）确认安装信息。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144901294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>8）安装进行中。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144925596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>9）安全中心警报。</strong></p><p>如果安装进行中出现Windows安全中心警报，选择“允许访问”。</p><p><img src="https://img-blog.csdnimg.cn/20200310144949508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>10）安装完成。</strong></p><p><img src="https://img-blog.csdnimg.cn/2020031014505356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="二-plsql-developer的安装"><a class="markdownIt-Anchor" href="#二-plsql-developer的安装"></a> 二、PL/SQL Developer的安装</h1><p>连接Oracle数据库的客户端软件比较多，如Navicat Premium，但是，PL/SQL Developer专为Oracle数据库定制开发的，功能强大，使用方便，是最佳的选择。</p><h2 id="1-下载软件安装包-2"><a class="markdownIt-Anchor" href="#1-下载软件安装包-2"></a> 1、下载软件安装包</h2><p>PL/SQL Developer是一款收费的软件。</p><p>官网地址：<a href="https://www.allroundautomations.com">https://www.allroundautomations.com</a></p><p>或者登录C语言技术网，在资源下载栏目中可以下载。</p><p>PL/SQL Developer安装过程中需要软件授权license，各位可以百度，解决方法很多。</p><p>PL/SQL Developer软件有多个版本，建议安装11以上版本。</p><h2 id="2-安装软件包"><a class="markdownIt-Anchor" href="#2-安装软件包"></a> 2、安装软件包</h2><p>PL/SQL Developer软件的安装没有任何技术含量，下一步再下一步就可以了。</p><h1 id="三-配置oracle客户端环境"><a class="markdownIt-Anchor" href="#三-配置oracle客户端环境"></a> 三、配置Oracle客户端环境</h1><h2 id="1-配置数据库参数"><a class="markdownIt-Anchor" href="#1-配置数据库参数"></a> 1、配置数据库参数</h2><p>Oracle数据库客户端软件安装完成后，数据库参数配置文件（tnsnames.ora）是不存在的。</p><p>从（Oracle客户端软件的安装位置）\network\admin\sample目录中把nsnames.ora文件复制到（Oracle客户端软件的安装位置）\network\admin目录。</p><p><img src="https://img-blog.csdnimg.cn/20200310145135894.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310145335283.png" alt="在这里插入图片描述" /></p><p>用写字板或其它的文本编辑软件（必须以系统管理员身证运行）打开tnsnames.ora，输入数据库配置参数，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310145359421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>文本内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">snorcl11g_143 =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = <span class="number">122.152</span><span class="number">.209</span><span class="number">.143</span>)(PORT = <span class="number">1521</span>))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SID = snorcl11g)</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>以上的参数中，您只需要关心四个内容。</p><p>1）数据库名，或数据库服务名，或tnsname，这个名称由您自定义，如<code>snorcl11g_143</code></p><p>2）数据库服务器的ip地址，您的服务器ip是多少就填多少，如：<code>(HOST = 122.152.209.143)</code></p><p>3）数据库服务器监听的端口，缺省是1521，如：<code>(PORT = 1521)</code></p><p>4）数据库的SID，即ORACLE_SID，如：<code>(SID = snorcl11g)</code></p><h2 id="2-启动plsql-developer软件"><a class="markdownIt-Anchor" href="#2-启动plsql-developer软件"></a> 2、启动PL/SQL Developer软件</h2><p>输入登录数据库的用户名、密码和数据库名。</p><h2 id="在这里插入图片描述3-打开sql窗口"><a class="markdownIt-Anchor" href="#在这里插入图片描述3-打开sql窗口"></a> <img src="https://img-blog.csdnimg.cn/20200310145557934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />3、打开SQL窗口</h2><p><img src="https://img-blog.csdnimg.cn/20200310145610862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="4-执行sql语句"><a class="markdownIt-Anchor" href="#4-执行sql语句"></a> 4、执行SQL语句</h2><p><img src="https://img-blog.csdnimg.cn/2020031014562860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-最常用的objects窗口"><a class="markdownIt-Anchor" href="#5-最常用的objects窗口"></a> 5、最常用的Objects窗口</h2><p><img src="https://img-blog.csdnimg.cn/20200310145640402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="四-客户端环境变量"><a class="markdownIt-Anchor" href="#四-客户端环境变量"></a> 四、客户端环境变量</h1><h2 id="1-path环境变量"><a class="markdownIt-Anchor" href="#1-path环境变量"></a> 1、Path环境变量</h2><p>Oracle客户端软件安装完成后，会修改Windows系统变量的Path环境变量，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310145702206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-注册表"><a class="markdownIt-Anchor" href="#2-注册表"></a> 2、注册表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regedit.exe</span><br></pre></td></tr></table></figure><p>HKEY_LOCAL_MACHINE -&gt; SOFTWARE -&gt; ORACLE -&gt; KEY_OraClient11g_home1</p><p><img src="https://img-blog.csdnimg.cn/20200310145728965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-判断客户端是否能连上数据库"><a class="markdownIt-Anchor" href="#五-判断客户端是否能连上数据库"></a> 五、判断客户端是否能连上数据库</h1><h2 id="1-打开dos窗口"><a class="markdownIt-Anchor" href="#1-打开dos窗口"></a> 1、打开DOS窗口</h2><p><img src="https://img-blog.csdnimg.cn/2020031014574439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-判断数据库的监听端口"><a class="markdownIt-Anchor" href="#2-判断数据库的监听端口"></a> 2、判断数据库的监听端口</h2><p>telnet数据库服务器的1521端口。</p><p>如果成功，会出现一个空白窗口，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310145801960.png" alt="在这里插入图片描述" /></p><p>如果失败，会出现如下提示：</p><p><img src="https://img-blog.csdnimg.cn/20200310145820149.png" alt="在这里插入图片描述" /></p><p>如果telnet数据库的1521端口成功，表示网络和防火墙都没有问题。如果失败，有四种可能：1）Oracle数据库没有启动监听服务；2）Oracle数据库服务器的防火墙没有开通1521端口；3）云平台的安全组（或访问策略）没有开通1521端口；4）网络故障，网络不通。</p><h2 id="3-tnsping判断数据库客户端配置"><a class="markdownIt-Anchor" href="#3-tnsping判断数据库客户端配置"></a> 3、tnsping判断数据库客户端配置</h2><p><img src="https://img-blog.csdnimg.cn/20200310145842729.png" alt="在这里插入图片描述" /></p><p>以上成功的情况，如果出现其它内容，则表示tnsnames.ora文件中的配置不正确。但是，要注意一个问题，如果tnsname中的sid配置不正确，tnsping也是成功的，所以tnsping成功，并不表示客户端可以正常连接。</p><h2 id="4-windows下的sqlplus"><a class="markdownIt-Anchor" href="#4-windows下的sqlplus"></a> 4、Windows下的sqlplus</h2><p>Oracle的客户端软件自带sqlplus工具，也可以登录数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200310145902725.png" alt="在这里插入图片描述" /></p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle11g数据库快速安装</title>
      <link href="/post/2b2262da.html"/>
      <url>/post/2b2262da.html</url>
      
        <content type="html"><![CDATA[<p>关于Oracle数据库安装的文章网上到处都是，百度一下就能找到很多，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200310112336403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>能百度到的Oracle安装是常规的方法，我就不讲了，本文向大家介绍一种更简单的非常规的安装方法，这种方法适用于初学者。</p><h1 id="一-oracle安装存在的问题"><a class="markdownIt-Anchor" href="#一-oracle安装存在的问题"></a> 一、Oracle安装存在的问题</h1><p>Oracle数据库系统对服务器的硬件和软件要求比较严格，一般来说，用于Oracle生产环境的服务器配置非常好，内存在16GB以上，在图形界面中安装Oracle非常容易，极少失败。</p><p>但是，对初学者来说，学习资源有限，一般是在VMWare虚拟机上安装CentOS操作系统，或租用最低配置的云服务器（1核1G/2G内存），不可能有那么好的服务器来安装Oracle，也可能没有图形界面。在虚拟机或低配置的云服务器上安装Oracle问题很多，莫名其妙，根本找不到问题的原因和解决方法，困难重重，让人欲哭无泪。</p><h1 id="二-如何解决oracle安装的问题"><a class="markdownIt-Anchor" href="#二-如何解决oracle安装的问题"></a> 二、如何解决Oracle安装的问题</h1><p>解决虚拟机或低配置的云服务器上安装Oracle的方法有两种：</p><p>1）不用图形界面，采用静默方式安装，这种方法的技术难度比较大，Oracle的DBA经常采用这种方法，而普通程序员很难掌握。</p><p>2）把已经安装好的Oracle软件、数据库实例和环境参数打包压缩，然后在目标服务上解压恢复，对初学者来说，这是搭建Oracle数据库学习环境的最佳方案，也是本文采用的方案。</p><p><strong>在安装Oracle之前，您必须已经掌握了Linux的常用命令，具备Oracle数据库系统的基础知识。</strong></p><h1 id="三-获得oracle压缩包"><a class="markdownIt-Anchor" href="#三-获得oracle压缩包"></a> 三、获得Oracle压缩包</h1><p>登录C语言技术网，在“资源下载”栏目中下载软件安装包，文件名是oracle11gR2.tgz。</p><h1 id="四-软件需求"><a class="markdownIt-Anchor" href="#四-软件需求"></a> 四、软件需求</h1><p>建议采用CentOS7系列版本的操作系统，CentOS6和CentOS7在系统配置和操作上有较大差别，CentOS8以上版本对初学者来说没有必要。</p><p>建议先把CentOS7操作系统的字符集设置为zh_CN.gbk。</p><h1 id="五-硬件需求"><a class="markdownIt-Anchor" href="#五-硬件需求"></a> 五、硬件需求</h1><h2 id="1-查看内存和交换区的大小"><a class="markdownIt-Anchor" href="#1-查看内存和交换区的大小"></a> 1、查看内存和交换区的大小</h2><p>采用<code>free -m</code>命令查看系统的内存和交换区，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310112432223.png" alt="在这里插入图片描述" /></p><p><code>Mem:</code>行显示的是物理内存的大小和使用情况，<code>Swap:</code>行显示的是交换区的大小和使用情况，单位是MB。</p><p>安装Oracle的物理内存要求在1024MB以上，交换区的要求如下：</p><table><thead><tr><th>可用内存</th><th>交换区大小</th></tr></thead><tbody><tr><td>1024MB到2048MB之间。</td><td>1.5倍于物理内存。</td></tr><tr><td>2049MB到8192MB之间。</td><td>1倍于物理内存。</td></tr><tr><td>大于8192MB。</td><td>0.75倍于物理内存。</td></tr></tbody></table><h2 id="2-创建交换区"><a class="markdownIt-Anchor" href="#2-创建交换区"></a> 2、创建交换区</h2><p>如果没有交换区或交换区太小，先创建交换区，交换区的大小见上表的对应关系，以下步骤将创建一个2048M的交换区。</p><p>1）用root用户执行dd命令创建/swap1文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/swap1 bs=<span class="number">1024</span> count=<span class="number">2048000</span></span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310112541735.png" alt="在这里插入图片描述" /></p><p>2）把/swap1文件设置成交换区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/mkswap /swap1</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310112616800.png" alt="在这里插入图片描述" /></p><p>3）把/swap1交换区设置为有效状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/swapon /swap1</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310121957730.png" alt="在这里插入图片描述" /></p><p>4）用<code>free -m</code>命令查看交换区，确认已生效。</p><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310122017555.png" alt="在这里插入图片描述" /></p><p>5）修改/etc/fstab文件，让CentOS操作系统在每次重启时自动加载/swap1交换区。</p><p>在/etc/fstab文件中增加以下内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swap1 swap swap defaults <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310122044518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>6）重启操作系统，重启后再确认一下交换区/swap1是否已加载。</p><h2 id="3-删除交换区"><a class="markdownIt-Anchor" href="#3-删除交换区"></a> 3、删除交换区</h2><p>如果创建的交换区不符合要求，可以用以下步骤删除它。</p><p>1）停止正在使用的swap分区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff /swap1</span><br></pre></td></tr></table></figure><p>2）删除swap分区文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /swap1</span><br></pre></td></tr></table></figure><p>3）修改/etc/fstab文件，删除开机自动挂载/swap1的命令。</p><h1 id="六-安装对应的依赖包"><a class="markdownIt-Anchor" href="#六-安装对应的依赖包"></a> 六、安装对应的依赖包</h1><p>安装Oracle之前，还需要安装一些CentOS的软件包，用以下命令执行安装（用root用户执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y binutils* compat-libstdc* elfutils-libelf* gcc* glibc* ksh* libaio* libgcc* libstdc* make* sysstat* libXp*  glibc-kernheaders ksh binutils compat-libstdc++<span class="number">-33</span> elfutils-libelf elfutils-libelf-devel gcc gcc-c++ glibc glibc-common glibc-devel libaio libaio-devel libgcc libstdc++ libstdc++-devel make numactl sysstat libXp unixODBC unixODBC-devel</span><br></pre></td></tr></table></figure><p>这些软件包依赖关系比较复杂，不管它，多执行几次以上命令，直到全部的软件包都是最新版本。</p><h1 id="七-修改系统核心参数"><a class="markdownIt-Anchor" href="#七-修改系统核心参数"></a> 七、修改系统核心参数</h1><h2 id="1-修改etcsysctlconf文件"><a class="markdownIt-Anchor" href="#1-修改etcsysctlconf文件"></a> 1、修改/etc/sysctl.conf文件</h2><p>/etc/sysctl.conf是操作系统的核心参数配置文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max = <span class="number">6815744</span></span><br><span class="line">fs.aio-max-nr = <span class="number">1048576</span></span><br><span class="line">kernel.shmall = <span class="number">2097152</span></span><br><span class="line">kernel.shmmax= <span class="number">2147483648</span></span><br><span class="line">kernel.shmmni= <span class="number">4096</span></span><br><span class="line">kernel.sem = <span class="number">250</span> <span class="number">32000100</span> <span class="number">128</span></span><br><span class="line">net.ipv4.ip_local_port_range= <span class="number">9000</span> <span class="number">65500</span></span><br><span class="line">net.core.rmem_default= <span class="number">262144</span></span><br><span class="line">net.core.rmem_max= <span class="number">4194304</span></span><br><span class="line">net.core.wmem_default = <span class="number">262144</span></span><br><span class="line">net.core.wmem_max= <span class="number">1048576</span></span><br></pre></td></tr></table></figure><p>注意，kernel.shmmax参数的值为操作系统内存的一半，单位是字节。例如，操作系统总内存如果是1024MB，那么kernel.shmmax的值应该是512*1024*1024=536870912，即kernel.shmmax=536870912</p><p>其它的参数照抄。</p><h2 id="2-修改etcsecuritylimitsconf文件"><a class="markdownIt-Anchor" href="#2-修改etcsecuritylimitsconf文件"></a> 2、 修改/etc/security/limits.conf文件</h2><p>/etc/security/limits.conf是操作系统对用户使用资源的配置文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oracle           soft    nproc     <span class="number">2047</span></span><br><span class="line">oracle           hard    nproc    <span class="number">16384</span></span><br><span class="line">oracle           soft    nofile    <span class="number">1024</span></span><br><span class="line">oracle           hard    nofile   <span class="number">65536</span></span><br><span class="line">oracle           hard    stack    <span class="number">10240</span></span><br></pre></td></tr></table></figure><h2 id="3-修改etcpamdlogin文件"><a class="markdownIt-Anchor" href="#3-修改etcpamdlogin文件"></a> 3、 修改/etc/pam.d/login文件</h2><p>/etc/pam.d/login是用户认证文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session    required     /lib64/security/pam_limits.so</span><br></pre></td></tr></table></figure><h2 id="4-修改etcprofile文件"><a class="markdownIt-Anchor" href="#4-修改etcprofile文件"></a> 4、 修改/etc/profile文件</h2><p>/etc/profile是系统环境参数配置文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $USER = <span class="string">&quot;oracle&quot;</span> ]; then</span><br><span class="line">        <span class="keyword">if</span> [ $SHELL = <span class="string">&quot;/bin/ksh&quot;</span> ]; then</span><br><span class="line">              ulimit -p <span class="number">16384</span></span><br><span class="line">              ulimit -n <span class="number">65536</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">              ulimit -u <span class="number">16384</span> -n <span class="number">65536</span></span><br><span class="line">        fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="5-修改etcselinuxconfig文件"><a class="markdownIt-Anchor" href="#5-修改etcselinuxconfig文件"></a> 5、 修改/etc/selinux/config文件</h2><p>/etc/selinux/config是SELinux配置文件，修改SELINUX的值，禁用它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><h2 id="6-重启服务器"><a class="markdownIt-Anchor" href="#6-重启服务器"></a> 6、重启服务器</h2><p><code>init 6</code> 或 <code>reboot</code></p><h1 id="八-创建oracle用户和组"><a class="markdownIt-Anchor" href="#八-创建oracle用户和组"></a> 八、创建Oracle用户和组</h1><p>Oracle的安装用户是oracle，组是dba，oracle用户的根目录是/oracle，不能采用其它目录（注意是小写的字母），如果/oracle目录的空间不够，可以采用软链接的方式，把有/oracle链接到其它有足够空间的目录。</p><p>1）创建dba组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd dba</span><br></pre></td></tr></table></figure><p>2）创建oracle用户，组名是dba，用户根目录是/oracle，不可改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -n oracle -g dba -d /oracle</span><br></pre></td></tr></table></figure><p>3）修改oracle用户的密码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd oracle</span><br></pre></td></tr></table></figure><h1 id="九-解开压缩包"><a class="markdownIt-Anchor" href="#九-解开压缩包"></a> 九、解开压缩包</h1><p>把Oracle的压缩包文件oracle11gR2.tgz上传到服务器的/tmp目录。</p><p>采用<code>su - oracle</code>切换到oracle用户，在根目录下执行解开压缩包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su - oracle</span><br><span class="line">cd /</span><br><span class="line">tar zxvf /tmp/oracle11gR2.tgz</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p><strong>注意，解压缩包后，一定要退出oracle用户，否则oracle用户的环境变量不会生效。</strong></p><h1 id="十-数据库的参数"><a class="markdownIt-Anchor" href="#十-数据库的参数"></a> 十、数据库的参数</h1><p>oracle11gR2.tgz解压后，会生成/oracle/.bash_profile文件，包括了Oracle数据库的安装参数，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ORACLE_BASE=/oracle/base</span><br><span class="line"><span class="keyword">export</span> ORACLE_HOME=/oracle/home</span><br><span class="line"><span class="keyword">export</span> ORACLE_SID=snorcl11g</span><br><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/lib</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin:.</span><br></pre></td></tr></table></figure><h1 id="十一-数据库的启动"><a class="markdownIt-Anchor" href="#十一-数据库的启动"></a> 十一、数据库的启动</h1><p>用oracle用户登录，执行<code>lsnrctl start</code>启动网络监听服务，执行<code>dbstart</code>启动数据库系统。</p><p><img src="https://img-blog.csdnimg.cn/20200310125054387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310125103846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="十二-数据库的关闭"><a class="markdownIt-Anchor" href="#十二-数据库的关闭"></a> 十二、数据库的关闭</h1><p>用oracle用户登录，执行<code>lsnrctl stop</code>关闭网络监听服务，执行<code>dbshut</code>关闭数据库系统。</p><p><strong>在重启或关闭服务器操作系统之前，一定要关闭数据库，否则数据库损坏的概率非常大。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310125138444.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310125146429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="十三-采用sqlplus登录数据库"><a class="markdownIt-Anchor" href="#十三-采用sqlplus登录数据库"></a> 十三、采用sqlplus登录数据库</h1><p>用oracle用户登录CentOS系统。</p><p>执行<code>sqlplus scott/tiger</code>，以scott用户的身份登录数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200310125223438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>在sqlplus中，输入<code>exit</code>;退出sqlplus。</p><p>在Shell中，执行<code>sqlplus / as sysdba</code>以系统管理员身份登录数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200310125257850.png" alt="在这里插入图片描述" /></p><h1 id="十四-查询数据库的版本"><a class="markdownIt-Anchor" href="#十四-查询数据库的版本"></a> 十四、查询数据库的版本</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from v$version;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310125330225.png" alt="在这里插入图片描述" /></p><h1 id="十五-服务器防火墙配置"><a class="markdownIt-Anchor" href="#十五-服务器防火墙配置"></a> 十五、服务器防火墙配置</h1><p>Oracle数据库缺省的通信端口是1521，如果想从远程连接Oracle数据库，需要开通服务器防火墙的1521端口。</p><p>CentOS7和CentOS6的防火墙设置不同，CentOS7采用以下命令开通1521端口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">1521</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>以下是CentOS7防火墙的相关操作命令。</p><h2 id="1-查看防火墙的命令"><a class="markdownIt-Anchor" href="#1-查看防火墙的命令"></a> 1、查看防火墙的命令</h2><p>1）查看防火墙的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --version</span><br></pre></td></tr></table></figure><p>2）查看firewall的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>3）查看firewall服务状态（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>4）查看防火墙全部的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>5）查看防火墙已开通的端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-port</span><br></pre></td></tr></table></figure><p>6）查看防火墙已开通的服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-service</span><br></pre></td></tr></table></figure><p>7）查看全部的服务列表（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><p>8）查看防火墙服务是否开机启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled firewalld</span><br></pre></td></tr></table></figure><h2 id="2-配置防火墙的命令"><a class="markdownIt-Anchor" href="#2-配置防火墙的命令"></a> 2、配置防火墙的命令</h2><p>1）启动、重启、关闭防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#启动</span><br><span class="line">systemctl start firewalld</span><br><span class="line">#重启</span><br><span class="line">systemctl restart firewalld</span><br><span class="line">#关闭</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>2）开放、移去1521端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放<span class="number">1521</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">1521</span>/tcp --permanent</span><br><span class="line">#移去<span class="number">1521</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-port=<span class="number">1521</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>4）设置开机时启用、禁用防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启用服务</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">#禁用服务</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h1 id="十六-云平台访问策略配置"><a class="markdownIt-Anchor" href="#十六-云平台访问策略配置"></a> 十六、云平台访问策略配置</h1><p>如果Oracle数据库安装在云服务器上，需要登录云服务器提供商的管理平台开通访问策略（或安全组），开通1521端口的访问策略。</p><p>不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。</p><h1 id="十七-版权声明"><a class="markdownIt-Anchor" href="#十七-版权声明"></a> 十七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库介绍</title>
      <link href="/post/adfcc7f1.html"/>
      <url>/post/adfcc7f1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-oracle数据库"><a class="markdownIt-Anchor" href="#一-oracle数据库"></a> 一、Oracle数据库</h1><p>Oracle Database，又名Oracle RDBMS，简称Oracle数据库。</p><p>Oracle数据库系统是美国Oracle公司（甲骨文）提供的以分布式数据库为核心的一系列软件产品，是目前世界上使用最为广泛的数据库管理系统，具备完整的数据管理功能，真正实现了分布式处理功能。</p><p>Oracle数据库最新版本为Oracle Database 19c。Oracle数据库12c 引入了一个新的多承租方架构，使用该架构可轻松部署和管理数据库云。此外，一些新特性可最大限度地提高资源使用率和灵活性，这些独一无二的技术进步再加上在可用性、安全性和大数据支持方面的增强，使得Oracle数据库12c 成为私有云和公有云部署的理想平台。</p><h1 id="二-支持平台"><a class="markdownIt-Anchor" href="#二-支持平台"></a> 二、支持平台</h1><p>在2001年发布的Oracle9i之前，甲骨文公司把他们的数据库产品广泛的移植到了不同的平台上，支持各种主流的操作系统。近期，甲骨文公司巩固了少部分的操作系统平台。</p><h1 id="三-oracle数据库的特点"><a class="markdownIt-Anchor" href="#三-oracle数据库的特点"></a> 三、Oracle数据库的特点</h1><p>该用什么词语来描述Oracle的特点呢？高可用？高稳定？最高安全级别？性能卓越？无与伦比？我认为，这些形容词不足以表达Oracle数据库的的特点，它的强大超出您的想象。</p><p>既然说不清楚Oracle数据库的优点，那就说说它的缺点吧，Oracle的缺点很好找：</p><p>1）贵、价格很贵。</p><p>2）贵，很高贵，连Oracle的安装也是一个技术活，对于习惯“下一步”的初学者还说，Oracle的安装实在太麻烦，不过这一点有所改善，在Oracle 18c中，已经支持rpm一键安装了。</p><p>3）Oracle提供的OCI函数库极其强大，但是难以驾驭，近年来，Oracle公司提供了一些帮助文档和示例代码，网上也有一些非常棒的开源库。</p><h1 id="四-与其它数据库的比较"><a class="markdownIt-Anchor" href="#四-与其它数据库的比较"></a> 四、与其它数据库的比较</h1><p>其它的数据库产品，如Sybase、SQL Server、MySQL等与Oracle根本不是同一级别的软件产品，没有可比性。如果一定要比较，其它的数据库像拖拉机或皮卡，Oracle是重卡。</p><h1 id="五-就业前景"><a class="markdownIt-Anchor" href="#五-就业前景"></a> 五、就业前景</h1><p>没有搞过Oracle数据库的程序员不好意思说自己熟悉数据库，熟悉Oracle数据库的程序员可以认为经历过了项目的毒打。</p><h1 id="六-初学者的误区"><a class="markdownIt-Anchor" href="#六-初学者的误区"></a> 六、初学者的误区</h1><p>1）2019年9月DB-Engines的数据库流行度排行榜如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310111425160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2）2019年12月前程无忧发布的招聘职位中，分别以Oracle、MySQL和 SQL Server 为关键字搜索，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310111440865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/202003101114586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310111509212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>从DB-Engines的数据库流行度排行榜和前程无忧招聘的数据上看，MySQL的受欢迎程度和职位数似乎与Oracle不相上下，那么MySQL和Oracle真的有可比性吗？<br />这里说说我的一些观点。</p><p>1）Oracle是收费的（企业版售价约20-30万人民币），MySQL是免费的，举个例子，比如去市场买菜，有免费的猪肉和收费的猪肉，如果最终选择免费猪肉和收费猪肉的顾客人数相当，那么您还会认为这两种猪肉的品质相当吗？</p><p>2）Oracle数据库的运行环境难以搭建，Oracle的安装就是一个技术活，对开发者的技术门槛也比较高，以C/C<ins>程序员为例，Oracle提供了OCI函数库，但是，如果不采用第三方的开源软件，能熟练运用OCI函数库的C/C</ins>程序员如凤毛麟角。</p><p>3）在某些国企和政府部门，提倡采用免费的数据库产品，这是非常草率的决定，最后的结局往往是：a）免费的数据库产品无法满足应用的需求；b）免费的数据库在可用性和可维护性方面比较差，需要更多技术人员的投入，增加的人力成本远远超过购买Oracle数据库软件的费用。</p><p>4）Oracle是收费的，很贵，但是贵有贵的道理，便宜不是那么好捡的。</p><p>5）顺便提一下，MySQL已经被Oracle公司收购，Oracle想把MySQL怎么样就怎么样，MySQL的前景有一百万个可能，唯一不可能的是希望Oracle会对MySQL有任何的提升。</p><p>6）我们的目标是成为职业的程序员，学习最有竞争力的软件产品和技术是明智的选择。</p><p>7）SQL Server一直是个边缘化的产品。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7配置rsync实现文件同步</title>
      <link href="/post/40b4a6a3.html"/>
      <url>/post/40b4a6a3.html</url>
      
        <content type="html"><![CDATA[<p>rsync（remote synchronize ）是一个远程文件同步工具，支持多个操作系统，用于在多台服务器之间同步目录和文件。rsync采用增量传输文件的方法，只传输新文件和修改过的文件，而不是每次都全部传输，效率比较高。</p><p>rsync有以下特点：</p><p>1）支持目录和文件的上传和下载功能；</p><p>2）可以镜像保存整个目录树和文件系统；</p><p>3）传输效率高，只传输新增和修改过的文件。</p><h1 id="一-安装软件包"><a class="markdownIt-Anchor" href="#一-安装软件包"></a> 一、安装软件包</h1><p>rsync的客户端和服务器软件的安装包都是rsync。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install rsync</span><br></pre></td></tr></table></figure><h1 id="二-修改系统配置"><a class="markdownIt-Anchor" href="#二-修改系统配置"></a> 二、修改系统配置</h1><h2 id="1-关闭selinux"><a class="markdownIt-Anchor" href="#1-关闭selinux"></a> 1、关闭SELINUX</h2><p>修改/etc/selinux/config文件，把SELINUX参数的值改为disabled。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX =disabled</span><br></pre></td></tr></table></figure><p>重启linux系统或执行 setenforce 0 使修改马上生效。</p><h2 id="2-开通防火墙端口"><a class="markdownIt-Anchor" href="#2-开通防火墙端口"></a> 2、开通防火墙端口</h2><p>rsync缺省的端口是873，您可以修改配置文件中的端口。</p><p>1）防火墙开通873端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">873</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>2）重启防火墙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="3-启用rsyncd服务"><a class="markdownIt-Anchor" href="#3-启用rsyncd服务"></a> 3、启用rsyncd服务</h2><p>rsync的服务名是rsyncd。</p><p>1）启动rsyncd服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rsyncd</span><br></pre></td></tr></table></figure><p>2）把rsyncd服务设置为开机自启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rsyncd</span><br></pre></td></tr></table></figure><h1 id="三-配置rsync"><a class="markdownIt-Anchor" href="#三-配置rsync"></a> 三、配置rsync</h1><p>接下来我用示例来显示文件同步的配置和使用，需求如下：</p><p>1）我只用一台服务器来测试，IP地址是192.168.1.129，既是服务器，也是客户端；</p><p>2）服务端的目录是/tmp/docs；</p><p>3）我将创建两个客户端用户：client1和client2；</p><p>4）客户端client1的目录是/tmp/docs1；</p><p>5）客户端client2的目录是/tmp/docs2；</p><p>6）客户端client1把/tmp/docs1目录中的文件发送给服务端；</p><p>7）客户端client2从服务端下载文件，存放在/tmp/docs2目录中。</p><p>rsync的服务器和客户端，这是一个逻辑的概念，并不是物理的，如果您有三个服务器，就可以用三台服务器来测试，原理是一样的。</p><h2 id="1-创建操作系统用户"><a class="markdownIt-Anchor" href="#1-创建操作系统用户"></a> 1、创建操作系统用户</h2><p>操作系统用户可以是普通的用户，也可以是简单的、无需登录的、没有HOME目录的用户，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin rsync -g bin  # 创建rsync用户，指定组为bin（其它组也行）。</span><br></pre></td></tr></table></figure><p>注意，这个用户是在服务器上创建的，不是客户端。</p><h2 id="2-创建测试目录和文件"><a class="markdownIt-Anchor" href="#2-创建测试目录和文件"></a> 2、创建测试目录和文件</h2><p>执行以下脚本，创建/tmp/docs目录，生成测试和文件，并指定用户和组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/docs /tmp/docs1 /tmp/docs2  # 删除测试目录。</span><br><span class="line">mkdir /tmp/docs /tmp/docs1 /tmp/docs2  # 创建三个测试目录。</span><br><span class="line">ls /usr &gt; /tmp/docs1/usr.txt  # 把ls /usr的结果输出到/tmp/docs1/usr.txt文件。</span><br><span class="line">ls /etc &gt; /tmp/docs1/etc.txt  # 把ls /etc的结果输出到/tmp/docs1/etc.txt文件。</span><br><span class="line">chown -R rsync:rsync /tmp/docs # 修改/tmp/docs目录及文件用户和组。</span><br></pre></td></tr></table></figure><h2 id="3-创建rsnyc登录用户密码文件"><a class="markdownIt-Anchor" href="#3-创建rsnyc登录用户密码文件"></a> 3、创建rsnyc登录用户密码文件</h2><p>在rsync服务器上创建登录用户/密码文件/etc/rsyncd.passwd，用于客户端的身份认证，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client1:pwd1</span><br><span class="line">client2:pwd2</span><br></pre></td></tr></table></figure><p>以上文件包括了两个用户（用户名/密码分别是client/pwd1和client2/pwd2）。</p><p><strong>把/etc/rsyncd.passwd文件的权限设置为600，如果不这么做，客户端登录会失败。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">600</span> /etc/rsync.passwd</span><br></pre></td></tr></table></figure><h2 id="4-配置rsync服务器参数"><a class="markdownIt-Anchor" href="#4-配置rsync服务器参数"></a> 4、配置rsync服务器参数</h2><p>rsync服务器的配置文件是/etc/rsyncd.conf，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># /etc/rsyncd: configuration file <span class="keyword">for</span> rsync daemon mode</span><br><span class="line"># See rsyncd.conf man page <span class="keyword">for</span> more options.</span><br><span class="line"></span><br><span class="line"><span class="meta"># rsyncd全局参数。</span></span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line">port = <span class="number">873</span></span><br><span class="line">fake super = yes</span><br><span class="line">use chroot = no</span><br><span class="line">max connections = <span class="number">200</span></span><br><span class="line">timeout = <span class="number">600</span></span><br><span class="line">ignore errors</span><br><span class="line">read only = <span class="literal">false</span></span><br><span class="line">list = <span class="literal">false</span></span><br><span class="line">auth users = client1,client2</span><br><span class="line">secrets file = /etc/rsync.passwd</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line"># 同步模块配置。</span><br><span class="line">[docs]</span><br><span class="line">comment = welcome to docs!</span><br><span class="line">path = /tmp/docs</span><br></pre></td></tr></table></figure><p><strong>注意，不要在参数后面加#和说明文字，是非法的。</strong></p><p>全局参数说明：</p><p>1）uid = rsync，rsync服务端操作系统的用户，即上面第1点中创建的操作系统用户，您可以创建新的操作系统用户，也可以用现有的用户。</p><p>2）gid = rsync，rsync服务端操作系统的用户的组，即uid用户的组。</p><p>3）port = 873，用于通信的TCP端口，缺省是873。</p><p>4）fake super = yes，rsync服务端操作系统的用户可以不用root。</p><p>5）use chroot = no，关闭假根功能。</p><p>6）max connections = 200，客户端最大连接数。</p><p>7）timeout = 600，超时时间。</p><p>8）ignore errors，忽略错误信息。</p><p>9）read only = false，是否为只读方式。</p><p>10）list = false，不允许查看模块信息。</p><p>11）auth users = client1,client2，指定允许登录的客户端认证用户清单，用逗号分隔，必须是/etc/rsync.passwd文件中配置的用户。</p><p>12）secrets file = /etc/rsync.passwd，定义rsync客户端用户认证的密码文件。</p><p>13）log file = /var/log/rsyncd.log，rsync服务运行日志文件，注意，日志文件日积月累，必须保证有足够的磁盘空间。</p><p>同步参数说明：</p><p>1）[docs]，模块名称，自定义的名称，不一定要与同步目录相同。</p><p>2）comment = welcome to docs!，模块说明文字。</p><p>3）path = /tmp/docs，同步的目录名，必须是uid参数指定的用户和gid参数指定的组。</p><h2 id="5-把客户端的文件同步上传到服务器"><a class="markdownIt-Anchor" href="#5-把客户端的文件同步上传到服务器"></a> 5、把客户端的文件同步上传到服务器</h2><p>1）采用client1用户，把客户端/tmp/docs1目录下的文件同步到服务器，命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /tmp/docs1<span class="comment">/* client1@192.168.1.129::docs</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200401195721644.png" alt="在这里插入图片描述" /></p><p>2）检查服务端的/tmp/docs目录和客户端的/tmp/docs目录下的文件是否相同。</p><p>3）再生成一些测试文件：创建/tmp/docs1/aaa/tmp.txt文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/docs1/aaa</span><br><span class="line">ls /tmp &gt; /tmp/docs1/aaa/tmp.txt</span><br></pre></td></tr></table></figure><p>4）再执行一次同步。<br /><img src="https://img-blog.csdnimg.cn/20200401195805550.png" alt="在这里插入图片描述" /></p><h2 id="6-从服务器同步下载文件到客户端"><a class="markdownIt-Anchor" href="#6-从服务器同步下载文件到客户端"></a> 6、从服务器同步下载文件到客户端</h2><p>1）采用client2用户，把服务器的文件下载到客户端/tmp/docs2目录命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz client2@<span class="number">192.168</span><span class="number">.1</span><span class="number">.129</span>::docs /tmp/docs2</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200401195835906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1Y3oxMjIxNDA3Mjk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意，我用client1用户上传文件，用client2下载文件，其目的是为了演示多个客户端帐号的配置和使用方法，您也可以只用一个帐号上传和下载文件。</p><h2 id="7-客户端的密码配置"><a class="markdownIt-Anchor" href="#7-客户端的密码配置"></a> 7、客户端的密码配置</h2><p>以上演示客户端同步文件的时候，需要手工的输入密码，但是在实际应用中，命令可能在后台运行，不希望手工输入密码，这个需求有两种解决方法：</p><p>1）设置客户端的密码文件。</p><p>例如client1用户，密码文件是/etc/client1.passwd，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo pwd1 &gt; /etc/client1.passwd</span><br><span class="line">chmod <span class="number">600</span> /etc/client1.passwd</span><br></pre></td></tr></table></figure><p><strong>注意，客户端的密码文件权限一定要是600，否则认证会失败。</strong></p><p>同步上传的命令如下：<br />rsync -avz /tmp/docs1/* <a href="mailto:client1@192.168.1.129">client1@192.168.1.129</a>::docs --password-file=/etc/client1.passwd</p><p>2）设置客户端的密码环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> RSYNC_PASSWORD=pwd1</span><br></pre></td></tr></table></figure><p>同步上传的命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /tmp/docs1<span class="comment">/* client1@192.168.1.129::docs</span></span><br></pre></td></tr></table></figure><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><h2 id="1-小心有坑"><a class="markdownIt-Anchor" href="#1-小心有坑"></a> 1、小心有坑</h2><p>rsrync的配置有两个坑：1）配置文件/etc/rsyncd.conf中，参数后面不要用#注释；2）服务端和客户端密码文件的权限一定要是600，否则认证失败。</p><h2 id="2-客户端权限问题"><a class="markdownIt-Anchor" href="#2-客户端权限问题"></a> 2、客户端权限问题</h2><p>客户端可以用任何用户来执行，只要该用户对本地目录有足够的权限就可以了。</p><h2 id="3-日志文件的问题"><a class="markdownIt-Anchor" href="#3-日志文件的问题"></a> 3、日志文件的问题</h2><p>小心服务端的日志文件（log file）越积越大。</p><h2 id="4-效率问题"><a class="markdownIt-Anchor" href="#4-效率问题"></a> 4、效率问题</h2><p>rsync同步文件采用的是增量同步的方法，本质上就是在传输文件之前，先判断客户端与服务器目录的文件变量情况，如果待同步目录下的文件太多，这个判断很费时间。</p><h2 id="5-rsyncsersync架构"><a class="markdownIt-Anchor" href="#5-rsyncsersync架构"></a> 5、rsync+sersync架构</h2><p>上面提到的rsync存在效率问题，最终的解决方法是采用rsync+sersync架构。</p><p>1）sersync可以记录被监听目录中发生变化的（增，删，改）具体某个文件或目录的名字；</p><p>2）rsync在同步时，只同步发生变化的文件或目录（每次发生变化的数据相对整个同步目录数据来说很小，rsync在遍历查找对比文件时，速度很快），因此效率很高。</p><p>rsync+sersync架构在本文就不介绍了，各位真的有需求时再研究它。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7配置samba共享文件系统</title>
      <link href="/post/2dc95266.html"/>
      <url>/post/2dc95266.html</url>
      
        <content type="html"><![CDATA[<p>我们知道Windows系统之间可以共享文件系统和打印机，Linux系统采用Samba来实现共享文件系统和打印机的功能。通过SMB协议，Windows和Linux系统之间的文件系统和打印机可以互相访问。</p><p>SMB（Server Messages Block）协议是一种在局域网上共享文件系统和打印机的TCP应用层协议，它为局域网内的不同计算机之间提供文件系统和打印机的共享服务。SMB协议是客户/服务器型，Samba是在Linux系统上实现SMB协议的一个免费软件。</p><h1 id="一-安装软件包"><a class="markdownIt-Anchor" href="#一-安装软件包"></a> 一、安装软件包</h1><p>Samba涉及到四个软件包，有些功能您可能用不上，但是安装了也不会有问题。</p><p>1）samba：Samba服务器。</p><p>2）samba-client：Samba客户端。</p><p>3）samba-common：Samba服务器和客户端相关的软件。</p><p>4）cifs-utils：通用的Internet文件系统实用程序，支持与Windows、OS X和其他Unix系统进行跨平台文件共享。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install samba samba-client samba-common cifs-utils</span><br></pre></td></tr></table></figure><h1 id="二-修改系统配置"><a class="markdownIt-Anchor" href="#二-修改系统配置"></a> 二、修改系统配置</h1><h2 id="1-关闭selinux"><a class="markdownIt-Anchor" href="#1-关闭selinux"></a> 1、关闭SELINUX</h2><p>修改/etc/selinux/config文件，把SELINUX参数的值改为disabled。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX =disabled</span><br></pre></td></tr></table></figure><p>重启linux系统或执行 setenforce 0 使修改马上生效。</p><h2 id="2-开通防火墙端口"><a class="markdownIt-Anchor" href="#2-开通防火墙端口"></a> 2、开通防火墙端口</h2><p>Samba 涉及到以四个端口：UDP 137、UDP 138、TCP 139、TCP 445。</p><p>1）防火墙开通samba服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-service=samba --permanent</span><br></pre></td></tr></table></figure><p>2）重启防火墙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="3-启用smb服务"><a class="markdownIt-Anchor" href="#3-启用smb服务"></a> 3、启用smb服务</h2><p>Samba的服务名是smb。</p><p>1）启动smb服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start smb</span><br></pre></td></tr></table></figure><p>2）把smb服务设置为开机自启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable smb</span><br></pre></td></tr></table></figure><h1 id="三-samba服务的参数文件"><a class="markdownIt-Anchor" href="#三-samba服务的参数文件"></a> 三、Samba服务的参数文件</h1><p>Samba服务的参数文件是/etc/samba/smb.conf，在CentOS7版本的系统中，该文件的原始内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># See smb.conf.example <span class="keyword">for</span> a more detailed config file <span class="keyword">or</span></span><br><span class="line"><span class="meta"># read the smb.conf manpage.</span></span><br><span class="line"># Run <span class="string">&#x27;testparm&#x27;</span> to verify the config is correct after</span><br><span class="line"><span class="meta"># you modified it.</span></span><br><span class="line">[global]</span><br><span class="line">        workgroup = SAMBA</span><br><span class="line">        security = user</span><br><span class="line">        passdb backend = tdbsam</span><br><span class="line">        printing = cups</span><br><span class="line">        printcap name = cups</span><br><span class="line">        load printers = yes</span><br><span class="line">        cups options = raw</span><br><span class="line">[homes]</span><br><span class="line">        comment = Home Directories</span><br><span class="line">        valid users = %S, %D%w%S</span><br><span class="line">        browseable = No</span><br><span class="line">        read only = No</span><br><span class="line">        inherit acls = Yes</span><br><span class="line">[printers]</span><br><span class="line">        comment = All Printers</span><br><span class="line">        path = /var/tmp</span><br><span class="line">        printable = Yes</span><br><span class="line">        create mask = <span class="number">0600</span></span><br><span class="line">        browseable = No</span><br><span class="line">[print$]</span><br><span class="line">        comment = Printer Drivers</span><br><span class="line">        path = /var/lib/samba/drivers</span><br><span class="line">        write list = @printadmin root</span><br><span class="line">        force group = @printadmin</span><br><span class="line">        create mask = <span class="number">0664</span></span><br><span class="line">        directory mask = <span class="number">0775</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[global]组是全局参数，根据不同的需求，我们会修改部分参数。</p><p>[homes]组是用户主目录参数，我们不关心它。</p><p>[printers]和[print$]组是共享打印机参数，我们不关心它。</p><p>testparm命令可以测试smb.conf配置是否正确。</p><p>testparm -v命令可以详细的列出smb.conf支持的配置参数。</p><p>smb.conf文件的配置比较麻烦，网上有很多资料，但大部分不准确。我先不介绍smb.conf文件中参数的含义，我用实际应用的场景来介绍它的配置。</p><p><strong>共享文件系统的应用场景主要有两种：</strong></p><p><strong>1）匿名方式：不需要输入用户名和密码，任何人都可以访问共享文件系统；</strong></p><p><strong>2）用户名/密码方式：需要用户名和密码成功登录后才可以访问共享文件系统。</strong></p><h1 id="四-配置任何人都可以访问的共享文件系统"><a class="markdownIt-Anchor" href="#四-配置任何人都可以访问的共享文件系统"></a> 四、配置任何人都可以访问的共享文件系统</h1><p>例如您想把服务器/tmp/docs目录共享出来。</p><h2 id="1-创建测试目录和文件"><a class="markdownIt-Anchor" href="#1-创建测试目录和文件"></a> 1、创建测试目录和文件</h2><p>执行以下脚本，创建/tmp/docs目录，生成测试和文件，并指定用户和组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/docs  # 创建/tmp/docs目录。</span><br><span class="line">ls /usr &gt; /tmp/docs/usr.txt  # 把ls /usr的结果输出到/tmp/docs/usr.txt文件。</span><br><span class="line">ls /etc &gt; /tmp/docs/etc.txt  # 把ls /etc的结果输出到/tmp/docs/etc.txt文件。</span><br><span class="line">chown -R nobody:nobody /tmp/docs # 修改/tmp/docs目录及文件用户和组。</span><br></pre></td></tr></table></figure><h2 id="2-配置etcsambasmbconf文件"><a class="markdownIt-Anchor" href="#2-配置etcsambasmbconf文件"></a> 2、配置/etc/samba/smb.conf文件</h2><p>在[global]组中增加以下行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map to guest = Bad User</span><br></pre></td></tr></table></figure><p>在文件最后增加以下行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[docs]</span><br><span class="line">comment = Fully shared directory</span><br><span class="line">path = /tmp/docs</span><br><span class="line"><span class="keyword">public</span> = yes</span><br><span class="line">read only = no</span><br></pre></td></tr></table></figure><p>[docs]为待共享的文件系统起个名称，不要求与目录名相同，在windows下将看到这个名称。</p><p>comment参数是说明文字。</p><p>path是待共享的Linux目录。</p><p>public指定guest用户可以访问。</p><p>read only是否为只读，yes或no。</p><p>完整的/etc/samba/smb.conf文件的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">workgroup = SAMBA</span><br><span class="line">security = user</span><br><span class="line">map to guest = Bad User</span><br><span class="line"></span><br><span class="line">[docs]</span><br><span class="line">comment = Fully shared <span class="built_in">docs</span>(read/write)</span><br><span class="line">path = /tmp/docs</span><br><span class="line"><span class="keyword">public</span> = yes</span><br><span class="line">read only = no</span><br></pre></td></tr></table></figure><p>和打印机相关的参数我删除掉了，留着也没用。</p><h2 id="3-重启samba服务验证结果"><a class="markdownIt-Anchor" href="#3-重启samba服务验证结果"></a> 3、重启samba服务，验证结果</h2><p>每次修改/etc/samba/smb.conf文件后，要重启smb服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart smb</span><br></pre></td></tr></table></figure><p>在windows上的我的电脑中，输入\\服务器IP，不需要输入服户名和密码就可以访问Linux共享文件系统，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200331113054113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>您可以修改docs目录中的文件，也可以创建新的目录和文件。</p><h2 id="4-注意事项"><a class="markdownIt-Anchor" href="#4-注意事项"></a> 4、注意事项</h2><p>1）security参数要用user，不能用share，share已不支持；</p><p>2）map to guest = Bad User，这个配置的意思是将所有用户都映射成guest用户，所以访问共享文件时就不再需要用户名和密码了。</p><p>3）待共享的目录和文件的用户和组要设置成nobody。</p><p>4）/etc/samba/smb.conf文件中，global只能一组，共享目录可以配置多个。</p><h1 id="五-配置需要用户名密码才能访问的共享文件系统"><a class="markdownIt-Anchor" href="#五-配置需要用户名密码才能访问的共享文件系统"></a> 五、配置需要用户名/密码才能访问的共享文件系统</h1><h2 id="1-创建操作系统用户"><a class="markdownIt-Anchor" href="#1-创建操作系统用户"></a> 1、创建操作系统用户</h2><p>操作系统用户可以是普通的用户，也可以是简单的、无需登录的、没有HOME目录的用户，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin test -g bin  # 创建test用户，指定组为bin（其它组也行）。</span><br></pre></td></tr></table></figure><h2 id="2-创建测试目录和文件"><a class="markdownIt-Anchor" href="#2-创建测试目录和文件"></a> 2、创建测试目录和文件</h2><p>执行以下脚本，创建/tmp/docs目录，生成测试和文件，并指定用户和组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/docs  # 创建/tmp/docs目录。</span><br><span class="line">ls /usr &gt; /tmp/docs/usr.txt  # 把ls /usr的结果输出到/tmp/docs/usr.txt文件。</span><br><span class="line">ls /etc &gt; /tmp/docs/etc.txt  # 把ls /etc的结果输出到/tmp/docs/etc.txt文件。</span><br><span class="line">chown -R test:bin /tmp/docs # 修改/tmp/docs目录及文件用户和组。</span><br></pre></td></tr></table></figure><h2 id="3-添加-samba-用户"><a class="markdownIt-Anchor" href="#3-添加-samba-用户"></a> 3、添加 Samba 用户</h2><p>操作系统用户不能直接用于Samba服务的登录<br />，采用smbpasswd命令把操作系统用户添加到Samba的用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a test</span><br></pre></td></tr></table></figure><p>执行以上命令后，按系统提示两次输入密码，注意，输入的是用于登录Samba服务器的密码，与操作系统的密码没有关系。</p><p>smbpasswd 命令是用于维护 Samba 服务器的用户帐号的，具体如下：</p><p>1）添加 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a sambauser</span><br></pre></td></tr></table></figure><p>2）删除 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -x sambauser</span><br></pre></td></tr></table></figure><p>3）禁用 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -d sambauser</span><br></pre></td></tr></table></figure><p>4）启用 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -e sambauser</span><br></pre></td></tr></table></figure><h2 id="4-配置etcsambasmbconf文件"><a class="markdownIt-Anchor" href="#4-配置etcsambasmbconf文件"></a> 4、配置/etc/samba/smb.conf文件</h2><p>/etc/samba/smb.conf文件的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">        security = USER</span><br><span class="line">        workgroup = SAMBA</span><br><span class="line">[docs]</span><br><span class="line">        comment = Shared <span class="built_in">docs</span>(read/write)</span><br><span class="line">        path = /tmp/docs</span><br><span class="line">        read only = No</span><br></pre></td></tr></table></figure><p>注意：在/etc/samba/smb.conf文件中，global只能一组，共享目录可以配置多个。</p><h2 id="5-重启samba服务验证结果"><a class="markdownIt-Anchor" href="#5-重启samba服务验证结果"></a> 5、重启samba服务，验证结果</h2><p>每次修改/etc/samba/smb.conf文件后，要重启smb服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart smb</span><br></pre></td></tr></table></figure><p>在windows上的我的电脑中，输入\\服务器IP后，按提示输入用户名和密码就可以访问Linux共享文件系统，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200331113701698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="六-smbconf文件详解"><a class="markdownIt-Anchor" href="#六-smbconf文件详解"></a> 六、smb.conf文件详解</h1><p>smb.conf文件的参数非常多，也很麻烦，如果您有更多的需求，请阅读/etc/samba/smb.conf.example文件，或man 5 smb.conf查看帮助。</p><p>我从网上找了一些说明文字，供大家参考，但是，我不保证这些说明文字是正确的，我没有测试验证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"># 全局参数</span><br><span class="line"># ==================Global Settings =================== #</span><br><span class="line">[global]</span><br><span class="line">config file = /usr/local/samba/lib/smb.conf.%m</span><br><span class="line">说明：config file可以让你使用另一个配置文件来覆盖缺省的配置文件。如果文件不存在，则该项无效。这个参数很有用，可以使得samba配置更灵活，可以让一台 samba服务器模拟多台不同配置的服务器。比如，你想让PC1（主机名）这台电脑在访问Samba Server时使用它自己的配置文件，那么先在/etc/samba/host/下为PC1配置一个名为smb.conf.pc1的文件，然后在 smb.conf中加入：config file = /etc/samba/host/smb.conf.%m。这样当PC1请求连接Samba Server时，smb.conf.%m就被替换成smb.conf.pc1。这样，对于PC1来说，它所使用的Samba服务就是由 smb.conf.pc1定义的，而其他机器访问Samba Server则还是应用smb.conf。</span><br><span class="line"></span><br><span class="line">workgroup = WORKGROUP</span><br><span class="line">说明：设定 Samba Server 所要加入的工作组或者域。</span><br><span class="line"></span><br><span class="line">server string = Samba Server Version %v</span><br><span class="line">说明：设定 Samba Server 的注释，可以是任何字符串，也可以不填。宏%v表示显示Samba的版本号。</span><br><span class="line"></span><br><span class="line">netbios name = smbserver</span><br><span class="line">说明：设置Samba Server的NetBIOS名称。如果不填，则默认会使用该服务器的DNS名称的第一部分。netbios name和workgroup名字不要设置成一样了。</span><br><span class="line"></span><br><span class="line">interfaces = lo eth0 <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>/<span class="number">24</span> <span class="number">192.168</span><span class="number">.13</span><span class="number">.2</span>/<span class="number">24</span></span><br><span class="line">说明：设置Samba Server监听哪些网卡，可以写网卡名，也可以写该网卡的IP地址。</span><br><span class="line"></span><br><span class="line">hosts allow = <span class="number">127.</span> <span class="number">192.168</span><span class="number">.1</span>. <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br><span class="line">说明：表示允许连接到Samba Server的客户端，多个参数以空格隔开。可以用一个IP表示，也可以用一个网段表示。hosts deny 与hosts allow 刚好相反。</span><br><span class="line">例如：hosts allow=<span class="number">172.17</span><span class="number">.2</span>.EXCEPT172<span class="number">.17</span><span class="number">.2</span><span class="number">.50</span></span><br><span class="line">表示容许来自<span class="number">172.17</span><span class="number">.2</span>.*的主机连接，但排除<span class="number">172.17</span><span class="number">.2</span><span class="number">.50</span></span><br><span class="line">hosts allow=<span class="number">172.17</span><span class="number">.2</span><span class="number">.0</span>/<span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">表示容许来自<span class="number">172.17</span><span class="number">.2</span><span class="number">.0</span>/<span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>子网中的所有主机连接</span><br><span class="line">hosts allow=M1，M2</span><br><span class="line">表示容许来自M1和M2两台计算机连接</span><br><span class="line">hosts allow=@pega</span><br><span class="line">表示容许来自pega网域的所有计算机连接</span><br><span class="line"></span><br><span class="line">max connections = <span class="number">0</span></span><br><span class="line">说明：max connections用来指定连接Samba Server的最大连接数目。如果超出连接数目，则新的连接请求将被拒绝。<span class="number">0</span>表示不限制。</span><br><span class="line"></span><br><span class="line">deadtime = <span class="number">0</span></span><br><span class="line">说明：deadtime用来设置断掉一个没有打开任何文件的连接的时间。单位是分钟，<span class="number">0</span>代表Samba Server不自动切断任何连接。</span><br><span class="line"></span><br><span class="line">time server = yes/no</span><br><span class="line">说明：time server用来设置让nmdb成为windows客户端的时间服务器。</span><br><span class="line"></span><br><span class="line">log file = /var/log/samba/log.%m</span><br><span class="line">说明：设置Samba Server日志文件的存储位置以及日志文件名称。在文件名后加个宏%m（主机名），表示对每台访问Samba Server的机器都单独记录一个日志文件。如果pc1、pc2访问过Samba Server，就会在/var/log/samba目录下留下log.pc1和log.pc2两个日志文件。</span><br><span class="line"></span><br><span class="line">max log size = <span class="number">50</span></span><br><span class="line">说明：设置Samba Server日志文件的最大容量，单位为kB，<span class="number">0</span>代表不限制。</span><br><span class="line"></span><br><span class="line">security = user</span><br><span class="line">说明：设置用户访问Samba Server的验证方式，一共有四种验证方式。</span><br><span class="line"><span class="number">1</span>）share：用户访问Samba Server不需要提供用户名和口令, 安全性能较低，已不兼容。</span><br><span class="line"><span class="number">2</span>）user：Samba Server共享目录只能被授权的用户访问,由Samba Server负责检查账号和密码的正确性。账号和密码要在本Samba Server中建立。</span><br><span class="line"><span class="number">3</span>）server：依靠其他Windows NT/<span class="number">2000</span>或Samba Server来验证用户的账号和密码,是一种代理验证。此种安全模式下,系统管理员可以把所有的Windows用户和口令集中到一个NT系统上,使用 Windows NT进行Samba认证, 远程服务器可以自动认证全部用户和口令,如果认证失败,Samba将使用用户级安全模式作为替代的方式。</span><br><span class="line"><span class="number">4</span>）domain：域安全级别,使用主域控制器(PDC)来完成认证。</span><br><span class="line"></span><br><span class="line">passdb backend = tdbsam</span><br><span class="line">说明：passdb backend就是用户后台的意思。目前有三种后台：smbpasswd、tdbsam和ldapsam。sam应该是security account manager（安全账户管理）的简写。</span><br><span class="line"><span class="number">1</span>）smbpasswd：该方式是使用smb自己的工具smbpasswd来给系统用户（真实用户或者虚拟用户）设置一个Samba密码，客户端就用这个密码来访问Samba的资源。smbpasswd文件默认在/etc/samba目录下，不过有时候要手工建立该文件。</span><br><span class="line"><span class="number">2</span>）tdbsam： 该方式则是使用一个数据库文件来建立用户数据库。数据库文件叫passdb.tdb，默认在/etc/samba目录下。passdb.tdb用户数据库 可以使用smbpasswd –a来建立Samba用户，不过要建立的Samba用户必须先是系统用户。我们也可以使用pdbedit命令来建立Samba账户。pdbedit命令的 参数很多，我们列出几个主要的。</span><br><span class="line">　　pdbedit –a username：新建Samba账户。</span><br><span class="line">　　pdbedit –x username：删除Samba账户。</span><br><span class="line">　　pdbedit –L：列出Samba用户列表，读取passdb.tdb数据库文件。</span><br><span class="line">　　pdbedit –Lv：列出Samba用户列表的详细信息。</span><br><span class="line">　　pdbedit –c “[D]” –u username：暂停该Samba用户的账号。</span><br><span class="line">　　pdbedit –c “[]” –u username：恢复该Samba用户的账号。</span><br><span class="line"><span class="number">3</span>）ldapsam：该方式则是基于LDAP的账户管理方式来验证用户。首先要建立LDAP服务，然后设置“passdb backend = ldapsam:ldap:<span class="comment">//LDAP Server”</span></span><br><span class="line"></span><br><span class="line">encrypt passwords = yes/no</span><br><span class="line">说明：是否将认证密码加密。因为现在windows操作系统都是使用加密密码，所以一般要开启此项。不过配置文件默认已开启。</span><br><span class="line"></span><br><span class="line">smb passwd file = /etc/samba/smbpasswd</span><br><span class="line">说明：用来定义samba用户的密码文件。smbpasswd文件如果没有那就要手工新建。</span><br><span class="line"></span><br><span class="line">username map = /etc/samba/smbusers</span><br><span class="line">说明：用来定义用户名映射，比如可以将root换成administrator、admin等。不过要事先在smbusers文件中定义好。比如：root = administrator admin，这样就可以用administrator或admin这两个用户来代替root登陆Samba Server，更贴近windows用户的习惯。</span><br><span class="line"></span><br><span class="line">guest account = nobody</span><br><span class="line">说明：用来设置guest用户名。</span><br><span class="line"></span><br><span class="line">socket options = TCP_NODELAY SO_RCVBUF=<span class="number">8192</span> SO_SNDBUF=<span class="number">8192</span></span><br><span class="line">说明：用来设置服务器和客户端之间会话的Socket选项，可以优化传输速度。</span><br><span class="line"></span><br><span class="line">domain master = yes/no</span><br><span class="line">说明：设置Samba服务器是否要成为网域主浏览器，网域主浏览器可以管理跨子网域的浏览服务。</span><br><span class="line"></span><br><span class="line">local master = yes/no</span><br><span class="line">说明：local master用来指定Samba Server是否试图成为本地网域主浏览器。如果设为no，则永远不会成为本地网域主浏览器。但是即使设置为yes，也不等于该Samba Server就能成为主浏览器，还需要参加选举。</span><br><span class="line"></span><br><span class="line">preferred master = yes/no</span><br><span class="line">说明：设置Samba Server一开机就强迫进行主浏览器选举，可以提高Samba Server成为本地网域主浏览器的机会。如果该参数指定为yes时，最好把domain master也指定为yes。使用该参数时要注意：如果在本Samba Server所在的子网有其他的机器（不论是windows NT还是其他Samba Server）也指定为首要主浏览器时，那么这些机器将会因为争夺主浏览器而在网络上大发广播，影响网络性能。</span><br><span class="line">如果同一个区域内有多台Samba Server，将上面三个参数设定在一台即可。</span><br><span class="line"></span><br><span class="line">os level = <span class="number">200</span></span><br><span class="line">说明：设置samba服务器的os level。该参数决定Samba Server是否有机会成为本地网域的主浏览器。os level从<span class="number">0</span>到<span class="number">255</span>，winNT的os level是<span class="number">32</span>，win95/<span class="number">98</span>的os level是<span class="number">1</span>。Windows <span class="number">2000</span>的os level是<span class="number">64</span>。如果设置为<span class="number">0</span>，则意味着Samba Server将失去浏览选择。如果想让Samba Server成为PDC，那么将它的os level值设大些。</span><br><span class="line"></span><br><span class="line">domain logons = yes/no</span><br><span class="line">说明：设置Samba Server是否要做为本地域控制器。主域控制器和备份域控制器都需要开启此项。</span><br><span class="line"></span><br><span class="line">logon script = %u.bat</span><br><span class="line">说明：当使用者用windows客户端登陆，那么Samba将提供一个登陆档。如果设置成%u.bat，那么就要为每个用户提供一个登陆档。如果人比较多， 那就比较麻烦。可以设置成一个具体的文件名，比如start.bat，那么用户登陆后都会去执行start.bat，而不用为每个用户设定一个登陆档了。 这个文件要放置在[netlogon]的path设置的目录路径下。</span><br><span class="line"></span><br><span class="line">wins support = yes/no</span><br><span class="line">说明：设置samba服务器是否提供wins服务。</span><br><span class="line"></span><br><span class="line">wins server = wins服务器IP地址</span><br><span class="line">说明：设置Samba Server是否使用别的wins服务器提供wins服务。</span><br><span class="line"></span><br><span class="line">wins proxy = yes/no</span><br><span class="line">说明：设置Samba Server是否开启wins代理服务。</span><br><span class="line"></span><br><span class="line">dns proxy = yes/no</span><br><span class="line">说明：设置Samba Server是否开启dns代理服务。</span><br><span class="line"></span><br><span class="line">load printers = yes/no</span><br><span class="line">说明：设置是否在启动Samba时就共享打印机。</span><br><span class="line"></span><br><span class="line">printcap name = cups</span><br><span class="line">说明：设置共享打印机的配置文件。</span><br><span class="line"></span><br><span class="line">printing = cups</span><br><span class="line">说明：设置Samba共享打印机的类型。现在支持的打印系统有：bsd, sysv, plp, lprng, aix, hpux, qnx</span><br><span class="line"> </span><br><span class="line"># 共享参数</span><br><span class="line"># ================== Share Definitions ================== #</span><br><span class="line"></span><br><span class="line">[共享名]</span><br><span class="line">comment = 任意字符串</span><br><span class="line">说明：comment是对该共享的描述，可以是任意字符串。</span><br><span class="line"></span><br><span class="line">path = 共享目录路径</span><br><span class="line">说 明：path用来指定共享目录的路径。可以用%u、%m这样的宏来代替路径里的unix用户和客户机的Netbios名，用宏表示主要用于[homes] 共享域。例如：如果我们不打算用home段做为客户的共享，而是在/home/share/下为每个Linux用户以他的用户名建个目录，作为他的共享目 录，这样path就可以写成：path = /home/share/%u; 。用户在连接到这共享时具体的路径会被他的用户名代替，要注意这个用户名路径一定要存在，否则，客户机在访问时会找不到网络路径。同样，如果我们不是以用 户来划分目录，而是以客户机来划分目录，为网络上每台可以访问samba的机器都各自建个以它的netbios名的路径，作为不同机器的共享资源，就可以 这样写：path = /home/share/%m 。</span><br><span class="line"></span><br><span class="line">browseable = yes/no</span><br><span class="line">说明：browseable用来指定该共享是否可以浏览。</span><br><span class="line"></span><br><span class="line">writable = yes/no</span><br><span class="line">说明：writable用来指定该共享路径是否可写。</span><br><span class="line"></span><br><span class="line">available = yes/no</span><br><span class="line">说明：available用来指定该共享资源是否可用。</span><br><span class="line"></span><br><span class="line">admin users = 该共享的管理者</span><br><span class="line">说明：admin users用来指定该共享的管理员（对该共享具有完全控制权限）。</span><br><span class="line">例如：admin users =david，sandy（多个用户中间用逗号隔开）。</span><br><span class="line"></span><br><span class="line">valid users = 允许访问该共享的用户</span><br><span class="line">说明：valid users用来指定允许访问该共享资源的用户。</span><br><span class="line">例如：valid users = david，@dave，@tech（多个用户或者组中间用逗号隔开，如果要加入一个组就用“@组名”表示。）</span><br><span class="line"></span><br><span class="line">invalid users = 禁止访问该共享的用户</span><br><span class="line">说明：invalid users用来指定不允许访问该共享资源的用户。</span><br><span class="line">例如：invalid users = root，@bob（多个用户或者组中间用逗号隔开。）</span><br><span class="line"></span><br><span class="line">write list = 允许写入该共享的用户</span><br><span class="line">说明：write list用来指定可以在该共享下写入文件的用户。</span><br><span class="line">例如：write list = david，@dave</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> = yes/no</span><br><span class="line">说明：<span class="keyword">public</span>用来指定该共享是否允许guest账户访问。</span><br><span class="line"></span><br><span class="line">guest ok = yes/no</span><br><span class="line">说明：意义同<span class="keyword">public</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux开机启动程序</title>
      <link href="/post/f284833.html"/>
      <url>/post/f284833.html</url>
      
        <content type="html"><![CDATA[<p>在CentOS7中，实现开机启动程序主要有两种方法：</p><p>1）把要启动的程序配置成自定义的系统服务，该方法我已经介绍过，请阅读：<a href="http://www.freecplus.net/web/list.jsp?typeId=41a73911ba7b45f4931a344387a6a794&amp;navId=056c325857234b9bb0db62329af213ef">CentOS7添加自定义系统服务</a>。</p><p>2）在/etc/rc.local脚本文件中编写启动程序的脚本，本文将详细介绍这种方法。</p><h2 id="1-etcrclocal是etcrcdrclocal的软链接"><a class="markdownIt-Anchor" href="#1-etcrclocal是etcrcdrclocal的软链接"></a> 1、/etc/rc.local是/etc/rc.d/rc.local的软链接</h2><p>执行<code>ls -l /etc/rc.local</code>看看。<br /><img src="https://img-blog.csdnimg.cn/20200328084556723.png" alt="在这里插入图片描述" /><br />/etc/rc.local是/etc/rc.d/rc.local文件的软链接，也就是说他们是同一个文件。</p><h2 id="2-rclocal文件的原始内容"><a class="markdownIt-Anchor" href="#2-rclocal文件的原始内容"></a> 2、rc.local文件的原始内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line">#</span><br><span class="line"># It is highly advisable to create own systemd services <span class="keyword">or</span> udev rules</span><br><span class="line"><span class="meta"># to run scripts during boot instead of using this file.</span></span><br><span class="line">#</span><br><span class="line"># In contrast to previous versions due to parallel execution during boot</span><br><span class="line"><span class="meta"># this script will NOT be run after all other services.</span></span><br><span class="line">#</span><br><span class="line"># Please note that you must run <span class="string">&#x27;chmod +x /etc/rc.d/rc.local&#x27;</span> to ensure</span><br><span class="line"><span class="meta"># that this script will be executed during boot.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">touch /var/lock/subsys/local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中文意思如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加此文件是为了兼容。</span><br><span class="line"># 强烈建议创建自己的systemd服务或udev规则，以便在引导期间运行脚本，而不是使用此文件。</span><br><span class="line"># 与以前版本不同，由于在引导期间并行执行，此脚本不会在所有其他服务之后运行。</span><br><span class="line"># 请注意，必须运行<span class="string">&#x27;chmod+x/etc/rc.d/rc.local&#x27;</span>，以确保在引导期间执行此脚本。</span><br></pre></td></tr></table></figure><p>明白了吧。</p><p>虽然Linux强烈建议采用自定义的系统服务实现开机自启动程序，不过我认为在rc.local中配置开机启动程序也是一个不错的方法，因为rc.local的配置更简单明了，所以仍被广泛的使用。</p><h2 id="3-rclocal文件的配置"><a class="markdownIt-Anchor" href="#3-rclocal文件的配置"></a> 3、rc.local文件的配置</h2><p>rc.local本质上是一个shell脚本文件，可以把启动时需要执行的命令写在里面，启动时将按顺序执行。</p><p>接下来我们来测试它。</p><p>1）在rc.local中添加以下脚本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/date &gt;&gt; /tmp/date1.log # 把当前时间追加写入到/tmp/date1.log中。</span><br><span class="line">/usr/bin/sleep <span class="number">10</span> # 睡眠<span class="number">10</span>秒。</span><br><span class="line">/usr/bin/date &gt;&gt; /tmp/date2.log # 把当前时间追加写入到/tmp/date2.log中。</span><br></pre></td></tr></table></figure><p>2）修改/etc/rc.d/rc.local的可执行权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><p>3）重启服务器。</p><p>4）查看日志文件/tmp/date1.log和/tmp/date2.log的内容。<br /><img src="https://img-blog.csdnimg.cn/20200328084831361.png" alt="在这里插入图片描述" /></p><h2 id="4-应用经验"><a class="markdownIt-Anchor" href="#4-应用经验"></a> 4、应用经验</h2><p>1）rc.local脚本在操作系统启动时只执行一次。</p><p>2）环境变量的问题。</p><p>在rc.local脚本中执行程序时是没有环境变量的，如果您执行的程序需要环境变量，可以在脚本中设置环境变量，也可以用su切换用户来执行，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - oracle -c <span class="string">&quot;sqlplus scott/tiger @/tmp/test.sql&quot;</span></span><br></pre></td></tr></table></figure><p>以上命令的含义就是以oracle用户登录再执行sqlplus命令。</p><p>3）不要让rc.local挂起。</p><p>rc.local是一个脚本，是按顺序执行的，执行完一个程序后才会执行下一个程序，如果某程序不是后台程序，就应该加&amp;让程序运行在后台，否则rc.local会挂起。</p><p>可以用以下脚本来测试，rc.local的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/date &gt;&gt; /tmp/date1.log  # 把当前时间追加写入到/tmp/date1.log中。</span><br><span class="line">/usr/bin/sleep <span class="number">100</span> # 睡眠<span class="number">100</span>秒。</span><br><span class="line">/usr/bin/date &gt;&gt; /tmp/date2.log  # 把当前时间追加写入到/tmp/date2.log中。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果采用了以上脚本，Linux系统在启动完成100后，才会出现以下的登录界面。<br /><img src="https://img-blog.csdnimg.cn/20200328084946139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-版权声明"><a class="markdownIt-Anchor" href="#5-版权声明"></a> 5、版权声明</h2><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7配置IP地址和DNS</title>
      <link href="/post/bce3b467.html"/>
      <url>/post/bce3b467.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-查看ip地址"><a class="markdownIt-Anchor" href="#一-查看ip地址"></a> 一、查看IP地址</h1><h2 id="1-ifconfig命令"><a class="markdownIt-Anchor" href="#1-ifconfig命令"></a> 1、ifconfig命令</h2><p>ifconfig是Linux查看和配置网卡的命令，</p><p><img src="https://img-blog.csdnimg.cn/20200326144626655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>上图中，我们重点关注五方面信息：</p><p>1）网卡名：即网卡设备名，lo是本机（全称loopback，是回环地址，经常被分配到127.0.0.1地址上，用于本机通信，经过内核处理后直接返回，不会在任何网络中出现）；eth0是真实的网卡，如果服务器有多个网卡，网卡命名将是eth0、eth1、eth2、……。注意：真实网卡的名称不一定是eth打头，还可以是no（由主板bios内置的网卡）、ens（代表有主板bios内置的PCI-E网卡）、enp2s（PCI-E独立网卡）等，后面的编号也不一定从0开始。</p><p>2）IP地址：inet后的内容是IP地址，我们现在常说的IP地址是指IPV4，IPV6的地址是inet6之后的内容，暂时不关注。</p><p>3）子网掩码：netmask后的内容是子网掩码。</p><p>4）网卡状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><br></pre></td></tr></table></figure><p>UP：网卡处于启动状态。</p><p>BROADCAST：网卡有广播地址，可以发生广播包。</p><p>MULTICAST：网卡可以发生多播包。</p><p>LOWER_UP：L1是启动的，即网线是插着的。</p><p>5）MAC地址：MAC地址是生产厂家定的，每个网卡拥有的一个地址，相当于设备的序列号。</p><h2 id="2-ip-addr命令"><a class="markdownIt-Anchor" href="#2-ip-addr命令"></a> 2、ip addr命令</h2><p><img src="https://img-blog.csdnimg.cn/20200326144730778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>ip addr命令显示的内容和ifconfig差不多，就不解释了。注意：ip<br />addr命令把IP地址和子网掩码在一起显示，如：<code>172.16.0.7/20</code>。</p><h1 id="二-配置网卡"><a class="markdownIt-Anchor" href="#二-配置网卡"></a> 二、配置网卡</h1><p>每一个网卡都有一个配置文件，存放在/etc/sysconfig/network-scripts目录中，文件名是<code>ifcfg-网卡</code>，网卡eth0的配置文件是<code>ifcfg-eth0</code>，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200326144859680.png" alt="在这里插入图片描述" /></p><h2 id="1-动态ip地址"><a class="markdownIt-Anchor" href="#1-动态ip地址"></a> 1、动态IP地址</h2><p>如果采用的是动态分配IP的方法，ifcfg-eth0的配置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet  # 网卡类型。</span><br><span class="line">PROXY_METHOD=none  # 代理模式。</span><br><span class="line">BROWSER_ONLY=no  # 只是浏览器。</span><br><span class="line">BOOTPROTO=dhcp  <span class="meta"># dhcp-动态分配，static-静态分配（重要）。</span></span><br><span class="line">DEFROUTE=yes  # 启动默认路由。</span><br><span class="line">IPV4_FAILURE_FATAL=no  # 不启用IPV4错误检测功能。</span><br><span class="line">IPV6INIT=yes  # 启用IPV6协议。</span><br><span class="line">IPV6_AUTOCONF=yes  # 自动配置IPV6地址。</span><br><span class="line">IPV6_DEFROUTE=yes  # 用IPV6默认路由。</span><br><span class="line">IPV6_FAILURE_FATAL=no  # 不启用IPV6错误检测功能。</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy  # IPV6地址生成模型。</span><br><span class="line">NAME=eth0  # 网卡物理设备名称（重要）。</span><br><span class="line">UUID=<span class="number">63749b</span>32<span class="number">-6852</span><span class="number">-4535</span><span class="number">-96</span>a9<span class="number">-58</span>d24732771d</span><br><span class="line">DEVICE=eth0  # 网卡设备名称, 必须和NAME值相同（重要）。</span><br><span class="line">ONBOOT=yes  # 是否开机引导。</span><br></pre></td></tr></table></figure><p>以上参数是系统缺省的，只需要关注NOBOOT参数就可以了。</p><h2 id="2-静态ip地址"><a class="markdownIt-Anchor" href="#2-静态ip地址"></a> 2、静态IP地址</h2><p>如果采用的是静态设置IP，ifcfg-eth0的配置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet  # 网卡类型。</span><br><span class="line">PROXY_METHOD=none  # 代理模式。</span><br><span class="line">BROWSER_ONLY=no  # 只是浏览器。</span><br><span class="line">BOOTPROTO=<span class="type">static</span>  <span class="meta"># dhcp-动态分配，static-静态分配（重要）。</span></span><br><span class="line">DEFROUTE=yes  # 启动默认路由。</span><br><span class="line">IPV4_FAILURE_FATAL=no  # 不启用IPV4错误检测功能。</span><br><span class="line">IPV6INIT=yes  # 启用IPV6协议。</span><br><span class="line">IPV6_AUTOCONF=yes  # 自动配置IPV6地址。</span><br><span class="line">IPV6_DEFROUTE=yes  # 用IPV6默认路由。</span><br><span class="line">IPV6_FAILURE_FATAL=no  # 不启用IPV6错误检测功能。</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy  # IPV6地址生成模型。</span><br><span class="line">NAME=eth0  # 网卡物理设备名称（重要，不必修改）。</span><br><span class="line">UUID=<span class="number">63749b</span>32<span class="number">-6852</span><span class="number">-4535</span><span class="number">-96</span>a9<span class="number">-58</span>d24732771d</span><br><span class="line">DEVICE=eth0  # 网卡设备名称, 必须和NAME值相同（重要，不必修改）。</span><br><span class="line">ONBOOT=yes  # 是否开机引导。</span><br></pre></td></tr></table></figure><br/><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNS1=<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span>  # 第<span class="number">1</span>个DSN服务器的IP地址（重要）。</span><br><span class="line">DNS2=<span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span>  # 第<span class="number">2</span>个DSN服务器的IP地址（重要）。</span><br></pre></td></tr></table></figure><br/><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=<span class="number">192.168</span><span class="number">.126</span><span class="number">.128</span>  # IP地址（重要）。</span><br><span class="line">NETMARSK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  # 子网掩码（重要）。</span><br><span class="line">GATEWAY=<span class="number">192.168</span><span class="number">.126</span><span class="number">.2</span>  # 网关（重要）。</span><br></pre></td></tr></table></figure><h2 id="3-重启网卡"><a class="markdownIt-Anchor" href="#3-重启网卡"></a> 3、重启网卡</h2><p>采用root用户，执行以下命令重启网络服务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h1 id="三-注意事项"><a class="markdownIt-Anchor" href="#三-注意事项"></a> 三、注意事项</h1><p><strong>1）如果在VMWare虚拟机中，CentOS7最小安装的网卡设备名缺省是ens33，配置文件名是ifcfg-ens33。</strong></p><p><strong>2）CentOS7最小化安装缺省是不启动网卡的，需要手工修改网卡配置文件，设置<code>ONBOOT=yes</code>。</strong></p><p><strong>3）DNS服务器的参数可以在网卡的配置文件中设置，也可以在/etc/resolv.conf文件中设置，如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Generated by NetworkManager</span><br><span class="line">nameserver <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">nameserver <span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span></span><br></pre></td></tr></table></figure><p><strong>4）如果在VMWare虚拟机中，把CentOS7修改为静态IP后，可能无法上网，处理方法见下一章节。</strong></p><h1 id="四-本地虚拟机设置静态ip后不能上网的解决方法"><a class="markdownIt-Anchor" href="#四-本地虚拟机设置静态ip后不能上网的解决方法"></a> 四、本地虚拟机设置静态IP后不能上网的解决方法</h1><p>在VMWare中安装的本地虚拟机CentOS7操作系统，动态IP地址会经常变化，设置成静态IP地址后，本地局域网可以互相访问，但CentOS7系统无法访问互联网，按以下步骤解决这个问题。</p><h2 id="1-以系统管理员打开vmware"><a class="markdownIt-Anchor" href="#1-以系统管理员打开vmware"></a> 1、以系统管理员打开VMWare</h2><p><img src="https://img-blog.csdnimg.cn/20200326145801288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-选择虚拟网络编辑器菜单"><a class="markdownIt-Anchor" href="#2-选择虚拟网络编辑器菜单"></a> 2、选择虚拟网络编辑器菜单</h2><p><img src="https://img-blog.csdnimg.cn/20200326145816287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-选择vmnet8这一行"><a class="markdownIt-Anchor" href="#3-选择vmnet8这一行"></a> 3、选择VMnet8这一行</h2><p><img src="https://img-blog.csdnimg.cn/20200326145841317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="4-还原vmnet8的默认设置"><a class="markdownIt-Anchor" href="#4-还原vmnet8的默认设置"></a> 4、还原VMnet8的默认设置</h2><p><img src="https://img-blog.csdnimg.cn/20200326150003691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-修改vmnet8的参数"><a class="markdownIt-Anchor" href="#5-修改vmnet8的参数"></a> 5、修改VMnet8的参数</h2><p><img src="https://img-blog.csdnimg.cn/2020032615002036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>虚拟机子网IP地址段和子网掩码由您自己来定，如果你不熟练，就按上图中的内容来设置也没有问题。</strong></p><h2 id="6-nat设置"><a class="markdownIt-Anchor" href="#6-nat设置"></a> 6、NAT设置</h2><p><img src="https://img-blog.csdnimg.cn/20200326150034808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200326150048884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="7-保存设置"><a class="markdownIt-Anchor" href="#7-保存设置"></a> 7、保存设置</h2><p><img src="https://img-blog.csdnimg.cn/20200326150112836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="8-确认虚拟机为nat模式"><a class="markdownIt-Anchor" href="#8-确认虚拟机为nat模式"></a> 8、确认虚拟机为NAT模式</h2><p><img src="https://img-blog.csdnimg.cn/20200326150125711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="9-启动虚拟机centos7"><a class="markdownIt-Anchor" href="#9-启动虚拟机centos7"></a> 9、启动虚拟机CentOS7</h2><h2 id="10-设置centos7的不静态ip地址"><a class="markdownIt-Anchor" href="#10-设置centos7的不静态ip地址"></a> 10、设置CentOS7的不静态IP地址</h2><p>修改虚拟机网卡配置文件，如/etc/sysconfig/network-scripts/ifcfg-ens33，注意，文件名不一定是ifcfg-ens33，根据您的实际情况决定。</p><p>1）修改BOOTPROTO参数，把地址协议改为静态IP方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=<span class="type">static</span>  <span class="meta"># dhcp-动态分配，static-静态分配（重要）。</span></span><br></pre></td></tr></table></figure><p>2）修改ONBOOT参数，把开机启动选项ONBOOT设置为yes。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBOOT=yes  # 是否开机引导。</span><br></pre></td></tr></table></figure><p>3）设置DSN服务器的IP，添加以下内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNS1=<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span>  # 第<span class="number">1</span>个DSN服务器的IP地址。</span><br><span class="line">DNS2=<span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span>  # 第<span class="number">2</span>个DSN服务器的IP地址。</span><br></pre></td></tr></table></figure><p>4）设置CentOS7的IP地址、子网掩码和网关参数，添加以下内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=<span class="number">192.168</span><span class="number">.226</span><span class="number">.128</span>  # IP地址（重要）。</span><br><span class="line">NETMARSK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  # 子网掩码（重要）。</span><br><span class="line">GATEWAY=<span class="number">192.168</span><span class="number">.226</span><span class="number">.2</span>   # 网关（重要）。</span><br></pre></td></tr></table></figure><h2 id="11-重启centos7的网络服务"><a class="markdownIt-Anchor" href="#11-重启centos7的网络服务"></a> 11、重启CentOS7的网络服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h2 id="12-测试效果"><a class="markdownIt-Anchor" href="#12-测试效果"></a> 12、测试效果</h2><p>ping一下百度。</p><p><img src="https://img-blog.csdnimg.cn/20200326150749789.png" alt="在这里插入图片描述" /><br />ok。</p><h2 id="13-注意事项"><a class="markdownIt-Anchor" href="#13-注意事项"></a> 13、注意事项</h2><p>如果您对网络知识不熟悉，或对虚拟机不熟悉，建议按本文章依葫芦画瓢，照抄参数。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7添加自定义系统服务</title>
      <link href="/post/c61bfc2f.html"/>
      <url>/post/c61bfc2f.html</url>
      
        <content type="html"><![CDATA[<p>CentOS 6版本的系统服务是/etc/init.d启动脚本的方式，CentOS 7采用强大的systemctl来管理系统服务，大幅提高了系统服务的运行效率，但是服务的配置和以前版本完全不同，这是很大的进步，systemctl太简单易用了。</p><p>CentOS7添加自定义系统服务的步骤如下：</p><p>1）编写自定义的系统服务脚本文件；</p><p>2）用systemctl命令把自定义的系统服务设置为开机/关机自启动/停止。</p><p>本文以Oracle数据库为例子来介绍添加自定义系统服务的知识。假设ORACLE_HOME环境变量的值是/oracle/home，各位根据自己的实际情况调整脚本的内容，把文中/oracle/home替换成您ORACLE_HOME的值。</p><h1 id="一-编写oracle数据库启动重启关闭的脚本"><a class="markdownIt-Anchor" href="#一-编写oracle数据库启动重启关闭的脚本"></a> 一、编写Oracle数据库启动/重启/关闭的脚本</h1><h2 id="1-启动oracle数据库的shell脚本"><a class="markdownIt-Anchor" href="#1-启动oracle数据库的shell脚本"></a> 1、启动Oracle数据库的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbstart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改脚本的权限为可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /oracle/home/bin/dbstart</span><br></pre></td></tr></table></figure><h2 id="2-重启oracle数据库的shell脚本"><a class="markdownIt-Anchor" href="#2-重启oracle数据库的shell脚本"></a> 2、重启Oracle数据库的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbrestart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改脚本的权限为可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /oracle/home/bin/dbrestart</span><br></pre></td></tr></table></figure><h2 id="3-关闭oracle数据库的shell脚本"><a class="markdownIt-Anchor" href="#3-关闭oracle数据库的shell脚本"></a> 3、关闭Oracle数据库的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbshut，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改脚本的权限为可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /oracle/home/bin/dbshut</span><br></pre></td></tr></table></figure><h1 id="二-编写自定义服务的配置文件"><a class="markdownIt-Anchor" href="#二-编写自定义服务的配置文件"></a> 二、编写自定义服务的配置文件</h1><p>系统服务的启动/重启/停止由它的配置文件决定，本文把Oracle数据库的系统服务命名为oracle.service。</p><p>创建服务配置文件/usr/lib/systemd/system/oracle.service，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle RDBMS</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbstart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbrestart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbshut &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>接下来介绍服务配置文件各部分的含义。</p><h2 id="1-unit部分"><a class="markdownIt-Anchor" href="#1-unit部分"></a> 1、Unit部分</h2><p>Unit部分是启动顺序与依赖关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle RDBMS</span><br><span class="line">After=network.target</span><br></pre></td></tr></table></figure><p>Description字段：给出当前服务的简单描述。</p><p>Documentation字段：给出文档位置。</p><p>After字段：表示本服务应该在某服务之后启动。</p><p>Before字段：表示本服务应该在某服务之前启动。</p><p>After和Before字段只涉及启动顺序，不涉及依赖关系。设置依赖关系，需要使用Wants字段和Requires字段。</p><p>Wants字段：表示本服务与某服务之间存在“依赖”系，如果被依赖的服务启动失败或停止运行，不影响本服务的继续运行。</p><p>Requires字段，表示本服务与某服务之间存在“强依赖”系，如果被依赖的服务启动失败或停止运行，本服务也必须退出。</p><h2 id="2-service部分"><a class="markdownIt-Anchor" href="#2-service部分"></a> 2、Service部分</h2><p>Service部分定义如何启动/重启/停止服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbstart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbrestart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbshut &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br></pre></td></tr></table></figure><p>1）启动类型（Type字段）</p><p>Type字段定义启动类型。它可以设置的值如下。</p><p>simple（默认值）：ExecStart字段启动的进程为主进程。</p><p>forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程。</p><p>oneshot：类似于simple，但只执行一次，Systemd会等它执行完，才启动其他服务。</p><p>dbus：类似于simple，但会等待D-Bus信号后启动。</p><p>notify：类似于simple，启动结束后会发出通知信号，然后Systemd再启动其他服务。</p><p>idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。</p><p>2）启动服务（ExecStart字段）</p><p>启动服务时执行的命令，可以是可执行程序、系统命令或shell脚本。</p><p>3）重启服务（ExecReload字段）</p><p>重启服务时执行的命令，可以是可执行程序、系统命令或shell脚本。</p><p>4）停止服务（ExecStop字段）</p><p>停止服务时执行的命令，可以是可执行程序、系统命令或shell脚本。</p><p>5）如果RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。</p><p>6）服务配置文件还可以读取环境变量参数文件，我个人认为比较麻烦，没有必要，就不介绍了，设置程序的环境变量有很多种方法，可以在脚本中配置，也可以用“su<br />–”的方法。</p><h2 id="3-install部分"><a class="markdownIt-Anchor" href="#3-install部分"></a> 3、Install部分</h2><p>Install部分定义如何安装这个配置文件，即怎样做到开机启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>WantedBy字段：表示该服务所在的Target。</p><p>Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，oracle所在的Target是multi-user.target（多用户模式）。</p><p>这个设置非常重要，因为执行systemctl enable<br />oracle.service命令时，oracle.service会被链接到/etc/systemd/system/multi-user.target.wants目录之中，实现开机启动的功能。</p><h2 id="4-重启行为"><a class="markdownIt-Anchor" href="#4-重启行为"></a> 4、重启行为</h2><p>Service部分还有一些字段，定义了重启行为。</p><p>1）KillMode字段</p><p>KillMode字段定义Systemd如何停止sshd服务，可以设置的值如下：</p><p>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉。</p><p>process：只杀主进程。</p><p>mixed：主进程将收到SIGTERM信号，子进程收到SIGKILL信号。</p><p>none：没有进程会被杀掉，只是执行服务的stop命令。</p><p>2）Restart字段</p><p>Restart字段定义了服务程序退出后，Systemd的重启方式，可以设置的值如下：</p><p>no（默认值）：退出后不会重启。</p><p>on-success：只有正常退出时（退出状态码为0），才会重启。</p><p>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启。</p><p>on-abnormal：只有被信号终止和超时，才会重启。</p><p>on-abort：只有在收到没有捕捉到的信号终止时，才会重启。</p><p>on-watchdog：超时退出，才会重启。</p><p>always：不管是什么退出原因，总是重启。</p><p>3）RestartSec字段。</p><p>RestartSec字段：表示Systemd重启服务之前，需要等待的秒数。</p><h1 id="三-使用自定义的服务"><a class="markdownIt-Anchor" href="#三-使用自定义的服务"></a> 三、使用自定义的服务</h1><h2 id="1-重新加载服务配置文件"><a class="markdownIt-Anchor" href="#1-重新加载服务配置文件"></a> 1、重新加载服务配置文件</h2><p>每次修改了服务配置文件后，需要执行以下命令重新加载服务的配置文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="2-启动停止启重oracle服务"><a class="markdownIt-Anchor" href="#2-启动停止启重oracle服务"></a> 2、启动/停止/启重oracle服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start oracle # 启动oracle服务。</span><br><span class="line"></span><br><span class="line">systemctl restart oracle # 重启oracle服务。</span><br><span class="line"></span><br><span class="line">systemctl stop oracle # 关闭oracle服务。</span><br></pre></td></tr></table></figure><h2 id="3-把oracle服务设置为开机关机自启动停止"><a class="markdownIt-Anchor" href="#3-把oracle服务设置为开机关机自启动停止"></a> 3、把oracle服务设置为开机/关机自启动/停止</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled oracle # 查看oracle服务是否是开机自启动。</span><br><span class="line"></span><br><span class="line">systemctl enable oracle # 把oracle服务设置为开机自启动。</span><br></pre></td></tr></table></figure><h2 id="4-查看oracle实例启动停止的日志"><a class="markdownIt-Anchor" href="#4-查看oracle实例启动停止的日志"></a> 4、查看Oracle实例启动/停止的日志</h2><p>Oracle实例启动的日志在/tmp/oracle.log文件中。</p><p>注意，只有通过systemctl启动/关闭Oracle实例和监听才会写日志，手工执行脚本不写日志。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7计划任务crontab</title>
      <link href="/post/c1035555.html"/>
      <url>/post/c1035555.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-计划任务的基本概念"><a class="markdownIt-Anchor" href="#一-计划任务的基本概念"></a> 一、计划任务的基本概念</h1><p>linux系统采用crond守护进程来控制系统和用户的计划任务，实现周期性的执行某种任务或处理某些事件。</p><p>Linux系统本身就有很多的计划任务，所以crond服务是默认安装和启动的。crond服务每分钟都会检查是否有需要执行的任务，如果有则自动执行该任务。执行以下命令可以看到crond服务的运行情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status crond</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200321091236120.png" alt="在这里插入图片描述" /></p><p>Linux下的计划任务分为两种：用户计划任务和系统计划任务。</p><h1 id="二-用户计划任务"><a class="markdownIt-Anchor" href="#二-用户计划任务"></a> 二、用户计划任务</h1><p>Linux的每个用户可以定义自己的计划任务，周期性的执行脚本或程序。计划任务的内容存放在crontab文件中，每个用户都有自己的crontab文件。</p><h2 id="1-查看crontab文件"><a class="markdownIt-Anchor" href="#1-查看crontab文件"></a> 1、查看crontab文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l [-u 用户名]</span><br></pre></td></tr></table></figure><p>root用户可以用-u参数查看指定用户的计划任务，如果没有-u参数，表示查看自己的计划任务。普通用户只查看自己的计划任务，不允许使用-u参数。</p><h2 id="2-编辑crontab文件"><a class="markdownIt-Anchor" href="#2-编辑crontab文件"></a> 2、编辑crontab文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e [-u 用户名]</span><br></pre></td></tr></table></figure><p>root用户可以用-u参数编辑指定用户的计划任务，如果没有-u参数，表示编辑自己的计划任务。普通用户只能编辑自己的计划任务，不允许使用-u参数。crontab缺省的编辑工具是vi。</p><h2 id="3-删除crontab文件"><a class="markdownIt-Anchor" href="#3-删除crontab文件"></a> 3、删除crontab文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -r [-u 用户名]</span><br></pre></td></tr></table></figure><p>root用户可以用-u参数删除指定用户的计划任务，如果没有-u参数，表示删除自己的计划任务。普通用户只删除自己的计划任务，不允许使用-u参数。</p><h2 id="4-crontab文件格式"><a class="markdownIt-Anchor" href="#4-crontab文件格式"></a> 4、crontab文件格式</h2><p><img src="https://img-blog.csdnimg.cn/20200321091331306.png" alt="在这里插入图片描述" /><br />crontab文件中的每个任务由两部分组成，执行时间和执行命令。</p><p><strong>1）执行时间，有5个参数：</strong></p><p>第1部分：分钟（minute），取值0-59。</p><p>第2部分：小时（hour），取值0-23。</p><p>第3部分：月当中的天（day of month），取值1-31，。</p><p>第4部分：月份（month），取值1-12，或采用月份单词的英文简写。</p><p>第5部分：星期中的天（day of week），取值0-6，或采用星期单词的英文简写。</p><p>在以上各部分中，还可以使用以下特殊字符：</p><p>星号（*）：代表全部的值，例如day of month字段如果是星号，则表示在满足其它字段的制约条件后每天执行该任务。</p><p>逗号（,）：可以用逗号分隔开的值指定一个列表，例如，“1,2,5,7,8,9”。</p><p>中杠（-）：可以中杠表示一个范围，例如“2-6”表示“2,3,4,5,6”。</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如minute字段，“0-30/5”表示在0-30的范围内每5分钟执行一次；“*/5”表示每十分钟执行一次。</p><p><strong>2）执行命令：任务执行的程序，可以是shell脚本，也可以是其它的可执行文件，但是要注意几个问题：</strong></p><p>a）crontab中执行程序的时候，不会先执行系统和用户的环境变量文件，如果待执行的程序需要环境变量，程序将无法执行；</p><p>b）crontab中执行的程序必须采用全路径。</p><h2 id="5-crontab示例"><a class="markdownIt-Anchor" href="#5-crontab示例"></a> 5、crontab示例</h2><p>1）每两分钟执行一次date命令，结果输出到/tmp/date.log文件（下同）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">2</span> * * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>2）在每个小时的05、10、15分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span> * * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>3）在每个小时20-30分之间的每一分钟执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span><span class="number">-30</span> * * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>4）在每天的10:30分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">10</span> * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>5）在每个月1号的02:30分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">02</span> <span class="number">1</span> * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>6）在每星期天的02:30分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">02</span> * * <span class="number">0</span> /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><h1 id="三-系统计划任务"><a class="markdownIt-Anchor" href="#三-系统计划任务"></a> 三、系统计划任务</h1><p>网上很多文章认为系统计划任务是执行系统级别的周期性任务，例如系统备份、把缓存数据写入硬盘、清理日志文件等。这些说法有些片面，我不这么认为，我先介绍系统计划任务的相关知识，然后通过示例来演示。</p><p>系统计划任务在/etc/crontab文件配置，以下缺省/etc/crontab文件的内容：<br /><img src="https://img-blog.csdnimg.cn/20200321091603618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />系统计划任务的/etc/crontab文件中，**可以设置环境变量，可以指定执行任务的用户。**系统计划任务的执行时间的与用户计划任务的执行时间含义相同，不再描述。</p><p>示例：</p><p>Oracle数据库提供了sqlplus工具，执行sqlplus需要环境变量，如ORACLE_HOME、ORACLE_BASE等，如果采用系统计划任务执行一个SQL脚本，步骤如下：</p><p>1）准备/tmp/test.sql脚本文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">to_char</span><span class="params">(sysdate,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>)</span> from dual</span>;</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>2）在/etc/crontab文件中增加环境变量和任务，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 设置Oracle的环境变量。</span><br><span class="line">ORACLE_BASE=/oracle/base</span><br><span class="line">ORACLE_HOME=/oracle/home</span><br><span class="line">ORACLE_SID=snorcl11g</span><br><span class="line">NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line">LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/usr/lib</span><br><span class="line"></span><br><span class="line"># 每分钟调用sqlplus执行/tmp/test.sql脚本，结果输出到/tmp/test.log文件。</span><br><span class="line">*/<span class="number">1</span> * * * * oracle /oracle/home/bin/sqlplus scott/tiger @/tmp/test.sql &gt;/tmp/test.log</span><br></pre></td></tr></table></figure><p>3）每隔一分钟查看/tmp/test.log文件的内容，如下：<br /><img src="https://img-blog.csdnimg.cn/20200321091806802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="四-如何在用户计划任务中执行需要环境变量的程序"><a class="markdownIt-Anchor" href="#四-如何在用户计划任务中执行需要环境变量的程序"></a> 四、如何在用户计划任务中执行需要环境变量的程序</h1><p>用户的计划任务无法设置环境变量，那么如何在用户计划任务中执行需要环境变量的程序呢？我们可以这么做：</p><p>1）编写一个shell脚本；</p><p>2）在脚本中设置环境变量；</p><p>3）在脚本中执行需要环境变量的程序。</p><p>示例：</p><p>1）编写/tmp/test.sh脚本文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置系统环境变量。</span><br><span class="line">source /etc/profile</span><br><span class="line"># 设置oracle用户的环境变量。</span><br><span class="line">source /oracle/.bash_profile</span><br><span class="line"># 执行/tmp/test.sql脚本。</span><br><span class="line">/oracle/home/bin/sqlplus scott/tiger @/tmp/test.sql &gt; /tmp/test1.log</span><br></pre></td></tr></table></figure><p>2）准备/tmp/test.sql脚本文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">to_char</span><span class="params">(sysdate,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>)</span> from dual</span>;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>3）设置oracle用户的计划任务文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每分钟执行一次/tmp/test.sh脚本。</span><br><span class="line">*/<span class="number">1</span> * * * * /bin/sh /tmp/test.sh</span><br></pre></td></tr></table></figure><p>4）每隔一分钟查看/tmp/test1.log文件的内容，如下：<br /><img src="https://img-blog.csdnimg.cn/20200321091956752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>用户计划任务和系统计划任务没有本质的区别，都可以达到相同的目的。</p><p>在实际项目中我偏向用户的计划任务，虽然用户计划任务的crontab文件中不能设置环境变量，但可以通过脚本文件来解决，并且，脚本文件中编写指令比crontab文件更灵活。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ftp命令详解</title>
      <link href="/post/7b2debb7.html"/>
      <url>/post/7b2debb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-安装ftp客户端软件包"><a class="markdownIt-Anchor" href="#一-安装ftp客户端软件包"></a> 一、安装ftp客户端软件包</h1><p>在CentOS7中，采用yum来安装ftp客户端软件包，如果已经安装，再次执行yum就会把软件包升级到最新版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp</span><br></pre></td></tr></table></figure><h1 id="二-ftp的用户"><a class="markdownIt-Anchor" href="#二-ftp的用户"></a> 二、ftp的用户</h1><p>缺省情况下，ftp服务器操作系统用户名/密码也是ftp客户端登录的用户名/密码。root用户的权限过大，不允许登录ftp服务器。</p><h1 id="三-登录服务器"><a class="markdownIt-Anchor" href="#三-登录服务器"></a> 三、登录服务器</h1><p>方法一：输入<code>ftp 服务器ip地址</code>，回车后根据提示输入用户名和密码，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310101306304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>方法二：输入<code>ftp</code>，用<code>open 服务器ip地址</code>，连上服务器后再输入用户名和密码，如下图：</p><p><img src="https://img-blog.csdnimg.cn/2020031010134425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>方法三：输入<code>ftp -n 服务器ip地址</code>，再输入<code>user 用户名 密码登录</code>，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310101428852.png" alt="在这里插入图片描述" /></p><h1 id="四-切换工作目录"><a class="markdownIt-Anchor" href="#四-切换工作目录"></a> 四、切换工作目录</h1><p>注意，如果目录名中有特殊符号，如空格，可以用双引号把目录名包含起来。</p><h2 id="1-查看服务器工作目录"><a class="markdownIt-Anchor" href="#1-查看服务器工作目录"></a> 1、查看服务器工作目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h2 id="2-切换服务器工作目录"><a class="markdownIt-Anchor" href="#2-切换服务器工作目录"></a> 2、切换服务器工作目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 目录名</span><br></pre></td></tr></table></figure><h2 id="3-切换本地工作目录"><a class="markdownIt-Anchor" href="#3-切换本地工作目录"></a> 3、切换本地工作目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd 目录名</span><br></pre></td></tr></table></figure><h1 id="五-查看服务器上的目录和文件"><a class="markdownIt-Anchor" href="#五-查看服务器上的目录和文件"></a> 五、查看服务器上的目录和文件</h1><h2 id="1-列出目录或文件名的详细信息"><a class="markdownIt-Anchor" href="#1-列出目录或文件名的详细信息"></a> 1、列出目录或文件名的详细信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls  目录或文件名</span><br><span class="line">dir 目录或文件名</span><br></pre></td></tr></table></figure><p>ls和dir都可以用于查看目录和文件信息，常用ls，语法和Linux的ls命令相同。</p><p><img src="https://img-blog.csdnimg.cn/20200310101543989.png" alt="在这里插入图片描述" /></p><h2 id="2-仅列出目录和文件名"><a class="markdownIt-Anchor" href="#2-仅列出目录和文件名"></a> 2、仅列出目录和文件名</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nlist 目录或文件名 [本地文件名]</span><br></pre></td></tr></table></figure><p>1）列出/freecplus目录下的匹配*.h的文件名信息。</p><p><img src="https://img-blog.csdnimg.cn/20200310101803702.png" alt="在这里插入图片描述" /></p><p>2）列出/freecplus目录下的匹配*.h的文件名信息，结果输出到本地的/tmp/freecplus.list文件中。</p><p><img src="https://img-blog.csdnimg.cn/20200310101831141.png" alt="在这里插入图片描述" /></p><p>查看/tmp/freecplus.list内容。</p><p><img src="https://img-blog.csdnimg.cn/20200310101843361.png" alt="在这里插入图片描述" /></p><h1 id="六-下载上传文件"><a class="markdownIt-Anchor" href="#六-下载上传文件"></a> 六、下载/上传文件</h1><h2 id="1-文件传输入的模式"><a class="markdownIt-Anchor" href="#1-文件传输入的模式"></a> 1、文件传输入的模式</h2><p>ftp的传输模式分为二进制和ASCII码两种模式，二进制模式可以传输任何文件，包括压缩包、可执行程序、图片、视频、音频等，而ASCII模式只能传输.txt、.htm等ascii码文件（文本文件）。在实际开发中，不管什么文件，都用二进制方式传输文件。</p><p>1）查看当前的传输模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type</span><br></pre></td></tr></table></figure><p>2）设定传输模式为二进制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin</span><br></pre></td></tr></table></figure><p>3）设定传输模式为ASCII。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200310101912441.png" alt="在这里插入图片描述" /></p><h2 id="2-下载文件"><a class="markdownIt-Anchor" href="#2-下载文件"></a> 2、下载文件</h2><p>1）下载单个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get/recv 服务器文件名 [本地文件名]</span><br></pre></td></tr></table></figure><p>使用说明：</p><p>a）下载文件用get和recv都可以。</p><p>b）文件名不允许用通配符。</p><p>c）服务器文件名和本地文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p><p>d）如果本地文件名省略不写，表示把服务器文件下载到本地的当前工作目录，文件名与服务器文件名相同。</p><p>2）下载多个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget 服务器文件<span class="number">1</span> 服务器文件<span class="number">2</span> 服务器文件<span class="number">3</span> …… 服务器文件n</span><br></pre></td></tr></table></figure><p>使用说明：</p><p>a）待下载的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p><p>b）下载的文件，存放在本地当前工作目录中。</p><p>c）下载文件时，会一一提示，如果想关闭都显示信息，先输入prompt命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt</span><br></pre></td></tr></table></figure><h2 id="3-上传文件"><a class="markdownIt-Anchor" href="#3-上传文件"></a> 3、上传文件</h2><p>1）上传单个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put/send 本地文件名 [服务器文件名]</span><br></pre></td></tr></table></figure><p>a）上传文件用put和send都可以。</p><p>b）文件名不允许用通配符。</p><p>c）本地文件名和服务器文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p><p>d）如果服务器文件名省略不写，表示把本地文件上传到服务器的当前工作目录，文件名与本地文件名相同。</p><p>2）上传多个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mput 本地文件<span class="number">1</span> 本地文件<span class="number">2</span> 本地文件<span class="number">3</span> …… 本地文件n</span><br></pre></td></tr></table></figure><p>使用说明：</p><p>a）待上传的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p><p>b）上传的文件，存放在服务器当前工作目录中。</p><p>c）上传文件时，会一一提示，如果想关闭都显示信息，先输入prompt命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt</span><br></pre></td></tr></table></figure><h1 id="七-其它ftp命令"><a class="markdownIt-Anchor" href="#七-其它ftp命令"></a> 七、其它ftp命令</h1><p>1）重命名服务器上的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename 旧文件名 新文件名</span><br></pre></td></tr></table></figure><p>2）删除ftp服务器上单个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> 文件名</span><br></pre></td></tr></table></figure><p>3）删除多个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdelete 文件名<span class="number">1</span> 文件名<span class="number">2</span> 文件名<span class="number">3</span> …… 文件名n</span><br></pre></td></tr></table></figure><p>4）在服务器上创建目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir pathname</span><br></pre></td></tr></table></figure><p>5）删除服务器上的目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir pathname</span><br></pre></td></tr></table></figure><p>6）切换传输模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passive</span><br></pre></td></tr></table></figure><p>7）显示帮助信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help [命令名]</span><br></pre></td></tr></table></figure><p>显示ftp命令的帮助信息，如果不输入命令名，则显示全ftp命令的帮助信息。</p><p>8）退出ftp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure><h1 id="八-windows的ftp客户端"><a class="markdownIt-Anchor" href="#八-windows的ftp客户端"></a> 八、Windows的ftp客户端</h1><p>在Windows的DOS命令提示符下输入ftp命令，但是不好用。</p><p>打开资源管理器，输入：<a href="ftp://%E6%9C%8D%E5%8A%A1%E5%99%A8ip%E5%9C%B0%E5%9D%80">ftp://服务器ip地址</a>，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310102206728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>在空白的位置点鼠标右键，选择登录菜单，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310102328728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />输入用户名和密码登录ftp服务器，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310102356906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>接下来的操作就像windows的目录文件操作一样了。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7配置防火墙</title>
      <link href="/post/b47381a7.html"/>
      <url>/post/b47381a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-防火墙的概念"><a class="markdownIt-Anchor" href="#一-防火墙的概念"></a> 一、防火墙的概念</h1><p>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。</p><p>专业的防火墙由软件和硬件组成，可以保护整个网络，价格也很贵，从几万到几十万的都有，功能非常强大，主要包括入侵检测、网络地址转换、网络操作的审计监控、强化网络安全服务等功能。</p><p>操作系统（Windows和Linux自带的）的防火墙只有软件部分，用于保护本操作系统，功能比较简单，只能防范简单的攻击。</p><p>本文的内容以介绍CentOS7以上版本防火墙的使用和配置为主。</p><h1 id="二-防火墙配置"><a class="markdownIt-Anchor" href="#二-防火墙配置"></a> 二、防火墙配置</h1><p>CentOS7的防火墙比CentOS6的功能更强大，配置方法和操作命令也完全不同。</p><p>CentOS7的防火墙规则既可以是端口，也可以是服务。</p><p>防火墙查看和配置以下介绍的命令，如果没有特别说明就表示需要管理员权限执行。</p><h2 id="1-查看防火墙的命令"><a class="markdownIt-Anchor" href="#1-查看防火墙的命令"></a> 1、查看防火墙的命令</h2><p>1）查看防火墙的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --version</span><br></pre></td></tr></table></figure><p>2）查看firewall的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>3）查看firewall服务状态（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>4）查看防火墙全部的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>5）查看防火墙已开通的端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-port</span><br></pre></td></tr></table></figure><p>6）查看防火墙已开通的服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-service</span><br></pre></td></tr></table></figure><p>7）查看全部的服务列表（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><p>8）查看防火墙服务是否开机启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled firewalld</span><br></pre></td></tr></table></figure><h2 id="2-配置防火墙的命令"><a class="markdownIt-Anchor" href="#2-配置防火墙的命令"></a> 2、配置防火墙的命令</h2><p>1）启动、重启、关闭防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#启动</span><br><span class="line">systemctl start firewalld</span><br><span class="line">#重启</span><br><span class="line">systemctl restart firewalld</span><br><span class="line">#关闭</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>2）开放、移去某个端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放<span class="number">80</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">#移去<span class="number">80</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-port=<span class="number">80</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>3）开放、移去范围端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放<span class="number">5000</span><span class="number">-5500</span>之间的端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">5000</span><span class="number">-5500</span>/tcp --permanent</span><br><span class="line">#移去<span class="number">5000</span><span class="number">-5500</span>之间的端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-port=<span class="number">5000</span><span class="number">-5500</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>4）开放、移去服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放ftp服务</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-service=ftp --permanent</span><br><span class="line">#移去http服务</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-service=ftp --permanent</span><br></pre></td></tr></table></figure><p>5）重新加载防火墙配置（修改配置后要重新加载防火墙配置或重启防火墙服务）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>6）设置开机时启用、禁用防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启用服务</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">#禁用服务</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h1 id="三-centos7以下版本"><a class="markdownIt-Anchor" href="#三-centos7以下版本"></a> 三、centos7以下版本</h1><p>1）开放80，22，8080 端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport <span class="number">80</span> -j ACCEPT</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport <span class="number">8080</span> -j ACCEPT</span><br></pre></td></tr></table></figure><p>2）保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure><p>3）查看打开的端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure><p>4）启动、关闭防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启动服务</span><br><span class="line">service iptables start</span><br><span class="line">#关闭服务</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p>5）设置开机时启用、禁用防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启用服务</span><br><span class="line">chkconfig iptables on</span><br><span class="line">#禁用服务</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure><h1 id="四-云平台访问策略配置"><a class="markdownIt-Anchor" href="#四-云平台访问策略配置"></a> 四、云平台访问策略配置</h1><p>如果您购买的是云服务器，除了配置云服务器的防火墙，还需要登录云服务器提供商的管理平台配置访问策略（或安全组）。</p><p>不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7系统服务管理</title>
      <link href="/post/2764ee64.html"/>
      <url>/post/2764ee64.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-systemctl介绍"><a class="markdownIt-Anchor" href="#一-systemctl介绍"></a> 一、systemctl介绍</h1><p>CentOS7启用了新的系统和服务管理器，采用systemctl命令代替了老版本的service和chkconfig。为了保持兼容性，在CentOS7中，老版本的service和chkconfig命令仍然可以使用。</p><p>systemctl命令是system（系统）和control（控制）两个单词的简写，它是一个功能强大的命令，本文只介绍与服务管理相关的用法。</p><p>systemctl命令有一点不足，就是很多命令执行后没有提示信息，例如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310092636364.png" alt="在这里插入图片描述" /></p><p>上图中，执行启动和停止服务命令后没有“服务已启动”或“服务已关闭”等提示信息，让人很不习惯。还有，start和stop各执行了两次，也没有任何提示信息，这也让人很不习惯。</p><h1 id="二-systemctl常用命令"><a class="markdownIt-Anchor" href="#二-systemctl常用命令"></a> 二、systemctl常用命令</h1><h2 id="1-启动服务"><a class="markdownIt-Anchor" href="#1-启动服务"></a> 1、启动服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start name.service</span><br></pre></td></tr></table></figure><p>注意name.service的.service可以省略不写，以下两条命令的效果相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd             # 启动ftp服务。</span><br><span class="line">systemctl start vsftpd.service      # 启动ftp服务。</span><br></pre></td></tr></table></figure><h2 id="2-停止服务"><a class="markdownIt-Anchor" href="#2-停止服务"></a> 2、停止服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop name.service</span><br></pre></td></tr></table></figure><h2 id="3-重启服务"><a class="markdownIt-Anchor" href="#3-重启服务"></a> 3、重启服务</h2><p>如果服务没有启动，就启动它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart name.service</span><br></pre></td></tr></table></figure><h2 id="4-查看服务是否已启动"><a class="markdownIt-Anchor" href="#4-查看服务是否已启动"></a> 4、查看服务是否已启动</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-active name.service</span><br></pre></td></tr></table></figure><h2 id="5-查看服务的状态"><a class="markdownIt-Anchor" href="#5-查看服务的状态"></a> 5、查看服务的状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status name.service</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200310092839233.png" alt="在这里插入图片描述" /></p><p>Loaded：关于服务是否已经加载的信息，文件的绝对路径以及是否被启用的注释。</p><p>Active：服务是否正在运行,然后是启动时间信息。</p><p>Process：进程额外信息。</p><p>Main PID：服务主进程pid。</p><p>CGroup:Control Groups额外信息。</p><h2 id="6-启用开机自启动服务"><a class="markdownIt-Anchor" href="#6-启用开机自启动服务"></a> 6、启用开机自启动服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable name.service</span><br></pre></td></tr></table></figure><h2 id="7-停用开机自启动服务"><a class="markdownIt-Anchor" href="#7-停用开机自启动服务"></a> 7、停用开机自启动服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable name.service</span><br></pre></td></tr></table></figure><h2 id="8-查看服务是否为开机自启动"><a class="markdownIt-Anchor" href="#8-查看服务是否为开机自启动"></a> 8、查看服务是否为开机自启动</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled name.service</span><br></pre></td></tr></table></figure><h2 id="9-只重启正在运行中的服务"><a class="markdownIt-Anchor" href="#9-只重启正在运行中的服务"></a> 9、只重启正在运行中的服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">try</span>-restart name.service</span><br></pre></td></tr></table></figure><h2 id="10-显示所有的服务状态"><a class="markdownIt-Anchor" href="#10-显示所有的服务状态"></a> 10、显示所有的服务状态</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service --all</span><br></pre></td></tr></table></figure><h2 id="11-查看启动成功的服务列表"><a class="markdownIt-Anchor" href="#11-查看启动成功的服务列表"></a> 11、查看启动成功的服务列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files|grep enabled</span><br></pre></td></tr></table></figure><h2 id="12-查看启动失败的服务列表"><a class="markdownIt-Anchor" href="#12-查看启动失败的服务列表"></a> 12、查看启动失败的服务列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --failed</span><br></pre></td></tr></table></figure><h2 id="13-查看所有服务的状态"><a class="markdownIt-Anchor" href="#13-查看所有服务的状态"></a> 13、查看所有服务的状态</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --type service</span><br></pre></td></tr></table></figure><h2 id="14-列出在指定服务之前启动的服务依赖"><a class="markdownIt-Anchor" href="#14-列出在指定服务之前启动的服务依赖"></a> 14、列出在指定服务之前启动的服务（依赖）</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies --after name.service</span><br></pre></td></tr></table></figure><h2 id="15-列出在指定服务之后启动的服务被依赖"><a class="markdownIt-Anchor" href="#15-列出在指定服务之后启动的服务被依赖"></a> 15、列出在指定服务之后启动的服务（被依赖）</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies --before name.service</span><br></pre></td></tr></table></figure><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装软件包的方法</title>
      <link href="/post/27bd545e.html"/>
      <url>/post/27bd545e.html</url>
      
        <content type="html"><![CDATA[<p>Linux有多种发行版本，各种发行版本之间安装软件包的方法和命令不一样，同发行版本之间安装软件包的方法也有不同。Linux主要有三大派系：红帽子派系（Redhat、Centos、Oracle Linux）、Debian派（Ubuntu、Kali），SUSE派系（SuSe、OpenSUSE）等。</p><p>红帽子派是Linux服务器操作系统的主流，本文重点介绍红帽子派系中rpm和yum安装软件包的方法。</p><h1 id="一-rpm安装"><a class="markdownIt-Anchor" href="#一-rpm安装"></a> 一、rpm安装</h1><p>RPM是RedHat Package Manager的缩写，由RedHat推出的软件包管理管理工具，在Fedora、Redhat、CentOS、Mandriva、SuSE、YellowDog等主流发行版本，以及在这些版本基础上二次开发出来的发行版采用。</p><p>RPM包里面包含可执行的二进制程序，自身所带的附加文件，版本文件（软件包的依赖关系）。</p><h2 id="1-查看系统中已安装的软件包"><a class="markdownIt-Anchor" href="#1-查看系统中已安装的软件包"></a> 1、查看系统中已安装的软件包</h2><p>1）查看已安装的软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端和ftp服务端软件包：</p><p><img src="https://img-blog.csdnimg.cn/20200309172432513.png" alt="在这里插入图片描述" /></p><p>2）查看软件包安装的目录和文件（包括了可执行程序、配置文件和帮助文档）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql ftp</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030917260113.png" alt="在这里插入图片描述" /></p><p>3）查看已安装软件包的详细信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端（显示内容太多，部分截图）：</p><p><img src="https://img-blog.csdnimg.cn/20200309172652175.png" alt="在这里插入图片描述" /></p><p>4）查看已安装软件包的配置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qc 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp服务端：</p><p><img src="https://img-blog.csdnimg.cn/20200309172731769.png" alt="在这里插入图片描述" /></p><p>5）查看已安装软件包所依赖的软件包及文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qR 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端（显示内容太多，部分截图）：</p><p><img src="https://img-blog.csdnimg.cn/20200309172811756.png" alt="在这里插入图片描述" /></p><h2 id="2-查看软件包的安装文件"><a class="markdownIt-Anchor" href="#2-查看软件包的安装文件"></a> 2、查看软件包的安装文件</h2><p>安装包文件的后缀是.rpm，以CentOS7为例，系统安装的光盘映像文件是CentOS-7-x86_64-DVD-1908.iso，解开后在Packages目录中有软件包的安装文件，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200309172824524.png" alt="在这里插入图片描述" /></p><p>接下来以ftp的客户端安装包文件ftp-0.17-67.el7.x86_64.rpm为例来介绍安装包文件的查看方法。</p><p>1）查看一个软件包的安装文件的详细信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpi 软件包的安装文件名</span><br></pre></td></tr></table></figure><p>（显示内容太多，部分截图）</p><p><img src="https://img-blog.csdnimg.cn/2020030917285624.png" alt="在这里插入图片描述" /></p><p>2）查看软件包的安装文件所包含的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpl 软件安装包文件名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309172931664.png" alt="在这里插入图片描述" /></p><p>3）查看软件包的依赖关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpR 软件包的安装文件名</span><br></pre></td></tr></table></figure><p>（显示内容太多，部分截图）</p><p><img src="https://img-blog.csdnimg.cn/20200309173013619.png" alt="在这里插入图片描述" /></p><h2 id="3-安装升级软件包"><a class="markdownIt-Anchor" href="#3-安装升级软件包"></a> 3、安装/升级软件包</h2><p>如果待安装/升级的软件与其它的软件有依赖关系，请解决依赖关系，即先安装/升级依赖关系的软件包。如果没有解决好依赖关系，可以强制安装/升级，不推荐采用强制的方法，因为有可能导致软件不可用。</p><p>1）安装软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 软件包的安装文件名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309173042545.png" alt="在这里插入图片描述" /></p><p>2）升级软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh 软件包的安装文件名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309173114715.png" alt="在这里插入图片描述" /></p><p>3）强制安装软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 软件包的安装文件名 --nodeps --force</span><br></pre></td></tr></table></figure><p>4）强制升级软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpv -Uvh 软件包的安装文件名 --nodeps --force</span><br></pre></td></tr></table></figure><h2 id="4-删除软件包"><a class="markdownIt-Anchor" href="#4-删除软件包"></a> 4、删除软件包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e 软件包名</span><br></pre></td></tr></table></figure><p>例如删除ftp客户端软件包：</p><p><img src="https://img-blog.csdnimg.cn/2020030917324431.png" alt="在这里插入图片描述" /></p><h1 id="二-yum安装"><a class="markdownIt-Anchor" href="#二-yum安装"></a> 二、yum安装</h1><p>rpmp安装软件包的虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件包需要安装多个其他软件包，还有不同版本的兼容性问题，很复杂。yum解决了这些问题，yum是rpm的前端程序，设计的主要目的就是为了自动解决rpm的依赖关系，有以下优点：</p><ol><li><p>自动解决依赖关系；</p></li><li><p>可以对rpm进行分组，基于组进行安装操作；</p></li><li><p>引入仓库概念，支持多个仓库；</p></li><li><p>配置简单。</p></li></ol><h2 id="1-yum的语法"><a class="markdownIt-Anchor" href="#1-yum的语法"></a> 1、yum的语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure><p>options：可选参数：1）-h帮助；2）-y，当安装过程提示选择全部为yes，不需要再次确认；3）-q，不显示安装的过程。</p><p>command：待操作的命令。</p><p>package：待操作的软件包名，多个软件包之间用空格分开，支持用星号*匹配。</p><h2 id="2-yum的常用命令"><a class="markdownIt-Anchor" href="#2-yum的常用命令"></a> 2、yum的常用命令</h2><p>最最常用的命令加粗显示。</p><p><strong>1）安装/升级软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 软件包名/软件包文件名</span><br></pre></td></tr></table></figure><p><strong>2）升级软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update 软件包名</span><br></pre></td></tr></table></figure><p><strong>3）删除软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove 软件包名</span><br></pre></td></tr></table></figure><p><strong>4）查找软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search 软件包名</span><br></pre></td></tr></table></figure><p>5）列出所有可更新的软件包清单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></table></figure><p>6）更新所有软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p>7）列出所有可安装软件包的清单；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list</span><br></pre></td></tr></table></figure><p>8）清除缓存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean [headers|packages|metadata|dbcache|plugins|expire-cache|all]</span><br></pre></td></tr></table></figure><h2 id="3-示例"><a class="markdownIt-Anchor" href="#3-示例"></a> 3、示例</h2><p>1）安装/升级ftp客户端软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp<span class="number">-0.17</span><span class="number">-67.</span>el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>2）升级ftp客户端软件包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update ftp</span><br></pre></td></tr></table></figure><p>3）删除ftp客户端软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove ftp</span><br></pre></td></tr></table></figure><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>1）rpm安装/升级软件包需要手工的解决包的依赖关系，这一点让人确实很烦，所以，软件包的安装/升级一般采用yum命令。</p><p>2）rpm的某些功能，例如查看软件包的详细信息、软件包的安装目录、软件包的配置文件等还是有实用价值的。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7设置中文字符集</title>
      <link href="/post/27842c1f.html"/>
      <url>/post/27842c1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-字符编码和字符集"><a class="markdownIt-Anchor" href="#一-字符编码和字符集"></a> 一、字符编码和字符集</h1><h2 id="1-字符编码character-encoding"><a class="markdownIt-Anchor" href="#1-字符编码character-encoding"></a> 1、字符编码（character encoding）：</h2><p>字符编码是一种法则，在数字与符号之间建立的对应关系。不同的国家有不同的语言，包含的文字、标点符号、图形符号各有不同。例如在ASCII编码中，用数字97表达字符’a’与字符集相对应，常见的字符编码有ASCII，GBK，GB18030，Unicode等。</p><h2 id="2-字符集character-set"><a class="markdownIt-Anchor" href="#2-字符集character-set"></a> 2、字符集（Character set）</h2><p>字符集是字符的集合，字符是文字和符号的总称，用ASCII编码的字符集称之为ASCII字符集，用GBK编码的字符集称之为GBK字符集。</p><h2 id="3-国际编码unicode"><a class="markdownIt-Anchor" href="#3-国际编码unicode"></a> 3、国际编码（Unicode）</h2><p>为了解决传统的字符编码方案的局限，1994年发布了Unicode（国际编码、统一码、万国码、单一码、通用码），它是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 将全世界所有的字符统一化，统一编码，再也不存在字符集不兼容和字符转换的问题。</p><p>Unicode 有以下三种编码方式：</p><p>1）UTF-8：兼容ASCII编码；拉丁文、希腊文等使用两个字节；包括汉字在内的其它常用字符使用三个字节；剩下的极少使用的字符使用四个字节。</p><p>2）UTF-16：对相对常用的60000余个字符使用两个字节进行编码，其余的使用4字节。</p><p>3）UTF-32：固定使用4个字节来表示一个字符，存在空间利用效率的问题。</p><h1 id="二-汉字的编码"><a class="markdownIt-Anchor" href="#二-汉字的编码"></a> 二、汉字的编码</h1><h2 id="1-汉字的编码"><a class="markdownIt-Anchor" href="#1-汉字的编码"></a> 1、汉字的编码</h2><p>支持汉字（简体中文）的编码有GB2312、GB13000、GBK、GB18030和Unicode（UTF-8、UTF-16、UTF-32）。</p><p>1）GB2312</p><p>仅包含大部分的常用简体汉字，但已经不能适应现在的需要。</p><p>2）GB13000</p><p>由于GB2312的局限性，国家标准化委员会制定了GB13000编码；但由于当时的硬件和软件都已经支持了GB2312，而GB13000与GB2312完全不兼容，所以没有能够得到大范围的推广使用。</p><p>3）GBK</p><p>有了GB13000的教训，中国国家标准化委员会制定了GBK标准，并兼容了GB2312标准，同时在GB2312标准的基础上扩展了GB13000包含的字；由于该标准有微软的支持，得到了广泛的应用。</p><p>4）GB18030</p><p>GB18030编码比GBK又新增了几千个汉字，但由于码位不足使用了2byte与4byte混合编码方式，这给软件开发增加了难度。</p><p>5）Unicode</p><p>包含全世界所有国家需要用到的字符，是国际编码，通用性强。</p><h2 id="2-汉字的编码选择"><a class="markdownIt-Anchor" href="#2-汉字的编码选择"></a> 2、汉字的编码选择</h2><p>在操作系统和数据库中，常用的汉字编码有GBK、GB18030和Unicode，GBK和GB18030的优势是占用空间小，Unicode的优势是全球化的支持。</p><p>在应用开发中，如果不考虑全球化，最好的选择是GBK和GB18030。</p><h2 id="3-编码的转换"><a class="markdownIt-Anchor" href="#3-编码的转换"></a> 3、编码的转换</h2><p>GBK和GB18030与Unicode编码之间需要转换，否则会出现汉字乱码。</p><h1 id="三-设置linux的字符集"><a class="markdownIt-Anchor" href="#三-设置linux的字符集"></a> 三、设置Linux的字符集</h1><h2 id="1-查看当前系统已安装的字符集"><a class="markdownIt-Anchor" href="#1-查看当前系统已安装的字符集"></a> 1、查看当前系统已安装的字符集</h2><p>1）locale命令用于查看当前系统全部的已安装的字符集，Linux支持的符集约800种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a</span><br></pre></td></tr></table></figure><p>2）查看已安装的中文字符集（只查看中国大陆的，不包括香港和台湾）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a|grep zh_CN</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311112001745.png" alt="在这里插入图片描述" /></p><p>上图表示已经安装了中文字符集。</p><h2 id="2-安装中文字符集"><a class="markdownIt-Anchor" href="#2-安装中文字符集"></a> 2、安装中文字符集</h2><p>如果您的Linux系统没有安装中文字符集，可以用yum命令安装。</p><p>我查了一些资料，安装中文字符集软件包的方法比较多，没找到准确的说法，所以把多种方法都写了进来，以下命令都可以执行，不会有副作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall chinese-support</span><br><span class="line">yum -y install chinese-support</span><br><span class="line">yum -y install kde-l10n-Chinese</span><br><span class="line">yum -y install ibus-table-chinese<span class="number">-1.4</span><span class="number">.6</span><span class="number">-3.</span>el7.noarch</span><br></pre></td></tr></table></figure><p>安装后，执行<code>locale -a|grep zh_CN</code>，如果显示的内容如下，表示安装成功。</p><p><img src="https://img-blog.csdnimg.cn/20200311112105986.png" alt="在这里插入图片描述" /></p><h2 id="3-修改字符集配置文件"><a class="markdownIt-Anchor" href="#3-修改字符集配置文件"></a> 3、修改字符集配置文件</h2><p>CentOS6.x 字符集配置文件在/etc/sysconfig/i18n文件中。</p><p>CentOS7.x 字符集配置文件在/etc/locale.conf文件中，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200311112120723.png" alt="在这里插入图片描述" /></p><p>执行以下命令或者重启系统使修改生效。</p><p>CentOS6.x</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/sysconfig/i18n</span><br></pre></td></tr></table></figure><p>CentOS7.x:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/locale.conf</span><br></pre></td></tr></table></figure><h1 id="四-lang环境变量"><a class="markdownIt-Anchor" href="#四-lang环境变量"></a> 四、LANG环境变量</h1><p>LANG环境变量存放的是Linux系统的语言、地区、字符集，它不需要系统管理员手工设置，/etc/profile会调用/etc/profile.d/lang.sh脚本完成对PATH的设置。</p><h1 id="五-修改客户端的字符集"><a class="markdownIt-Anchor" href="#五-修改客户端的字符集"></a> 五、修改客户端的字符集</h1><p>客户端的字符集必须与Linux服务端一致，否则会出现乱码，以SecureCRT为例。修改会话的属性，在Appearance界面中的Character<br />encoding下拉框中选择。</p><p><img src="https://img-blog.csdnimg.cn/20200311112259313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="六-字符集转换工具"><a class="markdownIt-Anchor" href="#六-字符集转换工具"></a> 六、字符集转换工具</h1><p>Linux提供了iconv命令把文件内容从一种编码转换成另一种编码。</p><p>参数说明：</p><p>--list：列出iconv支持的编码列表。</p><p>-f encoding：源文件内容的编码。</p><p>-t encoding：目标文件内容的编码。</p><p>-o file：指定输出文件。</p><p>-c：忽略输出的非法字符。</p><p>-l：列出已知的编码字符集。</p><p>-s：禁止警告信息，但不是错误信息。</p><p>--verbose：显示进度信息。</p><p>示例：</p><p>把当前目录的book1.c由gbk转换成utf-8，结果输出到/tmp/book1_utf8.c中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f gbk -t utf<span class="number">-8</span> book1.c -o /tmp/book1_utf8.c</span><br></pre></td></tr></table></figure><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>1）Linux系统在业务化之前，就应该确定字符集，然后不再改变。系统在业务化后，修改字符集是一件很麻烦的事情，最好别惹这个麻烦。</p><p>2）如果项目没有全球化的需求，Linux的字符集建议采用zh_CN.gbk。</p><p>3）虽然gb18030字符集比gbk更丰富，但是gb18030中有部分汉字是4字节，这一点让程序员很郁闷，所以，程序员更倾向gbk字符集。</p><p>4）设置Linux的字符集时，还要考虑WEB系统和数据库系统采用的字符集，最好是大家都保持一致。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7设置环境变量</title>
      <link href="/post/922d601b.html"/>
      <url>/post/922d601b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-环境变量的概念"><a class="markdownIt-Anchor" href="#一-环境变量的概念"></a> 一、环境变量的概念</h1><h2 id="1-环境变量的含义"><a class="markdownIt-Anchor" href="#1-环境变量的含义"></a> 1、环境变量的含义</h2><p>程序（操作系统命令和应用程序）的执行都需要运行环境，这个环境是由多个环境变量组成的。</p><h2 id="2-环境变量的分类"><a class="markdownIt-Anchor" href="#2-环境变量的分类"></a> 2、环境变量的分类</h2><p>1）按生效的范围分类。</p><p><strong>系统环境变量</strong>：公共的，对全部的用户都生效。</p><p><strong>用户环境变量</strong>：用户私有的、自定义的个性化设置，只对该用户生效。</p><p>2）按生存周期分类。</p><p><strong>永久环境变量</strong>：在环境变量脚本文件中配置，用户每次登录时会自动执行这些脚本，相当于永久生效。</p><p><strong>临时环境变量</strong>：使用时在Shell中临时定义，退出Shell后失效。</p><h2 id="3-linux环境变量"><a class="markdownIt-Anchor" href="#3-linux环境变量"></a> 3、Linux环境变量</h2><p>Linux环境变量也称之为Shell环境量变，以下划线和字母打头，由下划线、字母（区分大小写）和数字组成，习惯上使用大写字母，例如PATH、HOSTNAME、LANG等。</p><h1 id="二-常用的环境变量"><a class="markdownIt-Anchor" href="#二-常用的环境变量"></a> 二、常用的环境变量</h1><h2 id="1-查看环境变量"><a class="markdownIt-Anchor" href="#1-查看环境变量"></a> 1、查看环境变量</h2><p>1）env命令</p><p>在Shell下，用env命令查看当前用户全部的环境变量。</p><p><img src="https://img-blog.csdnimg.cn/20200309153619141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>上图只截取了部分环境变量，并非全部。</p><p>用env命令的时候，满屏显示了很多环境变量，不方便查看，可以用grep筛选。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env|grep 环境变量名</span><br></pre></td></tr></table></figure><p>例如查看环境变量名中包含PATH的环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env|grep PATH</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309153737428.png" alt="在这里插入图片描述" /></p><p>2）echo命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $环境变量名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309154019391.png" alt="在这里插入图片描述" /></p><p>注意，符号$不能缺少，这是语法规定。</p><h2 id="2-常用的环境变量"><a class="markdownIt-Anchor" href="#2-常用的环境变量"></a> 2、常用的环境变量</h2><p>1）PATH</p><p>可执行程序的搜索目录，可执行程序包括Linux系统命令和用户的应用程序，PATH变量的具体用法本文后面的章节中有详细的介绍。</p><p><img src="https://img-blog.csdnimg.cn/2020030915405165.png" alt="在这里插入图片描述" /></p><p>2）LANG</p><p>Linux系统的语言、地区、字符集，LANG变量的具体用法本文后面的章节中有详细的介绍。</p><p><img src="https://img-blog.csdnimg.cn/20200309154112233.png" alt="在这里插入图片描述" /></p><p>3）HOSTNAME</p><p>服务器的主机名。</p><p>4）SHELL</p><p>用户当前使用的Shell解析器。</p><p>5）HISTSIZE</p><p>保存历史命令的数目。</p><p>6）USER</p><p>当前登录用户的用户名。</p><p>7）HOME</p><p>当前登录用户的主目录。</p><p>8）PWD</p><p>当前工作目录。</p><p>9）LD_LIBRARY_PATH</p><p>C/C<ins>语言动态链接库文件搜索的目录，它不是Linux缺省的环境变量，但对C/C</ins>程序员来说非常重要，具体用法本文后面的章节中有详细的介绍。</p><p>10）CLASSPATH</p><p>JAVA语言库文件搜索的目录，它也不是Linux缺省的环境变量，但对JAVA程序员来说非常重要，具体用法本文后面的章节中有详细的介绍。</p><h1 id="三-设置环境量"><a class="markdownIt-Anchor" href="#三-设置环境量"></a> 三、设置环境量</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名=<span class="string">&#x27;值&#x27;</span></span><br><span class="line"><span class="keyword">export</span> 变量名</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> 变量名=<span class="string">&#x27;值&#x27;</span></span><br></pre></td></tr></table></figure><p>如果环境变量的值没有空格等特殊符号，可以不用单引号包含。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ORACLE_HOME=/oracle/home</span><br><span class="line"><span class="keyword">export</span> ORACLE_BASE=/oracle/base</span><br><span class="line"><span class="keyword">export</span> ORACLE_SID=snorcl11g</span><br><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin:.</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib:.</span><br></pre></td></tr></table></figure><p>采用export设置的环境变量，在退出Shell后就会失效，下次登录时需要重新设置。如果希望环境变量永久生效，需要在登录脚本文件中配置。</p><h2 id="1-系统环境变量"><a class="markdownIt-Anchor" href="#1-系统环境变量"></a> 1、系统环境变量</h2><p>系统环境变量对全部的用户生效，设置系统环境变量有三种方法。</p><p>1）在/etc/profile文件中设置。</p><p>用户登录时执行/etc/profile文件中设置系统的环境变量。但是，Linux不建议在/etc/profile文件中设置系统环境变量。</p><p>2）在/etc/profile.d目录中增加环境变量脚本文件，这是Linux推荐的方法。</p><p>/etc/profile在每次启动时会执行/etc/profile.d下全部的脚本文件。/etc/profile.d比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d下对应的 shell 脚本即可。</p><p>/etc/profile.d目录下有很多脚本文件，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200309154305141.png" alt="在这里插入图片描述" /></p><p>在以上示例中，/etc/profile.d目录中的oracle.sh是Oracle数据库的环境变量配置文件，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200309154317585.png" alt="在这里插入图片描述" /></p><p>3）在/etc/bashrc文件中设置环境变量。</p><p>该文件配置的环境变量将会影响全部用户使用的bash shell。但是，Linux也不建议在/etc/bashrc文件中设置系统环境变量。</p><h2 id="2-用户环境变量"><a class="markdownIt-Anchor" href="#2-用户环境变量"></a> 2、用户环境变量</h2><p>用户环境变量只对当前用户生效，设置用户环境变量也有多种方法。</p><p>在用户的主目录，有几个特别的文件，用<code>ls</code>是看不见的，用 <code>ls .bash_*</code> 可以看见。</p><p><img src="https://img-blog.csdnimg.cn/20200309155024757.png" alt="在这里插入图片描述" /></p><p>1）.bash_profile（推荐首选）</p><p>当用户登录时执行，每个用户都可以使用该文件来配置专属于自己的环境变量。</p><p>2）.bashrc</p><p>当用户登录时以及每次打开新的Shell时该文件都将被读取，不推荐在里面配置用户专用的环境变量，因为每开一个Shell，该文件都会被读取一次，效率肯定受影响。</p><p>3）.bash_logout</p><p>当每次退出系统（退出bash shell）时执行该文件。</p><p>4）.bash_history</p><p>保存了当前用户使用过的历史命令。</p><h2 id="3-环境变量脚本文件的执行顺序"><a class="markdownIt-Anchor" href="#3-环境变量脚本文件的执行顺序"></a> 3、环境变量脚本文件的执行顺序</h2><p>环境变量脚本文件的执行顺序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile-&gt;/etc/profile.d-&gt;/etc/bashrc-&gt;用户的.bash_profile-&gt;用户的.bashrc</span><br></pre></td></tr></table></figure><p>同名的环境变量，如果在多个脚本中有配置，以最后执行的脚本中的配置为准。</p><p>还有一个问题需要注意，在/etc/profile中执行了/etc/profile.d的脚本，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in /etc/profile.d<span class="comment">/*.sh ; do</span></span><br><span class="line"><span class="comment">    if [ -r &quot;$i&quot; ]; then</span></span><br><span class="line"><span class="comment">        if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then</span></span><br><span class="line"><span class="comment">            . &quot;$i&quot;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            . &quot;$i&quot; &gt;/dev/null</span></span><br><span class="line"><span class="comment">        fi</span></span><br><span class="line"><span class="comment">    fi</span></span><br><span class="line"><span class="comment">done</span></span><br></pre></td></tr></table></figure><p>所以，/etc/profile.d和/etc/profile的执行顺序还要看代码怎么写。</p><h1 id="四-重要环境变量的详解"><a class="markdownIt-Anchor" href="#四-重要环境变量的详解"></a> 四、重要环境变量的详解</h1><h2 id="1-path环境变量"><a class="markdownIt-Anchor" href="#1-path环境变量"></a> 1、PATH环境变量</h2><p>可执行程序的搜索目录，可执行程序包括Linux系统命令和用户的应用程序。如果可执行程序的目录不在PATH指定的目录中，执行时需要指定目录。</p><p>1）PATH环境变量存放的是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=目录<span class="number">1</span>:目录<span class="number">2</span>:目录<span class="number">3</span>:......目录n:.</span><br></pre></td></tr></table></figure><p>2）PATH缺省包含了Linux系统命令所在的目录（/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin），如果不包含这些目录，Linux的常用命令也无法执行（要输入绝对路径才能执行）。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200309155421291.png" alt="在这里插入图片描述" /></p><p>3）在用户的.bash_profile文件中，会对PATH进行扩充，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure><p>4）如果PATH变量中没有包含圆点.，执行当前目录下的程序需要加./或使用绝对路径。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200309155459804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-lang环境变量"><a class="markdownIt-Anchor" href="#2-lang环境变量"></a> 2、LANG环境变量</h2><p>LANG环境变量存放的是Linux系统的语言、地区、字符集，它不需要系统管理员手工设置，/etc/profile会调用/etc/profile.d/lang.sh脚本完成对PATH的设置。</p><p>CentOS6.x  字符集配置文件在/etc/syscconfig/i18n文件中。</p><p>CentOS7.x 字符集配置文件在/etc/locale.conf文件中，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200309155523512.png" alt="在这里插入图片描述" /></p><h2 id="3-ld_library_path环境变量"><a class="markdownIt-Anchor" href="#3-ld_library_path环境变量"></a> 3、LD_LIBRARY_PATH环境变量</h2><p>C/C<ins>语言动态链接库文件搜索的目录，它不是Linux缺省的环境变量，但对C/C</ins>程序员来说非常重要。</p><p>LD_LIBRARY_PATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=目录<span class="number">1</span>:目录<span class="number">2</span>:目录<span class="number">3</span>:......目录n:.</span><br></pre></td></tr></table></figure><h2 id="4-classpath"><a class="markdownIt-Anchor" href="#4-classpath"></a> 4、CLASSPATH</h2><p>JAVA语言库文件搜索的目录，它也不是Linux缺省的环境变量，但对JAVA程序员来说非常重要。</p><p>CLASSPATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。</p><h1 id="五-环境变量的生效"><a class="markdownIt-Anchor" href="#五-环境变量的生效"></a> 五、环境变量的生效</h1><p>1）在Shell下，用export设置的环境变量对当前Shell立即生效，Shell退出后失效。</p><p>2）在脚本文件中设置的环境变量不会立即生效，退出Shell后重新登录时才生效，或者用source命令让它立即生效，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h1 id="六-应用经验"><a class="markdownIt-Anchor" href="#六-应用经验"></a> 六、应用经验</h1><p>虽然设置环境变量的方法有多种，但是建议系统环境变量建议在/etc/profile.d目录中配置，用户环境变量在用户的.bash_profile中配置，不建议在其它脚本文件中配置环境变，会增加运维的麻烦，容易出错。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vi常用命令</title>
      <link href="/post/5e60c079.html"/>
      <url>/post/5e60c079.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-关于vi"><a class="markdownIt-Anchor" href="#一-关于vi"></a> 一、关于vi</h1><p>vi是最强大的文本编辑器，没有之一。尽管 vi已经是古董级的软件，但还是有无数新人迎着困难去学习，可见其经典与受欢迎的程度。</p><p>无论是小说中还是电视剧，真正强大的武器都不容易驾驭，需要付出一些努力才能收获到更加强大的力量，对于vi这<strong>上古神器</strong>说更是如此。由于它全程使用键盘操作，很多首次接触<br />vi的人会觉得不习惯而中途放弃。然而，坚持下来的朋友就会渐渐地发现这种键盘操作的设计绝妙，经典之所以能成为经典，必然有它的道理，不用解释太多。</p><p>观察一个程序员对vi的熟练程度，可以判断它的技术水平，如果他对vi不熟悉，就肯定不是Linux平台下的程序员，说vi不好用的人也肯定不熟悉vi和Linux，没有例外。</p><h1 id="二-创建打开文件"><a class="markdownIt-Anchor" href="#二-创建打开文件"></a> 二、创建/打开文件</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名</span><br></pre></td></tr></table></figure><p>打开一个文件，如果文件不存在，就创建它。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi book.c</span><br></pre></td></tr></table></figure><h1 id="三-vi的三种模式"><a class="markdownIt-Anchor" href="#三-vi的三种模式"></a> 三、vi的三种模式</h1><p>vi<br />有三种模式，命令行模式、插入模式和替换模式，在命令行模式下，任何键盘输入都是命令，在插入模式和替换模式下，键盘输入的才是字符。</p><p>插入模式和替换模式也合称为编辑模式。</p><h1 id="四-vi的常用命令"><a class="markdownIt-Anchor" href="#四-vi的常用命令"></a> 四、vi的常用命令</h1><p>Esc 从编辑模式切换到命令行模式。</p><p>i 在光标所在位置前面开始插入。</p><p>a 在光标所在的位置后面开始插入。</p><p>o 在光标所在位置行的下面插入空白行。</p><p>O 在光标所在位置行的上面插入空白行。</p><p>I 在光标所在位置行的行首开始插入。</p><p>A 在光标所在位置行的行末开始插入。</p><p>k 类似方向键上。</p><p>j 类似方向键下。</p><p>h 类似方向键左。</p><p>l 类是方向键右。</p><p>Ctrl+u 向上翻半页。</p><p>Ctrl+d 向下翻页。</p><p>nG 光标跳到文件的第n行行首。</p><p>G 光标跳到文件最后一行。</p><p>:5回车 光标跳到第5行。</p><p>:n回车 光标跳到第n行。</p><p>0 光标跳到当前行的行首。</p><p>$ 光标跳到当前行的行尾。</p><p>w 光标跳到下个单词的开头。</p><p>b 光标跳到上个单词的开头。</p><p>e 光标跳到本单词的尾部。</p><p>x 每按一次，删除光标所在位置的一个字符。</p><p>nx 如&quot;3x&quot;表示删除光标所在位置开始的3个字符。</p><p>dw 删除光标所在位置到本单词结尾的字符。</p><p>D 删除本行光标所在位置后面全部的内容。</p><p>dd 删除光标所在位置的一行。</p><p>ndd 如&quot;3dd&quot;表示删除光标所在位置开始的3行。</p><p>yy 将光标所在位置的一行复制到缓冲区。</p><p>nyy 将光标所在位置的n行复制到缓冲区。</p><p>p 将缓冲区里的内容粘贴到光标所在位置。</p><p>r 替换光标所在位置的一个字符 replace。</p><p>R 从光标所在位置开始替换，直到按下&quot;Esc&quot;。</p><p>cw 从光标所在位置开始替换单词，直到按下&quot;Esc&quot;。</p><p>u 撤销命令，可多次撤销。</p><p>J 把当前行的下一行接到当前行的尾部。</p><p>Ctrl+g 显示光标所在位置的行号和文件的总行数。</p><p>/abcd 在当前打开的文件中查找“abcd”文本内容。</p><p>n 查找下一个。</p><p>N 查找上一下。</p><p>. 重复执行上一次执行的vi命令。</p><p>~ 对光标当前所在的位置的字符进行大小写转换。</p><p>列操作</p><p>Ctrl+V 光标上或下 大写的I 输入内容 Esc</p><p>:w回车 存盘。</p><p>:w!回车 强制存盘。</p><p>:wq回车 存盘退出。</p><p>:x回车 存盘退出。</p><p>:q回车 不存盘退出。</p><p>:q!回车 不存盘强制退出。</p><p>:g/aaaaaaaaa/s//bbbbbb/g回车 把文件中全部的aaaaaaaaa替换成bbbbbb。</p><p>Ctl+insert 复制鼠标选中的文本，相当于Ctl+c。</p><p>Shift+insert 输出鼠标选中的文本，相当于Ctl+v。</p><p>以上两个命令在windows和UNIX中是通用的。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/post/d0edc1ed.html"/>
      <url>/post/d0edc1ed.html</url>
      
        <content type="html"><![CDATA[<p>Linux的命令有几百个，对程序员来说，常用的并不多，并不需要全部掌握。如果在学习和工作中遇到了陌生的Linux命令，不要轻易放过，多查资料，掌握它，日积月累，知识面就会宽广。</p><p>本文介绍的是Linux的常用命令，对初学者来说，建议系统化的学习Linux基础知识。</p><p>推荐视频：<a href="https://www.bilibili.com/video/av18156598">https://www.bilibili.com/video/av18156598</a></p><p>这个视频非本人录制，因为好所以推荐。</p><h2 id="1-开机"><a class="markdownIt-Anchor" href="#1-开机"></a> 1、开机</h2><p>物理机服务器：按下电源开关，就像Windows开机一样。</p><p>本地虚拟机：在VMware中点击“开启此虚拟机”。</p><h2 id="2-登录"><a class="markdownIt-Anchor" href="#2-登录"></a> 2、登录</h2><p>启动完成后，输入用户名和密码，一般情况下，不要用root用户登录，<strong>root用户的权限太大，如果产生了误操作，后果相当严重。</strong></p><h2 id="3-切换用户"><a class="markdownIt-Anchor" href="#3-切换用户"></a> 3、切换用户</h2><p>在命令提示符下输入：<code>su - root</code> ，然后按提示输入root的密码后将切换到root用户。</p><p>从root用户切换到其它普通用户不需要输入密码，从普通用户切换到任何用户都需要输入密码。</p><p><img src="https://img-blog.csdnimg.cn/2020030911452493.png" alt="在这里插入图片描述" /></p><h2 id="4-重启和关机"><a class="markdownIt-Anchor" href="#4-重启和关机"></a> 4、重启和关机</h2><p>重启和关机需要系统管理员用户权限。</p><p>1）重启。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init <span class="number">6</span> 或 reboot</span><br></pre></td></tr></table></figure><p>2）关机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init <span class="number">0</span> 或 halt</span><br></pre></td></tr></table></figure><p>如果没有执行关机命令，强制断电或关闭本地虚拟机的窗口，会导致Linux操作系统文件的损坏，严重的可能导致系统无法正常启动。</p><h2 id="5-清屏"><a class="markdownIt-Anchor" href="#5-清屏"></a> 5、清屏</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><p>清除当前屏幕上显示的内容。</p><h2 id="6-查看服务器的ip地址"><a class="markdownIt-Anchor" href="#6-查看服务器的ip地址"></a> 6、查看服务器的ip地址</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309114609137.png" alt="在这里插入图片描述" /></p><p>上图中，框中显示的就是IP地址。</p><h2 id="7-时间操作"><a class="markdownIt-Anchor" href="#7-时间操作"></a> 7、时间操作</h2><p>普通用户可以查看时间，但设置时区和时间要系统管理员用户登录 。</p><p>1）查看时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p>2）设置时区为中国上海时间（注意不是北京时间）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure><p>3）设置时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s <span class="string">&quot;yyyy-mm-dd hh:mi:ss&quot;</span></span><br></pre></td></tr></table></figure><p>例如：<code>date -s &quot;2020-01-02 12:35:28&quot;</code></p><p>4）把操作系统的时间写入CMOS。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock -w</span><br></pre></td></tr></table></figure><h2 id="8-目录和文件"><a class="markdownIt-Anchor" href="#8-目录和文件"></a> 8、目录和文件</h2><p>文件系统是像一棵树，树干是/（根）目录，树枝是子目录，树枝后面还有树枝（子目录中还有子目录），树枝最后是树叶，目录的最后是文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114643132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>严谨的说，文件名是由<strong>目录+文件名</strong>组成的。</p><p>对于目录和文件，有一些约定的表述，我们以/usr/etc/readme.txt为例。</p><p>1）<strong>全路径文件名</strong>包含了完整的目录名和文件名，即/usr/etc/readme.txt，还有一个称呼是“绝<strong>对路径文件名</strong>”。</p><p>2）readme.txt是文件名，它在/usr/etc目录中。</p><p>3）目录和文件的<strong>绝对路径</strong>是从根（/）算起，在任何时候都不会有岐义。</p><p>4）登录Linux后，一定处在目录树的某个目录中，这个目录称之为当前工作目录，简称<strong>当前目录</strong>。</p><p>5）目录和文件的<strong>相对路径</strong>是从当前目录算起，如果当前目录是/usr，etc/readme.txt等同于/usr/etc/readme.txt；如果当前目录是/usr/etc，readme.txt等同于/usr/etc/readme.txt。</p><p>6）用Linux的命令操作目录和文件的时候，采用绝对路径和相对路径都可以。</p><p>7）一个圆点.表示当前目录；</p><p>8）两个圆点…表示当前目录的上一级目录。</p><p><strong>理解绝对路径和相对路径的概念非常重要，在日常操作中，绝对路径和相对路径会同时使用，但是程序员在编写的程序中极少使用相对路径。</strong></p><h2 id="9-正则表达式"><a class="markdownIt-Anchor" href="#9-正则表达式"></a> 9、正则表达式</h2><p>正则表达式又称规则表达式、通配符，目录和文件名都支持正则表达式，正则表达式的规则比较多，在这里我只介绍最常用的两种：星号“*”和问号“?”。</p><p>星号“*”：匹配任意数量的字符。</p><p>问号“?”：匹配一个的字符。</p><p>示例：</p><p>当前目录下有以下几个文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book15  book15.c  book1.c  book5.c  makefile</span><br></pre></td></tr></table></figure><p>1）列出全部的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114820457.png" alt="在这里插入图片描述" /></p><p>2）列出文件名以book打头，.c结尾，中间可以是任意数量的字符的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114828791.png" alt="在这里插入图片描述" /></p><p>3）列出文件名以book打头，.c结尾，中间只能有一个字符的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114842120.png" alt="在这里插入图片描述" /></p><h2 id="10-查看当前目录"><a class="markdownIt-Anchor" href="#10-查看当前目录"></a> 10、查看当前目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309144153568.png" alt="在这里插入图片描述" /></p><h2 id="11-改变当前目录"><a class="markdownIt-Anchor" href="#11-改变当前目录"></a> 11、改变当前目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 目录名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）进入/tmp目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br></pre></td></tr></table></figure><p>2）进入上一级目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>3）进入用户的主目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure><h2 id="12-列出目录和文件信息"><a class="markdownIt-Anchor" href="#12-列出目录和文件信息"></a> 12、列出目录和文件信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-lt] 目录或文件名</span><br></pre></td></tr></table></figure><p>ls是list的缩写，通过ls命令不仅可以查看目录和文件信息，还可以目录和文件权限、大小、主人和组等信息。</p><p>选项-l列出目录和文件的详细信息。</p><p>选项-lt列出目录和文件的详细信息，按时间降序显示。</p><p>示例：</p><p>1）列出当前目录下全部的目录和文件名信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309115133910.png" alt="在这里插入图片描述" /></p><p>2）列出当前目录下全部的目录和文件名详细的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309115207241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>3）列出/tmp目录下全部的目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030911524922.png" alt="在这里插入图片描述" /></p><p>4）列出/tmp目录下以匹配exp*.dmp的目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp/exp*.dmp</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309115317418.png" alt="在这里插入图片描述" /></p><p>5）列出/tmp目录下匹配*.log的目录和文件，按时间降序显示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp<span class="comment">/*.log</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030911535932.png" alt="在这里插入图片描述" /></p><h2 id="13-创建目录"><a class="markdownIt-Anchor" href="#13-创建目录"></a> 13、创建目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 目录名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）在当前目录下创建aaa目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir aaa</span><br></pre></td></tr></table></figure><p>2）在当前目录的aaa目录下创建bbb目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir aaa/bbb</span><br></pre></td></tr></table></figure><p>3）创建/tmp/aaa目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/aaa</span><br></pre></td></tr></table></figure><h2 id="14-删除目录和文件"><a class="markdownIt-Anchor" href="#14-删除目录和文件"></a> 14、删除目录和文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-rf] 目录或文件列表</span><br></pre></td></tr></table></figure><p>选项-r可以删除目录，如果没有-r只能删除文件。</p><p>选项-f表示强制删除，不需要确认。</p><p>目录和文件列表中间用空格分隔。</p><p>示例：</p><p>1）删除当前目录下匹配*.log的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm *.log</span><br></pre></td></tr></table></figure><p>2）强制删除当前目录下匹配*.log的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f *.log</span><br></pre></td></tr></table></figure><p>3）删除/tmp/aaa目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r /tmp/aaa</span><br></pre></td></tr></table></figure><p>4）强制删除/tmp目录下匹配exp*的全部目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/exp*</span><br></pre></td></tr></table></figure><p>5）强制删除当前目录下的book和book.c文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf book book.c</span><br></pre></td></tr></table></figure><h2 id="15-移动目录和文件"><a class="markdownIt-Anchor" href="#15-移动目录和文件"></a> 15、移动目录和文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 旧目录或文件名 新目录或文件名</span><br></pre></td></tr></table></figure><p>如果第二个参数是已经存在的目录，则把第一个参数（旧目录或文件名）移动到该目录中。</p><p>示例：</p><p>1）把当前目录中的book.c文件重命名为book1.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv book.c book1.c</span><br></pre></td></tr></table></figure><p>2）如果/tmp/test3是一个已经存在的目录，以下命令将把当前目录下的book.c文件移动到/tmp/test3目录中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv book.c /tmp/test3</span><br></pre></td></tr></table></figure><p>3）如果/tmp/test3目录不存在，以下命令将把当前目录下的book.c文件改名为/tmp/test3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv book.c /tmp/test3</span><br></pre></td></tr></table></figure><h2 id="16-复制目录和文件"><a class="markdownIt-Anchor" href="#16-复制目录和文件"></a> 16、复制目录和文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [-r] 旧目录或文件名 新目录或文件名</span><br></pre></td></tr></table></figure><p>选项-r可以复制目录，如果没有选项-r只能复制文件。</p><p>示例：</p><p>1）把当前目录下的book1.c文件复制为book2.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp book1.c book2.c</span><br></pre></td></tr></table></figure><p>2）把当前目录下的aaa目录复制为bbb</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r aaa bbb</span><br></pre></td></tr></table></figure><p>3）把当前目录下的book1.c文件复制为/tmp/book1.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp book1.c /tmp/book1.c</span><br><span class="line">cp book1.c /tmp/.</span><br></pre></td></tr></table></figure><p>以上两个命令的效果相同。</p><p>4）把当前目录下的aaa目录复制为/tmp/aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -r aaa /tmp/aaa</span><br><span class="line">cp -r aaa /tmp/.</span><br></pre></td></tr></table></figure><p>以上两个命令的效果相同。</p><h2 id="17-修改用户的密码"><a class="markdownIt-Anchor" href="#17-修改用户的密码"></a> 17、修改用户的密码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [用户名]</span><br></pre></td></tr></table></figure><p>修改用户的密码，按提示两次输入新密码，如果两次输入的密码相同就修改成功。</p><p>普通用户只能修改自己的密码，只输入passwd就可以了，不能指定用户名。</p><p>系统管理员可以修改任何用户的密码，passwd后需要指定用户名。</p><h2 id="18-打包压缩和解包解压"><a class="markdownIt-Anchor" href="#18-打包压缩和解包解压"></a> 18、打包压缩和解包解压</h2><p>tar命令用来打包压缩和解包解压文件，类似windows的winrar工具。</p><p>打包压缩的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf压缩包文件名 目录或文件名列表</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）把当前目录的aaa、bbb和ccc目录打包压缩成123.tgz文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf <span class="number">123.</span>tgz aaa bbb ccc</span><br></pre></td></tr></table></figure><p>2）把/home/oracle/aaa、/home/oracle/bbb和/home/oracle/ccc目录打包压缩成/tmp/123.tgz文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf /tmp/<span class="number">123.</span>tgz /home/oracle/aaa /home/oracle/bbb /home/oracle/ccc</span><br></pre></td></tr></table></figure><p>解包解压的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf压缩包文件名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）把/tmp/123.tgz压缩包文件在当前目录下解压。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf /tmp/<span class="number">123.</span>tgz</span><br></pre></td></tr></table></figure><p>2）把/tmp/123.tgz压缩包文件在/tmp/aaa目录下解压。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/aaa</span><br><span class="line">tar zxvf /tmp/<span class="number">123.</span>tgz</span><br></pre></td></tr></table></figure><p>注意：</p><p>1）用tar命令打包和解包的目录和文件没有绝对路径的说法，都成了相对的，在包中相对的。</p><p>2）用tar命令打包的文件，用winrar可以解开。</p><p>3）在Linux系统中，还有其它的打包压缩和解包解压命令，例如zip/unzip和gzip/gunzip。</p><h2 id="19-判断网络是否连通"><a class="markdownIt-Anchor" href="#19-判断网络是否连通"></a> 19、判断网络是否连通</h2><p>Windows系统：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -n 包的个数 ip地址或域名</span><br></pre></td></tr></table></figure><p>Linux系统：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 包的个数 ip地址或域名</span><br></pre></td></tr></table></figure><p>ping用于确定本地主机是否能与另一台主机成功交换数据包，判断网络是否通畅。</p><p>127.0.0.1是指本地的ip地址，ping 127.0.0.1总是可以通的。</p><p>示例：</p><p>1）向本地主机（127.0.0.1）ping五个包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c <span class="number">5</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309141836638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2）向新浪的服务器（<a href="http://www.sina.com.xn--cnping-jm68a">www.sina.com.cn）ping</a>五个包。</p><p><img src="https://img-blog.csdnimg.cn/20200309141908845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>新浪的服务器是可以ping通的。</p><p>3）向谷歌的服务器（<a href="http://www.google.xn--comping-bt93b">www.google.com）ping</a> 五个包。</p><p><img src="https://img-blog.csdnimg.cn/20200309141947524.png" alt="在这里插入图片描述" /></p><p>谷歌的服务器是ping不通的。</p><h2 id="20-显示文本文件的内容"><a class="markdownIt-Anchor" href="#20-显示文本文件的内容"></a> 20、显示文本文件的内容</h2><p>显示文本文件的内容有三个命令：cat、more和tail。</p><p>1）cat命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件名</span><br></pre></td></tr></table></figure><p>cat命令一次显示整个文件的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat book1.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309142130768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2）more命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more 文件名</span><br></pre></td></tr></table></figure><p>为了方便阅读，more命令分页显示文件的内容，按空格键显示下一页，按b键显上一页，按q键退出。</p><p>3）tail命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f 文件名</span><br></pre></td></tr></table></figure><p>tail -f用于显示文本文件的最后几行，如果文件的内容有增加，就实时的刷新。对程序员来说，tail<br />-f极其重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行。</p><h2 id="21-统计文本文件的行数-单词数和字节数"><a class="markdownIt-Anchor" href="#21-统计文本文件的行数-单词数和字节数"></a> 21、统计文本文件的行数、单词数和字节数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc 文件名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）统计当前目录处book2*.c文件的行数、单词数和字节数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc book2*.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309142402897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="22-搜索文件中的内容"><a class="markdownIt-Anchor" href="#22-搜索文件中的内容"></a> 22、搜索文件中的内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;内容&quot;</span> 文件名</span><br></pre></td></tr></table></figure><p>注意，如果内容中没有空格等特殊字符，可以不用双引号括起来。</p><p>示例：</p><p>1）在*.c文件中搜索max</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep max *.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030914245064.png" alt="在这里插入图片描述" /></p><h2 id="23-搜索文件"><a class="markdownIt-Anchor" href="#23-搜索文件"></a> 23、搜索文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 目录名 -name 文件名 -print</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>目录名：待搜索的目录，搜索文件的时候，除了这个目录名，还包括它的各级子目录。</p><p>文件名：待搜索的文件名匹配的规则。</p><p>示例：</p><p>1）从/tmp目录开始搜索，把全部的*.c文件显示出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -name *.c -print</span><br></pre></td></tr></table></figure><p>2）从当前目录开始搜索，把全部的*.c文件显示出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name *.c -print</span><br></pre></td></tr></table></figure><h2 id="24-增加删除用户组"><a class="markdownIt-Anchor" href="#24-增加删除用户组"></a> 24、增加/删除用户组</h2><p>1）增加用户组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd dba</span><br></pre></td></tr></table></figure><p>2）删除用户组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel dba</span><br></pre></td></tr></table></figure><h2 id="25-增加删除用户"><a class="markdownIt-Anchor" href="#25-增加删除用户"></a> 25、增加/删除用户</h2><p>1）增加用户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -n 用户名 -g 组名 -d 用户的主目录</span><br></pre></td></tr></table></figure><p>例如增加一个用户，用户名为wucz，属于dba组，用户的主目录是/home/wucz，各位兄弟，wucz是我的名字，您可以改为您自己的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd  -n  wucz  -g  dba  -d  /home/wucz</span><br></pre></td></tr></table></figure><p>2）删除用户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure><p>例如删除wucz用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel wucz</span><br></pre></td></tr></table></figure><h2 id="26-修改目录和文件的主人和组"><a class="markdownIt-Anchor" href="#26-修改目录和文件的主人和组"></a> 26、修改目录和文件的主人和组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chwon [-R] 用户名:组名 目录或文件名列表</span><br></pre></td></tr></table></figure><p>chown将目录或文件的拥有者修改为参数指定的用户名和组，目录或文件名列表用空格分隔。</p><p>-R 选项表示处理各及子目录。</p><p>示例：</p><p>1）把/oracle/home和/oracle/base及其子目录的主人改为oracle，组改为dba。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R oracle:dba /oracle/home /oracle/base</span><br></pre></td></tr></table></figure><h2 id="27-查看系统磁盘空间"><a class="markdownIt-Anchor" href="#27-查看系统磁盘空间"></a> 27、查看系统磁盘空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [-h] [-T]</span><br></pre></td></tr></table></figure><p>选项-h 以方便阅读的方式显示信息。</p><p>选项-T 列出文件系统类型。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200309143023101.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200309143032655.png" alt="在这里插入图片描述" /></p><h2 id="28-版权声明"><a class="markdownIt-Anchor" href="#28-版权声明"></a> 28、版权声明</h2><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7的安装和配置</title>
      <link href="/post/7ad62309.html"/>
      <url>/post/7ad62309.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-ftp简介"><a class="markdownIt-Anchor" href="#一-ftp简介"></a> 一、ftp简介</h1><p>ftp（File Transfer Protocol文件传输协议）是基于TCP/IP协议的应用层协议，用于文件的传输，包括ftp服务器（或服务端）和ftp客户端。</p><p>ftp客户端与服务器创建网络连接，请求登录服务器，登录成功后，就可以进行文件传输，主要包括开载文件和上传文件两种操作。</p><p>ftp协议很古老，有人说它技术太落后，不安全，对于这种说法我不于评论。但是，ftp的应用场景仍非常广泛，这是不争的事实。</p><p>在Linux系统中，ftp客户端和ftp服务器是操作系统自带的，但不一定会缺省安装。</p><h1 id="二-安装ftp软件包"><a class="markdownIt-Anchor" href="#二-安装ftp软件包"></a> 二、安装ftp软件包</h1><p>在CentOS7中，采用yum来安装ftp软件包，包括ftp服务器和ftp客户端。如果已经安装，再次执行yum就会把软件包升级到最新版本。</p><h2 id="1-安装ftp服务器"><a class="markdownIt-Anchor" href="#1-安装ftp服务器"></a> 1、安装ftp服务器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vsftpd</span><br></pre></td></tr></table></figure><h2 id="2-安装ftp客户端"><a class="markdownIt-Anchor" href="#2-安装ftp客户端"></a> 2、安装ftp客户端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp</span><br></pre></td></tr></table></figure><h1 id="三-配置ftp服务器"><a class="markdownIt-Anchor" href="#三-配置ftp服务器"></a> 三、配置ftp服务器</h1><p>ftp的传输模式有被动模式和主动式两种，缺省是被动模式，主动模式的应用场景极少，为了方便表达，在接下来的内容中只介绍被动模式，主动模式在本文中也有介绍。</p><h2 id="1-关闭selinux"><a class="markdownIt-Anchor" href="#1-关闭selinux"></a> 1、关闭SELINUX</h2><p>修改/etc/selinux/config文件，把SELINUX参数的值改为disabled。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX =disabled</span><br></pre></td></tr></table></figure><p>重启linux系统或执行<code>setenforce 0</code>使修改马上生效。</p><h2 id="2-配置ftp数据端口参数"><a class="markdownIt-Anchor" href="#2-配置ftp数据端口参数"></a> 2、配置ftp数据端口参数</h2><p>ftp的数据端口也称为高端口，在/etc/vsftpd/vsftpd.conf文件中配置，由pasv_min_port和pasv_max_port两个参数指定，如果文件中没有这两个参数，手工的加进去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pasv_min_port=<span class="number">5000</span>   # 高端口范围的最小值。</span><br><span class="line">pasv_max_port=<span class="number">5500</span>   # 高端口范围的最大值。</span><br></pre></td></tr></table></figure><h2 id="3-开通防火墙"><a class="markdownIt-Anchor" href="#3-开通防火墙"></a> 3、开通防火墙</h2><p>开通防火墙的方法有两种：</p><p>1）开通ftp服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-service=ftp --permanent</span><br></pre></td></tr></table></figure><p>2）开通ftp服务需要的端口，21是控制端口，5000-5500是数据端口范围，也就是上一节中在/etc/vsftpd/vsftpd.conf文件中配置的pasv_min_port和pasv_max_port参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">21</span>/tcp --permanent</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">5000</span><span class="number">-5500</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>重启防火墙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><h2 id="4-启动vsftpd服务"><a class="markdownIt-Anchor" href="#4-启动vsftpd服务"></a> 4、启动vsftpd服务</h2><p>ftp服务器的服务名是vsftpd，相关的操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start    vsftpd   # 启动服务。</span><br><span class="line">systemctl stop    vsftpd    # 停止服务。</span><br><span class="line">systemctl restart vsftpd    # 重启服务。</span><br><span class="line">systemctl status  vsftpd    # 查看服务状态。</span><br><span class="line">systemctl enable  vsftpd    # 启用开机自动动vsftpd服务。</span><br><span class="line">systemctl disable vsftpd    # 禁用开机自动动vsftpd服务。</span><br></pre></td></tr></table></figure><h2 id="5-云平台访问策略配置"><a class="markdownIt-Anchor" href="#5-云平台访问策略配置"></a> 5、云平台访问策略配置</h2><p>如果您购买的是云服务器上，需要登录云服务器提供商的管理平台开通访问策略（或安全组），开通21和高端口的访问策略。</p><p>不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。</p><p>如果云服务器的ftp服务不对建立数据会话，在百度中输入“被动模式下FTP不能建立数据会话问题“可以找到解决问题的方法，目前的阿里云服务器就存在这个问题。</p><h1 id="四-主动模式和被动模式"><a class="markdownIt-Anchor" href="#四-主动模式和被动模式"></a> 四、主动模式和被动模式</h1><p>ftp有两种模式，分别是port模式（主动模式）和pasv模式（被动模式）。</p><h2 id="1-主动模式"><a class="markdownIt-Anchor" href="#1-主动模式"></a> 1、主动模式</h2><p>客户端给服务端的21端口发命令说：我要输传文件，我已经打开了自己的20端口，您向我的20端口发起TCP连接，我们来传输文件。服务端知道后，就会主动向客户端的20端口发起连接，连接成功后开始传输文件。</p><p><img src="https://img-blog.csdnimg.cn/20200310100630418.png" alt="在这里插入图片描述" /></p><p>在主动模式下，ftp请求是由客户端TCP连接的；传输数据的时候，TCP连接却是由服务端发起的。</p><h2 id="2-被动模式"><a class="markdownIt-Anchor" href="#2-被动模式"></a> 2、被动模式</h2><p>客户端给服务器端的21端口发命令说：我要传输文件。服务器端知道后打开一个空闲的高端口，然后告诉客户端，我已经打开了某某端口，您向我这个端口发起TCP连接，然后我们用这个端口来传输文件。<br /><img src="https://img-blog.csdnimg.cn/20200310100719255.png" alt="在这里插入图片描述" /><br />在被动模式下，不管是ftp命令，还是传输数据，都是由客户端向服务端发起TCP连接。</p><h2 id="3-从主动模式到被动模式"><a class="markdownIt-Anchor" href="#3-从主动模式到被动模式"></a> 3、从主动模式到被动模式</h2><p>在很久以前每台电脑都有一个ip地址，ftp只有主动模式，后来出现了共享上网技术，所以也就有了下面的问题。</p><p>共享上网就是多台电脑共享一个公网ip去使用internet，例如某个局域网出口的公网ip是210.33.25.108，当内网用户（192.168.1.100）访问外网的ftp服务器时，如果采用主动模式，192.168.1.100告诉了ftp服务器我需要某个文件和我打开了20端口之后，由于共享上网的原因，192.168.1.100在出网关的时候ip已经被转换成了210.33.25.108，所以ftp服务器端收到的消息是210.33.25.108需要某个文件并打开了20端口，ftp服务器就会尝试连接210.33.25.108的20端口，这样当然不会成功。</p><p>在主动模式中，ftp的两个端口是相对固定的，如果命令端口是n的话，那数据端口就是n-1，也就是说默认情况下，命令端口是21，数据端口就是20，如果您把ftp服务的端口改成了521，那么数据端口就是520，这样配置防火墙很方便，只需要开通两个端口就可以了。但是，在共享上网的环境中无法使用主动模式。</p><p>在被动模式中，默认情况下命令端口是21，数据端口是随机分配的。但是，被动模式中数据端口的范围可以配置，防火墙也可以配置端口范围。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习环境</title>
      <link href="/post/349a5512.html"/>
      <url>/post/349a5512.html</url>
      
        <content type="html"><![CDATA[<p>有三种方法可以获得Linux学习环境：安装本地虚拟机、购买云服务器和使用我们提供的服务器。</p><h1 id="一-安装本地虚拟机"><a class="markdownIt-Anchor" href="#一-安装本地虚拟机"></a> 一、安装本地虚拟机</h1><p>在您个人电脑的Windows系统中安装VMWare软件，然后在VMWare中安装CentOS7操作系统。对初学者来说，折腾一下本地虚拟机是有必要的。对职业的程序员来说，基本上不用本地虚拟机。</p><h2 id="1-优点"><a class="markdownIt-Anchor" href="#1-优点"></a> 1、优点</h2><p>1）可以让您熟悉Linux系统的安装和配置方面的知识。</p><p>2）让您对Linux的启动、关闭，操作界面等有直观的了解。</p><p>3）完全属于您自己的Linux系统，爱怎么折腾就怎么折腾。</p><p>4）备份和恢复很简单，时间短。</p><h2 id="2-缺点"><a class="markdownIt-Anchor" href="#2-缺点"></a> 2、缺点</h2><p>麻烦很多，不稳定，有些故障找不到原因。如果您的本地虚拟机不幸难产或夭折，也不用花太多时间和精力去抢救。</p><h1 id="二-购买云服务器"><a class="markdownIt-Anchor" href="#二-购买云服务器"></a> 二、购买云服务器</h1><p>云服务器本质上也是虚拟机，但是采用的虚拟化技术和本地虚拟机完全不同。本地虚拟机仅用于学习，云平台虚拟机是企业级的服务器，目前，互联网上的服务器有80%以上是采用云服务器。</p><p>国内主要的云服务器提供商有腾讯、阿里和华为，他们提供的产品没什么差别，谁家有优惠就用谁的。目前，云服务器的价格在100元/年之内，学生还有更多优惠。</p><p>和本地虚拟机相比，云服务器稳定可靠，但是您无法体验Linux的安装、配置、启动、关闭、操作界面等。</p><p>如果您打算深入的学习C/C++语言，购买云服务器是非常有必要的，它的意义远远超过购买任何书籍。</p><h1 id="三-使用我们的服务器"><a class="markdownIt-Anchor" href="#三-使用我们的服务器"></a> 三、使用我们的服务器</h1><p>为了方便大家学习，我们购买了云服务器，在云服务器上可以给大家分配操作系统用户，具体请前往C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）了解。</p><p>在我们的服务器上，您可以学习Linux系统的基本知识和C/C++语言，但是您只有普通用户权限，没有系统管理员权限。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统简介</title>
      <link href="/post/cf0ea7a1.html"/>
      <url>/post/cf0ea7a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-linux-简介"><a class="markdownIt-Anchor" href="#一-linux-简介"></a> 一、Linux 简介</h1><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix以网络为核心的设计思想，是一个稳定高性能的多用户网络操作系统。</p><h1 id="二-linux-的发行版"><a class="markdownIt-Anchor" href="#二-linux-的发行版"></a> 二、Linux 的发行版</h1><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p><p><img src="https://img-blog.csdnimg.cn/20200309100643901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>目前市面上较知名的发行版有：RedHat、CentOS、Debian、Fedora、SuSE、Ubuntu、OpenSUSE、Arch Linux、SolusOS 等。</p><p><img src="https://img-blog.csdnimg.cn/20200309100717525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-linux-应用领域"><a class="markdownIt-Anchor" href="#三-linux-应用领域"></a> 三、Linux 应用领域</h1><p>1）根据前程无忧官网发布的招聘职位的数据统计，Linux与Windows开发岗的职位比例约为3:1。<br /><img src="https://img-blog.csdnimg.cn/20200324132630771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200324132651700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />2）今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了主导地位。</p><p>3）目前 Linux 在家庭的应用很少，但在企业和政府中很受欢迎。</p><p>4）巴西联邦政府由于支持 Linux 而世界闻名。</p><p>5）有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</p><p>6）印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</p><p>7）中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</p><p>8）在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</p><p>9）葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalhes 笔记本电脑和 e-escola 政府软件。</p><p>10）法国和德国同样开始逐步采用 Linux。</p><p>11）微软的windows系统在个人电脑市场占统治地位，并不是因为windows有多好，而是生态圈已成熟，比windows更好的操作也没有生存空间。但是，智能手机是近十五年才出现，占统治地位的是苹果的IOS和谷歌的Android，它们的操作系统都是Linux（UNIX）。微软也推出过手机操作系统，但已经被人们遗忘。</p><h1 id="四-linux-vs-windows"><a class="markdownIt-Anchor" href="#四-linux-vs-windows"></a> 四、Linux vs Windows</h1><h2 id="1-免费与收费"><a class="markdownIt-Anchor" href="#1-免费与收费"></a> 1、 免费与收费</h2><p>Windows需要付费购买；</p><p>Linux 免费或少许费用。</p><h2 id="2-软件与支持"><a class="markdownIt-Anchor" href="#2-软件与支持"></a> 2、软件与支持</h2><p>Windows平台：数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务；</p><p>Linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；由全球所有的Linux开发者和自由软件社区提供支持。</p><h2 id="3-安全性"><a class="markdownIt-Anchor" href="#3-安全性"></a> 3、安全性</h2><p>Windows 平台：三天两头打补丁安装系统安全更新，还是会中病毒木马；</p><p>Linux 平台：要说 Linux 没有安全问题，那当然是不可能的，这一点仁者见仁智者见智，相对来说肯定比 Windows平台要更加安全，使用 Linux 您也不用装某杀毒、某毒霸。</p><h2 id="4-使用习惯"><a class="markdownIt-Anchor" href="#4-使用习惯"></a> 4、使用习惯</h2><p>Windows：普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易，入门简单；</p><p>Linux：兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导（这正是我们要做的事情），一旦熟练之后效率极高。</p><h2 id="5-可定制性"><a class="markdownIt-Anchor" href="#5-可定制性"></a> 5、可定制性</h2><p>Windows：这些年之前算是全封闭的，系统可定制性很差；</p><p>Linux：您想怎么做就怎么做，Windows 能做到得它都能，Windows 做不到的，它也能。</p><h2 id="6-应用范畴"><a class="markdownIt-Anchor" href="#6-应用范畴"></a> 6、应用范畴</h2><p>或许您之前不知道 Linux ，要知道，您之前在 Windows 使用百度、谷歌，上淘宝，聊 QQ 时，支撑这些软件和服务的，是后台成千上万的 Linux服务器主机，它们时时刻刻都在忙碌地进行着数据处理和运算，可以说世界上大部分软件和服务都是运行在Linux 之上的。</p><h2 id="7-linux的优点"><a class="markdownIt-Anchor" href="#7-linux的优点"></a> 7、Linux的优点</h2><p>1）极其稳定</p><p>2）性能卓越</p><p>3）安全性和漏洞的快速修补</p><p>4）多用户</p><p>5）用户和用户组的规划</p><p>6）相对较少的系统资源占用</p><p>7）可定制裁剪，移植到嵌入式平台（如安卓设备）</p><p>8）可选择的多种图形用户界面（如 GNOME，KDE）</p><h2 id="8-windows的优点"><a class="markdownIt-Anchor" href="#8-windows的优点"></a> 8、Windows的优点</h2><p>1）微软公司强大的支持</p><p>2）足够的游戏娱乐支持度</p><p>3）足够的专业软件支持度</p><h1 id="五-文章版权"><a class="markdownIt-Anchor" href="#五-文章版权"></a> 五、文章版权</h1><p>本文引用了菜鸟教程和CSDN博客的文章内容，原文地址如下。<br />菜鸟教程：<a href="https://www.runoob.com/linux/linux-intro.html">https://www.runoob.com/linux/linux-intro.html</a><br />CSDN博客：<a href="https://blog.csdn.net/qq_40530943/article/details/82349167">https://blog.csdn.net/qq_40530943/article/details/82349167</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux静态库与动态库</title>
      <link href="/post/6d3dd625.html"/>
      <url>/post/6d3dd625.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码的组织"><a class="markdownIt-Anchor" href="#一-源代码的组织"></a> 一、源代码的组织</h1><p>我们通常把公用的自定义函数和类从主程序中分离出来，函数和类的声明在头文件中，定义在程序文件中，主程序中要包含头文件，编译时要和程序文件一起编译。</p><p><strong>示例（public.h）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：public.h，公共功能函数声明的头文件，用于测试静态和动态链接</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUBLIC_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;   <span class="comment">// 自定义函数的声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>示例（public.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：public.cpp，公共功能函数定义的程序文件，用于测试静态和动态链接</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span>  <span class="comment">// 包含自定义函数声明的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span>   <span class="comment">// 自定义函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br><span class="line">  <span class="comment">//printf(&quot;生活美好如鲜花，不懂享受是傻瓜；\n&quot;);</span></span><br><span class="line">  <span class="comment">//printf(&quot;傻呀傻呀傻呀傻，比不上小鸟和乌鸦。\n&quot;);</span></span><br><span class="line">  <span class="comment">//printf(&quot;芳草地啊美如画，谁要不去是傻瓜；\n&quot;);</span></span><br><span class="line">  <span class="comment">//printf(&quot;我是一只傻傻鸟，独在枯枝丫上趴。\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例（book265.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book265.cpp，此程序用于测试静态和动态链接</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span>  <span class="comment">// 把public.h头文件包含进来</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译指令</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/202003060949331.png" alt="在这里插入图片描述" /></p><p>公用函数库的程序文件public.cpp程序文件是源代码，对任何程序员是可见的，没有安全性可言，但是，在实际开发中，出于技术保密或其它方面考虑，开发者并不希望提供公用函数库的源代码。</p><p>C/C++提供了一个可以保证代码安全性的方法，把公共的程序文件编译成库文件，库文件时一种可执行代码的二进制形式，可以与其它的源程序一起编译，也可以被操作系统载入内存执行。</p><p>库文件分为静态库与动态库。</p><h1 id="二-静态库"><a class="markdownIt-Anchor" href="#二-静态库"></a> 二、静态库</h1><p>静态库在编译的时候，主程序文件与静态库一起编译，把主程序与主程序中用到的库函数一起整合进了目标文件。这样做优点是在编译后的可执行程序可以独立运行，因为所使用的函数都已经被编译进去了。缺点是，如果所使用的静态库发生更新改变，我们的程序必须重新编译。</p><p>静态库文件名的命名方式是“libxxx.a”,库名前加”lib”，后缀用”.a”，“xxx”为静态库名。</p><p>把程序文件public.cpp编译成静态库的指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o libpublic.a <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p>使用静态库的方法一，直接把调用者源代码和静态库文件名一起编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp libpublic.a</span><br></pre></td></tr></table></figure><p>使用静态库的方法二，采用L参数指定静态库文件的目录，-l参数指定静态库名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp -L/home/wucz/demo -lpublic</span><br></pre></td></tr></table></figure><p>执行程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book265</span><br></pre></td></tr></table></figure><p>运行效果。</p><p><img src="https://img-blog.csdnimg.cn/20200306095203413.png" alt="在这里插入图片描述" /></p><p>注意：1）如果要指定多个静态库文件的目录，用法是“-L/目录1 -L目录2 -L目录3”；2）链接库的文件名是libpublic.a，但链接库名是”public”，不是“libpublic.a”；3）如果要指定多个静态库，用法是“-l库名1 -l库名2 -l库名3”。</p><h1 id="三-动态库"><a class="markdownIt-Anchor" href="#三-动态库"></a> 三、动态库</h1><p>动态库在编译时并不会被连接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要指定动态库的目录。</p><p>动态库的命名方式与静态库类似，前缀相同，为“lib”，后缀变为“.so” “xxx”为动态库名。</p><p>把程序文件public.cpp编译成动态库的指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared -o libpublic.so <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p>使用动态库的方法与使用静态库的方法相同。</p><p>如果在动态库文件和静态库文件同时存在，优先使用动态库编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp -L/home/wucz/demo -lpublic</span><br></pre></td></tr></table></figure><p>执行程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book265</span><br></pre></td></tr></table></figure><p>执行程序book265时，出现以下提示。</p><p><img src="https://img-blog.csdnimg.cn/20200306095527876.png" alt="在这里插入图片描述" /></p><p>这是因为采用了动态链接库的可执行程序在运行时需要指定动态库文件的目录，Linux系统中采用LD_LIBRARY_PATH环境变量指定动态库文件的目录。</p><p>采用以下命令设置LD_LIBRARY_PATH环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=/home/wucz/demo:.</span><br></pre></td></tr></table></figure><p>注意：1）如果要指定多个动态库文件的目录，用法是“export LD_LIBRARY_PATH=目录1:目录2:目录3:.”，目录之间用半角的冒号分隔，最后的圆点指当前目录。</p><p>接下来修改动态库中func函数的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生活美好如鲜花，不懂享受是傻瓜；\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;傻呀傻呀傻呀傻，比不上小鸟和乌鸦。\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;芳草地啊美如画，谁要不去是傻瓜；\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是一只傻傻鸟，独在枯枝丫上趴。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>重新编译动态库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared -o libpublic.so <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p>无需重新编译book265，直接执行程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book265</span><br></pre></td></tr></table></figure><p>执行效果。</p><p><img src="https://img-blog.csdnimg.cn/20200306095850185.png" alt="在这里插入图片描述" /><br />动态库在编译的时候只做语法检查，并没有被编译进目标代码，当程序执行到动态库中的函数时才调用该函数库里的代码。动态函数库并没有整合进程序，所以程序的运行环境必须提供动态库路径。优点是，如果所使用的动态库发生更新改变，程序不需要重新编译，所以动态库升级比较方便。</p><h1 id="四-静态库与动态库的优缺点"><a class="markdownIt-Anchor" href="#四-静态库与动态库的优缺点"></a> 四、静态库与动态库的优缺点</h1><h2 id="1-优点"><a class="markdownIt-Anchor" href="#1-优点"></a> 1、优点</h2><p>静态链接相当于复制一份库文件到可执行程序中，不需要像动态库那样有动态加载和识别函数地址的开销，也就是说采用静态链接编译的可执行程序运行更快。</p><h2 id="2-缺点"><a class="markdownIt-Anchor" href="#2-缺点"></a> 2、缺点</h2><p>1）静态链接生成的可执行程序比动态链接生成的大很多，运行时占用的内存也更多。</p><p>2）库文件的更新不会反映到可执行程序中，可执行程序需要重新编译。</p><h1 id="五-动态库的优缺点"><a class="markdownIt-Anchor" href="#五-动态库的优缺点"></a> 五、动态库的优缺点</h1><h2 id="1-优点-2"><a class="markdownIt-Anchor" href="#1-优点-2"></a> 1、优点</h2><p>1）相对于静态库，动态库在时候更新（修复bug，增加新的功能）不需要重新编译。</p><p>2）全部的可执行程序共享动态库的代码，运行时占用的内存空间更少。</p><h2 id="2-缺点-2"><a class="markdownIt-Anchor" href="#2-缺点-2"></a> 2、缺点</h2><p>1）使可执行程序在不同平台上移植变得更复杂，因为它需要为每每个不同的平台提供相应平台的共享库。</p><p>2）增加可执行程序运行时的时间和空间开销，因为应用程序需要在运行过程中查找依赖的库函数，并加载到内存中。</p><h1 id="六-编译的优先级"><a class="markdownIt-Anchor" href="#六-编译的优先级"></a> 六、编译的优先级</h1><p>静态库与动态库各有优缺点，该怎么选择，要看应用的场景。</p><p>所谓有得必有失，动态库在程序运行时被链接，故程序的运行速度和链接静态库的版本相比必然会打折扣。然而瑕不掩瑜，动态库的不足相对于它带来的好处在现今硬件下简直是微不足道的，所以链接程序在链接时一般是优先链接动态库的，除非用-static参数指定链接静态库。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux调用可执行程序</title>
      <link href="/post/5a838d54.html"/>
      <url>/post/5a838d54.html</url>
      
        <content type="html"><![CDATA[<p>在C/C<ins>程序中，经常需要调用其它的程序来先成某项任务，例如其它的C/C</ins>程序、操作系统命令或Shell脚本，C/C++提供了exec函数族和system函数来实现这个功能。</p><h1 id="一-exec函数族"><a class="markdownIt-Anchor" href="#一-exec函数族"></a> 一、exec函数族</h1><p>exec函数族提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新的进程替换了。还有，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。</p><p>exec函数族的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,..., <span class="type">char</span> * <span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>path：要执行的程序路径。可以是绝对路径或者是相对路径。在execv、execl和execle这三个函数中，使用带路径名的文件名作为参数。</p><p>file：要执行的程序名称。如果该参数中包含“/”字符，则视为路径名直接执行；否则视为单独的文件名，系统将根据PATH环境变量指定的路径顺序搜索指定的文件。</p><p>argv：命令行参数的数组。</p><p>envp：带有该参数的exec函数可以在调用时指定一个环境变量数组。其他不带该参数的exec函数则使用调用者进程的环境变量。</p><p>arg：程序的第0个参数，即程序名自身。相当于argv[0]。</p><p>…：命令行参数列表。调用相应程序时有多少命令行参数，就需要有多少个输入参数项。注意：在使用此类函数时，在所有命令行参数的最后应该增加一个空的参数项(NULL)，表明命令行参数结束。</p><p>如果执行失败则直接返回-1，失败原因存于errno 中。</p><p>如果执行成功则函数不会返回，这句话可能难以理解，当在主程序中成功调用execl后，被调用的程序将取代调用者程序，也就是说，execl函数之后的代码都不会被执行。</p><p>在实际开发中，最常用的是execl函数，其它的极少使用，我就不介绍了，如果大家认为execl满足不了实际开发的需求，再去研究其它几个函数。</p><p><strong>示例（book266.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book266.cpp，此程序用于演示用execl函数执行程序。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> iret=<span class="built_in">execl</span>(<span class="string">&quot;/bin/lss&quot;</span>,<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/usr/include/stdio.h&quot;</span>,<span class="number">0</span>);   <span class="comment">// /bin/lss不存在，执行不能成功。</span></span><br><span class="line">  <span class="comment">// int iret=execl(&quot;/bin/ls&quot;,&quot;/bin/ls&quot;,&quot;-l&quot;,&quot;/usr/include/stdio.h&quot;,0); // 可以调用成功的代码。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>,iret);</span><br><span class="line">  <span class="keyword">if</span> (iret==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先测试执行失败的情况，启用以下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iret=<span class="built_in">execl</span>(<span class="string">&quot;/bin/lss&quot;</span>,<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/usr/include/stdio.h&quot;</span>,<span class="number">0</span>);   <span class="comment">// /bin/lss不存在，执行不能成功。</span></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306093252273.png" alt="在这里插入图片描述" /></p><p>再测试执行成功的情况，启用以下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iret=<span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/usr/include/stdio.h&quot;</span>,<span class="number">0</span>); <span class="comment">// 可以调用成功的代码。</span></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306093322697.png" alt="在这里插入图片描述" /></p><p>从book266执行的结果可以看出，主程序中成功调用execl后，execl函数之后的代码都不会被执行。</p><h1 id="二-system函数"><a class="markdownIt-Anchor" href="#二-system函数"></a> 二、system函数</h1><p>system函数提供了另一种简单的执行程序的方法，把需要执行的命令用一个参数传给system函数。</p><p>system函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * string)</span></span>;</span><br></pre></td></tr></table></figure><p>system会调用fork产生子进程，由子进程来调用/bin/sh -c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。在调用system期间SIGCHLD信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。</p><p>如果fork失败 返回-1，出现错误。</p><p>如果execl失败，表示不能执行shell，返回值相当于shell执行了exit（127）。</p><p>如果执行成功则返回子shell的终止状态。</p><p>如果system在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针（NULL），仅当命令处理程序可用时，返回非零值。如果system调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为system调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。</p><p><strong>示例（book269.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book269.cpp，此程序用于演示用system函数执行程序。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> iret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用不成功的代码。</span></span><br><span class="line">  iret=<span class="built_in">system</span>(<span class="string">&quot;/bin/lss -l /usr/include/stdio.h&quot;</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>,iret);</span><br><span class="line">  <span class="keyword">if</span> (iret==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以调用成功的代码。</span></span><br><span class="line">  iret=<span class="built_in">system</span>(<span class="string">&quot;/bin/ls -l /usr/include/stdio.h&quot;</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>,iret);</span><br><span class="line">  <span class="keyword">if</span> (iret==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306093517519.png" alt="在这里插入图片描述" /></p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>============<br />C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux线程同步</title>
      <link href="/post/b7bd7fa2.html"/>
      <url>/post/b7bd7fa2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-线程同步的概念"><a class="markdownIt-Anchor" href="#一-线程同步的概念"></a> 一、线程同步的概念</h1><p>线程同步？怎么同步？一起运行？一起停止？我当年听说线程同步这个词的时候，也是一头雾水。</p><p>在人们的日常生活中的锁大概有两种：一种是不允许访问；另一种是资源忙，同一时间只允许一个使用者占用，其它使用者必须要等待。</p><p>1）不允许访问的锁容易理解，就像每家每户的门锁，不允许外人进入。</p><p>2）第二种锁，例如火车上的厕所，它是公共的，空闲的时候任何人可以进入，人进去以后就会把它锁起来，其它的人如果要上厕所，必须等待解锁，即里面的人出来。还有红绿灯，红灯是加锁，绿灯是解锁。</p><p>对多线程来说，资源是共享的，基本上不存在不允许访问的情况，但是，共享的资源在某一时间点只能有一个线程占用，所以需要给资源加锁。</p><p>不知道是什么人采用了线程同步这个词，如果让我的命名，我会定义为线程锁，锁线程吗？不是，是锁共享资源，线程给共享资源加的锁。</p><p>线程的锁的种类有互斥锁、读写锁、条件变量、自旋锁、信号灯。</p><p>在本章节中，只介绍互斥锁，其它的锁应用场景复杂，开发难度很大，不合适初学者。</p><h1 id="二-互斥锁"><a class="markdownIt-Anchor" href="#二-互斥锁"></a> 二、互斥锁</h1><p>互斥锁机制是同一时刻只允许一个线程占有共享的资源。</p><h2 id="1-初始化锁"><a class="markdownIt-Anchor" href="#1-初始化锁"></a> 1、初始化锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex,<span class="type">const</span> <span class="type">pthread_mutex_attr_t</span> *mutexattr)</span></span>;</span><br></pre></td></tr></table></figure><p>其中参数 mutexattr 用于指定锁的属性（见下），如果为NULL则使用缺省属性。</p><p>互斥锁的属性在创建锁的时候指定，当资源被某线程锁住的时候，其它的线程在试图加锁时表现将不同。当前有四个值可供选择：</p><p>1）PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。</p><p>2）PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。</p><p>3）PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。</p><p>4）PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，等待解锁后重新竞争。</p><h2 id="2-阻塞加锁"><a class="markdownIt-Anchor" href="#2-阻塞加锁"></a> 2、阻塞加锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>如果是锁是空闲状态，本线程将获得这个锁；如果锁已经被占据，本线程将排队等待，直到成功的获取锁。</p><h2 id="3-非阻塞加锁"><a class="markdownIt-Anchor" href="#3-非阻塞加锁"></a> 3、非阻塞加锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">( <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数语义与 pthread_mutex_lock() 类似，不同的是在锁已经被占据时立即返回<br />EBUSY，不是挂起等待。</p><h2 id="4-解锁"><a class="markdownIt-Anchor" href="#4-解锁"></a> 4、解锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>线程把自己持有的锁释放。</p><h2 id="5-销毁锁此时锁必需unlock状态否则返回ebusy"><a class="markdownIt-Anchor" href="#5-销毁锁此时锁必需unlock状态否则返回ebusy"></a> 5、销毁锁（此时锁必需unlock状态，否则返回EBUSY）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>销毁锁之前，锁必需是空闲状态（unlock）。</p><h1 id="三-示例程序"><a class="markdownIt-Anchor" href="#三-示例程序"></a> 三、示例程序</h1><p>多线程可以共享资源（变量和对象），对编程带来了方便，但是某些对象虽然可以共享，但在同一个时间只能由一个线程使用，多个线程同时使用会产生冲突，例如socket连接，数据库连接池。</p><p>我们把前几章节的socket客户端程序book247.cpp修改为多线程。</p><p><strong>示例（book263.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book263.cpp，此程序用于演示多线程的互斥锁</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xx pthread_mutex_t mutex; // 申明一个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pth_main</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> pno=(<span class="type">long</span>)arg;   <span class="comment">// 线程编号</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">3</span>;ii++)    <span class="comment">// 与服务端进行3次交互。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//xx pthread_mutex_lock(&amp;mutex);  // 加锁</span></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;线程%d：这是第%d个超级女生，编号%03d。&quot;</span>,pno,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程%d接收：%s\n&quot;</span>,pno,strbuffer);</span><br><span class="line">    <span class="comment">//xx pthread_mutex_unlock(&amp;mutex);  // 释放锁</span></span><br><span class="line">    <span class="comment">// usleep(100);   // usleep(100)，否则其它的线程无法获得锁。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;172.16.0.15&quot;</span>,<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;172.16.0.15\&quot;,5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//xx pthread_mutex_init(&amp;mutex,0); // 创建锁</span></span><br><span class="line"></span><br><span class="line">  <span class="type">pthread_t</span> pthid1,pthid2;</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pthid1,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)<span class="number">1</span>);   <span class="comment">// 创建第一个线程</span></span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pthid2,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)<span class="number">2</span>);   <span class="comment">// 创建第二个线程</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_join</span>(pthid1,<span class="literal">NULL</span>);    <span class="comment">// 等待线程1退出。</span></span><br><span class="line">  <span class="built_in">pthread_join</span>(pthid2,<span class="literal">NULL</span>);    <span class="comment">// 等待线程2退出。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//xx pthread_mutex_lock(&amp;mutex);   // 销毁锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book263.cpp程序中，客户端成功连上服务器后，创建两个线程，同时与服务端进行通信，发送3个请求报文并接收服务端的回应。</p><p>book263.cpp暂时不启用锁，先试试效果。</p><p>启动服务端程序book261，然后再启动book263。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306091730718.png" alt="在这里插入图片描述" /></p><p>大家仔细研究一下book263运行的结果，可以发现客户端的两个线程的报文收发出现了混乱。</p><p>把book263.cpp的线程锁代码启用，编译运行。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306091744817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />非常棒，这正在我们想要的结果。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程</title>
      <link href="/post/293980e9.html"/>
      <url>/post/293980e9.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-线程的概念"><a class="markdownIt-Anchor" href="#一-线程的概念"></a> 一、线程的概念</h1><p>和多进程相比，多线程是一种比较节省资源的多任务操作方式。启动一个新的进程必须分配给它独立的地址空间，每个进程都有自己的堆栈段和数据段，系统开销比较高，进行数据的传递只能通过进行间通信的方式进行。在同一个进程中，可以运行多个线程，运行于同一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享全局变量和对象，启动一个线程所消耗的资源比启动一个进程所消耗的资源要少。</p><h1 id="二-线程的使用"><a class="markdownIt-Anchor" href="#二-线程的使用"></a> 二、线程的使用</h1><h2 id="1-创建线程"><a class="markdownIt-Anchor" href="#1-创建线程"></a> 1、创建线程</h2><p>在Linux下，采用pthread_create函数来创建一个新的线程，函数声明：</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数thread为为指向线程标识符的地址。</p><p>参数attr用于设置线程属性，一般为空，表示使用默认属性。</p><p>参数start_routine是线程运行函数的地址，填函数名就可以了。</p><p>参数arg是线程运行函数的参数。新创建的线程从start_routine函数的地址开始运行，该函数只有一个无类型指针参数arg。若要想向start_routine传递多个参数，可以将多个参数放在一个结构体中，然后把结构体的地址作为arg参数传入，<strong>但是要非常慎重，程序员一般不会这么做。</strong></p><p>在编译时注意加上-lpthread参数，以调用静态链接库。因为pthread并非Linux系统的默认库。</p><h2 id="2-线程的终止"><a class="markdownIt-Anchor" href="#2-线程的终止"></a> 2、线程的终止</h2><p>如果进程中的任一线程调用了exit，则整个进程会终止，所以，在线程的start_routine函数中，不能采用exit。</p><p>线程的终止有三种方式：</p><p>1）线程的start_routine函数代码结束，自然消亡。</p><p>2）线程的start_routine函数调用pthread_exit结束。</p><p>3）被主进程或其它线程中止。</p><p>pthread_exit函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><p>参数retval填空，即0。</p><h2 id="3-多线程的socket服务端"><a class="markdownIt-Anchor" href="#3-多线程的socket服务端"></a> 3、多线程的socket服务端</h2><p>我们把TCP通信的服务端（book250.cpp）程序改一下，由多进程改为多线程。</p><p><strong>示例（book261.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book261.cpp，此程序用于演示多线程的socket通信服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_listenfd;   <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="type">int</span> m_clientfd;   <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">int</span> port)</span></span>;  <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;  <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// void CloseClient();    // 关闭客户端的socket，多线程服务端不需要这个函数。</span></span><br><span class="line">  <span class="comment">// void CloseListen();    // 关闭用于监听的socket，多线程服务端不需要这个函数。</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT和SIGTERM的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;程序退出，信号值=%d\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  TcpServer.~<span class="built_in">CTcpServer</span>();  <span class="comment">// 手动调用析构函数，释放资源</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pth_main</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 忽略全部的信号</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">50</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,EXIT); <span class="built_in">signal</span>(SIGTERM,EXIT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pthid;   <span class="comment">// 创建一线程，与新连接上来的客户端通信</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;pthid,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)((<span class="type">long</span>)TcpServer.m_clientfd))!=<span class="number">0</span>)</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;创建线程失败，程序退出。n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端通信的线程已创建。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">  m_listenfd=m_clientfd=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_listenfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  m_listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (m_clientfd=<span class="built_in">accept</span>(m_listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pth_main</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> clientfd=(<span class="type">long</span>) arg; <span class="comment">// arg参数为新客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd,strbuffer,<span class="built_in">sizeof</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd,strbuffer,<span class="built_in">strlen</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(clientfd);  <span class="comment">// 关闭客户端的连接。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意几个问题：</p><p>1）线程主函数的函数体中，不能使用<code>return;</code>语句，如果想退出线程，可以用<code>pthread_exit(0);</code>返回。</p><p>2）线程可以共享全局变量，当然也可以共享TcpServer的m_clientfd成员变量，但是，创建线程的时候，为什么要把客户端的socket用参数传给线程主函数，而不是直接获取TcpServer.m_clientfd的值，因为主进程调用pthread_create创建线程后，立即返回循环重新Accept，创建线程需要时间，如果在这段时间内有新的客户端连接上来，TcpServer.m_clientfd的值会发生改变。</p><p>3）TcpServer.m_clientfd的强制转换，在创建线程的时候，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;pthid,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)((<span class="type">long</span>)TcpServer.m_clientfd))!=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>线程中的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> clientfd=(<span class="type">long</span>) arg; <span class="comment">// arg参数为新客户端的socket。</span></span><br></pre></td></tr></table></figure><p>这种数据类型的转换方法可能会让初学者不理解，在学习指针的时候说过，指针是用来存放变量的地址，不能把整数赋给指针，那现在这是怎么回事？这么说吧，C语言很灵活，数据类型可以强制转换，怎么转过去就怎么转回来。举个例子：水桶是用来装水的，特殊情况下用水桶来装板砖其实也可以，但是，板砖放入水桶的方法和从水桶中取出板砖的方法与水不同，怎么放进去就怎么取出来。</p><p>4）book261.cpp程序有一个漏洞，没有保存客户端的socket，主程序退出时，没有关闭客户端的socket，资源没有释放，这么说您可能难以理解，没有关系，等您真的需要编写多线程的socket服务端程序的时候就明白了。</p><h1 id="三-线程资源的回收"><a class="markdownIt-Anchor" href="#三-线程资源的回收"></a> 三、线程资源的回收</h1><p>线程有joinable和unjoinable两种状态，如果线程是joinable状态，当线程主函数终止时（自己退出或调用pthread_exit退出）不会释放线程所占用内存资源和其它资源，这种线程被称为“僵尸线程”。创建线程时默认是非分离的，或者称为可连接的（joinable）。</p><p>避免僵尸线程就是如何正确的回收线程资源，有四种方法：</p><p>1）方法一：创建线程前，调用pthread_attr_setdetachstate将线程设为detached，这样线程退出时，系统自动回收线程资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr,PTHREAD_CREATE_DETACHED);  <span class="comment">// 设置线程的属性。</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;pthid,&amp;attr,pth_main,(<span class="type">void</span>*)((<span class="type">long</span>)TcpServer.m_clientfd);</span><br></pre></td></tr></table></figure><p>2）方法二：创建线程后，在创建线程的程序中调用pthread_detach将新创建的线程设置为detached状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(pthid);</span><br></pre></td></tr></table></figure><p>3）方法3：创建线程后，在创建线程的程序中调用pthread_join等待线程退出，一般不会采用这种方法，因为pthread_join会发生阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span>(pthid,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>4）方法4：在线程主函数中调用pthread_detach改变自己的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br></pre></td></tr></table></figure><h1 id="四-查看线程"><a class="markdownIt-Anchor" href="#四-查看线程"></a> 四、查看线程</h1><p>1）在top命令中，如果加上-H参数，top中的每一行显示的不是进程，而是一个线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H</span><br></pre></td></tr></table></figure><p>2）在ps命令中加-xH参数也可以显示线程，加grep可以过滤内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -xH</span><br><span class="line">ps -xH|grep book261</span><br></pre></td></tr></table></figure><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>Linux没有真正意义上的线程，它的实现是由进程来模拟，属于用户级线程。所以，在Linux系统下，进程与线程在性能和资源消耗方面没有本质的差别。</p><p><strong>对我们程序员来说，进程不能共享全局数据，线程可以共享全局数据，各位可以根据应用场景选择采用多进程或多线程。</strong></p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号量</title>
      <link href="/post/4ba52713.html"/>
      <url>/post/4ba52713.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-信号量的概念"><a class="markdownIt-Anchor" href="#一-信号量的概念"></a> 一、信号量的概念</h1><p>信号量（信号灯）本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读/写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</p><p>信号量是一个特殊的变量，只允许进程对它进行等待信号和发送信号操作。最简单的信号量是取值0和1的二元信号量，这是信号量最常见的形式。</p><p>通用信号量（可以取多个正整数值）和信号量集方面的知识比较复杂，应用场景也比较少。</p><p>本文只介绍二元信号量。</p><h1 id="二-相关函数"><a class="markdownIt-Anchor" href="#二-相关函数"></a> 二、相关函数</h1><p>Linux中提供了一组函数用于操作信号量，程序中需要包含以下头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="1-semget函数"><a class="markdownIt-Anchor" href="#1-semget函数"></a> 1、semget函数</h2><p>semget函数用来获取或创建信号量，它的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><p>1）参数key是信号量的键值，typedef unsigned int key_t，是信号量在系统中的编号，不同信号量的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。</p><p>2）参数nsems是创建信号量集中信号量的个数，该参数只在创建信号量集时有效，这里固定填1。</p><p>3）参数sem_flags是一组标志，如果希望信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。如果没有设置IPC_CREAT标志并且信号量不存在，就会返错误（errno的值为2，No such file or directory）。</p><p>4）如果semget函数成功，返回信号量集的标识；失败返回-1，错误原因存于error中。</p><p>示例：</p><p>1）获取键值为0x5000的信号量，如果该信号量不存在，就创建它，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> semid=<span class="built_in">semget</span>(<span class="number">0x5000</span>,<span class="number">1</span>,<span class="number">0640</span>|IPC_CREAT); </span><br></pre></td></tr></table></figure><p>2）获取键值为0x5000的信号量，如果该信号量不存在，返回-1，errno的值被设置为2，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> semid= <span class="built_in">semget</span>(<span class="number">0x5000</span>,<span class="number">1</span>,<span class="number">0640</span>)；</span><br></pre></td></tr></table></figure><h2 id="2-semctl函数"><a class="markdownIt-Anchor" href="#2-semctl函数"></a> 2、semctl函数</h2><p>该函数用来控制信号量（常用于设置信号量的初始值和销毁信号量），它的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>1）参数semid是由semget函数返回的信号量标识。</p><p>2）参数sem_num是信号量集数组上的下标，表示某一个信号量，填0。</p><p>3）参数cmd是对信号量操作的命令种类，常用的有以下两个：</p><p><strong>IPC_RMID</strong>：销毁信号量，不需要第四个参数；</p><p><strong>SETVAL</strong>：初始化信号量的值（信号量成功创建后，需要设置初始值），这个值由第四个参数决定。第四参数是一个自定义的共同体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于信号灯操作的共同体。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4）如果semctl函数调用失败返回-1；如果成功，返回值比较复杂，暂时不关心它。</p><p>示例：</p><p>1）销毁信号量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">semctl</span>(semid,<span class="number">0</span>,IPC_RMID);</span><br></pre></td></tr></table></figure><p>2）初始化信号量的值为1，信号量可用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">sem_union.val = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">semctl</span>(semid,<span class="number">0</span>,SETVAL,sem_union);</span><br></pre></td></tr></table></figure><h2 id="3-semop函数"><a class="markdownIt-Anchor" href="#3-semop函数"></a> 3、semop函数</h2><p>该函数有两个功能：1）等待信号量的值变为1，如果等待成功，立即把信号量的值置为0，这个过程也称之为等待锁；2）把信号量的值置为1，这个过程也称之为释放锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure><p>1）参数semid是由semget函数返回的信号量标识。</p><p>2）参数nsops是操作信号量的个数，即sops结构变量的个数，设置它的为1（只对一个信号量的操作）。</p><p>3）参数sops是一个结构体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">short</span> sem_num;   <span class="comment">// 信号量集的个数，单个信号量设置为0。</span></span><br><span class="line">  <span class="type">short</span> sem_op;    <span class="comment">// 信号量在本次操作中需要改变的数据：-1-等待操作；1-发送操作。</span></span><br><span class="line">  <span class="type">short</span> sem_flg;   <span class="comment">// 把此标志设置为SEM_UNDO，操作系统将跟踪这个信号量。</span></span><br><span class="line">                   <span class="comment">// 如果当前进程退出时没有释放信号量，操作系统将释放信号量，避免资源被死锁。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）等待信号量的值变为1，如果等待成功，立即把信号量的值置为0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>2）把信号量的值置为1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="三-示例程序"><a class="markdownIt-Anchor" href="#三-示例程序"></a> 三、示例程序</h1><p>为了便于理解，我把信号量的操作封装成CSEM类，称之为信号灯，类似互斥锁，包括初始化信号灯、等待信号灯、挂出信号灯和销毁信号灯。</p><h2 id="1-示例book259cpp"><a class="markdownIt-Anchor" href="#1-示例book259cpp"></a> 1、示例（book259.cpp）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book259.cpp，此程序用于演示信号量的使用方法。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSEM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">semun</span>  <span class="comment">// 用于信号灯操作的共同体。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span>  sem_id;  <span class="comment">// 信号灯描述符。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">key_t</span> key)</span></span>; <span class="comment">// 如果信号灯已存在，获取信号灯；如果信号灯不存在，则创建信号灯并初始化。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span>;          <span class="comment">// 等待信号灯挂出。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span></span>;          <span class="comment">// 挂出信号灯。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">destroy</span><span class="params">()</span></span>;       <span class="comment">// 销毁信号灯。</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   CSEM sem;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始信号灯。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">init</span>(<span class="number">0x5000</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.init failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.init ok\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">wait</span>()==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.wait failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.wait ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">50</span>);  <span class="comment">// 在sleep的过程中，运行其它的book259程序将等待锁。</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">post</span>()==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.post failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.post ok\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 销毁信号灯。</span></span><br><span class="line">   <span class="comment">// if (sem.destroy()==false) &#123; printf(&quot;sem.destroy failed.\n&quot;); return -1; &#125;</span></span><br><span class="line">   <span class="comment">// printf(&quot;sem.destroy ok\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::init</span><span class="params">(<span class="type">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取信号灯。</span></span><br><span class="line">  <span class="keyword">if</span> ( (sem_id=<span class="built_in">semget</span>(key,<span class="number">1</span>,<span class="number">0640</span>)) == <span class="number">-1</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">// 如果信号灯不存在，创建它。</span></span><br><span class="line">    <span class="keyword">if</span> (errno==<span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (sem_id=<span class="built_in">semget</span>(key,<span class="number">1</span>,<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;init 1 semget()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 信号灯创建成功后，还需要把它初始化成可用的状态。</span></span><br><span class="line">      <span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">      sem_union.val = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id,<span class="number">0</span>,SETVAL,sem_union) &lt;  <span class="number">0</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;init semctl()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="built_in">perror</span>(<span class="string">&quot;init 2 semget()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;destroy semctl()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">  sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">  sem_b.sem_op = <span class="number">-1</span>; </span><br><span class="line">  sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;wait semop()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::post</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">  sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">  sem_b.sem_op = <span class="number">1</span>;   </span><br><span class="line">  sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;post semop()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-测试方法"><a class="markdownIt-Anchor" href="#2-测试方法"></a> 2、测试方法</h2><p>第一步：运行book259程序，它会创建键值为5000的信号灯，并持有锁，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305180130425.png" alt="在这里插入图片描述" /></p><p>第二步：立即再运行一个book259程序，它会获取键值为5000的信号灯，并等待锁，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305180139481.png" alt="在这里插入图片描述" /></p><p>第三步，当第一次运行的book259程序sleep完50秒之后，释放锁，第二个运行book259的程序将获得锁；</p><p>第四步，可以启动更多的book259程序，它们将排队等待锁。</p><h1 id="四-其它的操作命令"><a class="markdownIt-Anchor" href="#四-其它的操作命令"></a> 四、其它的操作命令</h1><p>用ipcs -s 可以查看系统的信号量，内容有键值（key），信号量编号（semid），创建者（owner），权限（perms），信号量数（nsems）。</p><p><img src="https://img-blog.csdnimg.cn/2020030518094350.png" alt="在这里插入图片描述" /></p><p>用ipcrm -sem 信号量编号，可以手工删除信号量，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305180959334.png" alt="在这里插入图片描述" /></p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>============</p><p>课后作业，编写示例程序，利用信号灯给共享内存加锁。</p><p>注意一个问题，程序对共享内存的操作是很快的，很难测试出读/写共享冲突的情况，可以在程序员采用sleep语句，假设程序操作共享内存需要时间。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux共享内存</title>
      <link href="/post/fef582bb.html"/>
      <url>/post/fef582bb.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-共享内存的概念"><a class="markdownIt-Anchor" href="#一-共享内存的概念"></a> 一、共享内存的概念</h1><p>共享内存（Shared Memory）就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的读/写加锁，可以使用信号灯。</p><h1 id="二-相关函数"><a class="markdownIt-Anchor" href="#二-相关函数"></a> 二、相关函数</h1><p>Linux中提供了一组函数用于操作共享内存，程序中需要包含以下头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="1-shmget函数"><a class="markdownIt-Anchor" href="#1-shmget函数"></a> 1、shmget函数</h2><p>shmget函数用来获取或创建共享内存，它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数key是共享内存的键值，是一个整数，typedef unsigned int key_t，是共享内存在系统中的编号，不同共享内存的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。</p><p>参数size是待创建的共享内存的大小，以字节为单位。</p><p>参数shmflg是共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存。</p><h2 id="2-shmat函数"><a class="markdownIt-Anchor" href="#2-shmat函数"></a> 2、shmat函数</h2><p>把共享内存连接到当前进程的地址空间。它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数shm_id是由shmget函数返回的共享内存标识。</p><p>参数shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p>参数shm_flg是一组标志位，通常为0。</p><p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p><h2 id="3-shmdt函数"><a class="markdownIt-Anchor" href="#3-shmdt函数"></a> 3、shmdt函数</h2><p>该函数用于将共享内存从当前进程中分离，相当于shmat函数的反操作。它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>参数shmaddr是shmat函数返回的地址。</p><p>调用成功时返回0，失败时返回-1.</p><h2 id="4-shmctl函数"><a class="markdownIt-Anchor" href="#4-shmctl函数"></a> 4、shmctl函数</h2><p>删除共享内存，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>参数shm_id是shmget函数返回的共享内存标识符。</p><p>参数command填IPC_RMID。</p><p>参数buf填0。</p><p>解释一下，shmctl是控制共享内存的函数，其功能不只是删除共享内容，但其它的功能没什么用，所以不介绍了。</p><p><strong>注意，用root创建的共享内存，不管创建的权限是什么，普通用户无法删除。</strong></p><h1 id="三-示例程序"><a class="markdownIt-Anchor" href="#三-示例程序"></a> 三、示例程序</h1><p><strong>示例（book258.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book258.cpp，此程序用于演示共享内存的用法</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> shmid; <span class="comment">// 共享内存标识符</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建共享内存，键值为0x5005，共1024字节。</span></span><br><span class="line">  <span class="keyword">if</span> ( (shmid = <span class="built_in">shmget</span>((<span class="type">key_t</span>)<span class="number">0x5005</span>, <span class="number">1024</span>, <span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;shmat(0x5005) failed\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="type">char</span> *ptext=<span class="number">0</span>;   <span class="comment">// 用于指向共享内存的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将共享内存连接到当前进程的地址空间，由ptext指针指向它</span></span><br><span class="line">  ptext = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作本程序的ptext指针，就是操作共享内存</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;写入前：%s\n&quot;</span>,ptext);</span><br><span class="line">  <span class="built_in">sprintf</span>(ptext,<span class="string">&quot;本程序的进程号是：%d&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;写入后：%s\n&quot;</span>,ptext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">  <span class="built_in">shmdt</span>(ptext);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 删除共享内存</span></span><br><span class="line">  <span class="comment">// if (shmctl(shmid, IPC_RMID, 0) == -1)</span></span><br><span class="line">  <span class="comment">// &#123; printf(&quot;shmctl(0x5005) failed\n&quot;); return -1; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305173508356.png" alt="在这里插入图片描述" /></p><p>注意，程序第一次运行的时候，共享内存未创建，所以第一次运行程序的时候，共享内存中的内容为空。之后程序每次运行都能获取到上一次程序运行写入的内容。</p><h1 id="四-其它的操作命令"><a class="markdownIt-Anchor" href="#四-其它的操作命令"></a> 四、其它的操作命令</h1><p>用ipcs -m可以查看系统的共享内存，内容有键值（key），共享内存编号（shmid），创建者（owner），权限（perms），大小（bytes）。</p><p><img src="https://img-blog.csdnimg.cn/20200305173535830.png" alt="在这里插入图片描述" /></p><p>用ipcrm -m 共享内存编号，可以手工删除共享内存，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305173546999.png" alt="在这里插入图片描述" /></p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>============</p><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号</title>
      <link href="/post/99134621.html"/>
      <url>/post/99134621.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-如何让程序在后台运行"><a class="markdownIt-Anchor" href="#一-如何让程序在后台运行"></a> 一、如何让程序在后台运行</h1><p>在之前的章节中，如果要运行程序，在命令提示行下输入程序名后回车，程序被执行，然后等待程序运行完成，在程序运行的过程中，也可以用Ctrl+c中止它。</p><p>在实际开发中，我们需要让程序在后台运行，没有界面，没有用户输入数据，例如socket服务端程序book250。</p><p>如果想让程序在后台运行，有两种方法。</p><h2 id="1-加符号"><a class="markdownIt-Anchor" href="#1-加符号"></a> 1、加“&amp;”符号</h2><p>如果想让程序在后台运行，执行程序的时候，命令的最后面加“&amp;”符号。</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book250 &amp;</span><br></pre></td></tr></table></figure><p>程序就在后台运行了。</p><p><img src="https://img-blog.csdnimg.cn/20200305164356719.png" alt="在这里插入图片描述" /></p><p>在后台运行的程序，用Ctrl+c无法中断，并且就算终端退出了，程序仍在后台运行。</p><p>如果终端退出了，后台运行的程序将由系统托管。</p><p><img src="https://img-blog.csdnimg.cn/20200305164452174.png" alt="在这里插入图片描述" /></p><p>在第一张图中，book250的父进程是12178，第二张图中，book250的父进程是1。</p><p>为了不影响接下来的学习，用killall book250指令让book250程序退出。</p><p><img src="https://img-blog.csdnimg.cn/20200305164516214.png" alt="在这里插入图片描述" /></p><h2 id="2-采用fork"><a class="markdownIt-Anchor" href="#2-采用fork"></a> 2、采用fork</h2><p>另一种方法是采用fork，主程序执行fork，生成一个子进程，然后父进程退出，留下子进程继续运行，子进程将由系统托管。</p><p>在book250的main函数后增加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>重新编译后执行book250，运行效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305165858732.png" alt="在这里插入图片描述" /></p><p>上图中，20752是fork后的子进程，它的父进程号是1，是系统进程（亲爹没了，天地日月为父）。</p><h2 id="3-如何让中止后台运行中程序"><a class="markdownIt-Anchor" href="#3-如何让中止后台运行中程序"></a> 3、如何让中止后台运行中程序</h2><p>问题来了，程序在后台运行了，离开了终端控制，用Ctrl+c上也无法中止，那怎么让它停下来呢？暂时用一个笨方法，杀了它。</p><p>杀程序有两个方法：</p><p>1）killall 程序名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall book250</span><br></pre></td></tr></table></figure><p><strong>执行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305165933274.png" alt="在这里插入图片描述" /><br />2）先用“ps -ef|grep 程序名”找到程序的进程编号，然后用“kill 进程编号”。</p><p><strong>执行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305170052532.png" alt="在这里插入图片描述" /></p><h1 id="二-signal信号"><a class="markdownIt-Anchor" href="#二-signal信号"></a> 二、signal信号</h1><p>signal信号是Linux编程中非常重要的部分，接下来将详细介绍信号的基本概念、实现和使用，和与信号的几个系统调用（库函数）。</p><p>signal信号是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断，从它的命名可以看出，它的实质和使用很象中断。信号是进程控制的一部分。</p><h2 id="1-信号的基本概念"><a class="markdownIt-Anchor" href="#1-信号的基本概念"></a> 1、信号的基本概念</h2><p>软中断信号（signal，又简称为信号）用来通知进程发生了事件。进程之间可以通过调用kill库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。</p><p>注意，信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种：</p><p>1）第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。</p><p>2）第二种是设置中断的处理函数，收到信号后，由该函数来处理。</p><p>3）第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。</p><h2 id="2-信号的类型"><a class="markdownIt-Anchor" href="#2-信号的类型"></a> 2、信号的类型</h2><p>发出信号的原因很多，这里按发出信号的原因简单分类，以了解各种信号：</p><table><thead><tr><th>信号名</th><th>信号值</th><th>默认处 理动作</th><th>发出信号的原因</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>A</td><td>终端挂起或者控制进程终止</td></tr><tr><td><strong>SIGINT</strong></td><td><strong>2</strong></td><td><strong>A</strong></td><td><strong>键盘中断Ctrl+c</strong></td></tr><tr><td>SIGQUIT</td><td>3</td><td>C</td><td>键盘的退出键被按下</td></tr><tr><td>SIGILL</td><td>4</td><td>C</td><td>非法指令</td></tr><tr><td>SIGABRT</td><td>6</td><td>C</td><td>由abort(3)发出的退出指令</td></tr><tr><td>SIGFPE</td><td>8</td><td>C</td><td>浮点异常</td></tr><tr><td><strong>SIGKILL</strong></td><td><strong>9</strong></td><td><strong>AEF</strong></td><td><strong>采用kill -9 进程编号 强制杀死程序。</strong></td></tr><tr><td><strong>SIGSEGV</strong></td><td><strong>11</strong></td><td><strong>C</strong></td><td><strong>无效的内存引用</strong></td></tr><tr><td>SIGPIPE</td><td>13</td><td>A</td><td>管道破裂:写一个没有读端口的管道</td></tr><tr><td>SIGALRM</td><td>14</td><td>A</td><td>由alarm(2)发出的信号</td></tr><tr><td><strong>SIGTERM</strong></td><td><strong>15</strong></td><td><strong>A</strong></td><td><strong>采用“kill 进程编号”或“killall 程序名”通知程序。</strong></td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>A</td><td>用户自定义信号1</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>A</td><td>用户自定义信号2</td></tr><tr><td><strong>SIGCHLD</strong></td><td><strong>20,17,18</strong></td><td><strong>B</strong></td><td><strong>子进程结束信号</strong></td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td></td><td>进程继续（曾被停止的进程）</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>DEF</td><td>终止进程</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>D</td><td>控制终端（tty）上按下停止键</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>D</td><td>后台进程企图从控制终端读</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>D</td><td>后台进程企图从控制终端写</td></tr></tbody></table><p>处理动作一项中的字母含义如下</p><p>A 缺省的动作是终止进程。</p><p>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。</p><p>C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员<br />提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</p><p>D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去。</p><p>E 信号不能被捕获。</p><p>F 信号不能被忽略。</p><h2 id="3-signal库函数"><a class="markdownIt-Anchor" href="#3-signal库函数"></a> 3、signal库函数</h2><p>signal库函数可以设置程序对信号的处理方式。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><p>参数signum表示信号的编号。</p><p>参数handler表示信号的处理方式，有三种情况：</p><p>1）SIG_IGN：忽略参数signum所指的信号。</p><p>2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。</p><p>3）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。</p><p>程序员不关心signal的返回值。</p><h2 id="4-信号有什么用"><a class="markdownIt-Anchor" href="#4-信号有什么用"></a> 4、信号有什么用</h2><p>服务程序运行在后台，如果想让中止它，强行杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有释放资源，会影响系统的稳定，用Ctrl+c中止与杀程序是相同的效果。</p><p>如果能向后台程序发送一个信号，后台程序收到这个信号后，调用一个函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。</p><p>信号还可以用于网络服务程序抓包等，这是较复杂的应用场景，暂时不介绍。</p><h2 id="5-信号应用示例"><a class="markdownIt-Anchor" href="#5-信号应用示例"></a> 5、信号应用示例</h2><p>在实际开发中，在main函数开始的位置，程序员会先屏蔽掉全部的信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">100</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN);</span><br></pre></td></tr></table></figure><p>这么做的目的是不希望程序被干扰。然后，再设置程序员关心的信号的处理函数。</p><p>程序员关心的信号有三个：SIGINT、SIGTERM和SIGKILL。</p><p>程序在运行的进程中，如果按Ctrl+c，将向程序发出SIGINT信号，信号编号是2。</p><p>采用“kill 进程编号”或“killall 程序名”向程序发出的是SIGTERM信号，编号是15。</p><p>采用“kill -9 进程编号”向程序发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p><p>所以，程序员只要设置SIGINT和SIGTERM两个信号的处理函数就可以了，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p><p><strong>示例（book257.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book257.cpp，此程序用于演示用信号通知后台服务程序退出。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;收到了信号%d，程序退出。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里添加释放资源的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">// 程序退出。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">100</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN); <span class="comment">// 屏蔽全部的信号</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,EXIT);  <span class="built_in">signal</span>(SIGTERM,EXIT); <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">// 一个死循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305170352818.png" alt="在这里插入图片描述" /></p><p>不管是用Ctrl+c还是kill，程序都能体面的退出。</p><h1 id="三-发送信号"><a class="markdownIt-Anchor" href="#三-发送信号"></a> 三、发送信号</h1><p>Linux操作系统提供了kill命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>kill函数将参数sig指定的信号给参数pid 指定的进程。</p><p>参数pid 有几种情况：</p><p>1）pid&gt;0 将信号传给进程号为pid 的进程。</p><p>2）pid=0将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。</p><p>3）pid=-1将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。</p><p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。</p><p>返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。</p><p>EINVAL：指定的信号码无效（参数 sig 不合法）。</p><p>EPERM：权限不够无法传送信号给指定进程。</p><p>ESRCH：参数 pid 所指定的进程或进程组不存在。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>本章节的重点是介绍信号的应用场景，属于概念性的知识，代码其实很简单，只要各位理解了信号原理和应用就可以了。</p><p>但是，文章中提到的知识点，大家一定要用程序去测试它。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程间通信</title>
      <link href="/post/e0738fea.html"/>
      <url>/post/e0738fea.html</url>
      
        <content type="html"><![CDATA[<p>进程的数据空间是独立的，私有的，不能相互访问，但是在某些情况下进程之间需要通信来实现某功能或交换数据，包括：</p><p>1）数据传输：一个进程需要将它的数据发送给另一个进程。</p><p>2）共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p><p>3）通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如通知进程退出）。</p><p>4）进程控制：一个进程希望控制另一个进程的运行。</p><h1 id="一-进程通信"><a class="markdownIt-Anchor" href="#一-进程通信"></a> 一、进程通信</h1><p>进程通信的方式大概分为六种。</p><p>1）管道：包括无名管道（pipe）及命名管道（named pipe），无名管道可用于具有父进程和子进程之间的通信。命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p>2）消息队列（message）：进程可以向队列中添加消息，其它的进程则可以读取队列中的消息。</p><p>3）信号（signal）：信号用于通知其它进程有某种事件发生。</p><p>4）共享内存（shared memory）：多个进程可以访问同一块内存空间。</p><p>5）信号量（semaphore）：也叫信号灯，用于进程之间对共享资源进行加锁。</p><p>6）套接字（socket）：可用于不同计算机之间的进程间通信。</p><h1 id="二-应用经验"><a class="markdownIt-Anchor" href="#二-应用经验"></a> 二、应用经验</h1><p>1）管道和消息队列太过时了，实在没什么应用价值，了解概念就行。</p><p>2）socket可以用于不同系统之间的进程通信，完全可以代替只能在同一系统中进程之间通信的管道和消息队列。</p><p>3）信号的应用场景非常多，主要用于进程的控制，例如通知正在运行中的后台服务程序退出。</p><p>4）同一系统中，进程之间采用共享内存交换数据的效率是最高的，但是，共享内存没有加锁的机制，所以经常与信号灯结合一起来使用，在高性能的网络服务端程序中，可以用共享内存作为的数据缓存（cache）。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多进程的应用</title>
      <link href="/post/4e0c5a44.html"/>
      <url>/post/4e0c5a44.html</url>
      
        <content type="html"><![CDATA[<p>前面的章节介绍socket通信的时候，socket的服务端在同一时间只能和一个客户端通信，并不是服务端有多忙，而是因为单进程的程序在同一时间只能做一件事情，不可能一边等待客户端的新连接一边与其它的客户端进行通信。</p><h1 id="一-并发的服务端"><a class="markdownIt-Anchor" href="#一-并发的服务端"></a> 一、并发的服务端</h1><p>如果把socket服务端改为多进程，在每次accept到一个客户端的连接后，生成一个子进程，让子进程负责和这个客户端通信，父进程继续accept客户端的连接，socket的服务端在监听新客户端的同时，还可以与多个客户端进行通信。这就是并发，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200305155612655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="1-服务端"><a class="markdownIt-Anchor" href="#1-服务端"></a> 1、服务端</h2><p>把book248.cpp修改一下，改为多进程。</p><p><strong>示例（book250.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book250.cpp，此程序用于演示多进程的socket通信服务端。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_listenfd;   <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="type">int</span> m_clientfd;   <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">int</span> port)</span></span>;  <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;  <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;    <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;    <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) &#123; TcpServer.<span class="built_in">CloseClient</span>(); <span class="keyword">continue</span>; &#125;  <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">    TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端已连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">    <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">      <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">  m_listenfd=m_clientfd=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_listenfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  m_listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (m_clientfd=<span class="built_in">accept</span>(m_listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span>    <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_clientfd); m_clientfd=<span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span>    <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：</p><p>1）在CTcpServer中增加了两个成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;    <span class="comment">// 关闭客户端的socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;    <span class="comment">// 关闭用于监听的socket</span></span><br></pre></td></tr></table></figure><p>2）当有客户端连上来的时候，主进程执行fork，这时候会客户端的socket（m_clientfd）被复制了一份，对父进程来说，只负责监听客户端的连接，不需要与客户端通信，所以父进程关闭m_clientfd，注意，父进程关闭m_clientfd对子进程中的m_clientfd没有影响。</p><p>3）当有客户端连上来的时候，主进程执行fork，这时候服务端用于监听的socket（m_listenfd）也会被复制了一份，对子进程来说，只需要与客户端通信，不需要监听客户端的连接，所以子进程关闭监听的m_listenfd，同理，子进程关闭m_listenfd对父进程中的m_listenfd没有影响。</p><p>4）子进程执行完任务后，要调用retrun或exit(0)退出，如果没有调用return或exit(0)，子进程将又会回到while循环首部。</p><h2 id="2-客户端"><a class="markdownIt-Anchor" href="#2-客户端"></a> 2、客户端</h2><p>把book247.cpp修改一下，循环的次数改为50，每次与服务端完成报文交互后sleep一秒，方便观察程序运行的效果。</p><p><strong>示例（book249.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book249.cpp，此程序对book247.cpp略作修改，用于测试多进程的socket通信客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_sockfd;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpClient</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;172.16.0.15&quot;</span>,<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;172.16.0.15\&quot;,5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">50</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// sleep一秒，方便观察程序的运行。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  m_sockfd=<span class="number">0</span>;  <span class="comment">// 构造函数初始化m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::~<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_sockfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_sockfd);  <span class="comment">// 析构函数关闭m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpClient::ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">  <span class="keyword">if</span> ( (h=<span class="built_in">gethostbyname</span>(serverip))==<span class="number">0</span> ) </span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port); </span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(m_sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr))!=<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动服务端book250，然后启动多个book249，可以看到服务端可以同时与多个客户端进行通信，查看服务端的进行如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305160034649.png" alt="在这里插入图片描述" /><br />注意，服务端book250的主程序的while是一个死循环，没有退出机制，可以按Ctrl+c强制中止它，这不是正确的办法，后面我会介绍正确的方法。</p><h1 id="二-僵尸进程"><a class="markdownIt-Anchor" href="#二-僵尸进程"></a> 二、僵尸进程</h1><h2 id="1-僵尸进程产生的原因"><a class="markdownIt-Anchor" href="#1-僵尸进程产生的原因"></a> 1、僵尸进程产生的原因</h2><p>一个子进程在调用return或exit(0)结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个僵尸进程。</p><p>先启动服务端程序book250，然后多次启动客户端程序book249，马上查看book250的进程，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200305160112991.png" alt="在这里插入图片描述" /></p><p>等全部的客户端book249程序运行完成后，再查看book250的进程，如下图。</p><p><img src="https://img-blog.csdnimg.cn/20200305160124882.png" alt="在这里插入图片描述" /></p><p>被选中的就是僵尸进程，有&lt;defunct&gt;标志。</p><p>如果按Ctrl+c终止book250后，父进程退出，僵尸进程随之消失。</p><h2 id="2-僵尸进程的危害"><a class="markdownIt-Anchor" href="#2-僵尸进程的危害"></a> 2、僵尸进程的危害</h2><p>僵尸进程是子进程结束时，父进程又没有回收子进程占用的资源。</p><p>僵尸进程在消失之前会继续占用系统资源。</p><p>如果父进程先退出，子进程被系统接管，子进程退出后系统会回收其占用的相关资源，不会成为僵尸进程。父进和先退出的应用场景在以后的章节中介绍。</p><h2 id="3-如何解决僵尸进程"><a class="markdownIt-Anchor" href="#3-如何解决僵尸进程"></a> 3、如何解决僵尸进程</h2><p>解决僵尸进程的方法有两种。</p><p>子进程退出之前，会向父进程发送一个信号，父进程调用waid函数等待这个信号，只要等到了，就不会产生僵尸进程。这话说得容易，在并发的服务程序中这是不可能的，因为父进程要做其它的事，例如等待客户端的新连接，不可能去等待子进程的退出信号，这个方法我就不介绍了。</p><p>另一种方法就是父进程直接忽略子进程的退出信号，具体做法很简单，在主程序中启用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGCHLD,SIG_IGN);  <span class="comment">// 忽略子进程退出的信号，避免产生僵尸进程</span></span><br></pre></td></tr></table></figure><p>signal函数的用法暂时不介绍，以后会有详细说明。</p><p>先启动服务端程序book250，然后多次启动客户端程序book249，等book249运行结束后再查看book250的进程，不再有僵尸进程。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>在学习了多进程的基础知识之后，初学者可能会认为多进程是一个高大上的技术，认为多进程处理数据肯定比单进程快，其实不是。在实际开发中，采用多进程的主要目的是处理多个并发的任务，而不是为了提高程序的效率。</p><p>从效率方面来说，某些场景下多进程的效率比单进程低，原因很简单，因为在有限的硬件资源中，多进程程序的内存开销更大，还会产生资源的竞争。就像多个人端着一盆水，不如一个人端着一盆水走得快。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>本章节的重点是介绍多进程的应用场景，属于概念性的知识，代码其实很简单，只要各位理解了多进程应用的原理就行了。</p><p>但是，文章中提到的知识点，大家一定要用程序去测试它。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多进程</title>
      <link href="/post/3fdf8525.html"/>
      <url>/post/3fdf8525.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-进程的概念"><a class="markdownIt-Anchor" href="#一-进程的概念"></a> 一、进程的概念</h1><p>什么是进程？进程这个概念是针对系统而不是针对程序员的，对程序员来说，我们面对的概念是程序，当输入指令执行一个程序的时候，对系统而言，它将启动一个进程。</p><p>进程就是正在内存中运行中的程序，Linux下一个进程在内存里有三部分的数据，就是“代码段”、”堆栈段”和”数据段”。”代码段”，顾名思义，就是存放了程序代码。“堆栈段”存放的就是程序的返回地址、程序的参数以及程序的局部变量。而“数据段”则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用new函数分配的空间）。</p><p>系统如果同时运行多个相同的程序，它们的“代码段”是相同的，“堆栈段”和“数据段”是不同的（相同的程序，处理的数据不同）。</p><h1 id="二-进程的编号"><a class="markdownIt-Anchor" href="#二-进程的编号"></a> 二、进程的编号</h1><h2 id="1-查看进程"><a class="markdownIt-Anchor" href="#1-查看进程"></a> 1、查看进程</h2><p>ps 查看当前终端的进程。</p><p><img src="https://img-blog.csdnimg.cn/20200305153006162.png" alt="在这里插入图片描述" /></p><p>ps -ef 查看系统全部的进程。</p><p>ps -ef |more 查看系统全部的进程，结果分页显示。</p><p><img src="https://img-blog.csdnimg.cn/2020030515302358.png" alt="在这里插入图片描述" /></p><p>UID ：启动进程的操作系统用户。</p><p>PID ：进程编号。</p><p>PPID ：进程的父进程的编号。</p><p>C          ：CPU使用的资源百分比。</p><p>STIME ：进程启动时间。</p><p>TTY     ：进程所属的终端。</p><p>TIME   ：使用掉的CPU时间。</p><p>CMD   ：执行的是什么指令。</p><p>ps -ef |grep book查看系统全部的进程，然后从结果集中过滤出包含“book”单词的记录。程序员用得最多的指令就是这个了。</p><p><img src="https://img-blog.csdnimg.cn/20200305153045677.png" alt="在这里插入图片描述" /></p><h2 id="2-getpid库函数"><a class="markdownIt-Anchor" href="#2-getpid库函数"></a> 2、getpid库函数</h2><p>getpid库函数的功能是获取本程序运行时进程的编号。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>函数没有参数，返回值是进程的编号，pid_t就是typedef int pid_t。</p><p><strong>示例（book251.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book251.cpp，此程序用于演示获取程序运行时的进程编号</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本程序的进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">30</span>);    <span class="comment">// 是为了方便查看进程在shell下用ps -ef|grep book251查看本进程的编号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030515321396.png" alt="在这里插入图片描述" /></p><p>在book251运行时，切换到其它的窗口，执行ps -ef|grep book251可以查看进程，如下。</p><p><img src="https://img-blog.csdnimg.cn/20200305153319436.png" alt="在这里插入图片描述" /></p><p>注意两个细节：</p><p>1）进程的编号是系统动态分配的，相同的程序在不同的时间执行，进程的编号是不同的。</p><p>2）进程的编号会循环使用，但是，在同一时间，进程的编号是唯一的，也就是说，不管任何时间，系统不可能存在两个编号相同的进程。</p><h1 id="三-多进程"><a class="markdownIt-Anchor" href="#三-多进程"></a> 三、多进程</h1><p>fork在英文中是“分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork函数，就产生了另一个进程，于是进程就“分叉”了，所以这个名字取得很形象。下面就看看如何具体使用fork函数，这段程序演示了使用fork的基本框架。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>fork函数用于产生一个新的进程，函数返回值pid_t是一个整数，在父进程中，返回值是子进程编号，在子进程中，返回值是0。</p><p><strong>示例（book252.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book252.cpp，此程序用于演示用fork生成一个子进程。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本程序的进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ipid=fork();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);       <span class="comment">// sleep等待进程的生成。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>,ipid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ipid!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;父进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;子进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">30</span>);    <span class="comment">// 是为了方便查看进程在shell下用ps -ef|grep book252查看本进程的编号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305153451933.png" alt="在这里插入图片描述" /></p><p>查看进程情况，出现了两个book进程。</p><p><img src="https://img-blog.csdnimg.cn/20200305153528656.png" alt="在这里插入图片描述" /><br />初学者可能用点接受不了现实。</p><p>1）一个函数（fork）返回了两个值？</p><p>2）if和else中的代码能同时被执行？</p><p>那么调用这个fork函数时发生了什么呢？fork函数创建了一个新的进程，新进程（子进程）与原有的进程（父进程）一模一样。子进程和父进程使用相同的代码段；子进程拷贝了父进程的堆栈段和数据段。子进程一旦开始运行，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。</p><p>fork函数对返回值做了特别的处理，调用fork函数之后，在子程序中fork的返回值是0，在父进程中fork的返回值仍是原进程的编号，程序员可以通过fork的返回值来区分父进程和子进程，然后再执行不同的代码。</p><p><strong>示例（book253.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book253.cpp，此程序用于演示用fork生成一个子进程后，父子进程进入不同的流程。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fatchfunc</span><span class="params">()</span>  <span class="comment">// 父进程流程的主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我是老子，我喜欢孩子他娘。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">childfunc</span><span class="params">()</span>  <span class="comment">// 子进程流程的主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我是儿子，我喜欢西施。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;这是父进程，将调用fatchfunc()。\n&quot;</span>); <span class="built_in">fatchfunc</span>();&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;这是子进程，将调用childfunc()。\n&quot;</span>);  <span class="built_in">childfunc</span>();&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;父子进程执行完自己的函数后都来这里。\n&quot;</span>); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305153634305.png" alt="在这里插入图片描述" /></p><p>在上文上已提到过，子进程拷贝了父进程的堆栈段和数据段，也就是说，在父进程中定义的变量子进程中会复制一个副本，fork之后，子进程对变量的操作不会影响交父进程，父进程对变量的操作也不会影响子进程。</p><p><strong>示例（book254.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book254.cpp，此程序用于演示用fork之后的父子进程在内存中是独立的数据空间。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ii=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> jj=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    ii=<span class="number">11</span>;jj=<span class="number">21</span>; <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="built_in">printf</span>(<span class="string">&quot;父进程：ii=%d,jj=%d\n&quot;</span>,ii,jj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; </span><br><span class="line">    ii=<span class="number">12</span>;jj=<span class="number">22</span>; <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="built_in">printf</span>(<span class="string">&quot;子进程：ii=%d,jj=%d\n&quot;</span>,ii,jj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305153744739.png" alt="在这里插入图片描述" /></p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）编写一个多进程程序，验证子进程是复制父进程的内存变量，还是父子进程共享内存变量？</p><p>2）编写一个示例程序，由父进程生成10个子进程，在子进程中显示它是第几个子进程和子进程本身的进程编号。</p><p>3）编写示例程序，由父进程生成子进程，子进程再生成孙进程，共生成第10代进程，在各级子进程中显示它是第几代子进程和子进程本身的进程编号。</p><p>4）利用尽可能少的代码快速fork出更多的进程，试试看能不能把linux系统搞死。</p><p>5）ps -ef |grep book251命令是ps和grep两个系统命令的组合，各位查一下资料，了解一下grep命令的功能，对程序员来，grep是经常用到的命令。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装socket通信类</title>
      <link href="/post/6e96bc72.html"/>
      <url>/post/6e96bc72.html</url>
      
        <content type="html"><![CDATA[<p>book241.cpp和book242.cpp程序已经有点长了，有些啰嗦了，如果还想扩展功能，或用于多进程、多线程，程序结构将非常复杂。</p><p>不管是socket通信程序的客户端还是服务端，准备工作的代码又长又难看占地方，影响了主程序的结构，必须分离出来。</p><p>如何分离？ 封装。</p><h1 id="一-c的封装方法"><a class="markdownIt-Anchor" href="#一-c的封装方法"></a> 一、C的封装方法</h1><p>C语言只能把程序代码封装成函数。</p><h2 id="1-客户端"><a class="markdownIt-Anchor" href="#1-客户端"></a> 1、客户端</h2><p><strong>示例（book245.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book245.cpp，此程序用于演示用C语言的方法封装socket客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端连服务端的函数，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connecttoserver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="type">int</span> sockfd=<span class="built_in">connecttoserver</span>(<span class="string">&quot;118.89.50.198&quot;</span>,<span class="number">5051</span>);</span><br><span class="line">  <span class="keyword">if</span> (sockfd&lt;=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;连接服务器失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">10</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(sockfd,strbuffer,<span class="built_in">strlen</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(sockfd,strbuffer,<span class="built_in">sizeof</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端连服务端的函数，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="comment">// 返回值：成功返回已连接socket，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connecttoserver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(serverip)) == <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;gethostbyname&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port); </span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book245.cpp中，把客户端连接服务端的socket操作封装到connecttoserver函数中，主程序的代码更简洁。</p><h2 id="2-服务端"><a class="markdownIt-Anchor" href="#2-服务端"></a> 2、服务端</h2><p><strong>示例（book246.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book246.cpp，此程序用于演示用C语言的方法封装socket服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="comment">// 返回值：成功返回初始化的socket，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> listenfd=<span class="built_in">initserver</span>(<span class="number">5051</span>);  <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="keyword">if</span> (listenfd&lt;=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受客户端的连接。</span></span><br><span class="line">  <span class="type">int</span>  clientfd;                  <span class="comment">// 客户端的socket</span></span><br><span class="line">  <span class="keyword">if</span> ( (clientfd=<span class="built_in">accept</span>(listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端accept失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd,strbuffer,<span class="built_in">sizeof</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd,strbuffer,<span class="built_in">strlen</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(clientfd); <span class="built_in">close</span>(listenfd); <span class="comment">// 关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="comment">// 返回值：成功返回初始化的socket，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book246.cpp中，把服务端初始化socket操作封装到initserver函数中，主程序的代码更简洁。</p><h1 id="二-c的封装方法"><a class="markdownIt-Anchor" href="#二-c的封装方法"></a> 二、C++的封装方法</h1><p>C++语言可以封装数据和函数，采用的是类。</p><h2 id="1-客户端-2"><a class="markdownIt-Anchor" href="#1-客户端-2"></a> 1、客户端</h2><p><strong>示例（book247.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book247.cpp，此程序用于演示用C++的方法封装socket客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_sockfd;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpClient</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;118.89.50.198&quot;</span>,<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;118.89.50.198\&quot;,5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  m_sockfd=<span class="number">0</span>;  <span class="comment">// 构造函数初始化m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::~<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_sockfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_sockfd);  <span class="comment">// 析构函数关闭m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpClient::ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">  <span class="keyword">if</span> ( (h=<span class="built_in">gethostbyname</span>(serverip))==<span class="number">0</span> ) </span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port); </span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(m_sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr))!=<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-服务端-2"><a class="markdownIt-Anchor" href="#2-服务端-2"></a> 2、服务端</h2><p><strong>示例（book248.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book248.cpp，此程序用于演示用C++的方法封装socket服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_listenfd;   <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="type">int</span> m_clientfd;   <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">int</span> port)</span></span>;  <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;  <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.InitServer(5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.Accept() failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">  m_listenfd=m_clientfd=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_listenfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (m_clientfd=<span class="built_in">accept</span>(m_listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-c封装的意义"><a class="markdownIt-Anchor" href="#3-c封装的意义"></a> 3、C++封装的意义</h2><p>采用C++封装的意义主要有以下几方面。</p><p>1）把数据初始化的代码放在构造函数中；</p><p>2）把关闭socket等释放资源的代码放在析构函数中；</p><p>3）把socket定义为类的成员变量，类外部的代码根本看不到socket。</p><p>4）代码更简洁，更安全（析构函数自动调用关闭socket，释放资源）。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>本章节演示了如何封装socket，这种封装是最简单的，socket通讯的知识点不算多，但是要用好它并不容易，这么说吧，如果把这两个章节介绍的知识完全掌握，差不多就摸到门槛了，还算不上入门，千万别说自己精通socket通信，后面的路还长。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>充分理解本章节的内容，丰富您的函数库，编写您自己的CTcpClient类和CTcpServer类放入_public.h和_public.cpp中，可以作为您的通用工具。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信基础socket</title>
      <link href="/post/e32fddd2.html"/>
      <url>/post/e32fddd2.html</url>
      
        <content type="html"><![CDATA[<p>各位兄弟，在学习Linux编程基础之前，一定要先学习Linux基础知识和计算机网络基础知识，如果对这两方面的基础知识和基本概念不熟，谈不上Linux编程和网络通信编程。</p><h1 id="一-socket通信的概念"><a class="markdownIt-Anchor" href="#一-socket通信的概念"></a> 一、socket通信的概念</h1><p>socket也称作“套接字”，描述了计算机的IP地址和端口，运行在计算机中的程序之间采用socket进行数据通信。通信的两端都有socket，它是一个通道，数据在两个socket之间进行传输。</p><p>socket把复杂的TCP/IP协议族隐藏在socket接口后面，对程序员来说，只要用好socket相关的函数，就可以完成数据通信。</p><h1 id="二-套接字socket"><a class="markdownIt-Anchor" href="#二-套接字socket"></a> 二、套接字（socket）</h1><p>TCP提供了流（stream）和数据报（datagram）两种通信机制，所以套接字也分为流套接字和数据报套接字。</p><p>流套接字的类型是SOCK_STREAM，它提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有出错后重新发送的机制（就像两个人在打电话，聊天您一句我一句，有来有往，没听清楚就再说一次）。</p><p>数据报套接的类型是SOCK_DGRAM，它不需要建立和维持一个连接，采用UDP/IP协议实现。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输，它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它不需要建立和维持连接（就像一个人向另一个人发短信，一条短信发出去，对方不一定能收到）。</p><p>在实际开发中，数据报套接字（即UDP）的应用场景极少，本章节只介绍流套接字。</p><h1 id="三-socket通信的过程"><a class="markdownIt-Anchor" href="#三-socket通信的过程"></a> 三、socket通信的过程</h1><p>1）服务端程序将一个套接字绑定到指定的ip地址和端口，并通过此套接字等待和监听客户的连接请求。</p><p>2）客户程序向服务端程序绑定的地址和端口发出连接请求。</p><p>3）服务端接受连接请求。</p><p>4）客户端和服务端通过读写套接字进行通信。</p><h1 id="在这里插入图片描述四-客户服务端模式"><a class="markdownIt-Anchor" href="#在这里插入图片描述四-客户服务端模式"></a> <img src="https://img-blog.csdnimg.cn/20200305144642607.png" alt="在这里插入图片描述" /><br />四、客户/服务端模式</h1><p>在TCP/IP网络应用中，两个程序之间通信模式是客户/服务端模式（client/server），客户/服务端也叫作客户/服务器，各人习惯。</p><h2 id="服务端的工作流程"><a class="markdownIt-Anchor" href="#服务端的工作流程"></a> 服务端的工作流程</h2><p>1）创建服务端的socket。</p><p>2）把服务端用于通信的地址和端口绑定到socket上。</p><p>3）把socket设置为监听模式。</p><p>4）接受客户端的连接。</p><p>5）与客户端通信，接收客户端发过来的报文后，回复处理结果。</p><p>6）不断的重复第5）步，直到客户端断开连接。</p><p>7）关闭socket，释放资源。</p><p><strong>服务端示例（book242.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book242.cpp，此程序用于演示socket通信的服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 第1步：创建服务端的socket。</span></span><br><span class="line">  <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第2步：把服务端用于通信的地址和端口绑定到socket上。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET。</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);          <span class="comment">// 任意ip地址。</span></span><br><span class="line">  <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;118.89.50.198&quot;); // 指定ip地址。</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5051</span>);  <span class="comment">// 指定通信端口。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第3步：把socket设置为监听模式。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第4步：接受客户端的连接。</span></span><br><span class="line">  <span class="type">int</span>  clientfd;                  <span class="comment">// 客户端的socket。</span></span><br><span class="line">  <span class="type">int</span>  socklen=<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in); <span class="comment">// struct sockaddr_in的大小</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;  <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">  clientfd=<span class="built_in">accept</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,(<span class="type">socklen_t</span>*)&amp;socklen);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端（%s）已连接。\n&quot;</span>,<span class="built_in">inet_ntoa</span>(clientaddr.sin_addr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">// 接收客户端的请求报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">// 向客户端发送响应结果。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第6步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(listenfd); <span class="built_in">close</span>(clientfd);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端的工作流程"><a class="markdownIt-Anchor" href="#2-客户端的工作流程"></a> 2、客户端的工作流程</h2><p>1）创建客户端的socket。</p><p>2）向服务器发起连接请求。</p><p>3）与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</p><p>4）不断的重复第3）步，直到全部的数据被发送完。</p><p>5）第4步：关闭socket，释放资源。</p><p><strong>客户端示例（book241.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book241.cpp，此程序用于演示socket的客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 第1步：创建客户端的socket。</span></span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第2步：向服务器发起连接请求。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; </span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(<span class="string">&quot;118.89.50.198&quot;</span>)) == <span class="number">0</span> )   <span class="comment">// 指定服务端的ip地址。</span></span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;gethostbyname&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5051</span>); <span class="comment">// 指定服务端的通信端口。</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span>)  <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第3步：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">3</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(sockfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;    <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(sockfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;    <span class="comment">// 接收服务端返回的结果。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第4步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在运行程序之前，必须保证服务器的防火墙已经开通了网络访问策略，如果您不明这句话的意思，说明您的Linux基础知识不够，请先学习Linux基础知识之后再来学习socket通信。</strong></p><p>先启动服务端程序book242，服务端启动后，进入等待客户端连接状态，然后启动客户端。</p><p>客户端的输出如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305144923229.png" alt="在这里插入图片描述" /><br />服务端的输出如下：</p><h1 id="在这里插入图片描述五-注意事项"><a class="markdownIt-Anchor" href="#在这里插入图片描述五-注意事项"></a> <img src="https://img-blog.csdnimg.cn/20200305144932953.png" alt="在这里插入图片描述" /><br />五、注意事项</h1><h2 id="1-别去纠缠细节"><a class="markdownIt-Anchor" href="#1-别去纠缠细节"></a> 1、别去纠缠细节</h2><p>在socket通信的客户端和服务器的程序里，出现了多种数据结构，调用了多个函数，涉及到很多方面的知识，对初学者来说，更重要的是了解socket通信的过程、每段代码的用途和函数调用的功能，不要去纠缠这些结构体和函数的参数，这些函数和参数虽然比较多，但可以修改的非常少，别抄错就可以了，需要注意的地方我会提出。</p><h2 id="2-服务端程序绑定地址"><a class="markdownIt-Anchor" href="#2-服务端程序绑定地址"></a> 2、服务端程序绑定地址</h2><p>如果服务器有多个网卡，多个IP地址，socket通信可以指定用其中一个地址来进行通信，也可以任意ip地址。</p><p>1）指定ip地址的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.149.129&quot;</span>); <span class="comment">// 指定ip地址</span></span><br></pre></td></tr></table></figure><p>2）任意ip地址的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br></pre></td></tr></table></figure><p>在实际开发中，采用任意ip地址的方式比较多。</p><h2 id="3-服务端程序绑定的通信端口"><a class="markdownIt-Anchor" href="#3-服务端程序绑定的通信端口"></a> 3、服务端程序绑定的通信端口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5000</span>);  <span class="comment">// 通信端口</span></span><br></pre></td></tr></table></figure><h2 id="4-客户端程序指定服务端的ip地址"><a class="markdownIt-Anchor" href="#4-客户端程序指定服务端的ip地址"></a> 4、客户端程序指定服务端的ip地址</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line"><span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(<span class="string">&quot;192.168.149.129&quot;</span>)) == <span class="number">0</span> )</span><br><span class="line">&#123; <span class="built_in">perror</span>(<span class="string">&quot;gethostbyname&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="5-客户端程序指定服务端的通信端口"><a class="markdownIt-Anchor" href="#5-客户端程序指定服务端的通信端口"></a> 5、客户端程序指定服务端的通信端口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="6-send函数"><a class="markdownIt-Anchor" href="#6-send函数"></a> 6、send函数</h2><p>send函数用于把数据通过socket发送给对端。不论是客户端还是服务端，应用程序都用send函数来向TCP连接的另一端发送数据。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd为已建立好连接的socket。</p><p>buf为需要发送的数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，内存中有什么就发送什么。</p><p>len需要发送的数据的长度，为buf中有效数据的长度。</p><p>flags填0, 其他数值意义不大。</p><p>函数返回已发送的字符数。出错时返回-1，错误信息errno被标记。</p><p>注意，就算是网络断开，或socket已被对端关闭，send函数不会立即报错，要过几秒才会报错。</p><p>如果send函数返回的错误（&lt;=0），表示通信链路已不可用。</p><h2 id="7-recv函数"><a class="markdownIt-Anchor" href="#7-recv函数"></a> 7、recv函数</h2><p>recv函数用于接收对端socket发送过来的数据。</p><p>recv函数用于接收对端通过socket发送过来的数据。不论是客户端还是服务端，应用程序都用recv函数接收来自TCP连接的另一端发送过来数据。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd为已建立好连接的socket。</p><p>buf为用于接收数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，只要是一块内存就行了。</p><p>len需要接收数据的长度，不能超过buf的大小，否则内存溢出。</p><p>flags填0, 其他数值意义不大。</p><p>如果socket的对端没有发送数据，recv函数就会等待，如果对端发送了数据，函数返回接收到的字符数。出错时返回-1，错误信息errno被标记。如果socket被对端关闭，返回值为0。</p><p>如果recv函数返回的错误（&lt;=0），表示通信通道已不可用。</p><h2 id="8-服务端有两个socket"><a class="markdownIt-Anchor" href="#8-服务端有两个socket"></a> 8、服务端有两个socket</h2><p>对服务端来说，有两个socket，一个是用于监听的socket，还有一个就是客户端连接成功后，由accept函数创建的用于与客户端收发报文的socket。</p><h2 id="9-程序退出时先关闭socket"><a class="markdownIt-Anchor" href="#9-程序退出时先关闭socket"></a> 9、程序退出时先关闭socket</h2><p>socket是系统资源，操作系统打开的socket数量是有限的，在程序退出之前必须关闭已打开的socket，就像关闭文件指针一样，就像delete已分配的内存一样，极其重要。</p><p>值得注意的是，关闭socket的代码不能只在main函数的最后，那是程序运行的理想状态，还应该在main函数的每个return之前关闭。</p><h1 id="六-相关的库函数"><a class="markdownIt-Anchor" href="#六-相关的库函数"></a> 六、相关的库函数</h1><h2 id="1-socket函数"><a class="markdownIt-Anchor" href="#1-socket函数"></a> 1、socket函数</h2><p>socket函数用于创建一个新的socket，也就是向系统申请一个socket资源。socket函数用户客户端和服务端。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>domain：协议域，又称协议族（family）。常用的协议族有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p><p>type：指定socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。流式socket（SOCK_STREAM）是一种面向连接的socket，针对于面向连接的TCP服务应用。数据报式socket（SOCK_DGRAM）是一种无连接的socket，对应于无连接的UDP服务应用。</p><p>protocol：指定协议。常用协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p><p>说了一大堆废话，第一个参数只能填AF_INET，第二个参数只能填SOCK_STREAM，第三个参数只能填0。</p><p>除非系统资料耗尽，socket函数一般不会返回失败。</p><h2 id="2-gethostbyname函数"><a class="markdownIt-Anchor" href="#2-gethostbyname函数"></a> 2、gethostbyname函数</h2><p>把ip地址或域名转换为hostent 结构体表达的地址。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> *<span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span> *name);</span><br></pre></td></tr></table></figure><p>参数name，域名或者主机名，例如&quot;192.168.1.3&quot;、&quot;<a href="http://www.freecplus.net">www.freecplus.net</a>&quot;等。</p><p>返回值：如果成功，返回一个hostent结构指针，失败返回NULL。</p><p>gethostbyname只用于客户端。</p><p>gethostbyname只是把字符串的ip地址转换为结构体的ip地址，只要地址格式没错，一般不会返回错误。函数失败不会设置errno的值。</p><h2 id="3-connect函数"><a class="markdownIt-Anchor" href="#3-connect函数"></a> 3、connect函数</h2><p>向服务器发起连接请求。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr * serv_addr, <span class="type">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>函数说明：connect函数用于将参数sockfd 的socket 连至参数serv_addr<br />指定的服务端，参数addrlen为sockaddr的结构长度。</p><p>返回值：成功则返回0, 失败返回-1, 错误原因存于errno 中。</p><p>connect函数只用于客户端。</p><p>如果服务端的地址错了，或端口错了，或服务端没有启动，connect一定会失败。</p><h2 id="4-bind函数"><a class="markdownIt-Anchor" href="#4-bind函数"></a> 4、bind函数</h2><p>服务端把用于通信的地址和端口绑定到socket上。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数sockfd，需要绑定的socket。</p><p>参数addr，存放了服务端用于通信的地址和端口。</p><p>参数addrlen表示addr结构体的大小。</p><p>如果绑定的地址错误，或<strong>端口已被占用</strong>，bind函数一定会报错，否则一般不会返回错误。</p><h2 id="5-listen函数"><a class="markdownIt-Anchor" href="#5-listen函数"></a> 5、listen函数</h2><p>listen函数把主动连接套接字变为被动连接的套接字，使得这个socket可以接受其它socket的连接请求，从而成为一个服务端的socket。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>返回：0-成功， -1-失败</p><p>参数sockfd是已经被bind过的套接字。socket函数返回的套接字是一个主动连接的套接字，在服务端的编程中，程序员希望这个套接字可以接受外来的连接请求，也就是被动等待客户端来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告诉系统，程序员通过调用listen函数来完成这件事。</p><p>参数backlog，这个参数涉及到一些网络的细节，比较麻烦，填5、10都行，一般不超过30。</p><p>当调用listen之后，服务端的套接字就可以调用accept来接受客户端的连接请求。</p><p>listen函数一般不会返回错误。</p><h2 id="6-accept函数"><a class="markdownIt-Anchor" href="#6-accept函数"></a> 6、accept函数</h2><p>服务端接受客户端的连接。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数sockfd是已经被listen过的套接字。</p><p>参数addr用于存放客户端的地址信息，用sockaddr结构体表达，如果不需要客户端的地址，可以填0。</p><p>参数addrlen用于存放addr参数的长度，如果addr为0，addrlen也填0。</p><p>accept函数等待客户端的连接，如果没有客户端连上来，它就一直等待，这种方式称之为阻塞。</p><p>accept等待到客户端的连接后，创建一个新的套接字，函数返回值就是这个新的套接字，服务端使用这个新的套接字和客户端进行报文的收发。</p><p>accept在等待的过程中，如果被中断或其它的原因，函数返回-1，表示失败，如果失败，可以重新accept。</p><h2 id="7-函数小结"><a class="markdownIt-Anchor" href="#7-函数小结"></a> 7、函数小结</h2><p>服务端函数调用的流程是：socket-&gt;bind-&gt;listen-&gt;accept-&gt;<strong>recv/send</strong>-&gt;close</p><p>客户端函数调用的流程是：socket-&gt;connect-&gt;<strong>send/recv</strong>-&gt;close</p><p>其中<strong>send/recv</strong>可以进行多次交互。</p><h1 id="七-课后作业"><a class="markdownIt-Anchor" href="#七-课后作业"></a> 七、课后作业</h1><p>1）把book241.cpp和book242.cpp抄下来，编译运行，试试修改参数再运行。</p><p>2）book241.cpp和book242.cpp程序中，有些代码不能动，有些代码可以动，把能动的都动一下，就算是抄代码，也要抄个明白。</p><p>3）服务端的accept函数会阻塞，阻塞是专业名词，即等待，可以用代码测试一下。</p><p>4）不管是服务端还是客户端recv函数也会阻塞，可以用代码测试一下。</p><p>5）修改book241.cpp和book242.cpp，实现点对点的聊天功能，用户在客户端输入一个字符串，然后发送给服务端，服务端收到客户端的报文后，也提示用户输入一个字符串，返回给客户端，如果服务端收到客户端的报文是“bye”通信结束。</p><p>6）如果以上作业都能完成，建议再把本文章的内容再看一次，对文章开始部分的理论知识将有新的理解。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Linux编程前的准备</title>
      <link href="/post/b8c80ece.html"/>
      <url>/post/b8c80ece.html</url>
      
        <content type="html"><![CDATA[<p>如果您是非计算机相关专业零基础兄弟，在学习Linux编程基础之前，建议先学习计算机基础、Linux操作系统基础知识和计算机网络基础知识。</p><p>计算机基础知识包括了很多常识性的内容，学了不一定有用，但是如果对一些基本常识不了解，可能会闹笑话。</p><p>我们学习的目标是成为C/C++程序员，不是Linux系统管理员，也不是网络管理员。作为一个程序员，只需要了解Linux操作系统和计算机网络的基础知识就可以了，不需要深入研究它们的原理。大家不要去买这两方面书籍，建议大家去买一个云服务器，腾讯、华为、阿里的都可以，一年不超过100元，云服务器对学习非常有帮助，<strong>远远超过任何书籍。</strong></p><p>最好的学习方法是到网上找<strong>免费的视频教程</strong>，例如B站、腾讯课堂、CSDN学院等，这些很基础的知识网上非常多。</p><p><strong>总的来说，以学习概念和扩充知识面为主，不要深入理论，不要学习算法，应用为王。</strong></p><h1 id="一-计算机基础知识的学习"><a class="markdownIt-Anchor" href="#一-计算机基础知识的学习"></a> 一、计算机基础知识的学习</h1><p>====================</p><p>1）计算机历史。</p><p>2）计算机的应用领域。</p><p>3）二进制、十进制、十六进制的基本概念。</p><p>4）计算机总线、外部设备。</p><p>5）计算机软件、操作系统基本概念。</p><p>6）学习时间不超过20小时。</p><p>7）推荐视频<a href="https://www.bilibili.com/video/av80537766">https://www.bilibili.com/video/av80537766</a></p><h1 id="二-linux操作系统的学习内容"><a class="markdownIt-Anchor" href="#二-linux操作系统的学习内容"></a> 二、Linux操作系统的学习内容</h1><p>1）Linux系统简介。</p><p>2）Linux系统的安装。</p><p>3）远程登录命令（以ssh为主，了解telnet）。</p><p>4）Linux常用命令，注意，Linux的命令上千个，常用的约50个，能看懂多少就多少，看不懂的就算了，与程序员相关的Linux命令我会在教程中提到。</p><p>5）Linux用户和组的管理。</p><p>6）Linux文件系统。</p><p>7）Shell基础，注意，Shell可以很复杂，Shell脚本也是一种编程语言，但是，我们是C/C++程序员，一般不会采用Shell编写脚本程序，运维人员使用Shell脚本比较多。</p><p>8）Linux进程方面的基础知识。</p><p>9）Linux防火墙配置。</p><p>10）学习的时间不必超过50小时。</p><p>11）推荐视频<a href="https://www.bilibili.com/video/av18156598">https://www.bilibili.com/video/av18156598</a></p><h1 id="三-计算机网络的学习内容"><a class="markdownIt-Anchor" href="#三-计算机网络的学习内容"></a> 三、计算机网络的学习内容</h1><p>1）计算机网络的基本概念。</p><p>2）局域网、广域网和互联网。</p><p>3）ISO参考模型。</p><p>4）TCP协议（粗略的了解一下UDP）。</p><p>5）IP地址、网关、子网掩码、DHCP协议。</p><p>6）万维网和HTTP和HTTPS协议。</p><p>7）电子邮件和SMTP 协议。</p><p>8）文件传输协议FTP。</p><p>9）远程登录协议（以ssh为主，了解telnet）。</p><p>10）学习的时间不必超过30小时。</p><p>11）推荐视频<a href="https://www.bilibili.com/video/av70228743">https://www.bilibili.com/video/av70228743</a>或<a href="https://www.bilibili.com/video/av9876107">https://www.bilibili.com/video/av9876107</a></p><h1 id="四-学习策略"><a class="markdownIt-Anchor" href="#四-学习策略"></a> 四、学习策略</h1><p><strong>以学习概念和扩充知识面为主，不要深入理论，不要学习算法，应用为王。</strong></p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的多态</title>
      <link href="/post/8f6e21d8.html"/>
      <url>/post/8f6e21d8.html</url>
      
        <content type="html"><![CDATA[<p>多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就可能会用到多态。</p><p>C++多态就是当调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><h1 id="一-静态多态"><a class="markdownIt-Anchor" href="#一-静态多态"></a> 一、静态多态</h1><p>我们以前说过的函数重载就是一个简单的静态多态，静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错。</p><p><strong>示例（book236.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book236.cpp，此程序用于演示C++类的静态多态。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>       <span class="comment">// 显示超女基本信息的成员函数体</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\n&quot;</span>,m_name,m_age,m_height,m_sc,m_yz); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CKCon</span>:<span class="keyword">public</span> CGirl   <span class="comment">// 定义王妃类，从超女类继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_ch[<span class="number">50</span>];      <span class="comment">// 称号</span></span><br><span class="line">  <span class="type">char</span> m_palace[<span class="number">50</span>];  <span class="comment">// 居住的宫殿</span></span><br><span class="line">  <span class="type">int</span>  m_sal;         <span class="comment">// 奉禄</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>     <span class="comment">// 显示王妃的称号、宫殿和奉禄</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\n&quot;</span>,m_name,m_ch,m_palace,m_sal); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CKCon KCon;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_name,<span class="string">&quot;杨玉环&quot;</span>);   KCon.m_age=<span class="number">28</span>;            KCon.m_height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_sc,<span class="string">&quot;火辣&quot;</span>);       <span class="built_in">strcpy</span>(KCon.m_yz,<span class="string">&quot;漂亮&quot;</span>); <span class="built_in">strcpy</span>(KCon.m_ch,<span class="string">&quot;杨贵妃&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_palace,<span class="string">&quot;华清宫&quot;</span>); KCon.m_sal=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">  CGirl *pGirl;   <span class="comment">// 基类的指针</span></span><br><span class="line">  CKCon *pCon;   <span class="comment">// 派生类的指针</span></span><br><span class="line"></span><br><span class="line">  pGirl=pCon=&amp;KCon;  <span class="comment">// 都指向派生类</span></span><br><span class="line"></span><br><span class="line">  pGirl-&gt;<span class="built_in">Show</span>();   <span class="comment">// 将调用的是基类的Show方法</span></span><br><span class="line">  pCon-&gt;<span class="built_in">Show</span>();    <span class="comment">// 将调用的是派生类的Show方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305141738165.png" alt="在这里插入图片描述" /></p><p>在book236.cpp的main函数中，创建的是CKCon对象，如果采用基类指针调用Show方法，变成了调用CGirl类的Show方法，而不是CKcon类的Show方法，因为pGirl是CGirl的指针，pGirl-&gt;Show方法在程序编译期间就已经设置好了。</p><h1 id="二-动态多态"><a class="markdownIt-Anchor" href="#二-动态多态"></a> 二、动态多态</h1><p>动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。</p><p>让我们对程序稍作修改，在CGirl类中，Show方法的声明前放置关键字 virtual，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>       <span class="comment">// 显示超女基本信息的成员函数体</span></span></span><br></pre></td></tr></table></figure><p>其它的代码都不变，编译并运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305141817988.png" alt="在这里插入图片描述" /></p><p>此时，编译器看的是指针的内容，而不是它的类型。这就是多态的一般使用方式。</p><h1 id="三-虚函数"><a class="markdownIt-Anchor" href="#三-虚函数"></a> 三、虚函数</h1><p>虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义虚函数。</p><p>我们想要的是在程序中可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p><h1 id="四-纯虚函数"><a class="markdownIt-Anchor" href="#四-纯虚函数"></a> 四、纯虚函数</h1><p>我们可以在基类中只声明虚函数，没有函数的定义，在派生类中去实现函数的定义，这个时候就会用到纯虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Show</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">// 申明一个纯虚函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>virtual int Show()=0;;告诉编译器，函数只有声明，没有定义，是纯虚函数。</p><h1 id="五-c-接口抽象类"><a class="markdownIt-Anchor" href="#五-c-接口抽象类"></a> 五、C++ 接口（抽象类）</h1><p>接口描述了类的行为和功能，是标准和规范，而不需要完成类的功能实现。</p><p>C++接口是用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p><p>设计抽象类的目的，是为了给其他类提供一个可以继承的基类。抽象类不能用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p><p>如果一个基类的派生类需要实例化，则必须实现每个虚函数的定义，如果没有在派生类中纯虚函数的定义会导致编译错误。</p><p>可用于实例化对象的类被称为具体类。</p><h1 id="六-应用经验"><a class="markdownIt-Anchor" href="#六-应用经验"></a> 六、应用经验</h1><p>对初学者来说，类的多态、虚函数这些概念可能难以理解，因为您想不到它的应用场景，在实际开发中，这些知识的应用场景也比较少，在一些大型的项目开发中才可能用到，二十年来我只用过一次。</p><p>各位只要了解一下这些知识就可以了，掌握不了就算了。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的继承与派生</title>
      <link href="/post/26c0d8f0.html"/>
      <url>/post/26c0d8f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-继承"><a class="markdownIt-Anchor" href="#一-继承"></a> 一、继承</h1><p>继承是面向对象程序设计中最重要的一个概念。继承允许我们根据一个类来定义另一个类，达到了代码功能重用效果。</p><p>当创建一个类时，如果待创建的类与另一个类存在某些共同特征，程序员不需要全部重新编写成员变量和成员函数，只需指定继承另一个类即可，被继承的类称为基类或父类，新建的类称为派生类或子类。</p><h1 id="二-基类和派生类"><a class="markdownIt-Anchor" href="#二-基类和派生类"></a> 二、基类和派生类</h1><p>定义一个派生类，需要指定它的基类，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式&gt; &lt;基类名&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 派生类类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式是 public、protected 或 private 其中的一个，基类是之前定义过的某个类的名称。如果未指定继承方式，则默认为private。</p><p>选秀之后，被选中的超女成了宫女和王妃，宫女和王妃从超女那里继承了姓名、年龄、身高、身材、颜值等特征，还会具备一些新的特征，如果是王妃，有称号、居住的宫殿、奉䘵、为她服务的太监和宫女数量等。还有，王妃的年龄、身材和颜值都不能随便讨论的，会掉脑袋的。</p><p><strong>示例（book235.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book235.cpp，此程序用于演示C++类的继承与派生。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>       <span class="comment">// 显示超女基本信息的成员函数体 </span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\n&quot;</span>,m_name,m_age,m_height,m_sc,m_yz);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CKCon</span>:<span class="keyword">public</span> CGirl   <span class="comment">// 定义王妃类，从超女类继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_ch[<span class="number">50</span>];      <span class="comment">// 称号</span></span><br><span class="line">  <span class="type">char</span> m_palace[<span class="number">50</span>];  <span class="comment">// 居住的宫殿</span></span><br><span class="line">  <span class="type">int</span>  m_sal;         <span class="comment">// 奉禄</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>     <span class="comment">// 显示王妃的称号、宫殿和奉禄</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\n&quot;</span>,m_name,m_ch,m_palace,m_sal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CKCon KCon;   <span class="comment">// 实例化一个KCon对象</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_name,<span class="string">&quot;杨玉环&quot;</span>);</span><br><span class="line">  KCon.m_age=<span class="number">28</span>;      </span><br><span class="line">  KCon.m_height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_ch,<span class="string">&quot;杨贵妃&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_palace,<span class="string">&quot;华清宫&quot;</span>);</span><br><span class="line">  KCon.m_sal=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">  KCon.<span class="built_in">Show</span>();   <span class="comment">// 如果子类中没有Show函数，就会调用父类的Show函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305140744151.png" alt="在这里插入图片描述" /></p><h1 id="三-继承方式"><a class="markdownIt-Anchor" href="#三-继承方式"></a> 三、继承方式</h1><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种方式，当使用不同类型的继承时，遵循以下几个规则：</p><p>1）公有继承（public）：当类派生以public方式继承时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</p><p>2）保护继承（protected）： 当类派生以protected方式继承时，基类的公有和保护成员将成为派生类的保护成员。</p><p>3）私有继承（private）：当类派生以private方式继承时，基类的公有和保护成员将成为派生类的私有成员。</p><p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。</p><p>五、基类与派生类的指针</p><p>基类的指针可以指向基类对象，也可以指向派生类对象，但是不能通过基类的指针访问派生类的成员。</p><p>派生类的指针可以指向派生类对象，但不可以指向基类对象。</p><h1 id="六-多继承"><a class="markdownIt-Anchor" href="#六-多继承"></a> 六、多继承</h1><p>多继承即一个派生类可以有多个基类，它继承了多个基类的特性。</p><p>C++ 类可以从多个基类继承成员，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 派生类类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>类的继承与派生在windows环境开发中用得比较多，在Linux环境下用得比较少，这么多年来，我只是偶尔用一下，大家只要了解继承与派生基本用法就行了，如果在实际开发中真的要用到类的继承，再来研究也不迟，这个没什么技术难度。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深理解和映象。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++动态内存管理</title>
      <link href="/post/9dd7550d.html"/>
      <url>/post/9dd7550d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-c动态内存"><a class="markdownIt-Anchor" href="#一-c动态内存"></a> 一、C++动态内存</h1><p>在C<ins>程序中，内存需求都是在编写程序的时候声明变量来确定，但是程序在运行过程中需要动态分配内存的情况，C</ins>语言将运算符new和delete合成在一起。</p><h2 id="1-特点"><a class="markdownIt-Anchor" href="#1-特点"></a> 1、特点</h2><p>中通过new关键字向系统内存申请。</p><p>C++中的动态内存分配是基于数据类型进行的。</p><p>delete关键字用于内存释放。</p><h2 id="2-语法"><a class="markdownIt-Anchor" href="#2-语法"></a> 2、语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datatype *pointer = <span class="keyword">new</span> datatype;</span><br><span class="line"><span class="comment">//  其它代码</span></span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br></pre></td></tr></table></figure><p>datatype可以是C语言的基本数据类型，也可以是结构体，还可以是类。</p><p>pointer是一个指针，指向new返回的地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi= <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 动态分配一个整数大小的内存</span></span><br><span class="line">(*pi)=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> pi;  <span class="comment">// 释放pi指向的内存</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGirl *pgirl=<span class="keyword">new</span> CGirl;   <span class="comment">// 动态分配CGirl类</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">strcpy</span>(pgirl-&gt;name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"> pgirl-&gt;age=<span class="number">22</span>;</span><br><span class="line"> pgirl.height=<span class="number">168</span>;</span><br><span class="line"> <span class="built_in">strcpy</span>(pgirl-&gt;sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(pgirl-&gt;yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line"> pgirl-&gt;<span class="built_in">show</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">delete</span> pgirl; <span class="comment">// 释放pgirl指向的内存</span></span><br></pre></td></tr></table></figure><p>如果new出来的是类，相当于创建对象，所以会调用构造函数，delete的时候也会调用析构函数。</p><h1 id="二-应用经验"><a class="markdownIt-Anchor" href="#二-应用经验"></a> 二、应用经验</h1><p>有些程序员认为动态内存分配是高大上的技术，但是，在实际开发中，需要动态分配内存的场景极少，string和vector已经足够方便，如果不是非用不可的情况，采用动态分配内存就是给自己挖坑。</p><p>如果应用开发中一定要用动态内存分配技术，建议把它封装在类中，并在析构函数中编写释放内存的代码，防止内存泄漏。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的vector容器</title>
      <link href="/post/10540a7c.html"/>
      <url>/post/10540a7c.html</url>
      
        <content type="html"><![CDATA[<p>我们在声明数组的时候，采用的是datatype array[len]的形式，数组在分配之后，不能调整大小，删除和插入数据时操作十分的繁琐，虽然可以采用链表，但是链表的操作更麻烦，我们希望有更简单的方法。</p><p>与string类一样, 向量vector 同属于STL（Standard Template Library,标准模板库）中的定义的类, vector是一个封装了动态数组的顺序容器（Sequence Container），它能够存放各种类型的数据和对象。</p><p>可以简单的认为vector容器是一个能够存放任意类型的动态数组，与数组相比，vector容器的优点在于它能够根据需要自动调整的大小，随时放入更多的元素。此外, vector也提供了成员函数对自身进行操作。</p><h1 id="一-容器的定义"><a class="markdownIt-Anchor" href="#一-容器的定义"></a> 一、容器的定义</h1><p>首先，如果要在程序中使用vector容器，必须包含头文件 &lt;vector&gt;。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><p>vector类是一个模板类，位于std命名空间内，为方便使用还需要增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>声明一个容器很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi;              <span class="comment">// 定义用于存放整数的容器</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; vd;         <span class="comment">// 定义用于存放浮点数的容器</span></span><br><span class="line">vector&lt;string&gt; vs;           <span class="comment">// 定义用于存放string字符串的容器</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> st_girl&gt; vgirl;  <span class="comment">// 定义用于存放超女结构体的容器</span></span><br><span class="line">vector&lt;CGirl&gt; vGirl;         <span class="comment">// 定义用于存放超女类的容器</span></span><br></pre></td></tr></table></figure><p>vector容器可以存放C语言的基本数据类型，可以存放结构体，还可以存放类，这正是我们想要的简单的方法，链表？我已经有二十年没有用它了。</p><h1 id="二-容器的使用"><a class="markdownIt-Anchor" href="#二-容器的使用"></a> 二、容器的使用</h1><p>vector的功能强大，成员函数很多，我不想按普通教程的方式来介绍它，那样会太烦锁，我根据实际开发中应用的场景，采用示例程序介绍vector常用的用法。</p><h2 id="1-存放整数"><a class="markdownIt-Anchor" href="#1-存放整数"></a> 1、存放整数</h2><p><strong>示例（book220.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book220.cpp，此程序用于演示C++容器存放整数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>      <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>   <span class="comment">// sort函数需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> height=<span class="number">0</span>;             <span class="comment">// 存放从键盘输入的超女身高</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; vheight; <span class="comment">// 存放超女身高的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入超女身高（0-结束输入）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;height);         <span class="comment">// 接受键盘输入的数据</span></span><br><span class="line">    <span class="keyword">if</span> (height==<span class="number">0</span>) <span class="keyword">break</span>;        <span class="comment">// 0-结束输入</span></span><br><span class="line">    vheight.<span class="built_in">push_back</span>(height);   <span class="comment">// 把数据追加入容器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vheight.<span class="built_in">size</span>();ii++) <span class="comment">// 显示排序前容器中的记录</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vheight[%d]=%d\n&quot;</span>,ii,vheight[ii]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(vheight.<span class="built_in">begin</span>(),vheight.<span class="built_in">end</span>());  <span class="comment">// 容器中的记录排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vheight.<span class="built_in">size</span>();ii++) <span class="comment">// 显示排序后容器中的记录</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vheight[%d]=%d\n&quot;</span>,ii,vheight[ii]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vheight.clear();  // 清空容器，可以不写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030511135866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>程序解释如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vheight;   <span class="comment">// 声明容器用于存放整数，超女身高，单位是cm。</span></span><br></pre></td></tr></table></figure><p><strong>void push_back(const T&amp; x)成员函数</strong>：向容器尾部增加一个元素x，x就是您要向容器中增加的变量，在本示例中是一个整数，注意，参数x是一个引用，要用变量的名称，不是变量的地址，如vheight.push_back(height);。</p><p><strong>int size()成员函数</strong>：返回容器中数据的元素总数。</p><p><strong>像数组一样访问容器</strong>：容器像数组一样，可以用数组的下标访问，vheight[0]表示容器的第1个元素，vheight[n]表示容器的第n+1个元素。注意，采用下标方式放问容器的时候，下标不要越界，否则可能会引起内存溢出。</p><p><strong>iterator begin()成员函数</strong>：返回容器头指针，指向第一个元素。</p><p><strong>iterator end()成员函数</strong>：返回容器尾指针，指向容器最后一个元素的下一个位置。</p><p>容器中的元素排序：采用sort()函数对容器中的元素进行排序。如sort(vheight.begin(),vheight.end());表示对容器中全部的元素进行排序。</p><p><strong>void clear()</strong>：清空容器中的全部元素，注意两点：1）容器被声明的时候，本来就是空的；2）容器是类，有析构函数，析构函数中会自动清空容器中的元素，释放内存资源，不需要程序员担心。但是，程序员也可以调clear()函数手工清空容器中的元素。</p><p>示例book220.cpp程序展示了vector容器10%的功能和成员函数，但是，在实际开发中，对容器的操作，95%的内容就是这些。</p><h2 id="2-存放字符串"><a class="markdownIt-Anchor" href="#2-存放字符串"></a> 2、存放字符串</h2><p><strong>示例（book222.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book222.cpp，此程序用于演示C++容器存放字符串</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">char</span> strtmp[<span class="number">50</span>];                <span class="comment">// 存放姓名的临时变量</span></span><br><span class="line">  std::string name;               <span class="comment">// 存放从键盘输入的超女姓名</span></span><br><span class="line">  std::vector&lt;std::string&gt; vname; <span class="comment">// 存放超女姓名的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入超女姓名（0-结束输入）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,strtmp);               <span class="comment">// 接受键盘输入的数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(strtmp,<span class="string">&quot;0&quot;</span>)==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 0-结束输入</span></span><br><span class="line">    vname.<span class="built_in">push_back</span>(strtmp);          <span class="comment">// 把数据追加入容器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vname.<span class="built_in">size</span>();ii++) <span class="comment">// 显示容器中的记录</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vname[%d]=%s\n&quot;</span>,ii,vname[ii].<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305112634930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意几个问题：</p><p>1）用容器存放字符串，数据类型用string，不是C语言用0结尾的字符数组char []，string是一个变量，char []是一组变量。</p><p>2）用vname.push_back()成员函数把数据追加到容器中，参数的类型可以是string，也可以是char[]，但是，这并不是vector的特征，而是string的特征，容器声明的是string类型，string的构造函数支持char []，表面上看push_back()进去的是char []，实际上会被转换为string。</p><h2 id="3-存放结构体"><a class="markdownIt-Anchor" href="#3-存放结构体"></a> 3、存放结构体</h2><p><strong>示例（book225.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book225.cpp，此程序用于演示C++容器存放结构体</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>       <span class="comment">// 超女数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;             <span class="comment">// 超女数据结构</span></span><br><span class="line">  std::vector&lt;<span class="keyword">struct</span> st_girl&gt; vgirl; <span class="comment">// 存放超女结构体的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>); stgirl.age=<span class="number">18</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;杨玉环&quot;</span>); stgirl.age=<span class="number">28</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用数组下标访问容器中的记录</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vgirl.<span class="built_in">size</span>();ii++) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vgirl[%d].name=%s,vgirl[%d].age=%d\n&quot;</span>,\</span><br><span class="line">            ii,vgirl[ii].name,ii,vgirl[ii].age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把容器中的记录复制到结构体</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vgirl.<span class="built_in">size</span>();ii++) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;stgirl,&amp;vgirl[ii],<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stgirl.name=%s,stgirl.age=%d\n&quot;</span>,stgirl.name,stgirl.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305112727654.png" alt="在这里插入图片描述" /></p><p>总的来说，存放结构体的容器和数组的用法基本相同。</p><p>在book225.cpp中，采用了memcpy函数，它是C语言的库函数，用于内存中的数据复制，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>dest：指向用于存储复制内容的目标地址，类型强制转换为 void* 指针。</p><p>src：指向要复制的数据源地址，类型强制转换为 void* 指针。</p><p>n：要被复制的字节数。</p><p>该函数返回dest。</p><h2 id="4-存放类"><a class="markdownIt-Anchor" href="#4-存放类"></a> 4、存放类</h2><p>示例（book222.cpp）演示的存放字符串，string就是类。</p><h1 id="三-其它成员函数"><a class="markdownIt-Anchor" href="#三-其它成员函数"></a> 三、其它成员函数</h1><p>vector的成员函数比较多，为了不增加各位的学习负担，我只介绍常用的。</p><h2 id="1-定位的函数"><a class="markdownIt-Anchor" href="#1-定位的函数"></a> 1、定位的函数</h2><p><code>iterator begin()</code>：返回容器头的指针，指向容器第一个元素的位置。</p><p><code>iterator end()</code>：返回容器尾的指针，指向容器最后一个元素的下一个位置。</p><p>iterator是跌代器，这个名字让人难以理解，那就先不要管它，以下我会举例说明用法，一般来说，begin()和end()成员函数用于其它成员函数的参数中。</p><h2 id="2-增加元素的函数"><a class="markdownIt-Anchor" href="#2-增加元素的函数"></a> 2、增加元素的函数</h2><p><code>void push_back(const T&amp; x)</code>：向容器的尾部增加一个元素x。</p><p><code>iterator insert(iterator it,const T&amp; x)</code>：向容器中指定位置（it）前插入一个元素x。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;王昭群&quot;</span>); stgirl.age=<span class="number">22</span>;</span><br><span class="line">vgirl.<span class="built_in">insert</span>(vgirl.<span class="built_in">begin</span>()+<span class="number">1</span>,stgirl);  <span class="comment">// 在第2个元素前插入一个元素。</span></span><br></pre></td></tr></table></figure><h2 id="3-删除元素的函数"><a class="markdownIt-Anchor" href="#3-删除元素的函数"></a> 3、删除元素的函数</h2><p><code>iterator erase(iterator it)</code>：删除容器中指定位置（it）的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vgirl.<span class="built_in">erase</span>(vgirl.<span class="built_in">begin</span>()+<span class="number">2</span>);  <span class="comment">// 删除容器中第3个元素。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span>：删除容器中最后一个元素。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>：清空容器中全部的元素。</span></span><br></pre></td></tr></table></figure><h2 id="4-判断容器的大小"><a class="markdownIt-Anchor" href="#4-判断容器的大小"></a> 4、判断容器的大小</h2><p><code>bool empty()</code>：判断容器是否为空。</p><p><code>int size()</code>：返回容器中元素的个数。</p><h1 id="四-容器的排序"><a class="markdownIt-Anchor" href="#四-容器的排序"></a> 四、容器的排序</h1><p>在实际开发中，往往需要对vector容器中的元素进行排序，sort函数可以实现排序功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(begin,end,cmp);</span><br></pre></td></tr></table></figure><p>sort函数包含在头文件为#include &lt;algorithm&gt;的c++标准库中，调用排序方法不必知道其内部是如何实现的，只要出现我们想要的结果就行。</p><p>sort函数有三个参数：</p><p>（1）第一个是要排序的数组的起始地址。</p><p>（2）第二个是结束的地址。</p><p>（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时缺省的排序方法是从小到大排序。如果vector容器中元素的数据类型不是基本数据类型，sort函数必须指定排序方法函数。</p><p><strong>示例（book227.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book227.cpp，此程序用于演示C++容器的排序</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>      <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>   <span class="comment">// sort函数需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>       <span class="comment">// 超女数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序函数，按超女姓名排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sortbyname</span><span class="params">(<span class="type">const</span> st_girl &amp;p1,<span class="type">const</span> st_girl &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p1.name,p2.name)&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序函数，按超女年龄排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sortbyage</span><span class="params">(<span class="type">const</span> st_girl &amp;p1,<span class="type">const</span> st_girl &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p1.age&lt;p2.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;             <span class="comment">// 超女数据结构</span></span><br><span class="line">  std::vector&lt;<span class="keyword">struct</span> st_girl&gt; vgirl; <span class="comment">// 存放超女结构体的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>); stgirl.age=<span class="number">18</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;杨玉环&quot;</span>); stgirl.age=<span class="number">28</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sort(vgirl.begin(),vgirl.end());   // 如果不指定排序函数，编译将报错</span></span><br><span class="line">  <span class="comment">//sort(vgirl.begin(),vgirl.end(),sortbyname); // 按超女的姓名排序</span></span><br><span class="line">  <span class="built_in">sort</span>(vgirl.<span class="built_in">begin</span>(),vgirl.<span class="built_in">end</span>(),sortbyage);  <span class="comment">// 按超女的年龄排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vgirl.<span class="built_in">size</span>();ii++) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vgirl[%d].name=%s,vgirl[%d].age=%d\n&quot;</span>,\</span><br><span class="line">            ii,vgirl[ii].name,ii,vgirl[ii].age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>1）编写示例程序，类似本章节的book220.cpp、book222.cpp、book225.cpp、book227.cpp，编译并运行它，记住，程序员是写出来的，不是看出来的，熟能生巧，您每天的付出都有意义。</p><p>2）编写示例程序，测试一下vector容器其它成员函数的用法，玩一下就行了，有些成员函数以后可能有用。</p><p>3）丰富您的函数库，写一个类，封装随机数功能，类的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_val;  <span class="comment">// 用于存放生成好的随机数</span></span><br><span class="line">  <span class="built_in">CRand</span>();</span><br><span class="line"> ~<span class="built_in">CRand</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Rand</span><span class="params">(<span class="type">const</span> <span class="type">int</span> minvalue,<span class="type">const</span> <span class="type">int</span> maxvalue,<span class="type">bool</span> brep=<span class="literal">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>(1）随机数的种子不能只用time(0)的秒，还可以利用微秒，同一秒内取到的随机数将不同。</p><p>(2）Rand(const int minvalue,const int maxvalue,bool brep=true)生成指定范围的随机数，minvalue是最小值，maxvalue是最大值，brep是否允许重复。</p><p>4）vector容器的排序在实际开发中应用比较多，必须掌握。</p><p>5）vector容器存放超女类，能不写排序函数吗？如果存放string类，能不写排序函数吗？为什么？</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的string类</title>
      <link href="/post/aee85e8.html"/>
      <url>/post/aee85e8.html</url>
      
        <content type="html"><![CDATA[<p>在C语言中，用0结束的字符数组表示字符串，有些不方便：1）数组定义后大小不能改变；2）存入的内容只能比数组小，不能大，如果不小心存多了，会引起内存的溢出，这些问题让程序员有些郁闷。</p><p>C++的string属于STL（Standard Template Library,标准模板库）中的定义的类，它会随存放字符的长度自动伸缩，程序员不必担心内存溢出的问题，string类还和C语言的字符串之间还可以很方便的转换。</p><h1 id="一-string的声明"><a class="markdownIt-Anchor" href="#一-string的声明"></a> 一、string的声明</h1><p>首先，为了在程序中使用string类，必须包含头文件 &lt;string&gt;。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意这里不是string.h，string.h是C语言字符串头文件。</p><p>string是一个模板类，位于std命名空间内，为方便使用还需要在程序中增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">// 指定缺省的使名空间。</span></span><br><span class="line">string str;       <span class="comment">// 创建string对象。</span></span><br></pre></td></tr></table></figure><p>如果不指定命名空间，也就是说没有using namespace std，创建string对象的方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br></pre></td></tr></table></figure><p><strong>示例（book215.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book215.cpp，此程序用于演示C++string类。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">char</span> str1[<span class="number">31</span>];   <span class="comment">// C语言风格的字符串。</span></span><br><span class="line">  <span class="built_in">memset</span>(str1,<span class="number">0</span>,<span class="built_in">sizeof</span>(str1));</span><br><span class="line">  <span class="built_in">strcpy</span>(str1,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"></span><br><span class="line">  string str2;     <span class="comment">// C++的string字符串</span></span><br><span class="line"></span><br><span class="line">  str2=<span class="string">&quot;沉鱼&quot;</span>;     <span class="comment">// 对str2赋值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str2=%s\n&quot;</span>,str2.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断str2和str1是否相等</span></span><br><span class="line">  <span class="keyword">if</span> (str2!=str1) <span class="built_in">printf</span>(<span class="string">&quot;str2=%s,str1=%s，不相等。\n&quot;</span>,str2.<span class="built_in">c_str</span>(),str1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(str1,str2.<span class="built_in">c_str</span>());   <span class="comment">// 把string的内容赋值给C语言风格的字符串。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str1=%s\n&quot;</span>,str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305110046143.png" alt="在这里插入图片描述" /></p><h1 id="二-string的重载的操作符"><a class="markdownIt-Anchor" href="#二-string的重载的操作符"></a> 二、string的重载的操作符</h1><p>可以用=直接赋值。</p><p>可以用 ==、&gt;、&lt;、&gt;=、&lt;=、和!=比较字符串。</p><p>可以用+或者+=操作符连接两个字符串。</p><p>可以用[]获取指定位置的字符，类似数组。</p><h1 id="三-最重要的一个成员函数"><a class="markdownIt-Anchor" href="#三-最重要的一个成员函数"></a> 三、最重要的一个成员函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span></span>;  </span><br></pre></td></tr></table></figure><p>string类采用动态分配内存的方式来存放字符串，c_str函数返回这个字符串的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str1;</span><br><span class="line">str1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">31</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str2,str1.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h1 id="四-string特性描述函数"><a class="markdownIt-Anchor" href="#四-string特性描述函数"></a> 四、string特性描述函数</h1><p>可用下列函数来获得string的一些特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;             <span class="comment">// 返回当前字符串的大小。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>;           <span class="comment">// 返回当前字符串的长度，注意和size的区别。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;           <span class="comment">// 清空字符串。</span></span><br></pre></td></tr></table></figure><h1 id="五-string的其它成员函数"><a class="markdownIt-Anchor" href="#五-string的其它成员函数"></a> 五、string的其它成员函数</h1><p>string提供了上百个成员函数，非常丰富，丰富得有点眼花，各位自己找资料，有空的时候再研究一下，断章取义的使用。</p><h1 id="六-string的本质"><a class="markdownIt-Anchor" href="#六-string的本质"></a> 六、string的本质</h1><p>string是一个类，通过动态分配内存，实现对字符串的存储，我们来看以下代码。</p><p><strong>示例（book216.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book216.cpp，此程序用于演示C++的string类的字符串的地址。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  std::string str;</span><br><span class="line"></span><br><span class="line">  str=<span class="string">&quot;www&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str=str+<span class="string">&quot;.freecplus&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str=<span class="string">&quot;freecplus&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str=<span class="string">&quot;www.freecplus.net&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305110342525.png" alt="在这里插入图片描述" /></p><p>通过以上的例子，我们可以看到，string对象用于存放字符的内存地址是变化的，当前空间如果不足，就重新分配一个新的内存，同时会释放之前的内存，不是什么神奇的技术。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>C++的string类是一个变长的字符串，不需要程序员担心内存溢出的问题，还提供了很多字符串操作函数，初学者可能会想，用它取代C语言中的字符串（以0结尾的字符数组）一定是个很好的主意。我要告诉各位，这是不可能的，因为string中的字符串存储的内存空间没有固定的位置（它也没办法有固定位置）。</p><p>对初学者来说，用C/C++写一些简单的程序，做一些简单的事情，不懂得实际项目开发的需求，例如Oracle和MySQL数据库提供的接口，在交换数据的时候需要绑定一个固定的地址，string是做不到的。</p><p>我的建议是采用string存放一些需要动态分配内存的临时数据，避开动态内存技术带来的坑，然后转换为C的字符串。C的字符串没有string类那么丰富的成员函数，这个不是问题，我们可以自己写，这也是我不想介绍string成员函数的原因，与其花时间去研究string的成员函数，还不如自己写一个。</p><p>了解string类的原理和一些用得着的成员函数就可以了，不必太深入研究，意义不大。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>上网找C++string的资料，看看它的成员函数和重载的操作符，如果觉得有用，就编写代码测试一下，了解一下大概情况。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符重载</title>
      <link href="/post/1dfa3723.html"/>
      <url>/post/1dfa3723.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-运算符重载的概念"><a class="markdownIt-Anchor" href="#一-运算符重载的概念"></a> 一、运算符重载的概念</h1><p>在C语言中，运算符只能用于基本数据类型，例如，可以用==判断两个整数是否相等，但不能用于判断字符串是否相等，不能用于判断结构体，也不能用于判断类。</p><p>在C++中，运算符的重载就是把运算符的符号赋予新的含义，如果类重载了 == 运算符，那么就可以用== 判断两个类是否相等。</p><h1 id="二-运算符重载的实现"><a class="markdownIt-Anchor" href="#二-运算符重载的实现"></a> 二、运算符重载的实现</h1><p>operator是C++的一个关键字，它和运算符一起使用，表示一个运算符重载函数，在理解时可将operator和运算符（如operator==）视为类的一个成员函数名。</p><p><strong>示例（book214.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book214.cpp，此程序用于演示C++运算符重载。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CGirl &amp;Girl)  <span class="comment">// 重载==运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CGirl Girl1,Girl2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Girl1.m_name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(Girl2.m_name,<span class="string">&quot;东施&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (Girl1 == Girl2) <span class="built_in">printf</span>(<span class="string">&quot;Girl1和Girl2是同一个人。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Girl1和Girl2不是同一个人。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> CGirl::<span class="keyword">operator</span>==(<span class="type">const</span> CGirl &amp;Girl)  <span class="comment">// 重载==运算符</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">// 如果两个类的姓名相同，就相等</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(m_name,Girl.m_name)== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGirl类重载了==运算符，定义了operator==函数，用于判断两个对象是否相等，实际上是判断两个对象的成员变量m_name是否相同，如果相同，对象就相等。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305102701815.png" alt="在这里插入图片描述" /></p><p>通过上述结果能够知道，因为操作符重载函数operator==是CGirl类的一个成员函数，所以对象Girl1、Girl2都可以调用该函数。其中的 if (Gril1 ==Gril2) 语句，相当于对象Gril1调用函数operator==，把对象Girl2作为一个参数传递给该函数，从而实现了两个对象的比较。</p><p>我们把语句改为if (Gril1 ！= Gril2) ，会如何？编译如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305102734354.png" alt="在这里插入图片描述" /></p><p>编译无法通过，因为CGirl类并没有重载!=运算符。</p><h1 id="三-个人经验"><a class="markdownIt-Anchor" href="#三-个人经验"></a> 三、个人经验</h1><p>下一章节中将学习C++的string类，它重载了+、=、==、!=等运算符，对程序员来说，确实感觉有些方便。</p><p>在实际开发中，重载运算符有可能会模糊程序员的意图，如果要判断Girl1和Girl2的m_name成员是否相等，我更愿意用strcmp函数。</p><p>很久很久以前，学习了运算符重载的时候，可以把各种运算符重载成奇奇怪怪的功能，觉得很好玩，后来就不玩了，感觉没什么意思。</p><p>运算符重载还有很多其它的知识，我就不介绍了。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>对CGirl重载!=操作符试试。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="/post/101de459.html"/>
      <url>/post/101de459.html</url>
      
        <content type="html"><![CDATA[<p>对于习惯使用C进行开发的程序员来说，在看到C<ins>中出现的&amp;符号，可能会犯迷糊，因为在C语言中这个符号表示了取地址符，但是在C</ins>中，它除了取地址，还有其它的用途，叫做引用（reference），引用是C++的新特性。</p><h1 id="一-引用的概念"><a class="markdownIt-Anchor" href="#一-引用的概念"></a> 一、引用的概念</h1><p>引用就是变量的别名，对引用的操作与对变量直接操作完全一样。</p><p>引用的声明方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 &amp;引用名=目标变量名；</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; </span><br><span class="line"><span class="type">int</span> &amp;ra=a;  <span class="comment">// 定义引用ra，它是变量a的引用，即别名。</span></span><br><span class="line">ra=<span class="number">1</span>;  等价于  a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>1）&amp;在此不是求地址运算，而是起标识作用。</p><p>2）类型标识符是指目标变量的类型。</p><p>3）声明引用时，必须同时对其进行初始化，否则编译器会报错，所以，不能再把引用名作为其他变量名的别名。</p><p>4）引用声明后，相当于目标变量名有两个名称。</p><p>5）声明一个引用，不是新定义了一个新的变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。</p><p>6）不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法对数据建立引用。</p><p>7）引用可以用const修饰，表示只读，用这种方式声明的引用，不能通过引用对目标变量的值进行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ra=a;</span><br><span class="line">a=<span class="number">10</span>;    <span class="comment">// 可以</span></span><br><span class="line">ra=<span class="number">10</span>;   <span class="comment">// 不行</span></span><br></pre></td></tr></table></figure><h1 id="二-引用的应用"><a class="markdownIt-Anchor" href="#二-引用的应用"></a> 二、引用的应用</h1><p>引用的主要作用就是作为函数的参数。</p><p>在C语言中函数参数是值传递，如果有大块数据作为参数传递的时候，采用的方案是传递数据的地址。</p><p>在C++中，又增加了一种同样有效率的选择，就是引用。</p><p><strong>示例（book212.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book212.cpp，此程序用于演示C++的引用</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *a)</span> <span class="comment">// a是一个指针变量</span></span></span><br><span class="line"><span class="function"></span>&#123; *a=<span class="number">20</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;ra)</span> <span class="comment">// ra是一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123; ra=<span class="number">30</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>(&amp;ii);  <span class="comment">// 传递变量的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1 ii=%d\n&quot;</span>,ii);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>(ii);   <span class="comment">// 引用</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2 ii=%d\n&quot;</span>,ii);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305100641536.png" alt="在这里插入图片描述" /></p><p>从以上的示例可以看出，传递引用给函数与传递指针的效果是一样的。这时，被调函数的参数就成为调用者调函数中的变量或对象的一个别名来使用，所以在被调函数中对引用的操作就是对目标变量的操作。</p><p>在很多资料中，把引用的优点过于夸大，在我看来，引用的好处就是调用函数的时候，不用填写取地址符&amp;，子函数中也不写取变量符*，结构体和类不用-&gt;取成员。但我更倾向传递地址的方式，更直观，不管是在函数内部还是函数被调用的地方，一眼就能清楚是否是地址。</p><p>引用还可以作为函数的返回值，但我不建议这么用，我实在看不出这样做有什么好处，那就没必要把事情搞得那么复杂，所以这里就不介绍了。</p><h1 id="三-课后作业"><a class="markdownIt-Anchor" href="#三-课后作业"></a> 三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的详解</title>
      <link href="/post/fbe69a85.html"/>
      <url>/post/fbe69a85.html</url>
      
        <content type="html"><![CDATA[<p>超女选秀的例子我们玩了很久，为了学习的需要，暂时离开美眉们，我将采用实际项目开发的例子来讲解类的更多知识。</p><p>在C语言基础知识中已学习过文件操作，在实际开发中，为了提高效率，我会把文件操作封装成一个类，类的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件操作类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FILE *m_fp;        <span class="comment">// 文件指针</span></span><br><span class="line">  <span class="type">bool</span>  m_bEnBuffer; <span class="comment">// 是否启用缓冲区，true-启用；false-不启用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer);   <span class="comment">// 类的构造函数</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;  <span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开文件，参数与fopen相同，打开成功true，失败返回false          </span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fprintf向文件写入数据</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ... )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fgets从文件中读取一行</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Fgets</span><span class="params">(<span class="type">char</span> *strBuffer,<span class="type">const</span> <span class="type">int</span> ReadSize)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="一-类成员的访问权限"><a class="markdownIt-Anchor" href="#一-类成员的访问权限"></a> 一、类成员的访问权限</h1><p>C++通过 public、protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是类外面的代码访问该类中成员权限。</p><p>在类的内部，即类的成员函数中，无论成员被声明为 public、protected 还是private，都是可以互相访问的，没有访问权限的限制。</p><p>在类的外部（定义类的代码之外），只能通过对象访问public的成员，不能访问 private、protected属性的成员。</p><p>本节重点介绍 public 和 private，protected 将在以后介绍。</p><p>private 后面的成员都是私有的，如m_fp和m_bEnBuffer，直到有 public出现才会变成共有的；public 之后再无其他限定符，所以 public后面的成员都是共有的。</p><p>private关键字的作用在于更好地隐藏类的内部实现，该向外暴露的接口（能通过对象访问的成员）都声明为public，不希望外部知道、或者只在类内部使用的、或者对外部没有影响的成员，都建议声明为private。</p><p>声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private部分，也可以先出现 public 部分。如果既不写 private 也不写 public，就默认为private。</p><p>在一个类体中，private 和 public可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。</p><p>您可能会说，将成员变量全部设置为 public 省事，确实，这样做 99.9%的情况下都不是一种错误，我也不认为这样做有什么不妥；但是，将成员变量设置为private 是一种软件设计规范，尤其是在大中型项目中，还是请大家尽量遵守这一原则。</p><h1 id="二-成员变量的命名"><a class="markdownIt-Anchor" href="#二-成员变量的命名"></a> 二、成员变量的命名</h1><p>成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的参数名字区分开。</p><p>例如成员函数EnBuffer的函数体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-构造函数"><a class="markdownIt-Anchor" href="#三-构造函数"></a> 三、构造函数</h1><p>在CFile类的声明中，有一些特殊的成员函数CFile()，它就是构造函数（constructor）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数</span></span><br><span class="line"><span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer);   <span class="comment">// 类的构造函数</span></span><br></pre></td></tr></table></figure><p>构造函数的名字和类名相同，没有返回值，不能被显式的调用，而是在创建对象时自动执行。</p><p>构造函数具备以下特点：</p><p>1）构造函数必须是 public 属性。</p><p>2）构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是void 也不允许。</p><p>3）构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。</p><p>4）构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，注意，不能用memset对整下类进行初始化。</p><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CFile::<span class="built_in">CFile</span>()   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::<span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer)   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-析构函数"><a class="markdownIt-Anchor" href="#四-析构函数"></a> 四、析构函数</h1><p>在CFile类的声明中，还有一个特殊的成员函数~CFile()，它就是析构函数（destructor）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数</span></span><br></pre></td></tr></table></figure><p>析构函数的名字在类的名字前加~，没有返回值，但可以被显式的调用，在对象销毁时自动执行，用于进行清理工作，例如释放分配的内存、关闭打开的文件等，这个用途非常重要，可以防止程序员犯错。</p><p>析构函数具备以下特点：</p><p>1）构造函数必须是 public 属性的。</p><p>2）构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是void 也不允许。</p><p>3）析构函数不允许重载的。一个类只能有一个析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFile::~<span class="built_in">CFile</span>()   <span class="comment">// 类的析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Close</span>();  <span class="comment">// 调用Close释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-c程序也很优雅"><a class="markdownIt-Anchor" href="#五-c程序也很优雅"></a> 五、C++程序也很优雅</h1><p>很多人说C/C<ins>程序很烦锁，python程序很优雅，说这话人的很荒谬，那是因为他C/C</ins>并不了解，只要我们愿意，可以写出和python一样优雅简洁的代码，在book210.cpp中，main函数的代码极为精简。</p><p>示例（book210.cpp）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book210.cpp，此程序演示用C++类的更多知识。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件操作类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FILE *m_fp;        <span class="comment">// 文件指针</span></span><br><span class="line">  <span class="type">bool</span>  m_bEnBuffer; <span class="comment">// 是否启用缓冲区，true-启用；false-不启用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer);   <span class="comment">// 类的构造函数</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;  <span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开文件，参数与fopen相同，打开成功true，失败返回false          </span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fprintf向文件写入数据</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,... )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fgets从文件中读取一行</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Fgets</span><span class="params">(<span class="type">char</span> *strBuffer,<span class="type">const</span> <span class="type">int</span> ReadSize)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc !=<span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;请输入待打开的文件名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (File.<span class="built_in">Open</span>(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;File.Open(%s)失败。\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> strLine[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123; <span class="comment">// 从文件中读取每一行</span></span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Fgets</span>(strLine,<span class="number">300</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,strLine);   <span class="comment">// 把从文件中读到的内容显示到屏幕</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::<span class="built_in">CFile</span>()   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::<span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer)   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Close</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_fp!=<span class="number">0</span>) <span class="built_in">fclose</span>(m_fp);  <span class="comment">// 关闭文件指针</span></span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::~<span class="built_in">CFile</span>()   <span class="comment">// 类的析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Close</span>();  <span class="comment">// 调用Close释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件，参数与fopen相同，打开成功true，失败返回false          </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CFile::Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Close</span>();  <span class="comment">// 打开新的文件之前，如果已经打开了文件，关闭它。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (m_fp=<span class="built_in">fopen</span>(filename,openmode)) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用fprintf向文件写入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( m_fp == <span class="number">0</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(arg,ap);</span><br><span class="line">  <span class="built_in">vfprintf</span>(m_fp,fmt,ap);</span><br><span class="line">  <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( m_bEnBuffer == <span class="literal">false</span> ) <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用fgets从文件中读取一行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CFile::Fgets</span><span class="params">(<span class="type">char</span> *strBuffer,<span class="type">const</span> <span class="type">int</span> ReadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( m_fp == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strBuffer,<span class="number">0</span>,ReadSize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fgets</span>(strBuffer,ReadSize,m_fp) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>book210运行的效果就是把文件的内容一行一行的显示出来，类型linux系统的cat命令。</p><p><img src="https://img-blog.csdnimg.cn/20200305094411346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="六-类的其它知识"><a class="markdownIt-Anchor" href="#六-类的其它知识"></a> 六、类的其它知识</h1><p>关于类的其它知识，包括this指针、static静态成员、友元等内容，意义不大，我不介绍了，时间太宝贵，有太多重要的知识要学习，没必要把时间浪费在这些不痛不痒又没什么实用价值的知识点上，大家以后有时间了再看也行。</p><h1 id="七-可变参数"><a class="markdownIt-Anchor" href="#七-可变参数"></a> 七、可变参数</h1><p>我们已经介绍过printf、fprintf、sprintf、snprintf函数，它们是一组功能相似的函数，并且有一个共同点，就是函数的参数列表是可以变化的。</p><p>函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;        <span class="comment">// 格式化输出到屏幕</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;  <span class="comment">// 格式化输出到文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;     <span class="comment">// 格式化输出到字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>; <span class="comment">// 格式化输出指定长度的内容到字符串</span></span><br></pre></td></tr></table></figure><p>在实际开发中，我们的自定义函数也会用到可变参数，实现类似上述函数的功能，例如CFile类的Fprintf成员函数。</p><p>C语言采用va_start宏、va_end宏和一系列函数来实现可变参数功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( m_fp == <span class="number">0</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(arg,ap);</span><br><span class="line">  <span class="built_in">vfprintf</span>(m_fp,fmt,ap);</span><br><span class="line">  <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( m_bEnBuffer == <span class="literal">false</span> ) <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以CFile类的Fprintf成员函数为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;     <span class="comment">// 可变参数自定义函数的声明方法</span></span><br></pre></td></tr></table></figure><p>va_list指针、va_start宏、va_end宏用于分析参数，难以理解，大家会用就行，我不详细介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line"><span class="built_in">va_start</span>(ap,fmt);</span><br><span class="line"><span class="built_in">vfprintf</span>(m_fp,fmt,ap);     </span><br><span class="line"><span class="built_in">va_end</span>(ap);</span><br></pre></td></tr></table></figure><p>vfprintf函数把宏分析的结果输出到文件，还有一系列功能相似的函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出的屏幕</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到字符串，第二个参数指定了输出结果的长度，类似snprintf函数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>1）编写示例程序，测试类的类成员的访问权限。</p><p>2）编写示例程序，测试类的构造函数和它的重载，采用gdb跟踪构造函数的执行过程。</p><p>3）编写示例程序，测试类的析构函数，采用gdb跟踪析构造的执行过程。</p><p>4）编写示例程序，实现printf、sprintf和snprintf函数的功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mysprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mysnprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>5）类定义包括成员变量和成员函数的声明以及成员函数的定义，在实际开发中，我们通常将公共类的声明放在头文件中（如_public.h），成员函数的定义放在程序文件中（如_public.cpp），请按这种方式修改book210.cpp程序，增加_public.h和_public.cpp程序，修改makefile。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类和对象</title>
      <link href="/post/7368673d.html"/>
      <url>/post/7368673d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-c结构体的新特征"><a class="markdownIt-Anchor" href="#一-c结构体的新特征"></a> 一、C++结构体的新特征</h1><p>C语言的结构体不允许有函数，定义结构体变量的方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名 结构体变量名;</span><br></pre></td></tr></table></figure><p>在C++中，结构体的成员可以有函数，定义结构体变量可以用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体名 结构体变量名;</span><br></pre></td></tr></table></figure><p>struct关键字可以不书写。</p><p><strong>示例（book202.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book202.cpp，此程序用于演示C++结构体的新特征。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">show</span><span class="params">()</span></span>;       <span class="comment">// 声明结构体成员函数show，用于显示其它成员变量的值。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  st_girl stgirl;      <span class="comment">// struct关键定可以不书写</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;stgirl,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirl));</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">  stgirl.age=<span class="number">22</span>;</span><br><span class="line">  stgirl.height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  stgirl.<span class="built_in">show</span>();  <span class="comment">// 调用结构体的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">st_girl::show</span><span class="params">()</span>   <span class="comment">// 结构体st_girl成员函数的定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\n&quot;</span>,name,age,height,sc,yz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030509035835.png" alt="在这里插入图片描述" /></p><h1 id="二-c-类和对象"><a class="markdownIt-Anchor" href="#二-c-类和对象"></a> 二、C++ 类和对象</h1><p>我们先来做一个测试，修改一下book202.cpp的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">st_girl::show</span><span class="params">()</span>   <span class="comment">// 结构体st_girl成员函数的定义</span></span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">st_girl::show1</span><span class="params">()</span>   <span class="comment">// 结构体st_girl成员函数的定义</span></span></span><br></pre></td></tr></table></figure><p>修改后再编译。</p><p><img src="https://img-blog.csdnimg.cn/20200305090443927.png" alt="在这里插入图片描述" /></p><p>上图中，方框内的文字“未在类st_girl中声明”？我明明写的是一个结构体，怎么成了类？</p><p>C++把结构体看成了类（class），类的成员可以是变量和函数，通过类定义出来的变量也有特定的称呼，叫做对象。</p><p><strong>示例（book205.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book205.cpp，此程序演示用类的基本概念。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span></span>;      <span class="comment">// 申明显示超女基本信息的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CGirl Girl;   <span class="comment">// 实例化一个Girl对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问对象的成员变量，进行赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(Girl.m_name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  Girl.m_age=<span class="number">28</span>;      </span><br><span class="line">  Girl.m_height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(Girl.m_sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(Girl.m_yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Girl.<span class="built_in">Show</span>();   <span class="comment">// 调用对象的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CGirl::Show</span><span class="params">()</span>  <span class="comment">// 显示超女基本信息的成员函数体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s。\n&quot;</span>,m_name,m_age,m_height,m_sc,m_yz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305090548328.png" alt="在这里插入图片描述" /></p><p>解释一下book205.cpp。</p><p><strong>class</strong>是C++的关键字，用于定义类，就像结构体中的<strong>sturct</strong>。</p><p><strong>public</strong>也是C++中的关键字，各位先忽略它，后面再讲解，先这么抄就行。</p><p>类的成员变量和结构体成员变量一样，也有数据类型和名称。</p><p>int CGirl::Show()是类的成员函数的定义，在函数前加上类的名称和两个冒号，表示该函数是这个类的成员函数，类的成员函数的返回值、参数等语法与普通函数相同。</p><p>在C++中，用类定义一个类的变量叫做创建（或实例化）一个对象，成员变量称为类的属性（property），成员函数称为类的方法（method）。</p><p>类的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。</p><h1 id="三-对象数组"><a class="markdownIt-Anchor" href="#三-对象数组"></a> 三、对象数组</h1><p>类可以创建数组对象，就像结构体数组一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGirl Girl[<span class="number">10</span>];    <span class="comment">// 定义10个超女类数组</span></span><br><span class="line"><span class="built_in">strcpy</span>(Girl[<span class="number">0</span>].m_name,<span class="string">&quot;杨玉环&quot;</span>);</span><br><span class="line">Girl[<span class="number">0</span>].m_age=<span class="number">18</span>;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">strcpy</span>(Girl[<span class="number">9</span>].m_name,<span class="string">&quot;陈圆圆&quot;</span>);</span><br><span class="line">Girl[<span class="number">9</span>].m_age=<span class="number">21</span>;</span><br></pre></td></tr></table></figure><h1 id="四-对象的指针"><a class="markdownIt-Anchor" href="#四-对象的指针"></a> 四、对象的指针</h1><p>类是一种自定义的数据类型，对象是内存变量，有内存地址，当然也就有类的指针，就像结构体的指针一样。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGirl queen;</span><br><span class="line">CGirl *pst=&amp;queen;</span><br></pre></td></tr></table></figure><p>通过类指针可以访问对象的成员，书写方法与结构体相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pointer).memberName</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure><p>上面的两种写法是等效的，我们通常采用后面的写法，这样更加直观。</p><h1 id="五-对象作为函数的参数"><a class="markdownIt-Anchor" href="#五-对象作为函数的参数"></a> 五、对象作为函数的参数</h1><p>与结构体一样，对象可以作为参数传递给函数，最好的方法当然是传递对象的地址。</p><h1 id="六-对象的初始化和占用内存的大小"><a class="markdownIt-Anchor" href="#六-对象的初始化和占用内存的大小"></a> 六、对象的初始化和占用内存的大小</h1><p>按我们以前的经验，定义的变量使用前要初始化，C语言的基本数据类型可以直接赋值0，字符串和结构体用memset函数初始化，那么类的对象呢？对象不能用memset初始化，具体做法我们以后再介绍。</p><p>对象可以用sizeof运算符获取占用内存的大小，但是，在实际开发中，程序员不太关心对象占用内存的大小。</p><h1 id="七-小结"><a class="markdownIt-Anchor" href="#七-小结"></a> 七、小结</h1><p>在这个阶段，类就像一个有成员函数的结构体，定义的关键字和语法不同，使用方法完全相同。</p><p>各位可能会认为类好像没什么用，不用类也可以活得很好，这不一定，因为我先用尽可能简单的方式介绍类的基础知识，如果把实际开发的场景搬到教材中，大家可能接受不了，在实际开发中，某些类的代码非常长，类的声明就有好几页，还不包括成员函数体。</p><p>希望各位保持好的心态，循序渐进的学习。</p><h1 id="八-面向对象编程object-oriented-programmingoop"><a class="markdownIt-Anchor" href="#八-面向对象编程object-oriented-programmingoop"></a> 八、面向对象编程（Object Oriented Programming，OOP）</h1><p>类是一个通用的概念，C++、Java、C#、PHP等很多编程语言中都支持类，都可以通过类创建对象。因为 C++、Java、C#、PHP等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言，有点欺负人。</p><p>在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，而在C++中，多了一层封装，就是类（class），不要小看类（class）这一层封装，它有很多特性，极大地提高了程序员的开发效率。</p><p>面向对象编程在程序执行的效率上没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路。</p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>1）编写程序，测试对象数组、对象指针、对象作为函数的参数的用法。</p><p>2）参照book205.cpp程序，增加一个成员函数Level，Level函数根据超女资料，判断超女的级别，级别的判断标准如下：</p><p>妃子：（1）年龄18-25岁；（2）身高165-178cm；（3）身材火辣；（4）颜值漂亮。</p><p>宫女：（1）年龄18-30岁；（2）身高160-165cm；（3）身材火辣或者普通；（4）颜值一般。</p><p>杂役：（1）年龄35-40岁；（2）身高155-165cm；（3）身材普通或者飞机场；（4）颜值一般。</p><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数重载</title>
      <link href="/post/4f972a4b.html"/>
      <url>/post/4f972a4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-函数重载的概念"><a class="markdownIt-Anchor" href="#一-函数重载的概念"></a> 一、函数重载的概念</h1><p>在实际开发中，有时候我们需要实现几个功能类似的函数，例如把变量的值写入文件，变量的类型可能是int、long、double、char，通过参数把变量传入函数。在C语言中不允许函数同名，程序员只能设计出四个不同名的函数，其函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_int</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> value)</span></span>;  <span class="comment">// 写入int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_long</span><span class="params">(<span class="type">char</span> *filename,<span class="type">long</span> value)</span></span>;  <span class="comment">// 写入long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_double</span><span class="params">(<span class="type">char</span> *filename,<span class="type">double</span> value)</span></span>; <span class="comment">// 写入double</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_char</span><span class="params">(<span class="type">char</span> *filename,<span class="type">char</span> *value)</span></span>; <span class="comment">// 写入char字符串</span></span><br></pre></td></tr></table></figure><p>C语言中函数命名不能重复对程序员是一种负担，编程序的时候需要想象出相近的函数名，调用函数的时候，书写函数名也是一件麻烦的事情。</p><p>C++允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading），借助重载，多个功能相近的一系列函数可以使用同一函数名。</p><p>函数的参数列表包括<strong>参数的类型、参数的个数和参数的顺序</strong>，只要有一个不同就叫做参数列表不同。</p><p>使用C++函数重载，把变量的值写入文件的函数声明修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> value)</span></span>;     <span class="comment">// 写入int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">long</span> value)</span></span>;   <span class="comment">// 写入long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">double</span> value)</span></span>; <span class="comment">// 写入double</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">char</span> *value)</span></span>;   <span class="comment">// 写入char字符串</span></span><br></pre></td></tr></table></figure><p>重载就是在一个作用范围内（同一个程序、同一个类、同一个命名空间等）有多个<strong>名称相同但参数列表不同</strong>的一系列函数。</p><p>在使用重载函数时，同名函数的功能应当相似，不要用相同名称的函数名去实现不相干的功能，虽然程序也能运行，但可读性不好，使人觉得莫名其妙。</p><p>注意，参数列表不同包括参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的，函数返回值也不能作为重载的依据。</p><h1 id="二-c-是如何做到函数重载的"><a class="markdownIt-Anchor" href="#二-c-是如何做到函数重载的"></a> 二、C++ 是如何做到函数重载的</h1><p>编译器在编译C++程序时会根据参数列表对函数进行重命名，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> value)</span></span>;  </span><br></pre></td></tr></table></figure><p>重命名为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _writetofile_char_int(<span class="type">char</span> *filename,<span class="type">int</span> value); </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">long</span> value)</span></span>; </span><br></pre></td></tr></table></figure><p>重命名为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _writetofile_char_long(<span class="type">char</span> *filename,<span class="type">long</span> value);   </span><br></pre></td></tr></table></figure><p>程序被编译时，编译器会根据参数列表逐个匹配，选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。</p><p>所以，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p><h1 id="三-函数重载的示例"><a class="markdownIt-Anchor" href="#三-函数重载的示例"></a> 三、函数重载的示例</h1><p>我们在介绍C语言字符串的时候，学习了strcpy函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>strcpy函数有两个缺陷：1）没有对dest变量进行初始化；2）如果src的长度超过dest，会造成内存溢出。</p><p>我们现在来重写strcpy函数，弥补这两个缺陷，新函数名还是采用strcpy命名，但参数列表不同，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src,<span class="type">size_t</span> destsize)</span></span>;</span><br></pre></td></tr></table></figure><p>dest和src参数的含义与库函数strcpy相同，第三个参数destsize是dest占用内存的大小。</p><p><strong>示例（book201.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book201.cpp，此程序用于演示C++函数重载，修复strcpy函数的缺陷</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载strcpy函数，对dest初始化，防止内存溢出。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src,<span class="type">size_t</span> destsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(dest,<span class="string">&quot;www.freecplus.net&quot;</span>,<span class="built_in">sizeof</span>(dest));  <span class="comment">// 新strcpy</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,dest);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(dest,<span class="string">&quot;www.freecplus.net&quot;</span>);   <span class="comment">// 旧strcpy</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载strcpy函数，对dest初始化，防止内存溢出</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src,<span class="type">size_t</span> destsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dest,<span class="number">0</span>,destsize);  <span class="comment">// 对dest初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算需要复制的字符数，不能超出destsize-1</span></span><br><span class="line">  <span class="type">size_t</span> len=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(src)&lt;=destsize<span class="number">-1</span>) len=<span class="built_in">strlen</span>(src);</span><br><span class="line">  <span class="keyword">else</span> len=destsize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strncpy</span>(dest,src,len);   <span class="comment">// 复制字符串，超出的将扔掉</span></span><br><span class="line">  dest[len]=<span class="number">0</span>;  <span class="comment">// 强制字符串的结尾标志</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305084737560.png" alt="在这里插入图片描述" /></p><p>C语言提供了一些库函数，这些库函数的功能肯定不能满足实际开发的需求，需要程序员重新扩展加固，这是优秀程序员与普通程序员的差别。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><p>2）编写示例程序，测试函数的返回值不同能否作为函数重载的依据。</p><p>3）编写示例程序，测试函数的参数名不同能否作为函数重载的依据。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C到C++</title>
      <link href="/post/569d6b79.html"/>
      <url>/post/569d6b79.html</url>
      
        <content type="html"><![CDATA[<p>C<ins>读作“C加加”，是“C Plus Plus”的简称，C</ins>是在C语言的基础上增加新特性，从语法上看，C语言是C++ 的一部分，C语言代码几乎不用修改就能够以 C++ 的方式编译。</p><p>对于C和C<ins>的关系，有很多种说法，从表面上看，很容易认为C</ins>是C的升级版，C<ins>比C高大上，C过时了，有这种想法说明他不了解C/C</ins>语言，我们先来看看世界编程语言排行榜，下表是2019的数据（过去十年的数据也大致如此）。<br /><img src="https://img-blog.csdnimg.cn/20200314150950928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />从上表中看出，这个世界上的C程序员比C++程序员多很多。</p><p>这么多年了，我也搞不清楚自己是C程序员，还是C++程序员，好像没什么差别。</p><p>C<ins>有很多新的特征，这些新特征并不一定实用，甚至很烦人。但是，C</ins>的开发效率确实比C要高，所以我仍然采用断章取义的方式来介绍C<ins>的知识。不管是C还是C</ins>，实用就好。</p><h1 id="一-c程序的命名规则"><a class="markdownIt-Anchor" href="#一-c程序的命名规则"></a> 一、C++程序的命名规则</h1><p>C++头文件一般采用.h后缀，也用有.hpp的。</p><p>C<ins>程序文件一般采用.cpp后缀，也有用.cc的，建议采用.cpp，C</ins>对程序文件的命名没有强制要求，采用.cpp为后缀是大部分程序员的习惯。</p><h1 id="二-c程序的编译"><a class="markdownIt-Anchor" href="#二-c程序的编译"></a> 二、C++程序的编译</h1><p>在某些操作系统中，C和C<ins>是同一个编译器，在CentOS中，C的编译器是gcc，C</ins>的编译器是g++。</p><h2 id="1-安装g编译器"><a class="markdownIt-Anchor" href="#1-安装g编译器"></a> 1、安装g++编译器</h2><p>用root用户登录服务器，执行以下命令安装或升级gcc-c++编译器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install  gcc-c++ </span><br></pre></td></tr></table></figure><p>如果您的CentOS系统没有安装gcc-c++，以上命令就会安装最新版本的gcc-c++，如果已经安装了gcc-c++，就会更新到最新版本的gcc-c++，所以，以上命令不管执行多少次都没有问题。</p><p>安装gcc-c++的前提条件是服务器必须可以访问互联网。</p><h2 id="2-编译c程序"><a class="markdownIt-Anchor" href="#2-编译c程序"></a> 2、编译C++程序</h2><p>编译C程序的命令是gcc，编译C<ins>程序的命令是g</ins>，g<ins>命令和gcc命令的用法相同，把gcc改为g</ins>就可以了，我们在学习C语言时编写的那些示例程序，基本上都可以用g++来编译。</p><p><img src="https://img-blog.csdnimg.cn/20200305083533236.png" alt="在这里插入图片描述" /></p><h1 id="三-c是面向对象语言"><a class="markdownIt-Anchor" href="#三-c是面向对象语言"></a> 三、C++是面向对象语言</h1><p>C语言是面向过程的编程语言，C++是面向对象的编程语言，很多人认为面向对象会比面向过程的方法更先进。仁者和智者的说法各有不同，大家慢慢体会，不能人云亦云。</p><p>C++的对象，确实可以大幅的提升了C程序员的开发效率，降低程序员犯错的机会。</p><h1 id="四-c输入和输出"><a class="markdownIt-Anchor" href="#四-c输入和输出"></a> 四、C++输入和输出</h1><p>在C语言中，我们使用scanf和printf来对数据进行输入输出操作。在C++语言中，增加了cin和cout输入输出，但是我从来不用它，因为它不实用，对格式化的支持实在是太麻烦。</p><p>printf实在太完美，太强大。</p><h1 id="五-c异常"><a class="markdownIt-Anchor" href="#五-c异常"></a> 五、C++异常</h1><p>C++增加了异常机制，但是，它从诞生开始就一直有争议。</p><p>我没有发现C++的异常有什么实用价值，也从来没有用过它。</p><h1 id="六-c命名空间和模板"><a class="markdownIt-Anchor" href="#六-c命名空间和模板"></a> 六、C++命名空间和模板</h1><p>了解一下命名空间和模板的概念和用法是可以的，会使用就行，但我不建议自定义命名空间和模板，没必要把程序搞得那么麻烦。</p><h1 id="七-c布尔类型bool"><a class="markdownIt-Anchor" href="#七-c布尔类型bool"></a> 七、C++布尔类型（bool）</h1><p>C语言并没有彻底从语法上支持“真”和“假”，只是用 0 和非 0来代表。这点在 C<ins>中得到了改善，C</ins><br />新增了 bool 类型（布尔类型），它占用 1 个字节长度。bool 类型只有两个取值，true和 false：true 表示“真”，false 表示“假”。</p><p>bool 是类型名字，也是 C++ 中的关键字，它的用法和 int、char、long是一样的，可以用=赋值，可以用于函数的参数和返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag=<span class="literal">true</span>;  <span class="comment">// 定义bool型变量flag，赋值为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">&quot;flag is true&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;flag is fals&quot;</span>);</span><br><span class="line"></span><br><span class="line">flag=<span class="literal">false</span>;    <span class="comment">// 把flag赋值为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">&quot;flag is true&quot;</span>);       </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;flag is fals&quot;</span>);  </span><br></pre></td></tr></table></figure><h1 id="八-c定义变量的位置"><a class="markdownIt-Anchor" href="#八-c定义变量的位置"></a> 八、C++定义变量的位置</h1><p>ANSI C规定，所有局部变量都必须定义在函数开头，在定义变量之前不能有其他的执行语句。C99标准取消这这条限制，但是某些编译器对C99的支持很不积极，仍然要求变量定义在函数开头，或者只支持一部分。</p><p>取消限制带来的另外一个好处是，可以在 for 循环的控制语句中定义变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">1</span>; ii&lt;=<span class="number">100</span> ;ii++)</span><br><span class="line">&#123;</span><br><span class="line">  total = total + ii;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很棒，程序更简洁，更自由。</p><h1 id="九-c函数的缺省参数"><a class="markdownIt-Anchor" href="#九-c函数的缺省参数"></a> 九、C++函数的缺省参数</h1><p>在C语言中，函数在声明的时候指定了参数列表，调用的时候函数参数的个数、顺序和数据类型必须与函数声明参数列表相同，但是在C++中，声明函数的时候，可以为函数指定缺省参数，调用时缺省参数可以不填写。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">writetofile</span><span class="params">(FILE *fp,<span class="type">char</span> *strbuf,<span class="type">bool</span> enbuffer=<span class="literal">true</span>)</span></span>; <span class="comment">// 指定参数enbuffer的缺省值为true</span></span><br></pre></td></tr></table></figure><p>enbuffer参数表示是否启用缓冲区，writetofile函数被调用的时候，如果只写fp和strbuf参数，不写enbuffer参数，enbuffer参数将缺省为true，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">writetofile</span>(fp,strbuf);  <span class="comment">// 调用函数的时候，如果第三个参数enbuffer不填，就用缺省值true</span></span><br></pre></td></tr></table></figure><p>这个不错，程序更简洁。</p><h1 id="十-c动态内存管理"><a class="markdownIt-Anchor" href="#十-c动态内存管理"></a> 十、C++动态内存管理</h1><p>在C语言中，动态管理内存用 malloc() 函数，释放内存用 free() 函数。</p><p>在C<ins>中，这两个函数仍然可以使用，但是C</ins>又新增了两个关键字，new 和 delete，new用来动态分配内存，delete 用来释放内存。</p><p>和C语言的动态内存管理一样，C++动态内存管理的应用场景不多。</p><h1 id="十一-c的学习的策略"><a class="markdownIt-Anchor" href="#十一-c的学习的策略"></a> 十一、C++的学习的策略</h1><p>在我看来，C<ins>至少有70%的内容没有实用价值，在这个阶段，我们先只学习C</ins>中重要的、有实用价值的内容，十天左右的时间可以完成，如下：</p><p>1）C++函数重载；</p><p>2）类的基本知识。</p><p>3）引用。</p><p>4）string类。</p><p>5）vector容器。</p><p>6）类的继承。</p><p><strong>然后学习Linux编程基础，再进入职业技能教程，在学习完职业技术程后，您的学习能力和判断能力远远超过今日，再回头来看看C++的其它知识，网上的免费视频到处都是，三天就可以完成。</strong></p><p><strong>学习的技巧很重要，在基础知识上花太多的时间容易打击学习的积极性，那些没有实用价值的知识还会浪费您宝贵的时间。</strong></p><h1 id="十二-课后作业"><a class="markdownIt-Anchor" href="#十二-课后作业"></a> 十二、课后作业</h1><p>编写您最后一个C程序，生成一个makefile文件，把您在学习C语言基础时写的源代码用C<ins>来编译，个别用到_public.h和_public.c的程序例外用手工处理。顺便看看C</ins>编译器和C有什么不同。</p><h1 id="十三-版权声明"><a class="markdownIt-Anchor" href="#十三-版权声明"></a> 十三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言makefile文件</title>
      <link href="/post/3689c97f.html"/>
      <url>/post/3689c97f.html</url>
      
        <content type="html"><![CDATA[<p>在软件的工程中的源文件是很多的，其按照类型、功能、模块分别放在若干个目录和文件中，哪些文件需要编译，那些文件需要后编译，那些文件需要重新编译，甚至进行更复杂的功能操作，这就有了我们的系统编译的工具。</p><p>在linux和unix中，有一个强大的实用程序，叫make，可以用它来管理多模块程序的编译和链接，直至生成可执行文件。</p><p>make程序需要一个编译规则说明文件，称为makefile，makefile文件中描述了整个软件工程的编译规则和各个文件之间的依赖关系。</p><p>makefile就像是一个shell脚本一样，其中可以执行操作系统的命令，它带来的好处就是我们能够实现“自动化编译”，一旦写好，只要一个make命令，整个软件功能就完全自动编译，提高了软件开发的效率。</p><p>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说大多数编译器都有这个命令，使用make可以是重新编译的次数达到最小化。</p><h1 id="一-makefile的编写"><a class="markdownIt-Anchor" href="#一-makefile的编写"></a> 一、makefile的编写</h1><p>makefile文件的规则可以非常复杂，比C程序还要复杂，我通过示例来介绍它的简单用法。</p><p>文件名：makefile，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">all:book1 book46 </span><br><span class="line"></span><br><span class="line">book1:book1.c</span><br><span class="line">        gcc -o book1 book1.c</span><br><span class="line"></span><br><span class="line">book46:book46.c _public.h _public.c</span><br><span class="line">        gcc -o book46 book46.c _public.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f book1 book46</span><br></pre></td></tr></table></figure><p><strong>第一行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all:book book46</span><br></pre></td></tr></table></figure><p>all: 这是固定的写法。</p><p>book1 book46表示需要编译目标程序的清单，中间用空格分隔开，如果清单很长，可以用\换行。</p><p><strong>第二行</strong></p><p>makefile文件中的空行就像C程序中的空行一样，只是为了书写整洁，没有什么意义。</p><p><strong>第三行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book1:book1.c</span><br></pre></td></tr></table></figure><p>book1:表示需要编译的目标程序。</p><p>如果要编译目标程序book1，需要依赖源程序book1.c，当book1.c的内容发生了变化，执行make的时候就会重新编译book1。</p><p><strong>第四行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o book1 book1.c</span><br></pre></td></tr></table></figure><p>这是一个编译命令，和在操作系统命令行输入的命令一样，但是要注意一个问题，在gcc之前要用tab键，看上去像8个空格，实际不是，一定要用tab，空格不行。</p><p><strong>第六行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book46:book46.c _public.h _public.c</span><br></pre></td></tr></table></figure><p>与第三行的含义相同。</p><p>book46:表示编译的目标程序。</p><p>如果要编译目标程序book46，需要依赖源程序book46.c、_public.h和_public.c三个文件，只要任何一个的内容发生了变化，执行make的时候就会重新编译book46。</p><p><strong>第七行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o book46 book46.c _public.c</span><br></pre></td></tr></table></figure><p>与第四行的含义相同。</p><p><strong>第九行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br></pre></td></tr></table></figure><p>清除目标文件，清除的命令由第十行之后的脚本来执行。</p><p><strong>第十行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -f  book1 book46</span><br></pre></td></tr></table></figure><p>清除目标文件的脚本命令，注意了，rm之前也是一个tab键，不是空格。</p><h1 id="二-make命令"><a class="markdownIt-Anchor" href="#二-make命令"></a> 二、make命令</h1><p>makefile准备好了，在命令提示符下执行make就可以编译makefile中all参数指定的目标文件。</p><p>程序make编译目标程序。</p><p><img src="https://img-blog.csdnimg.cn/20200304165141588.png" alt="在这里插入图片描述" /></p><p>再执行一次make。</p><p><img src="https://img-blog.csdnimg.cn/20200304165151880.png" alt="在这里插入图片描述" /></p><p>因为全部的目标程序都是最新的，所以提示没有目标可以编译。</p><p>执行make clean，执行清除目标文件的指令。</p><p><img src="https://img-blog.csdnimg.cn/20200304165204920.png" alt="在这里插入图片描述" /></p><p>再执行make重新编译。</p><p><img src="https://img-blog.csdnimg.cn/20200304165217896.png" alt="在这里插入图片描述" /></p><p>修改_public.c程序，随便改点什么，只要改了就行。</p><p>然后再make</p><p><img src="https://img-blog.csdnimg.cn/20200304165230591.png" alt="在这里插入图片描述" /></p><p>注意了，因为book46依赖的源程序之一_public.c改变了，所以book46重新编译。</p><p>book1没有重新编译，因为book1依赖的源文件并没有改变。</p><h1 id="三-makefile文件中的变量"><a class="markdownIt-Anchor" href="#三-makefile文件中的变量"></a> 三、makefile文件中的变量</h1><p>makefile中，变量就是一个名字，变量的值就是一个文本字符串。在makefile中的目标，依赖，命令或其他地方引用变量时，变量会被它的值替代。</p><p>我通过示例来介绍它的简单用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">FLAG=-g</span><br><span class="line"></span><br><span class="line">all:book1 book46</span><br><span class="line"></span><br><span class="line">book1:book1.c</span><br><span class="line">        $(CC) $(FLAG) -o book1 book1.c</span><br><span class="line"></span><br><span class="line">book46:book46.c _public.h _public.c</span><br><span class="line">        $(CC) $(FLAG) -o book46 book46.c _public.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f book1 book46</span><br></pre></td></tr></table></figure><p><strong>第一行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br></pre></td></tr></table></figure><p>定义变量CC，赋值gcc。</p><p><strong>第二行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLAG=-g</span><br></pre></td></tr></table></figure><p>定义变量FLAG，赋值-g。</p><p><strong>第七行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(CC)  $(FLAG) -o book1 book1.c</span><br></pre></td></tr></table></figure><p>$(CC)和$(FLAG)就是使用变量CC和FLAG的值，类似于C语言的宏定义，替换后的结果是：</p><p><img src="https://img-blog.csdnimg.cn/20200304165658467.png" alt="在这里插入图片描述" /></p><p>在makefile文件中，使用变量的好处有两个：1）如果在很多编译指令采用了变量，只要修改变量的值，就相当于修改全部的编译指令；2）把比较长的、公共的编译指令采用变量来表示，可以让makefile更简洁。</p><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>makefile文件的编写可以很复杂，复杂到我不想看，在实际开发中，用不着那么复杂的makefile，我追求简单实用的方法，腾出更多的时间和精力去做更重要的事情，那些把makefile文件写得很复杂的程序员在我看来是吃饱了撑的。</p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>把您这段时间写的程序全部编写到makefile中，以后再也不要在命令提示符下用gcc了。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言gdb调试</title>
      <link href="/post/ec19abf3.html"/>
      <url>/post/ec19abf3.html</url>
      
        <content type="html"><![CDATA[<p>程序员写在编写程序的时候不可能是一帆风顺的，gcc编译器可以发现程序代码的语法错误，但不能发现程序的业务逻辑错误，调试程序是软件开发的内容之一。调试程序的方法有很多种，例如可以用printf语句跟踪程序的运行步骤和显示变量的值，本章节介绍一个功能强大的调试工具gdb。</p><h1 id="一-gdb的安装"><a class="markdownIt-Anchor" href="#一-gdb的安装"></a> 一、gdb的安装</h1><p>CentOS系统中，用root用户登录服务器，执行以下命令安装或升级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install  gdb </span><br></pre></td></tr></table></figure><p>注意，如果您的服务器没有安装gdb，以上命令就会安装最新版本的gdb，如果已经安装了gdb，就会更新到最新版本的gdb，所以，以上命令不管执行多少次都没有问题。</p><p>安装gdb，前提条件是服务器必须接入互联网。</p><h1 id="二-调试前的准备"><a class="markdownIt-Anchor" href="#二-调试前的准备"></a> 二、调试前的准备</h1><p>用gcc编译源程序的时候，编译后的可执行文件不会包含源程序代码，如果您打算编译后的程序可以被调试，编译的时候要加-g的参数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o book113 book113.c </span><br></pre></td></tr></table></figure><p>在命令提示符下输入gdb book113就可以调试book113程序了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb book113 </span><br></pre></td></tr></table></figure><h1 id="三-基本调试命令"><a class="markdownIt-Anchor" href="#三-基本调试命令"></a> 三、基本调试命令</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>命令 缩写</strong></th><th><strong>命令说明</strong></th></tr></thead><tbody><tr><td>set args</td><td></td><td>设置主程序的参数。 例如：./book119 /oracle/c/book1.c /tmp/book1.c 设置参数的方法是： gdb book119 (gdb) set args /oracle/c/book1.c /tmp/book1.c</td></tr><tr><td>break</td><td>b</td><td>设置断点，b 20 表示在第20行设置断点，可以设置多个断点。</td></tr><tr><td>run</td><td>r</td><td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。</td></tr><tr><td>next</td><td>n</td><td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td></tr><tr><td>step</td><td>s</td><td>执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。 注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。</td></tr><tr><td>print</td><td>p</td><td>显示变量值，例如：p name表示显示变量name的值。</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点。</td></tr><tr><td>set varname=v</td><td></td><td>设置变量的值，假设程序有两个变量：int ii; char name[21]; set ii=10 把ii的值设置为10； set name=“西施” 把name的值设置为&quot;西施&quot;，注意，不是strcpy。</td></tr><tr><td>quit</td><td>q</td><td>退出gdb环境。</td></tr></tbody></table><p>注意，在gdb环境中，可以用上下光标键选择执行过的gdb命令。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>gdb调试是程序员必须掌握的方法，多尝试一下，搞清楚每个命令的用法。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言目录和文件操作扩展</title>
      <link href="/post/e9b985fb.html"/>
      <url>/post/e9b985fb.html</url>
      
        <content type="html"><![CDATA[<p>本章节扩展一些目录和文件操作的更多知识，因为这些知识涉及到时间操作，所以放在时间操作之后的章节中介绍。</p><h1 id="一-access库函数"><a class="markdownIt-Anchor" href="#一-access库函数"></a> 一、access库函数</h1><p>access函数用于判断当前操作系统用户对文件或目录的存取权限。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>pathname文件名或目录名，可以是当前目录的文件或目录，也可以列出全路径。</p><p>mode 需要判断的存取权限。在头文件unistd.h中的预定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> R_OK 4     <span class="comment">// R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W_OK 2    <span class="comment">// W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_OK 1     <span class="comment">// X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F_OK 0     <span class="comment">// F_OK 只判断是否存在</span></span></span><br></pre></td></tr></table></figure><p>返回值：</p><p>当pathname满足mode的条件时候返回0，不满足返回-1。</p><p>在实际开发中，access函数主要用于判断文件或目录是否是存在。</p><h1 id="二-stat库函数"><a class="markdownIt-Anchor" href="#二-stat库函数"></a> 二、stat库函数</h1><h2 id="1-stat结构体"><a class="markdownIt-Anchor" href="#1-stat结构体"></a> 1、stat结构体</h2><p>struct stat结构体用于存放文件和目录的状态信息，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">dev_t</span> st_dev;   <span class="comment">// device 文件的设备编号</span></span><br><span class="line">  <span class="type">ino_t</span> st_ino;   <span class="comment">// inode 文件的i-node</span></span><br><span class="line">  <span class="type">mode_t</span> st_mode;   <span class="comment">// protection 文件的类型和存取的权限</span></span><br><span class="line">  <span class="type">nlink_t</span> st_nlink;   <span class="comment">// number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span></span><br><span class="line">  <span class="type">uid_t</span> st_uid;   <span class="comment">// user ID of owner 文件所有者的用户识别码</span></span><br><span class="line">  <span class="type">gid_t</span> st_gid;   <span class="comment">// group ID of owner 文件所有者的组识别码</span></span><br><span class="line">  <span class="type">dev_t</span> st_rdev;  <span class="comment">// device type 若此文件为设备文件, 则为其设备编号</span></span><br><span class="line">  <span class="type">off_t</span> st_size;  <span class="comment">// total size, in bytes 文件大小, 以字节计算</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> st_blksize;  <span class="comment">// blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> st_blocks;  <span class="comment">// number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span></span><br><span class="line">  <span class="type">time_t</span> st_atime;  <span class="comment">// time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.</span></span><br><span class="line">  <span class="type">time_t</span> st_mtime;  <span class="comment">// time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变</span></span><br><span class="line">  <span class="type">time_t</span> st_ctime;  <span class="comment">// time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct stat结构体的成员变量比较多，对程序员来说，重点关注st_mode、st_size和st_mtime成员就可以了。注意st_mtime是一个整数表达的时间，需要程序员自己写代码转换格式。</p><p>st_mode成员的取值很多，或者使用如下两个宏来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">S_ISREG</span> (st_mode) 是否为一般文件 </span><br><span class="line"><span class="built_in">S_ISDIR</span> (st_mode) 是否为目录 </span><br></pre></td></tr></table></figure><h2 id="2-stat库函数"><a class="markdownIt-Anchor" href="#2-stat库函数"></a> 2、stat库函数</h2><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>stat函数获取path指定文件或目录的信息，并将信息保存到结构体buf中，执行成功返回0，失败返回-1。</p><p><strong>示例（book145.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book145.c，此程序演示目录和文件的存取权限和状态信息</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本程序运行要带一个参数，即文件或目录名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)  &#123; <span class="built_in">printf</span>(<span class="string">&quot;请指定目录或文件名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">access</span>(argv[<span class="number">1</span>],F_OK) != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;文件或目录%s不存在。\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> ststat;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件的状态信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stat</span>(argv[<span class="number">1</span>],&amp;ststat) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">S_ISREG</span>(ststat.st_mode)) <span class="built_in">printf</span>(<span class="string">&quot;%s是一个文件。\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(ststat.st_mode)) <span class="built_in">printf</span>(<span class="string">&quot;%s是一个目录。\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304153705527.png" alt="在这里插入图片描述" /></p><h1 id="三-utime库函数"><a class="markdownIt-Anchor" href="#三-utime库函数"></a> 三、utime库函数</h1><p>utime函数用于修改文件的存取时间和更改时间。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span></span>;</span><br></pre></td></tr></table></figure><p>函数说明：utime()用来修改参数filename 文件所属的inode存取时间。如果参数times为空指针(NULL),<br />则该文件的存取时间和更改时间全部会设为目前时间。结构utimbuf 定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">utimbuf</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">time_t</span> actime;</span><br><span class="line">  <span class="type">time_t</span> modtime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值：执行成功则返回0，失败返回-1。</p><h1 id="四-rename库函数"><a class="markdownIt-Anchor" href="#四-rename库函数"></a> 四、rename库函数</h1><p>rename函数用于重命名文件或目录，相当于操作系统的mv命令，对程序员来说，在程序中极少重命名目录，但重命名文件是经常用到的功能。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>oldpath 文件或目录的原名。</p><p>newpath 文件或目录的新的名称。</p><p>返回值：0-成功，-1-失败。</p><h1 id="五-remove库函数"><a class="markdownIt-Anchor" href="#五-remove库函数"></a> 五、remove库函数</h1><p>remove函数用于删除文件或目录，相当于操作系统的rm命令。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>pathname 待删除的文件或目录名。</p><p>返回值：0-成功，-1-失败。</p><h1 id="六-课后作业"><a class="markdownIt-Anchor" href="#六-课后作业"></a> 六、课后作业</h1><p>1）继续丰富您的函数库，用mkdir创建目录的时候，例如mkdir(“/tmp/aaa/bbb/ccc”,0755);，如果上级目录不存在（/tmp/aaa或/tmp/aaa/bbb不存在），是无法创建/tmp/aaa/bbb/ccc目录的，这不是程序员想要的，我们要再写一个函数，如果上级目录不存在，就创建上级目录，一级一级的创建，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MKDIR</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><p>2）编写一个获取文件时间的函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件的时间，即modtime</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileMTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_FullFileName,<span class="type">char</span> *out_ModTime)</span></span>;</span><br></pre></td></tr></table></figure><p>out_ModTime的格式是&quot;yyyy-mm-dd hh24:mi:ss&quot;。</p><p>3）编写一个获取文件大小的函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件的大小，返回字节数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_FullFileName)</span></span>;</span><br></pre></td></tr></table></figure><p>4）rename函数有一个不足，如果目标文件名目录newpath的上级目录不存在，函数返回失败，重写一个新的RENAME函数，如果newpath的上级目录不存在，先创建newpath的上级目录，再rename，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RENAME</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure><p>5）utime函数的第二个参数是一个结构体utimbuf，不方便使用，在实际开发中，我们更希望是一个字符串格式的时间，如：“2019-02-08 12:05:02”，重写一个utime函数，功能与utime相同，但是把第二个参数改为字符串格式的时间，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">UTIME</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *strtime)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言系统错误</title>
      <link href="/post/392db03e.html"/>
      <url>/post/392db03e.html</url>
      
        <content type="html"><![CDATA[<p>我们在写程序的时候需要调用C语言提供的库函数，并通过函数的返回值判断调用是否成功。其实在C语言中，还有一个全局变量errno，存放了函数调用过程中产生的错误码。</p><p>为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt;文件中。如果库函数调用失败，可以通过读出 errno的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。</p><p>配合 strerror和perror两个库函数，可以很方便地查看出错的详细信息。</p><p>strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。</p><p>perror 在 &lt;stdio.h&gt;中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。</p><h1 id="一-strerror函数"><a class="markdownIt-Anchor" href="#一-strerror函数"></a> 一、strerror函数</h1><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strerror</span><span class="params">(<span class="type">int</span> errno)</span></span>;</span><br></pre></td></tr></table></figure><p>函数说明：strerror()用来依参数errno的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。</p><p>返回值：返回描述错误原因的字符串地址。</p><p>在gcc4.4.7版本中，定义了131个错误代码，我们用程序把它们全部显示出来。</p><p><strong>示例（book158.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book158.c，此程序演示strerror函数的使用。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> errorno;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(errorno=<span class="number">0</span>;errorno&lt;<span class="number">132</span>;errorno++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errorno,<span class="built_in">strerror</span>(errorno));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200304160453567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>一共有131个错误代码和描述，上面的截图只显示了前5条和最后5条。这些错误代码和描述看一下就行了，不需要记住。</p><h1 id="二-errno的细节"><a class="markdownIt-Anchor" href="#二-errno的细节"></a> 二、errno的细节</h1><h2 id="1-调用库函数失败不一定会设置errno"><a class="markdownIt-Anchor" href="#1-调用库函数失败不一定会设置errno"></a> 1、调用库函数失败不一定会设置errno</h2><p>如果库函数调用失败，库函数会设置errno的值，程序员通过 errno的值来判断出错的具体原因，但是，并不是全部的库函数在调用失败时都会设置errno的值，那么，哪些库函数会设置errno的值呢，要看函数的说明，例如fopen函数，在命令行下输入man fopen，在诸多的文字中，有以下行说明文字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The <span class="title">fopen</span><span class="params">()</span> function may also fail <span class="keyword">and</span> set errno <span class="keyword">for</span> any of the errors specified <span class="keyword">for</span> the routine <span class="title">open</span><span class="params">(<span class="number">2</span>)</span>.</span></span><br></pre></td></tr></table></figure><p>不属于系统调用的函数不会设置errno，属于系统调用的函数才会设置errno。</p><h2 id="2-errno不能作为调用库函数失败的标志"><a class="markdownIt-Anchor" href="#2-errno不能作为调用库函数失败的标志"></a> 2、errno不能作为调用库函数失败的标志</h2><p>在 C 语言中，如果库函数被正确地执行，那么 errno 的值不会被清零。换句话说，errno的值只有在一个库函数调用发生错误时才会被设置，当库函数调用成功运行时，errno的值不会被修改，当然也不会主动被置为0。也正因为如此，在实际编程中，判断函数执行是否成功还得靠函数的返回值，只有在返回值是失败的情况下，才需要关注errno的值。</p><h2 id="3-程序员可以不用errno"><a class="markdownIt-Anchor" href="#3-程序员可以不用errno"></a> 3、程序员可以不用errno</h2><p>关注errno的目的是为了获取更详细错误信息，这些错误信息对程序员诊断程序可能会有帮助，但不是必须的。</p><p><strong>示例（book160.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book160.c，此程序用于演示C程序的基本结构。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *  此程序演示errno全局变量和strerror函数</span></span><br><span class="line"><span class="comment"> *  作者：豫让 日期：20190601</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/tmp/book1.c</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/book1.c&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件/tmp/book1.c失败（%d：%s）。\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno)); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="keyword">if</span> ( fp!=<span class="number">0</span> ) <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030416055473.png" alt="在这里插入图片描述" /></p><h1 id="三-课后作业"><a class="markdownIt-Anchor" href="#三-课后作业"></a> 三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言编译预处理</title>
      <link href="/post/80fba3a4.html"/>
      <url>/post/80fba3a4.html</url>
      
        <content type="html"><![CDATA[<p>C语言由源代码生成可执行程序的过程如下：</p><p><strong>C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件</strong></p><p>其中编译预处理阶段，读取C源程序，对其中的预处理指令（以#开头的指令）和特殊符号进行处理。或者说是扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。</p><p>预处理过程先于编译器对源代码进行处理，读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行转换。预处理过程还会删除程序中的注释和多余的空白字符。</p><h1 id="一-预处理指令"><a class="markdownIt-Anchor" href="#一-预处理指令"></a> 一、预处理指令</h1><p>在C语言的程序中包括各种以符号#开头的编译指令，这些指令称为预处理命令。预处理命令属于C语言编译器，而不是C语言的组成部分，通过预处理命令可扩展C语言程序设计的环境。</p><p>预处理指令是以#号开头的代码行，#号必须是该行除了任何空白字符外的第一个字符。</p><p>#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。</p><p>预处理指令主要有以下三种：</p><p>1）包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。</p><p>2）宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。</p><p>3）条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。</p><h1 id="二-包含文件"><a class="markdownIt-Anchor" href="#二-包含文件"></a> 二、包含文件</h1><p>当一个C语言程序由多个文件模块组成时，主模块中一般包含main函数和一些当前程序专用的函数。程序从main函数开始执行，在执行过程中，可调用当前文件中的函数，也可调用其他文件模块中的函数。</p><p>如果在模块中要调用其他文件模块中的函数，首先必须在主模块中声明该函数原型。一般都是采用文件包含的方法，包含其他文件模块的头文件。</p><p>文件包含中指定的文件名即可以用引号括起来，也可以用尖括号括起来，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名&gt;</span></span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;文件名&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的include文件中去找指定的文件（/usr/include）。</p><p>因为C语言的标准头文件都存放在/usr/include文件夹中，所以一般对标准头文件采用尖括号；对程序员自己编写的文件，则使用双引号。</p><p>如果自己编写的文件不是存放在当前工作文件夹，可以在#include命令后面加在路径。</p><p>#include命令的作用是把指定的文件模块内容插入到#include所在的位置，当程序编译链接时，系统会把所有#include指定的文件链接生成可执行代码。</p><p>#include包含文件，可以是“.h”,表示C语言程序的头文件，也可以是“.c”,表示包含普通C语言源程序。</p><h1 id="三-宏定义指令"><a class="markdownIt-Anchor" href="#三-宏定义指令"></a> 三、宏定义指令</h1><p>使用#define命令并不是真正的定义符号常量，而是定义一个可以替换的宏。被定义为宏的标识符称为“宏名”。在编译预处理过程时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p><p>在C语言中，宏分为有参数和无参数两种。</p><h2 id="1-无参数的宏"><a class="markdownIt-Anchor" href="#1-无参数的宏"></a> 1、无参数的宏</h2><p>其定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名  字符串</span></span><br></pre></td></tr></table></figure><p>在以上宏定义语句中，各部分的含义如下：</p><p><strong>#</strong> 表示这是一条预处理命令(凡是以“#”开始的均为预处理命令)。</p><p><strong>define</strong> 关键字“define”为宏定义命令。</p><p><strong>宏名</strong> 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。</p><p><strong>字符串</strong>可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。</p><p>注意：预处理命令语句后面一般不会添加分号，如果在#define最后有分号，在宏替换时分号也将替换到源代码中去。在宏名和字符串之间可以有任意个空格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.141592</span></span><br></pre></td></tr></table></figure><p><strong>示例（book149.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book149.c，此程序演示不带参数的宏。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.141592</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;PI is %lf\n&quot;</span>,PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行预编译指令gcc -E -o book149.E book149.c，得到book149.E文件，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;book149.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;book149.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;PI is %lf\n&quot;</span>,<span class="number">3.141592</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用宏定义时，还需要注意以下几点：</p><p>宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何语法检查。如有错误，只能在编译已被宏展开后的源程序时发现。</p><p>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。建议不要这么做，会把程序复杂化。</p><p>习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。</p><h2 id="2-带参数的宏"><a class="markdownIt-Anchor" href="#2-带参数的宏"></a> 2、带参数的宏</h2><p>#define命令定义宏时，还可以为宏设置参数。与函数中的参数类似，在宏定义中的参数为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，还要用实参去代换形参。</p><p>带参宏定义的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(形参表) 字符串</span></span><br></pre></td></tr></table></figure><p>在定义带参数的宏时，宏名和形参表之间不能有空格出现，否则，就将宏定义成为无参数形式，而导致程序出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y)  ((x)&gt;(y) ? (x) : (y))</span></span><br></pre></td></tr></table></figure><p>以上的宏定义中，如果x的值大于y，得到x，否则得到y。</p><p><strong>示例（book150.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book150.c，此程序演示带参数的宏</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;MAX is %d\n&quot;</span>,<span class="built_in">MAX</span>(<span class="number">34</span>,<span class="number">59</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行预编译指令gcc -E -o book150.E book150.c，得到book50.E文件，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;book150.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;book150.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;MAX is %d\n&quot;</span>,((<span class="number">34</span>)&gt;(<span class="number">59</span>)?(<span class="number">34</span>):(<span class="number">59</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参的宏和带参的函数相似，但其本质是不同的。使用带参宏时，在预处理时将程序源代码替换到相应的位置，编译时得到完整的目标代码，而不进行函数调用，因此程序执行效率要高些。而函数调用只需要编译一次函数，代码量较少，一般情况下，对于简单的功能，可使用宏替换的形式来使用。</p><p>带参数的宏不容易理解，所以，在实际开发中，我不建议使用带参数的宏。</p><h1 id="四-条件编译"><a class="markdownIt-Anchor" href="#四-条件编译"></a> 四、条件编译</h1><p>条件编译有多种格式，在这里我只介绍最常用的两种格式#ifdef和#ifndef。</p><h2 id="1-ifdef"><a class="markdownIt-Anchor" href="#1-ifdef"></a> 1、#ifdef</h2><p>#ifdef命令的使用格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">  程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其意义是，如果#ifdef后面的标识符已被定义过，则对“程序段1”进行编译；如果没有定义标识符，则编译“程序段2”。一般不使用#else及后面的“程序2”。</p><p><strong>示例（book153.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book153.c，此程序用于演示#ifdef条件编译</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINUX</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> LINUX</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是Linux操作系统。\n&quot;</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未知的操作系统。\n&quot;</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行预编译指令gcc -E -o book153.E book153.c，得到book153.E文件，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;book153.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;book153.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这是Linux操作系统。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ifndef"><a class="markdownIt-Anchor" href="#2-ifndef"></a> 2、#ifndef</h2><p>而#ifndef的意义与#ifdef相反，其格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 标识符</span></span><br><span class="line">  程序段 <span class="number">1</span> </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  程序段 <span class="number">2</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其意义是，如果未定义标识符，则编译“程序段1”；否则编译“程序段2”</p><p>在实际开发中，程序员用#ifndef来防止头文件被重复包含。</p><p>我们打开/usr/include/stdio.h文件。</p><p>第一条有效行的代码是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H</span></span><br></pre></td></tr></table></figure><p>接下来是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _STDIO_H  1</span></span><br></pre></td></tr></table></figure><p>最后一行是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>程序员自定义的头文件，我们也会这么写，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：_public.h，公共功能函数声明的头文件</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PUBLIC_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把字符串格式的时间转换为整数的时间，函数的声明如下：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strtotime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strtime,<span class="type">time_t</span> *ti)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果头文件被包含多次，就表示头文件中的函数被多次声明，全局变量被多次定义，在以前的C语言编译器中，这是不允许的，编译时会报错，但是，现在的部分编译器比较智能，多次定义全局变量或多次声明函数也不会报错。这些新的特征让我这个老家伙很不适应。</p><h2 id="3-undef"><a class="markdownIt-Anchor" href="#3-undef"></a> 3、#undef</h2><p>#undef取消已定义的标识符。</p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>1）编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><p>2）编写代码测试多次声明同名的函数、多次定义同名的函数、多次声明同名的全局变量、多次声明同名的局部变量。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言时间操作</title>
      <link href="/post/98a10cf5.html"/>
      <url>/post/98a10cf5.html</url>
      
        <content type="html"><![CDATA[<p>UNIX操作系统根据计算机产生的年代和应用采用1970年1月1日作为UNIX的纪元时间，1970年1月1日0点作为计算机表示时间的是中间点，将从1970年1月1日开始经过的秒数用一个整数存放，这种高效简洁的时间表示方法被称为“Unix时间纪元”，向左和向右偏移都可以得到更早或者更后的时间。</p><p>在实际开发中，对日期和时间的操作场景非常多，例如程序启动和退出的时间，程序执行任务的时间，数据生成的时间，数据处理的各环节的时间等，无处不在。</p><p>在学习时间之前，请把Linux操作系统的时区设置为中国上海时间。</p><h1 id="一-time_t别名"><a class="markdownIt-Anchor" href="#一-time_t别名"></a> 一、time_t别名</h1><p>在C语言中，用time_t来表示时间数据类型，它是一个long（长整数）类型的别名，在time.h文件中定义，表示一个日历时间，是从1970年1月1日0时0分0秒到现在的秒数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">time_t</span>;  </span><br></pre></td></tr></table></figure><h1 id="二-time库函数"><a class="markdownIt-Anchor" href="#二-time库函数"></a> 二、time库函数</h1><p>time函数的用途是返回一个值，也就是从1970年1月1日0时0分0秒到现在的秒数。</p><p>time函数是C语言标准库中的函数，在time.h文件中声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *t)</span></span>;</span><br></pre></td></tr></table></figure><p>time函数有两种调用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> tnow;</span><br><span class="line">tnow =<span class="built_in">time</span>(<span class="number">0</span>);     <span class="comment">// 将空地址传递给time函数，并将time返回值赋给变量tnow</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">time</span>(&amp;tnow);       <span class="comment">// 将变量tnow的地址作为参数传递给time函数</span></span><br></pre></td></tr></table></figure><p>您可以写代码测试一下这两种方式，效果完全相同。</p><h1 id="三-tm结构体"><a class="markdownIt-Anchor" href="#三-tm结构体"></a> 三、tm结构体</h1><p>time_t只是一个长整型，不符合我们的使用习惯，需要转换成可以方便表示时间的结构体，即tm结构体，tm结构体在time.h中声明，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tm_sec;     <span class="comment">// 秒：取值区间为[0,59] </span></span><br><span class="line">  <span class="type">int</span> tm_min;     <span class="comment">// 分：取值区间为[0,59] </span></span><br><span class="line">  <span class="type">int</span> tm_hour;    <span class="comment">// 时：取值区间为[0,23] </span></span><br><span class="line">  <span class="type">int</span> tm_mday;    <span class="comment">// 日期：一个月中的日期：取值区间为[1,31]</span></span><br><span class="line">  <span class="type">int</span> tm_mon;     <span class="comment">// 月份：（从一月开始，0代表一月），取值区间为[0,11]</span></span><br><span class="line">  <span class="type">int</span> tm_year;    <span class="comment">// 年份：其值等于实际年份减去1900</span></span><br><span class="line">  <span class="type">int</span> tm_wday;    <span class="comment">// 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 </span></span><br><span class="line">  <span class="type">int</span> tm_yday;    <span class="comment">// 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 </span></span><br><span class="line">  <span class="type">int</span> tm_isdst;   <span class="comment">// 夏令时标识符，该字段意义不大，我们不用夏令时。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构定义了年、月、日、时、分、秒、星期、当年中的某一天、夏令时。用这个结构体可以很方便的显示时间。</p><h1 id="四-localtime库函数"><a class="markdownIt-Anchor" href="#四-localtime库函数"></a> 四、localtime库函数</h1><p>localtime函数用于把time_t表示的时间转换为struct tm结构体表示的时间，函数返回struct tm结构体的地址。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> * <span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span> *);</span><br></pre></td></tr></table></figure><p>struct tm结构体包含了时间的各要素，但还不是我们习惯的时间表达方式，我们可以用格式化输出printf、sprintf或fprintf等函数，把struct tm结构体转换为我们想要的结果。</p><p><strong>示例（book128.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book128.c，此程序演示获取操作系统时间</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">time_t</span> tnow;</span><br><span class="line">  tnow=<span class="built_in">time</span>(<span class="number">0</span>);      <span class="comment">// 获取当前时间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;tnow=%lu\n&quot;</span>,tnow);   <span class="comment">// 输出整数表示的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> *sttm;  </span><br><span class="line">  sttm=<span class="built_in">localtime</span>(&amp;tnow);  <span class="comment">// 把整数的时间转换为struct tm结构体的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// yyyy-mm-dd hh24:mi:ss格式输出，此格式用得最多</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%04u-%02u-%02u %02u:%02u:%02u\n&quot;</span>,sttm-&gt;tm_year+<span class="number">1900</span>,sttm-&gt;tm_mon+<span class="number">1</span>,\</span><br><span class="line">          sttm-&gt;tm_mday,sttm-&gt;tm_hour,sttm-&gt;tm_min,sttm-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%04u年%02u月%02u日%02u时%02u分%02u秒\n&quot;</span>,sttm-&gt;tm_year+<span class="number">1900</span>,\</span><br><span class="line">          sttm-&gt;tm_mon+<span class="number">1</span>,sttm-&gt;tm_mday,sttm-&gt;tm_hour,sttm-&gt;tm_min,sttm-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只输出年月日</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%04u-%02u-%02u\n&quot;</span>,sttm-&gt;tm_year+<span class="number">1900</span>,sttm-&gt;tm_mon+<span class="number">1</span>,sttm-&gt;tm_mday); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304150816893.png" alt="在这里插入图片描述" /></p><h1 id="五-mktime库函数"><a class="markdownIt-Anchor" href="#五-mktime库函数"></a> 五、mktime库函数</h1><p>mktime函数的功能与localtime函数相反。</p><p>localtime函数用于把time_t表示的时间转换为struct tm表示的时间。</p><p>mktime 函数用于把struct tm表示的时间转换为time_t表示的时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span></span>;</span><br></pre></td></tr></table></figure><p>函数返回time_t的值。</p><p><strong>示例（book130.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book130.c，此程序演示时间操作的mktime库函数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2019-12-25 15:05:03整数表示是1577257503</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> sttm;  </span><br><span class="line">  <span class="built_in">memset</span>(&amp;sttm,<span class="number">0</span>,<span class="built_in">sizeof</span>(sttm));</span><br><span class="line"></span><br><span class="line">  sttm.tm_year=<span class="number">2019</span><span class="number">-1900</span>; <span class="comment">// 注意，要减1900</span></span><br><span class="line">  sttm.tm_mon=<span class="number">12</span><span class="number">-1</span>;        <span class="comment">// 注意，要减1</span></span><br><span class="line">  sttm.tm_mday=<span class="number">25</span>;</span><br><span class="line">  sttm.tm_hour=<span class="number">15</span>;</span><br><span class="line">  sttm.tm_min=<span class="number">5</span>;</span><br><span class="line">  sttm.tm_sec=<span class="number">3</span>;</span><br><span class="line">  sttm.tm_isdst = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2019-12-25 15:05:03 is %lu\n&quot;</span>,<span class="built_in">mktime</span>(&amp;sttm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><h1 id="在这里插入图片描述六-程序睡眠"><a class="markdownIt-Anchor" href="#在这里插入图片描述六-程序睡眠"></a> <img src="https://img-blog.csdnimg.cn/20200304150951831.png" alt="在这里插入图片描述" /><br />六、程序睡眠</h1><p>在实际开发中，我们经常需要把程序挂起一段时间，可以使用sleep和usleep两个库函数，需要包含unistd.h头文件中。函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span></span>;</span><br></pre></td></tr></table></figure><p>sleep函数的参数是秒，usleep函数的参数是微秒，1秒=1000000微秒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);           <span class="comment">// 程序睡眠1秒。</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);          <span class="comment">// 程序睡眠10秒。</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);    <span class="comment">// 程序睡眠十分之一秒。</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">1000000</span>);   <span class="comment">// 程序睡眠一秒。</span></span><br></pre></td></tr></table></figure><p>程序员不关心sleep和usleep函数的返回值。</p><h1 id="七-精确到微秒的计时器"><a class="markdownIt-Anchor" href="#七-精确到微秒的计时器"></a> 七、精确到微秒的计时器</h1><h2 id="1-精确到微秒的timeval结构体"><a class="markdownIt-Anchor" href="#1-精确到微秒的timeval结构体"></a> 1、精确到微秒的timeval结构体</h2><p>timeval结构体在sys/time.h文件中定义，声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span>  tv_sec;  <span class="comment">// 1970年1月1日到现在的秒。</span></span><br><span class="line">  <span class="type">long</span>  tv_usec; <span class="comment">// 当前秒的微妙，即百万分之一秒。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-时区timezone-结构体"><a class="markdownIt-Anchor" href="#2-时区timezone-结构体"></a> 2、时区timezone 结构体</h2><p>timezone 结构体在sys/time.h文件中定义，声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timezone</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tz_minuteswest;  <span class="comment">// 和UTC（格林威治时间）差了多少分钟。</span></span><br><span class="line">  <span class="type">int</span> tz_dsttime;      <span class="comment">// type of DST correction，修正参数据，忽略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-gettimeofday库函数"><a class="markdownIt-Anchor" href="#3-gettimeofday库函数"></a> 3、gettimeofday库函数</h2><p>gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数，可以用于程序的计时。调用gettimeofday函数需要包含sys/time.h头文件。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span>  timeval *tv, <span class="keyword">struct</span>  timezone *tz )</span></span></span><br></pre></td></tr></table></figure><p>当前的时间存放在tv 结构体中，当地时区的信息则放到tz所指的结构体中，tz可以为空。</p><p>函数执行成功后返回0，失败后返回-1。</p><p>在使用gettimeofday()函数时，第二个参数一般都为空，我们一般都只是为了获得当前时间，不关心时区的信息。</p><p><strong>示例（book132.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book132.c，此程序演示精确到微秒的计时器。 </span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span>   <span class="comment">// 注意，不是time.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> begin,end;  <span class="comment">// 定义用于存放开始和结束的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;begin,<span class="number">0</span>);    <span class="comment">// 计时器开始</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;begin time(0)=%d,tv_sec=%d,tv_usec=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),begin.tv_sec,begin.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">100000</span>);     <span class="comment">// 程序睡眠十分之一秒。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;end,<span class="number">0</span>);      <span class="comment">// 计时器结束</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;end   time(0)=%d,tv_sec=%d,tv_usec=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),end.tv_sec,end.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;计时过去了%d微秒。\n&quot;</span>,\</span><br><span class="line">         (end.tv_sec-begin.tv_sec)*<span class="number">1000000</span>+(end.tv_usec-begin.tv_usec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304151937932.png" alt="在这里插入图片描述" /></p><p>各位，book132.c程序采用usleep睡眠十分之一秒，但是计时器显示的实际时间大于十分之一秒，为何？原因很简单，因为程序执行需要时间，虽然这个时间很短，在千分之一秒内，那也是需要时间。</p><p>还有一个要注意的问题，time.h 是ISO C99 标准日期时间头文件。sys/time.h 是Linux系统的日期时间头文件，也就是说，timeval、timezone结构体和gettimeofday函数在windows平台中不能使用，真是麻烦。</p><h1 id="八-应用经验"><a class="markdownIt-Anchor" href="#八-应用经验"></a> 八、应用经验</h1><p>在实际开发中，除了当前的时间，还经常需要一个偏移量的时间，例如获取十分钟之后的时间，方法是采用time函数得到一个整数后，再加上10*60秒，再用localtime函数转换为结构体。</p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>继续丰富您的函数库。</p><p>1）编写一个通用函数，把整数的时间转换为字符串格式的时间，格式如：“2019-02-08<br />12:05:08”，如果转换成功函数返回0，失败返回-1，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">timetostr</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> ti,<span class="type">char</span> *strtime)</span></span>;</span><br></pre></td></tr></table></figure><p>2）编写一个通用函数，把字符串格式的时间转换为整数的时间，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strtotime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strtime,<span class="type">time_t</span> *ti)</span></span>;</span><br></pre></td></tr></table></figure><p>3）编写一个通用函数，获取操作系统的时间，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LocalTime</span><span class="params">(<span class="type">char</span> *out_stime,<span class="type">const</span> <span class="type">char</span> *in_fmt,<span class="type">const</span> <span class="type">int</span> in_interval)</span></span>;</span><br></pre></td></tr></table></figure><p>out_stime是输出结果，格式由fmt决定。</p><p>in_interval是偏移常量，单位是秒。</p><p>in_fmt指定了out_stime的格式，取值如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常用的时间格式</span></span><br><span class="line"><span class="comment">yyyy-mm-dd hh24:mi:ss</span></span><br><span class="line"><span class="comment">yyyymmddhh24miss</span></span><br><span class="line"><span class="comment">yyyy-mm-dd</span></span><br><span class="line"><span class="comment">yyyymmdd</span></span><br><span class="line"><span class="comment">hh24:mi:ss</span></span><br><span class="line"><span class="comment">hh24miss</span></span><br><span class="line"><span class="comment">hh24:mi</span></span><br><span class="line"><span class="comment">hh24mi</span></span><br><span class="line"><span class="comment">hh24</span></span><br><span class="line"><span class="comment">mi</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strLocalTime[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取当前的时间，以yyyy-mm-dd hh24:mi:ss格式返回</span></span><br><span class="line"> <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line"> <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取比现在晚10分钟的时间，以yyyy-mm-dd hh24:mi:ss格式返回</span></span><br><span class="line"> <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line"> <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">10</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取当前的时间，以hh24:mi:ss格式返回</span></span><br><span class="line"> <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line"> <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;hh24:mi:ss&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言目录操作</title>
      <link href="/post/da2face3.html"/>
      <url>/post/da2face3.html</url>
      
        <content type="html"><![CDATA[<p>目录的操作不论是在嵌入式还是应用软件编程都是必不可少的，不同的开发语言可能略有不同，本章节主要是讨论在Linux系统下目录的一系列操作，以我的个人经验，创建目录和列出目录中的文件这两个功能用得最多。</p><h1 id="一-获取当前工作目录"><a class="markdownIt-Anchor" href="#一-获取当前工作目录"></a> 一、获取当前工作目录</h1><p>在shell中我们可以直接输入命令pwd来显示当前的工作目录，在C程序中调用getcwd函数可以获取当前的工作目录。函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">getcwd</span><span class="params">(<span class="type">char</span> * buf,<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>getcwd函数把当前工作目录存入buf中，如果目录名超出了参数size长度，函数返回NULL，如果成功，返回buf。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strpwd[<span class="number">301</span>];</span><br><span class="line"><span class="built_in">memset</span>(strpwd,<span class="number">0</span>,<span class="built_in">sizeof</span>(strpwd))</span><br><span class="line"><span class="built_in">getcwd</span>(strpwd,<span class="number">300</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n&quot;</span>,strpwd);</span><br></pre></td></tr></table></figure><h1 id="二-切换工作目录"><a class="markdownIt-Anchor" href="#二-切换工作目录"></a> 二、切换工作目录</h1><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure><p>就像我们在shell中使用cd命令切换目录一样，在C程序中使用chdir函数来改变工作目录。</p><p>返回值：0-切换成功；非0-失败。</p><h1 id="三-目录的创建和删除"><a class="markdownIt-Anchor" href="#三-目录的创建和删除"></a> 三、目录的创建和删除</h1><p>在shell中可以通过mkdir/rmdir命令来创建/删除目录，C程序中用mkdir/rmdir函数来创建/删除目录。</p><p>创建目录函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>mode的含义将按open系统调用的O_CREAT选项中的有关定义设置，当然，它还要服从umask的设置况，是不是看不明白？那先固定填0755，注意，0不要省略哦，它表示八进制。  例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>(<span class="string">&quot;/tmp/aaa&quot;</span>,<span class="number">0755</span>);   <span class="comment">// 创建/tmp/aaa目录</span></span><br></pre></td></tr></table></figure><p>删除目录函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="四-获取目录中的文件列表"><a class="markdownIt-Anchor" href="#四-获取目录中的文件列表"></a> 四、获取目录中的文件列表</h1><p>在实际开发中，文件是存放在目录中的，在处理文件之前，必须先知道目录中有哪些文件，所以要获取目录中的文件列表。涉及到的库函数如下：</p><h2 id="1-包含头文件"><a class="markdownIt-Anchor" href="#1-包含头文件"></a> 1、包含头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="2-相关的库函数"><a class="markdownIt-Anchor" href="#2-相关的库函数"></a> 2、相关的库函数</h2><p>打开目录的函数opendir的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><p>读取目录的函数readdir的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> *<span class="built_in">readdir</span>(DIR *dirp);</span><br></pre></td></tr></table></figure><p>关闭目录的函数closedir的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-数据结构"><a class="markdownIt-Anchor" href="#3-数据结构"></a> 3、数据结构</h2><p>1）目录指针DIR</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *目录指针名;</span><br></pre></td></tr></table></figure><p>2）struct dirent结构体</p><p>每调用一次readdir函数会返回一个struct dirent的地址，存放了本次读取到的内容，它的原理与fgets函数读取文件相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">long</span> d_ino;                    <span class="comment">// inode number 索引节点号</span></span><br><span class="line">   <span class="type">off_t</span> d_off;                   <span class="comment">// offset to this dirent 在目录文件中的偏移 </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> d_reclen;     <span class="comment">// length of this d_name 文件名长 </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> d_type;         <span class="comment">// the type of d_name 文件类型</span></span><br><span class="line">   <span class="type">char</span> d_name [NAME_MAX+<span class="number">1</span>];    <span class="comment">// file name文件名，最长255字符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们只需要关注结构体的d_type和d_name成员，其它的不必关心。</p><p>d_name文件名或目录名。</p><p>d_type描述了文件的类型，有多种取值，最重要的是8和4，8-常规文件（A regular file）；4-目录（A directory），其它的暂时不关心。</p><h2 id="4-读取目录"><a class="markdownIt-Anchor" href="#4-读取目录"></a> 4、读取目录</h2><p><strong>示例（book123.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book123.c，此程序用于演示读取目录下的文件名信息</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)  &#123; <span class="built_in">printf</span>(<span class="string">&quot;请指定目录名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  DIR *dir;   <span class="comment">// 定义目录指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开/tmp目录</span></span><br><span class="line">  <span class="keyword">if</span> ( (dir=<span class="built_in">opendir</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于存放从目录中读取到的文件和目录信息</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> *stdinfo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 读取一条记录并显示到屏幕</span></span><br><span class="line">    <span class="keyword">if</span> ((stdinfo=<span class="built_in">readdir</span>(dir)) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name=%s,type=%d\n&quot;</span>,stdinfo-&gt;d_name,stdinfo-&gt;d_type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">closedir</span>(dir);   <span class="comment">// 关闭目录指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304144747256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>在实际开发中，对目录的操作并不会像book123.c那样简单。</p><p>实际需求是这样的，文件存放在某目录中，该目录下还会有多级子目录，程序员想要的是列出该目录及其子目录下全部的文件名。</p><p>例如存在/home/wucz/tmp目录，其子目录结构和文件如下：</p><p><img src="https://img-blog.csdnimg.cn/20200304144802249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>示例（book124.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book124.c，此程序用于演示读取目录及其子目录下全部的文件信息</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录及子目录下的文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strpathname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)  &#123; <span class="built_in">printf</span>(<span class="string">&quot;请指定目录名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列出目录及子目录下的文件</span></span><br><span class="line">  <span class="built_in">ReadDir</span>(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录及子目录下的文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strpathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DIR *dir;   <span class="comment">// 定义目录指针</span></span><br><span class="line">  <span class="type">char</span> strchdpath[<span class="number">256</span>];  <span class="comment">// 子目录的全路径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (dir=<span class="built_in">opendir</span>(strpathname)) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 打开目录</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> *stdinfo; <span class="comment">// 用于存放从目录读取到的文件和目录信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((stdinfo=<span class="built_in">readdir</span>(dir)) == <span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">// 读取一记录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(stdinfo-&gt;d_name,<span class="string">&quot;.&quot;</span>,<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">continue</span>;  <span class="comment">// 以.开始的文件不读</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stdinfo-&gt;d_type==<span class="number">8</span>)    <span class="comment">// 如果是文件，显示出来</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;name=%s/%s\n&quot;</span>,strpathname,stdinfo-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stdinfo-&gt;d_type==<span class="number">4</span>)   <span class="comment">// 如果是目录，再调用一次ReadDir</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(strchdpath,<span class="string">&quot;%s/%s&quot;</span>,strpathname,stdinfo-&gt;d_name);</span><br><span class="line">      <span class="built_in">ReadDir</span>(strchdpath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">closedir</span>(dir);   <span class="comment">// 关闭目录指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304144840881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这才是程序员想要的结果。</p><p>在某些C语言的教材里，有递归函数这个概念，在我的教程里，没有讲这个概念，实际上，book124.c的ReadDir函数就是一个递归函数，在ReadDir函数中调用了自身。</p><h1 id="六-课后作业"><a class="markdownIt-Anchor" href="#六-课后作业"></a> 六、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/post/1617bb54.html"/>
      <url>/post/1617bb54.html</url>
      
        <content type="html"><![CDATA[<p>对计算机来说，一切皆数据，超女的信息是数据、C语言源代码文件是数据、编译后的可执行程序也是数据，数据的存放方式有很多种，如内存、文件、数据库等，文件是极其重要的一种。</p><p>根据文件中数据组织形式的不同，可以把文件分为文本文件和二进制文件，C语言源代码是文本文件，编译后的可执行程序是二进制文件。</p><h1 id="一-文本数据和二进制"><a class="markdownIt-Anchor" href="#一-文本数据和二进制"></a> 一、文本数据和二进制</h1><h2 id="1-文本数据"><a class="markdownIt-Anchor" href="#1-文本数据"></a> 1、文本数据</h2><p>文本数据由字符串组成，存放了每个字符的 ASCII码值，每个字符占一个字节，每个字节存放一个字符。</p><p>例如数字 123，如果用文本格式存放，数据内容是’1’、‘2’、'3’三个字符，占三个字节，如下表所示。</p><table><thead><tr><th><strong>字符</strong></th><th><strong>‘1’</strong></th><th><strong>‘2’</strong></th><th><strong>‘3’</strong></th></tr></thead><tbody><tr><td><strong>ASCII（十进制）</strong></td><td>49</td><td>50</td><td>51</td></tr><tr><td><strong>ASCII（二进制）</strong></td><td>00110001</td><td>00110010</td><td>00110011</td></tr></tbody></table><h2 id="2-二进制数据"><a class="markdownIt-Anchor" href="#2-二进制数据"></a> 2、二进制数据</h2><p>二进制数据是字节序列，数字123的二进制表示是01111011，如果用二进制格式形式存储，字符、短整型、短整型、长整型都可以存储123，存储方式分别如下：</p><p>1）字符型一个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01111011</span></span><br></pre></td></tr></table></figure><p>2）短整型2个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">01111011</span></span><br></pre></td></tr></table></figure><p>3）整型4个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01111011</span></span><br></pre></td></tr></table></figure><p>4）长整型8个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01111011</span></span><br></pre></td></tr></table></figure><h2 id="3-文本文件和二进制文件"><a class="markdownIt-Anchor" href="#3-文本文件和二进制文件"></a> 3、文本文件和二进制文件</h2><p>按文本格式存放数据的文件称为文本文件或ASCII文件，文件可以用vi和记事本打开，看到的都是ASCII字符。</p><p>按二进制格式存放数据的文件称为二进制文件，如果用vi打开二进制文件，看到的是乱码，没有意义。</p><h1 id="二-打开文件"><a class="markdownIt-Anchor" href="#二-打开文件"></a> 二、打开文件</h1><p>C 语言对文件进行操作必须先“打开”文件，操作（读和写）完成后，再“关闭”文件。</p><h2 id="1-文件指针"><a class="markdownIt-Anchor" href="#1-文件指针"></a> 1、文件指针</h2><p>打开文件的时候，C语言为打开的文件分配一个文件信息区，该信息区中包含文件描述信息、缓冲区位置、缓冲区大小、文件读写到的位置等基本信息，这些信息保存在一个结构体类型变量中struct_IO_FILE），这个结构体有一个别名FILE（typedef struct _IO_FILE FILE)，FILE结构体和对文件操作的库函数在 stdio.h 头文件中声明的。</p><p>打开文件的时候，调用fopen函数时会动态分配一个FILE结构体，并把FILE结构体的地址作为函数的返回值，程序中用FILE结构体指针存放这个地址。调用关闭文件的函数fclose时候，除了关闭文件，还会释放文件指针占用的内存空间。</p><p>FILE结构体指针习惯称为文件指针。</p><h2 id="2-打开文件"><a class="markdownIt-Anchor" href="#2-打开文件"></a> 2、打开文件</h2><p>我们可以使用 C语言提供的库函数fopen来创建一个新的文件或者打开一个已存的文件，调用fopen函数成功后，返回一个文件指针（ FILE *），函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode )</span></span>;</span><br></pre></td></tr></table></figure><p>参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的当前目录。实际开发中，采用文件的全路径。</p><p>参数mode也是字符串，表示打开文件的方式（模式），打开方式可以是下列值中的一个。</p><table><thead><tr><th><strong>方式</strong></th><th><strong>含 义</strong></th><th><strong>说 明</strong></th></tr></thead><tbody><tr><td><strong>r</strong></td><td>只读</td><td>文件必须存在，否则打开失败。</td></tr><tr><td><strong>w</strong></td><td>只写</td><td>如果文件存在，则清除原文件内容；如果文件不存在，则新建文件。</td></tr><tr><td><strong>a</strong></td><td>追加只写</td><td>如果文件存在，则打开文件，如果文件不存在，则新建文件。</td></tr><tr><td><strong>r+</strong></td><td>读写</td><td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。</td></tr><tr><td><strong>w+</strong></td><td>读写</td><td>在只写w的方式上增加可读的功能。</td></tr><tr><td><strong>a+</strong></td><td>读写</td><td>在追加只写a的方式上增加可读的功能。</td></tr></tbody></table><p>英文单词：read简写r、write简写w、append简写a。</p><p>注意了，不同教材中对文件打开的方式有不同的说法。</p><p>有的说打开文本文件的方式要用&quot;rt&quot;、“wt”、“at”、“rt+”、“wt+”、“at+”，&quot;t&quot;是text的简写，&quot;t&quot;可以省略不写。</p><p>有的说打开二进制文件的方式要用&quot;rb&quot;、“wb”、“ab”、“rb+”、“wb+”、“ab+”，&quot;b&quot;是binary的简写。</p><p>准确的说，在Linux平台下，打开文本文件和二进制文件的方式没有区别。</p><p>在windows平台下，如果以“文本”方式打开文件，当读取文件的时候，系统会将所有的&quot;/r/n&quot;转换成&quot;/n&quot;；当写入文件的时候，系统会将&quot;/n&quot;转换成&quot;/r/n&quot;写入， 如果以&quot;二进制&quot;方式打开文件，则读和写都不会进行这样的转换，真是罗嗦。</p><h2 id="3-关闭文件"><a class="markdownIt-Anchor" href="#3-关闭文件"></a> 3、关闭文件</h2><p>fclose库函数用于关闭文件，函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>fp为fopen函数返回的文件指针。</p><p><strong>示例（book108.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book108.c，此程序用于演示文件打开和关闭</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/home/wucz/demo/book1.c</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/home/wucz/demo/book1.c&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件/home/wucz/demo/book.c失败。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 上代码等同于以下代码</span></span><br><span class="line"><span class="comment">  fp=fopen(&quot;/oracle/c/book1.c&quot;,&quot;r&quot;);</span></span><br><span class="line"><span class="comment">  if (fp==0)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;打开文件/home/wucz/demo/book.c失败。\n&quot;); return -1;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/* 不信用这个代码来测试</span></span><br><span class="line"><span class="comment">  printf(&quot;fp=%p\n&quot;,(fp=fopen(&quot;/home/wucz/demo/book1.c&quot;,&quot;r&quot;)));</span></span><br><span class="line"><span class="comment">  printf(&quot;fp=%p\n&quot;,fp);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对初学者来说，以下代码可能难以理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/home/wucz/demo/book1.c&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>其实<code>(fp=fopen(&quot;/home/wucz/demo/book1.c&quot;,&quot;r&quot;))</code>表达式的值就是fp，我在讲if分支语句的时候就讨论过了，估计大家都没把它放在心上，我们可以用代码来测试它。</p><p>如果还不理解，就这么抄吧，抄多了就熟了。</p><h2 id="4-注意事项"><a class="markdownIt-Anchor" href="#4-注意事项"></a> 4、注意事项</h2><p>1）调用fopen打开文件的时候，一定要判断返回值，如果文件不存在、或没有权限、或磁盘空间满了，都有可能造成打开文件失败。</p><p>2）文件指针是调用fopen的时候，系统动态分配了内存空间，函数返回或程序退出之前，必须用fclose关闭文件指针，释放内存，否则后果严重。</p><p>3）如果文件指针是空的，用fclose关闭它相当于操作空指针，后果严重。</p><h1 id="三-文本文件的读写"><a class="markdownIt-Anchor" href="#三-文本文件的读写"></a> 三、文本文件的读写</h1><p>在实际开发中，文本文件以行的形式存放字符串，如C程序的源代码，一段文字等，所以一般是按行写入和读取数据。</p><h2 id="1-向文件中写入数据"><a class="markdownIt-Anchor" href="#1-向文件中写入数据"></a> 1、向文件中写入数据</h2><p>C语言向文件中写入数据库函数有fputc、fputs、fprintf，在实际开发中，fputc和fputs没什么用，只介绍fprintf就可以了。fprintf函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>fprintf函数的用法与printf相同，只是多了第一个参数文件指针，表示把数据输出到文件。</p><p>程序员不必关心fprintf函数的返回值。</p><p><strong>示例（book111.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book111.c，此程序用于演示向文件中写入文本数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>   ii=<span class="number">0</span>;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只写的方式打开文件/tmp/test1.txt</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.txt) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">3</span>;ii++) <span class="comment">// 往文件中写入3行</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;这是第%d条数数据。\n&quot;</span>,ii+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译book111.c程序并执行，采用cat命令查看/tmp/test1.txt的内容，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200304141004958.png" alt="在这里插入图片描述" /></p><p>可以看到/tmp/test1.txt中有3行记录，程序book111不管执行多少次，文件/tmp/test1.txt的记录都是3行记录，因为文件打开的方式是&quot;w&quot;，每次打开文件的时候都会清空原文件中的记录。</p><p>大家可以试一下把文件打开方式设置为&quot;a&quot;，看看程序执行的效果。</p><h2 id="2-从文件中读取数据"><a class="markdownIt-Anchor" href="#2-从文件中读取数据"></a> 2、从文件中读取数据</h2><p>C语言从文件中读取数据的库函数有fgetc、fgets、fscanf，在实际开发中，fgetc和fscanf没什么用，只介绍fgets就可以了。fgets函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>fgets的功能是从文件中读取一行。</p><p>参数buf是一个字符串，用于保存从文件中读到的数据。</p><p>参数size是打算读取内容的长度。</p><p>参数fp是待读取文件的文件指针。</p><p>如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。</p><p>调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</p><p><strong>示例（book113.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book113.c，此程序用于演示从文本文件中读取数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;        <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line">  <span class="type">char</span> strbuf[<span class="number">301</span>];  <span class="comment">// 存放从文件中读取到的一行的内容</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/tmp/test1.txt</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.txt) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐行读取文件的内容，输出到屏幕</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuf,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuf));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fgets</span>(strbuf,<span class="number">301</span>,fp)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,strbuf);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304141136317.png" alt="在这里插入图片描述" /></p><p>需要重点说明的是，在读取到 size-1个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。</p><p>不管 size 的值多大，fgets函只读取一行数据，不能跨行。</p><p>在实际开发中，可以将 size 的值设置地足够大，确保每次都能读取到一行完整的数据。</p><h1 id="四-二进制文件的读写"><a class="markdownIt-Anchor" href="#四-二进制文件的读写"></a> 四、二进制文件的读写</h1><p>二进制文件没有行的概念，没有字符串的概念。</p><p>我们把内存中的数据结构直接写入二进制文件，读取的时候，也是从文件中读取数据结构的大小一块数据，直接保存到数据结构中。注意，这里所说的数据结构不只是结构体，是任意数据类型。</p><h2 id="1-向文件中写入数据-2"><a class="markdownIt-Anchor" href="#1-向文件中写入数据-2"></a> 1、向文件中写入数据</h2><p>fwrite函数用来向文件中写入数据块，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>参数的说明：</p><p>ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。</p><p>size：固定填1。</p><p>nmemb：表示打算写入数据的字节数。</p><p>fp：表示文件指针。</p><p>函数的返回值是本次成功写入数据的字节数，一般情况下，程序员不必关心fwrite函数的返回值。</p><p><strong>示例（book115.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book115.c，此程序用于演示向文件中写入二进制数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;  <span class="comment">// 定义超女数据结构变量</span></span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只写的方式打开文件/tmp/test1.dat</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.dat&quot;</span>,<span class="string">&quot;w&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.dat) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>); stgirl.age=<span class="number">18</span>; stgirl.height=<span class="number">170</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.sc,<span class="string">&quot;火辣&quot;</span>); <span class="built_in">strcpy</span>(stgirl.yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line">  <span class="built_in">fwrite</span>(&amp;stgirl,<span class="number">1</span>,<span class="built_in">sizeof</span>(stgirl),fp);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;芙蓉妹妹&quot;</span>); stgirl.age=<span class="number">38</span>; stgirl.height=<span class="number">166</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.sc,<span class="string">&quot;膘肥体壮&quot;</span>); <span class="built_in">strcpy</span>(stgirl.yz,<span class="string">&quot;让人终生不忘&quot;</span>);</span><br><span class="line">  <span class="built_in">fwrite</span>(&amp;stgirl,<span class="number">1</span>,<span class="built_in">sizeof</span>(stgirl),fp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序，得到数据文件/tmp/test.dat，用vi命令打开文件，显示如下：</p><p><img src="https://img-blog.csdnimg.cn/2020030414125268.png" alt="在这里插入图片描述" /></p><p>可以看到很多乱码，其实并不是文件的内容乱，而是vi无法识别文件的格式，把内容当成ASCII码显示，如果内容刚好是ASCII码，就能正确显示，如果不是ASCII码（如年龄和身高是整数），就无法正常显示了。</p><h2 id="2-从文件中读取数据-2"><a class="markdownIt-Anchor" href="#2-从文件中读取数据-2"></a> 2、从文件中读取数据</h2><p>fread函数用来从文件中读取数据块，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。</p><p>size：固定填1。</p><p>nmemb：表示打算读取的数据的字节数。</p><p>fp：表示文件指针。</p><p>调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</p><p><strong>示例（book117.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book117.c，此程序用于演示从文件中读取二进制数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;  <span class="comment">// 定义超女数据结构变量</span></span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/tmp/test1.dat</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.dat&quot;</span>,<span class="string">&quot;rb&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.dat) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 从文件中读取数据，存入超女数据结构变量中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fread</span>(&amp;stgirl,<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl),fp)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 显示超女数据结构变量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\n&quot;</span>,\</span><br><span class="line">          stgirl.name,stgirl.age,stgirl.height,stgirl.sc,stgirl.yz);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304141445760.png" alt="在这里插入图片描述" /></p><h2 id="3-注意事项"><a class="markdownIt-Anchor" href="#3-注意事项"></a> 3、注意事项</h2><p>1）我对fread和fwrite函数的size和nmemb以及它们的返回值的解释是不准确的，这么做的原因是为了方便大家的学习，正确的解释会把大家搞晕，等您功力提升之候，我们再讨论它的准确含义。</p><p>2）fwrite和fread函数也可以写入和读取文本文件，但是没有换行的概念，不管是换行符或其它的特殊字符，无区别对待。</p><p>3）一般来说，二进制文件有约定的数据格式，程序必须按约定的格式写入/读取数据，book115.c写入的是超女结构体，book117.c就要用超女结构体来存放读取到的数据。这道理就像图片查看软件无法打开音频文件，音频播放软件也无法打开图片文件，因为音频文件和图片文件的格式不同。</p><h1 id="五-文件定位"><a class="markdownIt-Anchor" href="#五-文件定位"></a> 五、文件定位</h1><p>在文件内部有一个位置指针，用来指向当前读写的位置。在文件打开时，如果打开方式是r和w，位置指针指向文件的第一个字节，如果打开方式是a，位置指针指向文件的尾部。每当从文件里读n个字节或文件里写入n个字节之后位置指针也会向后移动n个字节。</p><p>文件位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，不是变量的地址。文件每读写一次，位置指针就会移动一次，它不需要您在程序中定义和赋值，而是由系统自动设置，对程序员来说是隐藏的。</p><p>在实际开发中，偶尔需要移动位置指针，实现对指定位置数据的读写。我们把移动位置指针称为文件定位。</p><p>C语言提供了ftell、rewind和fseek三个库函数来实现文件定位功能。</p><h2 id="1-ftell函数"><a class="markdownIt-Anchor" href="#1-ftell函数"></a> 1、ftell函数</h2><p>ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-rewind函数"><a class="markdownIt-Anchor" href="#2-rewind函数"></a> 2、rewind函数</h2><p>rewind函数用来将位置指针移动到文件开头，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewind</span> <span class="params">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-fseek函数"><a class="markdownIt-Anchor" href="#3-fseek函数"></a> 3、fseek函数</h2><p>fseek() 用来将位置指针移动到任意位置，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span> <span class="params">( FILE *fp, <span class="type">long</span> offset, <span class="type">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>1）fp 为文件指针，也就是被移动的文件。</p><p>2）offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。</p><p>3）origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">100</span>,<span class="number">0</span>);     <span class="comment">// 从文件的开始位置计算，向后移动100字节。</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">100</span>,<span class="number">1</span>);     <span class="comment">// 从文件的当前位置计算，向后移动100字节。</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">-100</span>,<span class="number">2</span>);    <span class="comment">// 从文件的尾部位置计算，向前移动100字节。</span></span><br></pre></td></tr></table></figure><h2 id="4-注意事项-2"><a class="markdownIt-Anchor" href="#4-注意事项-2"></a> 4、注意事项</h2><p>当offset是向文件尾方向偏移的时候，无论偏移量是否超出文件尾，fseek都是返回0，当偏移量没有超出文件尾的时候，文件指针式指向正常的偏移地址的，当偏移量超出文件尾的时候，文件指针是指向文件尾的，不会返回偏移出错-1值。</p><p>当offset是向文件头方向偏移的时候，如果offset没有超出文件头，是正常偏移，文件指针指向正确的偏移地址，fseek返回值为0，当offset超出文件头时，fseek返回出错-1值，文件指针还是处于原来的位置。</p><h1 id="六-文件缓冲区"><a class="markdownIt-Anchor" href="#六-文件缓冲区"></a> 六、文件缓冲区</h1><p>在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。</p><p>在实际开发中，如果程序员想把缓冲区的数据立即写入文件，可以调用fflush库函数，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的参数只有一个，即文件指针，返回0成功，其它失败，程序员一般不关心它的返回值。</p><h1 id="七-标准输入-标准输出和标准错误"><a class="markdownIt-Anchor" href="#七-标准输入-标准输出和标准错误"></a> 七、标准输入、标准输出和标准错误</h1><p>Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(stdout,<span class="string">&quot;Hello world.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这几个文件指针没什么用，让大家了解一下就行。在实际开发中，我们一般会关闭这几个文件指针。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>在实际开发中，文件操作极其重要，本章节的课后作业一定要认真完成。</p><p>1）编写示例程序，从界面上输入五名超女的数据，存放在struct st_girl结构体数组中，然后把结构体数组以二进制的方式写入文件。</p><p>2）编写示例程序，把上一题写入的数据从二进制文件中读取出来，存入struct st_girl结构体中，然后在界面上显示出来。</p><p>3）编写示例程序，从界面上输入五名超女的数据，存放在struct st_girl结构体数组中，然后把结构体数组以xml字符串的方式写入文本文件。文件内容的格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;<span class="number">20</span>&lt;/age&gt;&lt;height&gt;<span class="number">166</span>&lt;/height&gt;&lt;sc&gt;一般&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;</span><br><span class="line">&lt;name&gt;王昭君&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;height&gt;<span class="number">160</span>&lt;/height&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;一般&lt;/yz&gt;</span><br><span class="line">&lt;name&gt;杨玉环&lt;/name&gt;&lt;age&gt;<span class="number">22</span>&lt;/age&gt;&lt;height&gt;<span class="number">177</span>&lt;/height&gt;&lt;sc&gt;一般&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;</span><br><span class="line">&lt;name&gt;陈圆圆&lt;/name&gt;&lt;age&gt;<span class="number">26</span>&lt;/age&gt;&lt;height&gt;<span class="number">159</span>&lt;/height&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;不行&lt;/yz&gt;</span><br></pre></td></tr></table></figure><p>4）编写示例程序，把上一题写入的数据从文本文件中读取出来，并解析xml，存入struct st_girl结构体中，然后在界面上显示出来。</p><p>5）编写示例程序，实现文件复制的功能，文本文件用fget和fprintf读写？二进制文件用fread和fwrite读写？用fread和fwrite读写文本文件是什么效果？</p><p>6）编写示例程序，测试文件定位函数ftell、rewind和fseek的使用。</p><p>7）编写示例程序，测试文件缓冲函数fflush的使用。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言动态内存管理</title>
      <link href="/post/9f069264.html"/>
      <url>/post/9f069264.html</url>
      
        <content type="html"><![CDATA[<p>在C语言中，编写程序的时候不能确定内存的大小，希望程序在运行的过程中根据数据量的大小动态的分配内存。动态内存管理，就是指在程序运行过程中动态的申请和释放内存空间。</p><p>C语言允许程序动态管理内存，需要时随时开辟，不需要时随时释放。内存的动态管理是通过调用库函数来实现的，主要有malloc和free函数。</p><h1 id="一-相关的库函数"><a class="markdownIt-Anchor" href="#一-相关的库函数"></a> 一、相关的库函数</h1><h2 id="1-malloc-函数"><a class="markdownIt-Anchor" href="#1-malloc-函数"></a> 1、malloc 函数</h2><p>函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>；</span></span><br></pre></td></tr></table></figure><p>malloc的作用是向系统申请一块大小为size的连续内存空间，如果申请失败，函数返回0，如果申请成功，返回成功分配内存块的起始地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">100</span>)； <span class="comment">// 申请 100 个字节的临时分配域，返回值为其第一个字节的地址</span></span><br></pre></td></tr></table></figure><p>malloc的返回值的地址的基类型为void，即不指向任何类型的数据，只提供一个地址，程序中需要定义一个指针来指向动态分配的内存地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><h2 id="2-free-函数"><a class="markdownIt-Anchor" href="#2-free-函数"></a> 2、free 函数</h2><p>函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *p)</span></span>;</span><br></pre></td></tr></table></figure><p>free的作用是释放指针p指向的动态内存空间，p是调用malloc函数时返回的地址，free函数无返回值。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);     <span class="comment">// 释放指针变量pi指向的已分配的动态空间</span></span><br></pre></td></tr></table></figure><p><strong>示例（book107.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book107.c，此程序用于演示C程序动态内存管理。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>  <span class="comment">// 超女结构体</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    *pi=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">// 分配int类型大小的内存</span></span><br><span class="line">  <span class="type">long</span>   *pl=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>));   <span class="comment">// 分配long类型大小的内存</span></span><br><span class="line">  <span class="type">double</span> *pd=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>)); <span class="comment">// 分配double类型大小的内存</span></span><br><span class="line">  <span class="type">char</span>   *pc=<span class="built_in">malloc</span>(<span class="number">101</span>);            <span class="comment">// 分配101字节的内存，可存放100个字符的字符串</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl)); <span class="comment">// 分配struct st_girl结构体大小的内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码是像普通指针和变量一样使用动态分配的内存</span></span><br><span class="line">  *pi=<span class="number">10</span>;     <span class="built_in">printf</span>(<span class="string">&quot;*pi=%d\n&quot;</span>,*pi);</span><br><span class="line">  *pl=<span class="number">20</span>;     <span class="built_in">printf</span>(<span class="string">&quot;*pl=%d\n&quot;</span>,*pl);</span><br><span class="line">  *pd=<span class="number">10.5</span>;   <span class="built_in">printf</span>(<span class="string">&quot;*pd=%.1f\n&quot;</span>,*pd);</span><br><span class="line">  <span class="built_in">strcpy</span>(pc,<span class="string">&quot;西施&quot;</span>); <span class="built_in">printf</span>(<span class="string">&quot;*pc=%s\n&quot;</span>,pc);</span><br><span class="line">  <span class="built_in">strcpy</span>(pst-&gt;name,<span class="string">&quot;杨玉环&quot;</span>); pst-&gt;age=<span class="number">21</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,age=%d\n&quot;</span>,pst-&gt;name,pst-&gt;age);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">  <span class="built_in">free</span>(pi); <span class="built_in">free</span>(pl); <span class="built_in">free</span>(pd); <span class="built_in">free</span>(pc); <span class="built_in">free</span>(pst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304112551794.png" alt="在这里插入图片描述" /></p><h1 id="二-内存被耗尽"><a class="markdownIt-Anchor" href="#二-内存被耗尽"></a> 二、内存被耗尽</h1><p>使用动态分配内存技术的时候，分配出来的内存必须及时释放，否则会引起系统内存耗尽，这话说起来简单，好像很容易做到，但是在实际开发中，程序员往往是漏洞百出。</p><p>内存问题是C程序员的主要问题之一，是初学者的恶梦。</p><h1 id="三-野指针"><a class="markdownIt-Anchor" href="#三-野指针"></a> 三、野指针</h1><p>野指针就是无效的指针，与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。</p><h2 id="1-指针变量未初始化"><a class="markdownIt-Anchor" href="#1-指针变量未初始化"></a> 1、指针变量未初始化</h2><p>指针变量刚被创建时不一定会自动初始化成为空指针（与编译器有关），它的缺省值是可能随机的，它会随便乱指。所以，指针变量在创建的同时应当被初始化，要么将指针的值设置为0，要么让它指向合法的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *pi=&amp;i;</span><br></pre></td></tr></table></figure><h2 id="2-指针释放后之后未置空"><a class="markdownIt-Anchor" href="#2-指针释放后之后未置空"></a> 2、指针释放后之后未置空</h2><p>指针在free时会把指针所指的内存给释放掉，但指针不一定会赋值0（也与编译器有关），如果对释放后的指针进行操作，相当于非法操作内存。释放内存后应立即将指针置为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><h2 id="1-数组申明的改进"><a class="markdownIt-Anchor" href="#1-数组申明的改进"></a> 1、数组申明的改进</h2><p>在C语言的早期标准中，定义数组必须用常量指明大小，不能用变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">101</span>];        <span class="comment">// 可以这样</span></span><br><span class="line"><span class="type">int</span> len=<span class="number">101</span>;</span><br><span class="line"><span class="type">char</span> str[len];         <span class="comment">// 不可以这样</span></span><br></pre></td></tr></table></figure><p>程序在运行的时候，如果要定义一个字符串存放100个字符，那怎么办，只能通过动态分配内存技术。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str=<span class="built_in">malloc</span>(<span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>现在，定义数组可以用变量指明大小，就不必为数组动态分配内存了。</p><p>还有，C++的string是一个变长的字符串，非常好用，程序员根本不必关心内存的问题。</p><h2 id="2-链表"><a class="markdownIt-Anchor" href="#2-链表"></a> 2、链表</h2><p>链表是C语言的一个经典的数据结构，相当于一个动态的结构体数组，非常巧妙，功能强大，但操作也麻烦，在这里我就不介绍了。</p><p>在C++中，容器全完代替了链表的功能，极其好用，程序员也不必关心内存的问题。</p><h2 id="3-我的建议"><a class="markdownIt-Anchor" href="#3-我的建议"></a> 3、我的建议</h2><p>在中国，没有纯C程序员，如果他不会C++，不是他对C有多么执着，可能是不会C++。</p><p>至少十年了，我不再使用动态内存分配技术，也想不到有什么场景非得用动态内存分配技术。</p><p>哦，嵌入式开发可能是个例外，可能还有其它只能用C不能用C++的场景。</p><p>动态内存分配并不是什么高大上的技术，我是一个实用的程序员，绝不给自己挖坑，这与水平高低无关。</p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言main函数的参数</title>
      <link href="/post/adcf2046.html"/>
      <url>/post/adcf2046.html</url>
      
        <content type="html"><![CDATA[<p>程序运行的时候，有些需要带参数，有些不带参数，例如linux操作系统的命令，它们本质上就是C程序。</p><p>1）Linux命令中，无参数的不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd  #显示当前目录</span><br><span class="line">clear  #清屏</span><br></pre></td></tr></table></figure><p>2）大部Linux命令是带参数的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp  book1.c book2.c</span><br><span class="line">mkdir /tmp/dname</span><br><span class="line">mv book3 /tmp/dname/book3</span><br><span class="line">rm -rf /tmp/dname</span><br></pre></td></tr></table></figure><p>各位现在是在C语言学习的初级阶段，编写的C程序非常简单，运行不需要参数，但是在实际开发中，main函数一般都需要参数，没有参数的情况极少。</p><p>main函数的参数是从命令提示符下执行程序的时候传入，例如ls 命令。</p><p><img src="https://img-blog.csdnimg.cn/20200304110829716.png" alt="在这里插入图片描述" /></p><p>在以上示例中ls命令有两个参数，-l和book1?.c。</p><h1 id="一-main函数的参数"><a class="markdownIt-Anchor" href="#一-main函数的参数"></a> 一、main函数的参数</h1><p>main函数有三个参数，argc、argv和envp，它的标准写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure><p>int argc，存放了命令行参数的个数。</p><p>char *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。</p><p>char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。</p><p>envp先放一下，先讲argc和argv。</p><p><strong>示例（book101.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book101.c，此程序演示main函数的参数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示参数的个数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;argc is %d\n&quot;</span>,argc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列出全部的参数</span></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;argc;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] is %s\n&quot;</span>,ii,argv[ii]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304110937722.png" alt="在这里插入图片描述" /></p><p>注意几个事项：</p><p>1）argc的值是参数个数加1，因为程序名称是程序的第一个参数，即argv[0]，在上面的示例中，argv[0]是./book101。</p><p>2）main函数的参数，不管是书写的整数还是浮点数，全部被认为是字符串。</p><p>3）参数的命名argc和argv是程序员的约定，您也可以用argd或args，但是不建议这么做。</p><h1 id="二-c程序的规范写法"><a class="markdownIt-Anchor" href="#二-c程序的规范写法"></a> 二、C程序的规范写法</h1><p>先假设程序执行都是有参数的，也就是说main函数都有参数，那么使用者怎么知道程序的参数个数和含义，记住它？看使用手册？不是，优秀的程序员会在程序中提供说明文字。我们先来看一个例子。</p><p><strong>示例（book103.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book103.c，此程序演示main函数的参数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">6</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n这是一个超女选秀程序，根据提供的超女信息，判断&quot;</span>\</span><br><span class="line">           <span class="string">&quot;她是否符合王妃的标准。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;用法：./book103 name age height sc yz\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;例如：./book103 西施 22 170 火辣 漂亮\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name   超女的姓名。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age    超女的年龄。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;height 超女的身高，单位：cm。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sc     超女的身材，火辣；普通；飞机场。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;yz     超女的颜值，漂亮；一般；歪瓜裂枣。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;您输入的超女信息是：姓名（%s）,年龄（%s），身高（%s），身材（%s），颜值（%s）。\n&quot;</span>,\</span><br><span class="line">          argv[<span class="number">1</span>],argv[<span class="number">2</span>],argv[<span class="number">3</span>],argv[<span class="number">4</span>],argv[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;正在计算中，请稍候......\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (((<span class="built_in">atoi</span>(argv[<span class="number">2</span>]) &gt;=  <span class="number">20</span>) &amp;&amp; (<span class="built_in">atoi</span>(argv[<span class="number">2</span>]) &lt;=  <span class="number">30</span>)) &amp;&amp;  <span class="comment">// 年龄在20-30之间</span></span><br><span class="line">      ((<span class="built_in">atoi</span>(argv[<span class="number">3</span>]) &gt;= <span class="number">165</span>) &amp;&amp; (<span class="built_in">atoi</span>(argv[<span class="number">3</span>]) &lt;= <span class="number">175</span>)) &amp;&amp;  <span class="comment">// 身高在165-175之间</span></span><br><span class="line">      ((<span class="built_in">strcmp</span>(argv[<span class="number">4</span>],<span class="string">&quot;火辣&quot;</span>)==<span class="number">0</span>)                     ) &amp;&amp;  <span class="comment">// 身材火辣</span></span><br><span class="line">      ((<span class="built_in">strcmp</span>(argv[<span class="number">5</span>],<span class="string">&quot;漂亮&quot;</span>)==<span class="number">0</span>)                     ))    <span class="comment">// 颜值漂亮</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女（%s）选秀合格，送往后宫。\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女（%s）选秀不合格，发放五两银子后送回家。\n&quot;</span>, argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行程序的时候，如果参数不符，运行效果如下。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304111048243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>如果参数个数相符，运行效果如下。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304111105939.png" alt="在这里插入图片描述" /></p><p>从以上的例子可以看出，如果执行程序的时候提供的参数与设计不符，显示程序的使用说明，说明文字应该包括程序的功能和全部参数的解释，还可以包括作者、联系方式等更详细的信息。</p><p>程序的使用说明文字非常重要，有几个原因：</p><p>1）程序的使用者不一定会写程序，也没必要去查使用手册等资料；</p><p>2）程序的使用者就算会写程序，也没必要在使用的时候去看源代码，并且，您也不一定想让他看到源代码；</p><p>3）如果程序的使用者是您自己，时间一长，您也会忘记程序的参数。</p><p>当然，这些只是程序员的约定，不是C语言的规定。</p><h1 id="三-envp参数"><a class="markdownIt-Anchor" href="#三-envp参数"></a> 三、envp参数</h1><p>envp存放了当前程序运行环境的参数。</p><p><strong>示例（book105.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book105.c，此程序用于演示当前程序运行环境的参数envp。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (envp[ii] != <span class="number">0</span>)  <span class="comment">// 数组最后一个元素是0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,envp[ii]); ii++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304111241101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意了，book105运行的结果与linux系统的env命令相同。</p><p>在实际开发中，envp参数的应用场景不多，各位了解一下就行了。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言格式化输出</title>
      <link href="/post/e45b3b92.html"/>
      <url>/post/e45b3b92.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-格式化输出"><a class="markdownIt-Anchor" href="#一-格式化输出"></a> 一、格式化输出</h1><p>格式化输出的函数有printf、sprintf和snprintf等，功能略有不同，使用方法大同小异，本章节我们先以printf为例。</p><p>对于 printf 函数，相信大家并不陌生。之所以称它为格式化输出函数，该函数的声名如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure><p>大家看到printf函数的声明就会有点懵，它参数的写法与我们之前学到的函数知识不一样，printf函数是一个“可变参数函数”（即函数参数的个数是可变的），可变参数函数的知识以后再介绍，现在只要知道怎么使用就行了。</p><p>printf函数的参数的个数和类型都是可变的，每一个参数的输出格式都有对应的格式说明符与之对应，从格式串的左端第1 个格式说明符对应第 1 个输出参数，第 2 个格式说明符对应第 2 个输出参数，第 3个格式说明符对应第 3 个输出参数，以此类推。</p><p>其中，格式说明符的形式如下（方括号 [] 中的项为可选项）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.prec] type</span><br></pre></td></tr></table></figure><h2 id="1-类型符type"><a class="markdownIt-Anchor" href="#1-类型符type"></a> 1、类型符（type）</h2><p>它用以表示输出数据的类型，以下是常用类型的汇总，不常用的就不列了。</p><p>%hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。</p><p>%hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数</p><p>%c 输出字符。</p><p>%lf 以普通方式输出double（float弃用，long doube无用）。</p><p>%e 以科学计数法输出double。</p><p>%s 输出字符串。</p><p>以上输出数据的知识在之前介绍数据类型的时候已演示过，这里就不举例了。</p><h2 id="2-宽度width"><a class="markdownIt-Anchor" href="#2-宽度width"></a> 2、宽度（width）</h2><p>它用于控制输出内容的宽度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);     <span class="comment">// 输出=         abc=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12d=\n&quot;</span>,<span class="number">123</span>);       <span class="comment">// 输出=         123=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12lf=\n&quot;</span>,<span class="number">123.5</span>);    <span class="comment">// 输出=  123.500000=</span></span><br></pre></td></tr></table></figure><h2 id="3-对齐标志flags"><a class="markdownIt-Anchor" href="#3-对齐标志flags"></a> 3、对齐标志（flags）</h2><p>flags它用于控制输出内容的对齐方式。</p><p><strong>不填或+</strong>：输出的内容右对齐，这是缺省的方式，上一小节就是右对齐的示例。</p><p><strong>-</strong>：输出的内容左对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);    <span class="comment">// 输出=abc         =</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12d=\n&quot;</span>,<span class="number">123</span>);     <span class="comment">// 输出=123         =</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12f=\n&quot;</span>,<span class="number">123.5</span>);    <span class="comment">// 输出=123.500000  =</span></span><br></pre></td></tr></table></figure><p>如果输出的内容是整数或浮点数，并且对齐的方式是右对齐，可以加0填充，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 输出=         abc=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012d=\n&quot;</span>,<span class="number">123</span>);   <span class="comment">// 输出=000000000123=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012f=\n&quot;</span>,<span class="number">123.5</span>);  <span class="comment">// 输出=00123.500000= </span></span><br></pre></td></tr></table></figure><p>从上面第一行代码的结果看出，输出的内容不是整数或浮点数，是字符串，不能在前面填0。</p><p>左对齐的时候，能在整数或浮点数的后面补0吗？浮点数最多可以补到6位，整数不行，为什么？您的存款能在后面补0吗？</p><h2 id="4-精度prec"><a class="markdownIt-Anchor" href="#4-精度prec"></a> 4、精度（prec）</h2><p>如果输出的内容是浮点数，它用于控制输出内容的精度，也就是说小数点后面保留多少位，后面的数四舍五入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12.2lf=\n&quot;</span>,<span class="number">123.5</span>);   <span class="comment">// 输出=      123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%.2lf=\n&quot;</span>,<span class="number">123.5</span>);     <span class="comment">// 输出=123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12.2e=\n&quot;</span>,<span class="number">123500000000.0</span>);  <span class="comment">// 输出=    1.24e+11=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%.2e=\n&quot;</span>,<span class="number">123500000000.0</span>);    <span class="comment">// 输出=1.24e+11=</span></span><br></pre></td></tr></table></figure><h1 id="二-格式化输出到字符串"><a class="markdownIt-Anchor" href="#二-格式化输出到字符串"></a> 二、格式化输出到字符串</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。</p><p>在之前的章节中，介绍过把字符串转换为整数和浮点数据的库函数，C语言没有提供把整数和浮点数据转换为字符串的库函数，而是采用sprintf和snprintf函数格式化输出到字符串。</p><p><strong>示例（book98.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book98.c，此程序演示格式化输出sprintf和snprintf函数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化输出到str中</span></span><br><span class="line">  <span class="built_in">sprintf</span>(str,<span class="string">&quot;%d,%c,%f,%s&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">25.97</span>,<span class="string">&quot;一共输入了三个数。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化输出到str中，只截取前7个字符</span></span><br><span class="line">  <span class="built_in">snprintf</span>(str,<span class="number">8</span>,<span class="string">&quot;%d,%c,%f,%s&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">25.97</span>,<span class="string">&quot;一共输入了三个数。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304104504898.png" alt="在这里插入图片描述" /></p><p>程序运行第二行只输出了6个字符，注意，snprintf函数在unix和windows平台下的表现略有不同，在windows平台下，第二行会输出7个字符。</p><h1 id="三-c语言代码的多行书写"><a class="markdownIt-Anchor" href="#三-c语言代码的多行书写"></a> 三、C语言代码的多行书写</h1><p>在我们之前学习的过程中，编写的程序的功能很简单，一句代码很短，但是在实际开发中，参数往往很长很多，一句代码可能会很长，需要用多行才能书写。</p><p>如果我们在一行代码的行尾放置一个反斜杠，c语言编译器会忽略行尾的换行符，而把下一行的内容也算作是本行的内容。这里反斜杠起到了续行的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;aaaaaaaaaa\</span></span><br><span class="line"><span class="string">bbbbbbbbb);</span></span><br></pre></td></tr></table></figure><p>如果我们不使用反斜杠，当我们试图初始化一个跨多行的字符串时，c语言编译器可能会发出警告或错误，如下面的语句是不正确的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;aaaaaaaaaa</span></span><br><span class="line"><span class="string">bbbbbbbbb);</span></span><br></pre></td></tr></table></figure><p>C语言中还有字符串多行书写的方法，那就是将它写个多个字符串，C语言编译器会自动将这些字符串连接起来，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;aaabbbccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">strcpy</span>(str,<span class="string">&quot;aaa&quot;</span><span class="string">&quot;bbb&quot;</span><span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">strcpy</span>(str,<span class="string">&quot;aaa&quot;</span>\</span><br><span class="line">            <span class="string">&quot;bbb&quot;</span>\</span><br><span class="line">            <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="built_in">sprintf</span>(str,<span class="string">&quot;aaabbbccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">sprintf</span>(str,<span class="string">&quot;aaa&quot;</span><span class="string">&quot;bbb&quot;</span><span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">sprintf</span>(str,<span class="string">&quot;aaa&quot;</span>\</span><br><span class="line">             <span class="string">&quot;bbb&quot;</span>\</span><br><span class="line">             <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br></pre></td></tr></table></figure><p>以上每段代码的输出结果完全一样，表达式：“aaa”  “bbb” “ccc” 实际上相当于&quot;aaabbbccc&quot;。</p><p>把字符串很长，参数很多的代码用多行书写，可以使程序代码结构更清晰，以下代码是我实际开发中用到的一句代码，这还不算长的。</p><p><img src="https://img-blog.csdnimg.cn/20200304104727548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><p>2）编写一个解析XML字符串的函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_XMLBuffer,<span class="type">const</span> <span class="type">char</span> *in_FieldName,<span class="type">char</span> *out_Value)</span></span>;</span><br></pre></td></tr></table></figure><p>in_XMLBuffer，XML格式的字符串，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;</span><br></pre></td></tr></table></figure><p>in_FieldName，字段的标签名。</p><p>out_Value，获取内容存放的变量的指针。</p><p>返回值，0-成功，-1-失败。</p><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strXMLBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(strXMLBuffer,<span class="string">&quot; &lt;name&gt;西施&lt;/name&gt;&lt;age&gt;18&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&quot;</span>);</span><br><span class="line"><span class="type">char</span> strvalue[<span class="number">51</span>];</span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;name&quot;</span>,strvalue);   <span class="comment">// strvalue的内容将是&quot;西施&quot;</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;age&quot;</span>,strvalue);     <span class="comment">// strvalue的内容将是&quot;18&quot;</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;sc&quot;</span>,strvalue);       <span class="comment">// strvalue的内容将是&quot;火辣&quot;</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;yz&quot;</span>,strvalue);       <span class="comment">// strvalue的内容将是&quot;漂亮&quot;</span></span><br></pre></td></tr></table></figure><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言结构体</title>
      <link href="/post/d6d91a4f.html"/>
      <url>/post/d6d91a4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-结构体的概念"><a class="markdownIt-Anchor" href="#一-结构体的概念"></a> 一、结构体的概念</h1><p>前面的教程中我们讲解了变量和数组（array），变量是一个一个定义的，数组是一组具有相同类型的变量的集合。但在实际的工作和生活中，为了表达一个数据集，需要用不同数据类型的变量。例如超女基本信息，姓名为字符串，身高和年龄为整数，体重为浮点数，身材和颜值为字符串，因为数据集各要素的数据类型不同，不能用一个数组来存放。</p><p>用我们之前学过的知识，如果要存放超女信息，可以用多个变量，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">51</span>];   <span class="comment">// 姓名</span></span><br><span class="line"><span class="type">int</span>  age;        <span class="comment">// 年龄</span></span><br><span class="line"><span class="type">int</span>  height;     <span class="comment">// 身高，单位：cm</span></span><br><span class="line"><span class="type">double</span> weight;     <span class="comment">// 体重，单位：kg</span></span><br><span class="line"><span class="type">char</span> sc[<span class="number">31</span>];     <span class="comment">// 身材，火辣；普通；飞机场</span></span><br><span class="line"><span class="type">char</span> yz[<span class="number">31</span>];     <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣</span></span><br></pre></td></tr></table></figure><p>这种方式有一个缺陷，如果某数据集有100个要素，就要定义100个变量，对100个变量初始化，把100个变量作为函数的参数传递，实在太麻烦。</p><p>在C语言中，使用结构体（struct）来存放一组不同类型的数据，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名</span><br><span class="line">&#123;</span><br><span class="line">  结构体成员变量一的声明;</span><br><span class="line">  结构体成员变量二的声明;</span><br><span class="line">  结构体成员变量三的声明;</span><br><span class="line">  ......</span><br><span class="line">  结构体成员变量四的声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体是一个集合，是一种构造的数据类型，是程序员为了描述一个数据集自己定义出来的数据类型。结构体的成员（member）可以是任意类型的变量，也可以是结构体变量。以超女为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];   <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;        <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;     <span class="comment">// 身高，单位：cm</span></span><br><span class="line">  <span class="type">int</span>  weight;     <span class="comment">// 体重，单位：kg</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">31</span>];     <span class="comment">// 身材，火辣；普通；飞机场</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">31</span>];     <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二-结构体变量"><a class="markdownIt-Anchor" href="#二-结构体变量"></a> 二、结构体变量</h1><p>结构体是一种程序员自定义的数据类型，是模板，可以用它来定义变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> queen, princess, waiting, workers;</span><br></pre></td></tr></table></figure><p>定义了四个结构体变量，queen王后、princess王妃，waiting宫女和workers侍者。</p><h1 id="三-占用内存的情况"><a class="markdownIt-Anchor" href="#三-占用内存的情况"></a> 三、占用内存的情况</h1><p>理论上讲结构体的各个成员在内存中是连续存放的，和数组非常类似，但是，结构体的占用内存的总大小不一定等于全部成员变量占用内存大小之和。在编译器的具体实现中，为了提高内存寻址的效率，各个成员之间可能会存在缝隙。用sizeof可以得到结构体占用内容在总大小，sizeof(结构体名)或sizeof(结构体变量名)都可以。</p><p><strong>示例（book90.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book90.c，此程序用于演示C语言的结构体占用内存的情况</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct st_girl) %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(queen) %d\n&quot;</span>,<span class="built_in">sizeof</span>(queen));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304100720779.png" alt="在这里插入图片描述" /></p><p>从上面的示例可以看出，struct st_girl全部成员变量占用的内存是50+4+4+30+30=118，但是结构体占用的内存是120。</p><p>注意，C语言提供了结构体成员内存对齐的方法，可以使结构体成员变量之间的内存没有空隙，我暂时不介绍。</p><h1 id="四-结构体的变量名"><a class="markdownIt-Anchor" href="#四-结构体的变量名"></a> 四、结构体的变量名</h1><p>和数组不一样，结构体变量名不是结构体变量的地址，结构体变量名就是变量名，就象int ii一样，只是不能直接输出，直接输出没有意义。取地址要用&amp;，不用钻牛角尖，不直接输出就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stgirl);   <span class="comment">// 没有意义。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,stgirl);   <span class="comment">// 没有意义，结构体变量名不是结构体变量的地址。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;stgirl);  <span class="comment">// 这才是结构体的地址。</span></span><br></pre></td></tr></table></figure><h1 id="五-结构体初始化"><a class="markdownIt-Anchor" href="#五-结构体初始化"></a> 五、结构体初始化</h1><p>采用memset函数初始化结构体，全部成员变量的值清零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(queen));</span><br></pre></td></tr></table></figure><p>注意事项，如果把一个结构体的地址传给子函数，子函数用一个结构体指针（如struct st_girl *pst）来存放传入的结构体的地址，那么，在子函数中只能用以下方法来初始化结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pst,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br></pre></td></tr></table></figure><p>不能用以下方法来初始化结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pst,<span class="number">0</span>,<span class="built_in">sizeof</span>(pst));</span><br></pre></td></tr></table></figure><p>因为子函数中用sizeof(pst)，得到的不是结构体占用内存的字节数，而是结构体指针变量占用内存的字节数（8字节）。</p><h1 id="六-成员的访问使用"><a class="markdownIt-Anchor" href="#六-成员的访问使用"></a> 六、成员的访问（使用）</h1><p>使用使用圆点.运算符可以访问（使用）结构的成员，结构体成员变量的使用与普通变量的使用相同。</p><p><strong>示例（book92.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book92.c，此程序演示结构体的访问（使用）。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;  <span class="comment">// 定义结构体变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化结构体变量</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对结构体每个成员赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(queen.name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  queen.age=<span class="number">28</span>;</span><br><span class="line">  queen.height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(queen.sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(queen.yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>,queen.name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;年龄：%d\n&quot;</span>,queen.age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;身高：%d\n&quot;</span>,queen.height);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;身材：%s\n&quot;</span>,queen.sc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;颜值：%s\n&quot;</span>,queen.yz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101054894.png" alt="在这里插入图片描述" /></p><h1 id="七-结构体数组"><a class="markdownIt-Anchor" href="#七-结构体数组"></a> 七、结构体数组</h1><p>结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> princess[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">memset</span>(princess,<span class="number">0</span>,<span class="built_in">sizeof</span>(princess));</span><br><span class="line"><span class="built_in">strcpy</span>(princess[<span class="number">0</span>].name,<span class="string">&quot;杨玉环&quot;</span>);</span><br><span class="line">princess[<span class="number">0</span>].age=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(princess[<span class="number">1</span>].name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">princess[<span class="number">1</span>].age=<span class="number">28</span>;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>在实际开发中，我们很少用结构体数组，C++标准库的vector容器是一个动态的结构体数组，比结构体数组更方便。</p><h1 id="八-结构体指针"><a class="markdownIt-Anchor" href="#八-结构体指针"></a> 八、结构体指针</h1><p>结构体是一种自定义的数据类型，结构体变量是内存变量，有内存地址，也就有结构体指针。</p><p>在指针章节中我们已经学习过，采用不同数据类型的指针指向不同数据类型的变量的地址，这一规则也适用于结构体。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst=&amp; queen;</span><br></pre></td></tr></table></figure><p>通过结构体指针可以使用结构体成员，一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pointer).memberName</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure><p>第一种写法中，圆点.的优先级高于*，(*pointer)两边的括号不能少。如果去掉括号写作*pointer.memberName，那么就等效于*(pointer.memberName)，这样意义就完全不对了。</p><p>第二种写法中，-&gt;是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接使用结构体成员；这也是-&gt;在C语言中的唯一用途。</p><p>上面的两种写法是等效的，程序员通常采用后面的写法，这样更加直观。</p><p><strong>示例（book93.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book93.c，此程序演示结构体的指针</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst,queen;  <span class="comment">// 定义结构体变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化结构体变量</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  pst=&amp;queen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对结构体每个成员赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(pst-&gt;name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  pst-&gt;age=<span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,queen.name,queen.age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,pst-&gt;name,pst-&gt;age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,(*pst).name,(*pst).age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101335656.png" alt="在这里插入图片描述" /></p><h1 id="九-结构体的复制"><a class="markdownIt-Anchor" href="#九-结构体的复制"></a> 九、结构体的复制</h1><p>在C语言中，结构体的成员如果是基本数据类型（int、char、double）可以用=号赋值，如果是字符串，字符串不是基本数据类型，可以用strcpy函数赋值，如果要把结构体变量的值赋给另一个结构体变量，有两种方法：1）一种是把结构体变量成员的值逐个赋值给另一个结构体变量的成员，这种方法太笨，没人使用；2）另一种方法是内存拷贝，C语言提供了memcpy（memory copy的简写）实现内存拷贝功能。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><strong>src</strong> 源内存变量的起始地址。</p><p><strong>dest</strong> 目的内存变量的起始地址。</p><p><strong>n</strong> 需要复制内容的字节数。</p><p>函数返回指向dest的地址，函数的返回值意义不大，程序员一般不关心这个返回值。</p><p><strong>示例（book94.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book94.c， 此程序演示采用memcpy函数复制结构体</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> girl1,girl2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(girl1.name,<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 对girl1的成员赋值</span></span><br><span class="line">  girl1.age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把girl1的内容复制到girl2中</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;girl2,&amp;girl1,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girl1.name=%s,girl1.age=%d\n&quot;</span>,girl1.name,girl1.age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girl2.name=%s,girl2.age=%d\n&quot;</span>,girl2.name,girl2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101430559.png" alt="在这里插入图片描述" /><br />大家可能想起了strcpy函数，与memcpy有相似之处，实际上这两个函数从功能和实现原理上完本不同，甚至不应该放在一起比较。</p><p>1）复制的内容不同，strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</p><p>2）用途不同，通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p><p>3）复制的方法不同，strcpy不需要指定长度，它遇到被复制字符的串结尾符0才结束，memcpy则是根据其第3个参数决定复制的长度。</p><h1 id="十-结构体作为函数的参数"><a class="markdownIt-Anchor" href="#十-结构体作为函数的参数"></a> 十、结构体作为函数的参数</h1><p>结构体是多个变量集合，作为函数参数时就可以传递整个集合，也就是所有成员。如果结构体成员较多，函数参数的初始化和赋值的内存开销会很大，影响程序的运行效率。所以最好的办法就是传递结构体变量的地址。</p><p><strong>示例（book95.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book95.c，此程序演示结构体作为函数的参数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对结构体赋值的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(<span class="keyword">struct</span> st_girl *pst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;  <span class="comment">// 定义结构体变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化结构体变量</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setvalue</span>(&amp;queen);  <span class="comment">// 调用函数，传结构体的地址</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,queen.name,queen.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(<span class="keyword">struct</span> st_girl *pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 对结构体每个成员赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(pst-&gt;name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  pst-&gt;age=<span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101531550.png" alt="在这里插入图片描述" /></p><h1 id="十一-枚举和共同体"><a class="markdownIt-Anchor" href="#十一-枚举和共同体"></a> 十一、枚举和共同体</h1><p>C语言还有两种数据结构：枚举和共同体，这两种数据结构的应用太少了，少到我已经记不起它们的定义，二十年来，我从未使用过，也不介绍了。</p><h1 id="十二-memset和bzero函数"><a class="markdownIt-Anchor" href="#十二-memset和bzero函数"></a> 十二、memset和bzero函数</h1><h2 id="1-memset函数"><a class="markdownIt-Anchor" href="#1-memset函数"></a> 1、memset函数</h2><p>memset 函数是内存空间赋值函数，用来给某一块内存空间进行赋值的。</p><p>包含在&lt;string.h&gt;头文件中。</p><p>函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> v, <span class="type">size_t</span> n)</span></span>;  </span><br></pre></td></tr></table></figure><p>s为内存空间的地址，一般是数组名或结构体的地址。</p><p>v为要填充的值，填0就是初始化。</p><p>n为要填充的字节数。</p><p>在实际开发中，程序员用memset函数对数组或结构体清零，在之前的章节中，我们已经用过很多次了。</p><h2 id="2-bzero函数"><a class="markdownIt-Anchor" href="#2-bzero函数"></a> 2、bzero函数</h2><p>bzero函数是内存空间清零。</p><p>包含在&lt;string.h&gt;头文件中。</p><p>函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bzero</span><span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> n)</span></span>; </span><br></pre></td></tr></table></figure><p>s为内存空间的地址，一般是数组名或结构体的地址。</p><p>n为要清零的字节数。</p><p>如果要对数组或结构体清零，用memset和bzero都可以，没什么差别，看程序员的习惯。</p><h1 id="十三-课后作业"><a class="markdownIt-Anchor" href="#十三-课后作业"></a> 十三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="十四-版权声明"><a class="markdownIt-Anchor" href="#十四-版权声明"></a> 十四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据类型转换</title>
      <link href="/post/32666f02.html"/>
      <url>/post/32666f02.html</url>
      
        <content type="html"><![CDATA[<p>计算机进行算术运算时，要求各操作数的类型具有相同的大小（存储位数）及存储方式，不能将char 型（ 1 字节）数据与 int 型（2、4或8字节）数据直接参与运算；由于存储方式的不同，也不能将 int 型数据与 double 型数据直接参与运算。</p><p>然而，由于 C语言的灵活性，在一个表达式或一条语句中，允许不同类型的数据混合运算。</p><p>C语言的灵活性与计算机的机械性是一对矛盾，如处理不好，将会产生错误结果。对于某些类型的转换编译器可隐式地自动进行，不需程序员干预，称这种转换为<strong>自动类型转换</strong>；而有些类型转换需要程序员显式指定，这种类型转换称为<strong>强制类型转换</strong>。</p><h1 id="一-自动类型转换"><a class="markdownIt-Anchor" href="#一-自动类型转换"></a> 一、自动类型转换</h1><p>一个表达式中出现不同类型间的混合运算，较低类型将自动向较高类型转换。</p><p>不同数据类型之间的差别在于数据的取值范围和精度上，一般情况下，数据的取值范围越大、精度越高，其类型也越“高级”。</p><p>整型类型级别从低到高依次为：</p><p>signed char-&gt;unsigned char-&gt;short-&gt;unsigned short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long</p><p>浮点型级别从低到高依次为：</p><p>float-&gt;double</p><p>float浮点类型被我们弃用了，所以不提它了。</p><h2 id="1-操作数中没有浮点型数据时"><a class="markdownIt-Anchor" href="#1-操作数中没有浮点型数据时"></a> 1、操作数中没有浮点型数据时</h2><p>当 char、unsigned char、short 或 unsigned short出现在表达式中参与运算时，一般将其自动转换为 int 类型。</p><p>int 与 unsigned int混合运算时，int自动转换为unsigned int型。</p><p>int、unsigned int 与 long 混合运算时，均转换为 long 类型。</p><h2 id="2-操作数中有浮点型数据时"><a class="markdownIt-Anchor" href="#2-操作数中有浮点型数据时"></a> 2、操作数中有浮点型数据时</h2><p>当操作数中含有浮点型数据时，所有操作数都将转换为 double 型。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii=<span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> dd=<span class="number">200.5</span>;</span><br><span class="line">ii+dd;</span><br></pre></td></tr></table></figure><p>上述算术表达式中操作数 dd 为double，所以先把ii转换为double浮点数后再参与运算，运算结果为双精度浮点数300.5。</p><h2 id="3-赋值运算符两侧的类型不一致时"><a class="markdownIt-Anchor" href="#3-赋值运算符两侧的类型不一致时"></a> 3、赋值运算符两侧的类型不一致时</h2><p>当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型提升/降低为左值类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dd;</span><br><span class="line">dd=<span class="number">10</span>;  <span class="comment">// 右值为双精度，左值为整数</span></span><br></pre></td></tr></table></figure><p>由于左值dd为双精度浮点型，所以先把右值整型常量10 提升为双精度浮点型后，再赋值给dd，不但不丢失精度反而提高了精度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;</span><br><span class="line">ii=<span class="number">10.5</span>;   <span class="comment">// 右值10.5为双精度，左值为整型</span></span><br></pre></td></tr></table></figure><p>右值双精度型 10.5 降低为左值整型，即10.5舍弃小数部分后，把10 赋给整型变量ii，这种情况会丢失精度。</p><h2 id="4-右值超出左值类型范围时"><a class="markdownIt-Anchor" href="#4-右值超出左值类型范围时"></a> 4、右值超出左值类型范围时</h2><p>更糟糕的情况是，赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;             <span class="comment">//  char占8位，取值范围是-128-127。</span></span><br><span class="line">c=<span class="number">1025</span>;             <span class="comment">//  整数1025 对应二进制形式是100 0000 0001，超出了8位。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;％d&quot;</span>,c) ;  <span class="comment">//  以十进制输出c的值</span></span><br></pre></td></tr></table></figure><p>该输出结果为 1，因为只取 1025 低 8 位 0000 0001（值为1），赋给字符型变量c，得到毫无意义的值。</p><h1 id="二-强制类型转换"><a class="markdownIt-Anchor" href="#二-强制类型转换"></a> 二、强制类型转换</h1><p>虽然自动类型转换不需要人工干预，使用方便，但有利也有弊，尤其当自动类型转换是从较高类型转换为较低类型时，将会降低精度或截断数据，可能得不到预期的结果。</p><p>为了给程序设计人员提供更多的类型转换控制权限，使程序设计更加灵活，转换的目的更加清晰，C语言提供了可显式指定类型转换的语法，通常称之为强制类型转换。</p><p>强制类型转换的格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(目标类型) 表达式;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a=<span class="number">4</span>;</span><br><span class="line">b=<span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> dd;</span><br><span class="line">dd=a/b;            <span class="comment">// dd的结果将是1。</span></span><br><span class="line">dd=(<span class="type">double</span>)(a/b);  <span class="comment">// dd的结果是1.000000。</span></span><br><span class="line">dd=(<span class="type">double</span>)a/b;   <span class="comment">// dd的结果是1.333333</span></span><br></pre></td></tr></table></figure><p>dd=a/b，dd的结果是1，这个很好理解，因为整数除整数还是整数，没有小数部分。</p><p>dd=(double)(a/b)，dd的结果也是1.000000，这个不好理解，它的运算过程是：</p><p>（1）先运算a/b，得到的结果是整数的1；</p><p>（2）把整数的1转换成double，是1.000000。</p><p>dd=(double)a/b，dd的结果是1.333333，这个也不好理解，它的运算过程是：</p><p>（1）先执行(double)a，把a转换为double，即4.000000；</p><p>（2）把4.00000除以3，得到1.333333，符合自动类型转换的规则。</p><p>这里还有个问题，程序员搞不清楚是(double)a优先还是a/b优先，最好的办法是写成这样((double)a)/b，这样就没有疑问了。</p><h1 id="三-课后作业"><a class="markdownIt-Anchor" href="#三-课后作业"></a> 三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言字符串</title>
      <link href="/post/9d2c959b.html"/>
      <url>/post/9d2c959b.html</url>
      
        <content type="html"><![CDATA[<p>在很多教程中，字符串不过是一个以0结束的字符数组，但是，在我看来，字符串虽然不是C语言基本数据类型，但它比任何数据类型都重要，因为字符串是最常用的数据。</p><h1 id="一-字符串的概念"><a class="markdownIt-Anchor" href="#一-字符串的概念"></a> 一、字符串的概念</h1><p>我们可以把字符串储存在char类型的数组中，如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200304090742725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>因为字符串需要用\0结尾，所以在定义字符串的时候，字符数组的长度要预留多一个字节用来存放\0，\0就是数字0。这是约定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];  <span class="comment">// 定义一个最多存放20个英文字符或十个中文的字符串</span></span><br></pre></td></tr></table></figure><p>字符串也可以存放中文和全角的标点符号，一个中文字符占两个字节（GBK编码）。char strname[21]用于存放中文的时候，只能存10个汉字。</p><p>字符串采用双引号包含起来，如：“hello”、“中华人民共和国”、“A”、“”，这是约定。</p><h1 id="二-占用内存的情况"><a class="markdownIt-Anchor" href="#二-占用内存的情况"></a> 二、占用内存的情况</h1><p>一个字符占用一字节的内存，字符串定义时数组的大小就是字符串占用内存的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">21</span>];     <span class="comment">// 占用21字节的内存</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];   <span class="comment">// 占用1024字节的内存</span></span><br></pre></td></tr></table></figure><h1 id="三-字符串的初始化"><a class="markdownIt-Anchor" href="#三-字符串的初始化"></a> 三、字符串的初始化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line">strname[<span class="number">0</span>]=<span class="number">0</span>;    <span class="comment">// 把第一个元素的值置为0</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));  <span class="comment">// 把全部的元素置为0</span></span><br></pre></td></tr></table></figure><p>strname[0]=0;不够规范，并且存有隐患，在实际开发中，一般采用memset的函数初始化字符串。</p><h1 id="四-字符串与指针"><a class="markdownIt-Anchor" href="#四-字符串与指针"></a> 四、字符串与指针</h1><p>在C语言中，数组名是数组无素的首地址，字符串是字符数组，所以在获取字符串的地址的时候，不需要用&amp;取地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;abcdefghijk&quot;</span>);     <span class="comment">// 把abcdefghijk赋值给strname</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,strname);              <span class="comment">// 输出abcdefghijk</span></span><br></pre></td></tr></table></figure><h1 id="五-字符串的结尾标志"><a class="markdownIt-Anchor" href="#五-字符串的结尾标志"></a> 五、字符串的结尾标志</h1><p>字符串的结尾标志是0，如果没有结尾标志的情况我们在数组章节中已介绍过，现在我们介绍结尾标志后面的内容如何处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;abcdefghijk&quot;</span>);     <span class="comment">// 把abcdefghijk赋值给strname</span></span><br><span class="line">strname[<span class="number">5</span>]=<span class="number">0</span>;     <span class="comment">// 强制把第6个元素赋值0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,strname);   <span class="comment">// 输出的结果是abcde</span></span><br></pre></td></tr></table></figure><p>以上代码输出的结果是abcde，但是，在内存中的值仍是abcde0ghijk，后面的ghijk成了内存中的垃圾值。</p><p>不要让字符串的内存中有垃圾值，容易产生意外的后果，我们将在后面的内容中演示，所以字符串的初始化不建议采用把第一个元素的值置为0的方式（strname[0]=0）。</p><h1 id="六-字符串的输出"><a class="markdownIt-Anchor" href="#六-字符串的输出"></a> 六、字符串的输出</h1><p>字符串采用%s输出，可以加格式控制，常用的如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%10s=\n&quot;</span>,<span class="string">&quot;abcd&quot;</span>);   <span class="comment">// 输出10个字符宽度，右对齐，执行结果是=      abcd=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-10s=\n&quot;</span>,<span class="string">&quot;abcd&quot;</span>);  <span class="comment">// 输出10个字符宽度，左对齐，执行结果是=abcd      =</span></span><br></pre></td></tr></table></figure><p>如果输出的字符串的长度大于对齐格式中的数字，就按字符串的实际长度输出。</p><h1 id="七-字符串越界"><a class="markdownIt-Anchor" href="#七-字符串越界"></a> 七、字符串越界</h1><p>字符串是字符数组，字符串越界就是数组越界。字符串的越界是初学者经常犯的错误之一。</p><p><strong>示例（book80.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book80.c，此程序演示字符串的越界。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> strname1[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strname1,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname1));</span><br><span class="line">  <span class="type">char</span> strname2[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strname2,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname2));</span><br><span class="line">  <span class="built_in">strcpy</span>(strname1,<span class="string">&quot;真的只能存十个汉字吗，多几个行不行？&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(strname2,<span class="string">&quot;是的，只能十个，多了不行。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname2);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strname[<span class="number">2</span>][<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line">  <span class="built_in">strcpy</span>(strname[<span class="number">1</span>],<span class="string">&quot;是的，只能十个，多了不行。&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(strname[<span class="number">0</span>],<span class="string">&quot;真的只能存十个汉字吗，多几个行不行？&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304091144396.png" alt="在这里插入图片描述" /></p><p>我们来分析一下book80.c。</p><p>前8行代码定义了两个字符串变量，每个能存放20个字符或10个中文，但实际赋值都超过了10个中文，从输出结果看，没有问题。</p><p>后6行代码采用了二维数组的方式定义了字符串变量，理论上说，与分开定义的两个字符串变量没有区别，但是，从输出结果看，很有问题。</p><p>真正的原因是这样的，在C语言中，数组越界肯定是非法的，但非法操作并不一定会出问题，前8行代码的字符串是越界了，但是strname1和strname2变量的内存之后的内存空间是未分配的，所以对strname1和strname2赋值过长也没关系。后6行代码就不一样了，二维数组的两个变量之间的内存是连续的，第一个元素之后没有多余的空间，所以第一个元素的值就出问题了。</p><p>总的来说，在C语言中，非法操作内存不一定会报错，要看运气。</p><p>在现实生活中，一个农民把庄稼种到了自家的地盘之外，如果您的地盘之外的地没有主人，是不会有问题的，但如果有主人，这事就肯定会引起纠纷，系统对这种纠纷的裁决是内存越界的程序非法，强制终止它（段错误）。</p><h1 id="八-字符串常用的库函数"><a class="markdownIt-Anchor" href="#八-字符串常用的库函数"></a> 八、字符串常用的库函数</h1><h2 id="1-获取字符串的长度strlen"><a class="markdownIt-Anchor" href="#1-获取字符串的长度strlen"></a> 1、获取字符串的长度（strlen）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span>  <span class="title">strlen</span><span class="params">( <span class="type">const</span> <span class="type">char</span>*  str)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：计算字符串的有效长度，不包含0。</p><p>返回值：返回字符串的字符数 。</p><p>strlen 函数计算的是字符串的实际长度，遇到第一个0结束。</p><p>函数返回值一定是size_t，是无符号的整数，即typedef unsigned int size_t。</p><p>如果您只定义字符串没有初始化，求它的长度是没意义的，它会从首地址一直找下去，遇到0停止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;wucongzhou&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name 的长度是%d\n&quot;</span>,<span class="built_in">strlen</span>(name));     <span class="comment">// 输出结果：name 的长度是10</span></span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name 的长度是%d\n&quot;</span>,<span class="built_in">strlen</span>(name));     <span class="comment">// 输出结果：name 的长度是4</span></span><br></pre></td></tr></table></figure><p>还有一个注意事项，sizeof返回的是变量所占的内存数，不是实际内容的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;                           <span class="comment">// 定义的时候初始化。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;strlen(buf)=%d\n&quot;</span>,<span class="built_in">strlen</span>(buf));    <span class="comment">// 输出结果strlen(buf)=3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(buf));    <span class="comment">// 输出结果sizeof(buf)=10</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串复制或赋值strcpy"><a class="markdownIt-Anchor" href="#2-字符串复制或赋值strcpy"></a> 2、字符串复制或赋值（strcpy）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>功 能: 将参数src字符串拷贝至参数dest所指的地址。</p><p>返回值: 返回参数dest的字符串起始地址。</p><p>复制完字符串后，在dest后追加0。</p><p>如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</p><h2 id="3-字符串复制或赋值strncpy"><a class="markdownIt-Anchor" href="#3-字符串复制或赋值strncpy"></a> 3、字符串复制或赋值（strncpy）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strncpy</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">char</span>* src, <span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：把src前n字符的内容复制到dest中</p><p>返回值：dest字符串起始地址。</p><p>dest必须有足够的空间放置n个字符，否则可能会造成缓冲溢出的错误情况。</p><h2 id="4-字符串拼接strcat"><a class="markdownIt-Anchor" href="#4-字符串拼接strcat"></a> 4、字符串拼接（strcat）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：将src字符串拼接到dest所指的字符串尾部。</p><p>返回值：返回dest字符串起始地址。</p><p>dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。</p><p>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p><h2 id="5-字符串拼接strncat"><a class="markdownIt-Anchor" href="#5-字符串拼接strncat"></a> 5、字符串拼接（strncat）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncat</span> <span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">char</span>* src, <span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。</p><p>返回值：返回dest字符串的起始地址。</p><p>如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n大于字符串src的长度，只追加src的前n个字符。</p><p>strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。</p><p>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p><h2 id="6-字符串比较strcmp-strncmp"><a class="markdownIt-Anchor" href="#6-字符串比较strcmp-strncmp"></a> 6、字符串比较（strcmp、strncmp）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2 )</span></span>;</span><br></pre></td></tr></table></figure><p>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1,<span class="type">const</span> <span class="type">char</span> *str2 ,<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</p><p>两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。</p><p>在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。</p><h2 id="7-字符查找strchr-strrchr"><a class="markdownIt-Anchor" href="#7-字符查找strchr-strrchr"></a> 7、字符查找（strchr、strrchr）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个指向在字符串s中第一个出现c的位置，如果找不到，返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个指向在字符串s中最后一个出现c的位置，如果找不到，返回0。</p><h2 id="8-字符串查找strstr"><a class="markdownIt-Anchor" href="#8-字符串查找strstr"></a> 8、字符串查找（strstr）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">const</span> <span class="type">char</span>* substr)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：检索子串在字符串中首次出现的位置。</p><p>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。</p><h1 id="九-应用经验"><a class="markdownIt-Anchor" href="#九-应用经验"></a> 九、应用经验</h1><h2 id="1-留有余地"><a class="markdownIt-Anchor" href="#1-留有余地"></a> 1、留有余地</h2><p>字符串的strcpy和strcat函数要求dest参数有足够的空间，否则会造成内存的泄漏，所以在实际开发中，定义字符串的时候，可以大一些，例如姓名，中国人的姓名以两三个汉字为主，最多五个，少数民族可能十几个，外国人的很长，喜欢在自己的名字前加上爷爷的名字和外公的名字，那么我们在定义变量的时候，可以char name[301];存放他祖宗十八代的名字也没有问题。</p><p>内存不值钱，程序的稳定性高于一切。</p><h2 id="2-变量初始化"><a class="markdownIt-Anchor" href="#2-变量初始化"></a> 2、变量初始化</h2><p><strong>字符串在每次使用前都要初化</strong>，减少入坑的可能，<strong>是每次，不是第一次</strong>。这是职业程序员的良好习惯。</p><h2 id="3-位置地址偏移的用法"><a class="markdownIt-Anchor" href="#3-位置地址偏移的用法"></a> 3、位置（地址）偏移的用法</h2><p>字符串的地址偏移其本质是指针的运算，常用于灵活的处理字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;abcdefghijk&quot;</span>);     <span class="comment">// 把abcdefghijk赋值给strname</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> strname1[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname1,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname1));</span><br><span class="line"><span class="built_in">strcpy</span>(strname1,strname+<span class="number">1</span>);       <span class="comment">// 把bcdefghijk的值赋给strname1</span></span><br><span class="line"><span class="built_in">strncpy</span>(strname1,strname+<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">// 把cde的值赋给strname1</span></span><br></pre></td></tr></table></figure><p>当然，对strname1也可以使用偏移量。</p><h2 id="4-不要在子函数中对字符指针用sizeof"><a class="markdownIt-Anchor" href="#4-不要在子函数中对字符指针用sizeof"></a> 4、不要在子函数中对字符指针用sizeof</h2><p>如果把一个字符串（如char  strname[21]）的地址传给子函数，子函数用一个字符指针（如char *pstr）来存放传入的字符串的地址，如果在子函数中用sizeof(pstr)，得到的不是字符串占用内存的字节数，而是字符指针变量占用内存的字节数（8字节）。</p><p>所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。</p><h1 id="十-课后作业"><a class="markdownIt-Anchor" href="#十-课后作业"></a> 十、课后作业</h1><p>本章节的课后作业非常要，一定要认真完成，字符串操作是C程序员的主要工作之一，这些都是职业程序员在日常开发中用到的技巧。还有，这些作业题可以培养写程序的感觉。</p><p>1）编写示例程序，实现字符串操作常用的库函数的功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen1</span><span class="params">( <span class="type">const</span> <span class="type">char</span>*  str)</span></span>;          <span class="comment">// 实现strlen函数的功能。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy1</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;  <span class="comment">// 实现strcpy函数的功能，下同。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy1</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat1</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncat1</span> <span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strchr1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strrchr1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>以下三个函数难度较大，如果无法完成，不要过于纠结，以后功力提升了再做。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strstr1</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span></span>;   <span class="comment">// 实现strstr1函数的功能，下同。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp1</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2 )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2, <span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>2）丰富您的函数库，增加STRCPY、STRNCPY、STRCAT、STRNCAT四个安全的函数，弥补库函数的缺陷，解决dest的初始化和内存越界的问题，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，上述函数的第二个参数destsize是第一个参数dest占用内存的字节数。</p><p>3）丰富您的函数库，增加以下函数，这些是freecplus框架中的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除字符串左边指定的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char)</span></span>;</span><br><span class="line"><span class="comment">// 删除字符串右边指定的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char)</span></span>;</span><br><span class="line"><span class="comment">// 删除字符串两边指定的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char)</span></span>;</span><br><span class="line"><span class="comment">// 删除字符串中间的字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteMStr</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> *in_str)</span></span>;</span><br><span class="line"><span class="comment">// 在字符串的左边补字符到指定长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LPad</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char,<span class="type">unsigned</span> <span class="type">int</span> in_len)</span></span>;</span><br><span class="line"><span class="comment">// 在字符串的右边补字符到指定长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RPad</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char,<span class="type">unsigned</span> <span class="type">int</span> in_len)</span></span>;</span><br><span class="line"><span class="comment">// 把小写转换成大写，忽略不是字母的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToUpper</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 把大写转换成小写，忽略不是字母的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToLower</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是数字，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsDigit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是大写字母，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsUpper</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是小写字母，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsLower</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是ASCII字符，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsASCII</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="十一-版权声明"><a class="markdownIt-Anchor" href="#十一-版权声明"></a> 十一、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浮点数</title>
      <link href="/post/8d2f5a40.html"/>
      <url>/post/8d2f5a40.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-浮点数的概念"><a class="markdownIt-Anchor" href="#一-浮点数的概念"></a> 一、浮点数的概念</h1><p>浮点数也称小数或实数。例如，0.0、75.0、4.023、0.27、-937.198 都是合法的小数。</p><p>C语言中采用float和double关键字来定义小数，float称为单精度浮点型，double称为双精度浮点型，long double更长的双精度浮点型。</p><p>在任何区间内（如1.0 到 2.0 之间）都存在无穷多个实数，计算机的浮点数不能表示区间内所有的值。</p><h1 id="二-点用内存的情况"><a class="markdownIt-Anchor" href="#二-点用内存的情况"></a> 二、点用内存的情况</h1><p>我们先来测试一下float、double和long double三种浮点数据类型占用内存的字节数。</p><p><strong>示例（book71.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book71.c，此程序测试float、double和long double占用内存的字节数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof float is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof double is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof long double is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304083510575.png" alt="在这里插入图片描述" /></p><h1 id="三-浮点数的精度"><a class="markdownIt-Anchor" href="#三-浮点数的精度"></a> 三、浮点数的精度</h1><p>C标准规定，float类型必须至少能表示6位有效数字，且取值范围至少是10<sup>-37</sup>～10<sup>+37</sup>。</p><p>double类型和 float类型的最小取值范围相同，但至少必须能表示10位有效数字。</p><p>long double，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。</p><p>看了上面这段文字，估计大家有点晕，在之前的整数章节中，long比int的占用的内存多，存放数据的值也就越大，并且有一个准确的范围，但是，为什么各种浮点数存放数据的值怎么就这么模糊呢？我先不解释原因，浮点数的存储方式比较复杂，暂时不讨论，先用几个程序来测试一下它们的特征。</p><h2 id="1-测试float类型"><a class="markdownIt-Anchor" href="#1-测试float类型"></a> 1、测试float类型</h2><p><strong>示例（book73.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book73.c，此程序测试float的特征</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> ff2=<span class="number">9.9</span>;   <span class="comment">// 测试2位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff2=%f\n&quot;</span>,ff2);</span><br><span class="line">  <span class="keyword">if</span> (ff2==<span class="number">9.9</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff2==9.9\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff5=<span class="number">99.999</span>;   <span class="comment">// 测试5位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff5=%f\n&quot;</span>,ff5);</span><br><span class="line">  <span class="keyword">if</span> (ff5==<span class="number">99.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff5==99.999\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff6=<span class="number">999.999</span>;   <span class="comment">// 测试6位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff6=%f\n&quot;</span>,ff6);</span><br><span class="line">  <span class="keyword">if</span> (ff6==<span class="number">999.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff6==999.999\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff7=<span class="number">9999.999</span>;   <span class="comment">// 测试7位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff7=%f\n&quot;</span>,ff7);</span><br><span class="line">  <span class="keyword">if</span> (ff7==<span class="number">9999.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff7==9999.999\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff8=<span class="number">99999.999</span>;   <span class="comment">// 测试8位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff8=%f\n&quot;</span>,ff8);</span><br><span class="line">  <span class="keyword">if</span> (ff8==<span class="number">99999.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff8==99999.999\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084005413.png" alt="在这里插入图片描述" /></p><p>从程序的运行我们可以看出float数的两个特征：</p><p>1）float数据类型表达的是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大，到8位的时候，误差了1，基本上不能用了。</p><p>2）用“==”可以比较两个整数或字符是否相等，但是，看起来相等的两个浮点数，就是不会相等。</p><h2 id="2-测试double类型"><a class="markdownIt-Anchor" href="#2-测试double类型"></a> 2、测试double类型</h2><p><strong>示例（book74.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book74.c，此程序测试double的特征</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> ff2=<span class="number">9.9</span>;   <span class="comment">// 测试2位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff2=%lf\n&quot;</span>,ff2);</span><br><span class="line">  <span class="keyword">if</span> (ff2==<span class="number">9.9</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff2与9.9相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff12=<span class="number">999999999.99</span>;   <span class="comment">// 测试12位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff12=%lf\n&quot;</span>,ff12);</span><br><span class="line">  <span class="keyword">if</span> (ff12==<span class="number">999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff12与999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff13=<span class="number">9999999999.99</span>;   <span class="comment">// 测试13位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff13=%lf\n&quot;</span>,ff13);</span><br><span class="line">  <span class="keyword">if</span> (ff13==<span class="number">9999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff13与9999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff14=<span class="number">99999999999.99</span>;   <span class="comment">// 测试14位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff14=%lf\n&quot;</span>,ff14);</span><br><span class="line">  <span class="keyword">if</span> (ff14==<span class="number">99999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff14与99999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff15=<span class="number">999999999999.99</span>;   <span class="comment">// 测试15位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff15=%lf\n&quot;</span>,ff15);</span><br><span class="line">  <span class="keyword">if</span> (ff15==<span class="number">999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff15与999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff16=<span class="number">9999999999999.99</span>;   <span class="comment">// 测试16位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff16=%lf\n&quot;</span>,ff16);</span><br><span class="line">  <span class="keyword">if</span> (ff16==<span class="number">9999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff16与9999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff17=<span class="number">99999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff17=%lf\n&quot;</span>,ff17);</span><br><span class="line">  <span class="keyword">if</span> (ff17==<span class="number">99999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff18=<span class="number">999999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff18=%lf\n&quot;</span>,ff18);</span><br><span class="line">  <span class="keyword">if</span> (ff18==<span class="number">999999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084121487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>从程序的运行我们可以看出double数的两个特征：</p><p>1）double数据类型表达的也是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大，到17位的时候，误差了1，基本上不能用了。</p><p>2）用“==”可以比较两个double数值是否相等。</p><h2 id="3-测试long-double类型"><a class="markdownIt-Anchor" href="#3-测试long-double类型"></a> 3、测试long double类型</h2><p><strong>示例（book75.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book75.c，此程序测试long double的特征</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff2=<span class="number">9.9</span>;   <span class="comment">// 测试2位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff2=%Lf\n&quot;</span>,ff2);</span><br><span class="line">  <span class="keyword">if</span> (ff2==<span class="number">9.9</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff2与9.9相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff12=<span class="number">999999999.99</span>;   <span class="comment">// 测试12位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff12=%Lf\n&quot;</span>,ff12);</span><br><span class="line">  <span class="keyword">if</span> (ff12==<span class="number">999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff12与999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff13=<span class="number">9999999999.99</span>;   <span class="comment">// 测试13位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff13=%Lf\n&quot;</span>,ff13);</span><br><span class="line">  <span class="keyword">if</span> (ff13==<span class="number">9999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff13与9999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff14=<span class="number">99999999999.99</span>;   <span class="comment">// 测试14位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff14=%Lf\n&quot;</span>,ff14);</span><br><span class="line">  <span class="keyword">if</span> (ff14==<span class="number">99999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff14与99999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff15=<span class="number">999999999999.99</span>;   <span class="comment">// 测试15位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff15=%Lf\n&quot;</span>,ff15);</span><br><span class="line">  <span class="keyword">if</span> (ff15==<span class="number">999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff15与999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff16=<span class="number">9999999999999.99</span>;   <span class="comment">// 测试16位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff16=%Lf\n&quot;</span>,ff16);</span><br><span class="line">  <span class="keyword">if</span> (ff16==<span class="number">9999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff16与9999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff17=<span class="number">99999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff17=%Lf\n&quot;</span>,ff17);</span><br><span class="line">  <span class="keyword">if</span> (ff17==<span class="number">99999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff18=<span class="number">999999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff18=%Lf\n&quot;</span>,ff18);</span><br><span class="line">  <span class="keyword">if</span> (ff18==<span class="number">999999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084213344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>long double的测试结果与double相同。</p><h2 id="4-测试总结"><a class="markdownIt-Anchor" href="#4-测试总结"></a> 4、测试总结</h2><p>float只能表达6-7位的有效数字，不能用“==”判断两个数字是否相等。</p><p>double能表达15-16位有效的数字，可以用“==”判断两个数字是否相等。</p><p>long double占用的内存是double的两倍，但表达数据的精度和double相同。</p><p><strong>在实际开发中，建议弃用float，只采用double就可以，long double暂时没有必要，但不知道以后的操作系统和编译器对long double是否有改进。</strong></p><h1 id="四-浮点数的输出"><a class="markdownIt-Anchor" href="#四-浮点数的输出"></a> 四、浮点数的输出</h1><p>float采用%f占位符。</p><p>double采用%lf占位符。测试结果证明，double不可以用%f输入，但可以用%f输出，但是不建议采用%f，因为不同的编译器可能会有差别。</p><p>long double采用%Lf占位符，注意，L是大写。</p><p>浮点数输出缺省显示小数点后六位。</p><p>浮点数采用%lf输出，完整的输出格式是%m.nlf，指定输出数据整数部分和小数部分共占m位，其中有n位是小数。如果数值长度小于m，则左端补空格，若数值长度大于m，则按实际位数输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ff=<span class="number">70001.538</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%lf=\n&quot;</span>,ff);       <span class="comment">// 输出结果是ff=70001.538000=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%.4lf=\n&quot;</span>,ff);     <span class="comment">// 输出结果是ff=70001.5380=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%11.4lf=\n&quot;</span>,ff);   <span class="comment">// 输出结果是ff= 70001.5380=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%8.4lf=\n&quot;</span>,ff);    <span class="comment">// 输出结果是ff=70001.5380=</span></span><br></pre></td></tr></table></figure><h1 id="五-常用的库函数"><a class="markdownIt-Anchor" href="#五-常用的库函数"></a> 五、常用的库函数</h1><p><strong>在接下来的内容中，我只介绍double，不再介绍float和long double两种数据类型相关的知识。</strong></p><p>以下是常用的浮点数函数，必须掌握。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;       <span class="comment">// 把字符串nptr转换为double</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span>;                <span class="comment">// 求双精度实数x的绝对值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>;      <span class="comment">// 求 x 的 y 次幂（次方）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">round</span><span class="params">(<span class="type">double</span> x)</span></span>;               <span class="comment">// double四舍五入</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">double</span> x)</span></span>;                <span class="comment">// double向上取整数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">floor</span><span class="params">(<span class="type">double</span> x)</span></span>;               <span class="comment">// double向下取整数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fmod</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span>;      <span class="comment">// 求x/y整除后的双精度余数</span></span><br><span class="line"><span class="comment">// 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中，返回小数部分。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">modf</span><span class="params">(<span class="type">double</span> val,<span class="type">double</span> *ip)</span></span>;</span><br></pre></td></tr></table></figure><p>还有一些数据计算函数，如正弦、对数、指数等，实际开发中极少使用，大家要用的时候再查资料，我就不介绍了。</p><h1 id="六-整数转换为浮点数"><a class="markdownIt-Anchor" href="#六-整数转换为浮点数"></a> 六、整数转换为浮点数</h1><p><strong>示例（book77.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book77.c，此程序测试整数与浮点数的转换。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> jj=<span class="number">4</span>;</span><br><span class="line">  <span class="type">double</span> dd;</span><br><span class="line"></span><br><span class="line">  dd=ii;        <span class="comment">// 可以</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2lf\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=ii/jj;     <span class="comment">// 不行</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2lf\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=(<span class="type">double</span>)ii/jj;  <span class="comment">// 可以</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2lf\n&quot;</span>,dd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084430801.png" alt="在这里插入图片描述" /></p><p>需要特别注意的是dd=ii/jj这一行代码，dd的值0，不是0.75，有点意外，所以，如果对整数转换为浮点数没有把握，加（double）强制转换是个好办法。关于数据类型的转换，在《C语言数据类型转换》章节中将有更详细的介绍。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>浮点数有一些坑，例如两个浮点数不相等和精度的问题，在实际开发中，我们经常用整数代替浮点数，因为整数是精确的，效率也更高。</p><p>例如人的身高一米七五，以米为单位，用浮点数表示是1.75米，如果以厘米为单位，用整数表示是175。</p><p>long整数的取值是-9223372036854775808~9223372036854775807，有效数字是19位，而double的有效数字才15-16位，所以，整数可以表达的小数更大的数，更实用，麻烦也更少。</p><p>货币：1.75元，如果采用0.01元为单位就是175，采用0.001元为单位就是1750，如果您说要更多小数怎么办？您这是钻牛角尖。</p><p><strong>码农之道：高水平的程序员不容易掉坑里，注意，是不容易，不是不会，最好的方法是不要靠近坑。</strong></p><h1 id="八-科学计数法"><a class="markdownIt-Anchor" href="#八-科学计数法"></a> 八、科学计数法</h1><p>在实际开发中，我们很少使用科学计数法，但是它经常出现在计算机系统中，例如浮点数在内存中的存放方式就是科学计数法，所以我们还是有必要学习科学计数法。</p><p>科学记数法是一种记数的方法。把一个数表示成a与10<sup>n</sup>相乘的形式（1≤|a|&lt;10，n为整数），这种记数法叫做科学记数法。当我们要书写或运算某个较大或较小且位数较多时，用科学记数法免去浪费很多空间和时间。</p><p>例如：51400000000=5.14×10<sup>11</sup>，计算机表达10的幂是一般是用E或e，也就是51400000000=5.14E11或5.14e11。</p><p>用科学记数法表示数时，不改变数的符号，只是改变数的书写形式而已，可以方便的表示日常生活中遇到的一些极大或极小的数 。如：光的速度大约是300,000,000米/秒；全世界人口数大约是：6,100,000,000，这样的数书写和显示都很不方便，为了免去写这么多重复的0，将其表现为这样的形式：6,100,000,000=6.1×10<sup>9</sup>，即6.1E9或6.1e9。</p><p>0.00001=1×10<sup>-5</sup>，即绝对值小于1的数也可以用科学记数法表示为a乘10<sup>-n</sup>的形式。即1E-5或1e-5。</p><p>科学计数法采用%e或%E输出，完整的输出格式是%m.ne或%<a href="http://m.nE">m.nE</a>，指定输出数据整数部分和小数部分共占m位，其中有n位是小数。如果数值长度小于m，则左端补空格，若数值长度大于m，则按实际位数输出。</p><p><strong>示例（book78.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book78.c，此程序测试浮点数据的科学计数法。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> dd;</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">123000000</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is  %.2e\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">-123000000</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2e\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">0.0000000123</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is  %.2e\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">-0.0000000123</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2e\n&quot;</span>,dd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084516467.png" alt="在这里插入图片描述" /></p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>1）编写示例程序，类似本章节的book71.c、book73.c、book74.c、book75.c、book77.c、book78.c，编译并运行它，程序员是写出来的，不是看出来的，熟能生巧，您每天的付出都有意义。</p><p>2）编写示例程序，测试浮点数赋值超过取值范围的后果。</p><p>3）关于浮点数在内存中的存储方式，建议大家去百度一下（搜索关键字为C语言浮点数存储方式），了解一下相关的概念。</p><p>4）编写示例程序，测试把浮点数赋给整数变量的结果，并思考原因。</p><p>5）本题作业建议在学完《C语言数据类型转换》后再做，因为有知识点交叉，重写浮点数的常用库函数，实现其功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">FABS</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;          <span class="comment">// 求双精度实数x的绝对值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ROUND</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;         <span class="comment">// double四舍五入</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">CEIL</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;          <span class="comment">// double向上取整数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">FLOOR</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;         <span class="comment">// double向下取整数</span></span><br><span class="line"><span class="comment">// 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中，返回小数部分。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">MODF</span><span class="params">(<span class="type">double</span> val,<span class="type">double</span> *ip)</span></span>;  </span><br></pre></td></tr></table></figure><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言字符</title>
      <link href="/post/70da0f30.html"/>
      <url>/post/70da0f30.html</url>
      
        <content type="html"><![CDATA[<p>在实际开发中，程序员很少用单个字符来表示数据，字符的意义主要作为数组的时候可以形成一个字符串。在本章节中，我们重点介绍字符与整数之间的关系和ASCII码的相关知识。</p><p>字符类型char，只能用单引号’ ‘来包围，不是用双引号&quot; “包围。而字符串只能用双引号”<br />&quot;包围，不能用单引号’ '包围。</p><p>输出字符使用 %c，输出字符串使用 %s。</p><h1 id="一-ascii码表"><a class="markdownIt-Anchor" href="#一-ascii码表"></a> 一、ASCII码表</h1><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码方案，它主要用于显示现代英语和其他西欧语言，它是现今最通用的单字节编码方案，等同于国际标准ISO/IEC646。</p><p>ASCII码规范于1967年第一次发布，最后一次更新是在1986年，它包含了33个控制字符（具有特殊含义无法显示的字符）和95个可显示字符。</p><h2 id="1-ascii-控制字符-字符编码-0-31"><a class="markdownIt-Anchor" href="#1-ascii-控制字符-字符编码-0-31"></a> 1、ASCII 控制字符 （字符编码: 0-31）</h2><p>在ASCII码表中，前32个字符是不能用于打印的编码，而是用于控制像打印机一样的外围设备。</p><table><thead><tr><th>十进制</th><th>符号</th><th>中文解释</th><th>十进制</th><th>符号</th><th>中文解释</th></tr></thead><tbody><tr><td>0</td><td>NULL</td><td>空字符</td><td>16</td><td>DLE</td><td>数据链路转义</td></tr><tr><td>1</td><td>SOH</td><td>标题开始</td><td>17</td><td>DC1</td><td>设备控制 1</td></tr><tr><td>2</td><td>STX</td><td>正文开始</td><td>18</td><td>DC2</td><td>设备控制 2</td></tr><tr><td>3</td><td>ETX</td><td>正文结束</td><td>19</td><td>DC3</td><td>设备控制 3</td></tr><tr><td>4</td><td>EOT</td><td>传输结束</td><td>20</td><td>DC4</td><td>设备控制 4</td></tr><tr><td>5</td><td>ENQ</td><td>询问</td><td>21</td><td>NAK</td><td>拒绝接收</td></tr><tr><td>6</td><td>ACK</td><td>收到通知</td><td>22</td><td>SYN</td><td>同步空闲</td></tr><tr><td>7</td><td>BEL</td><td>铃</td><td>23</td><td>ETB</td><td>传输块结束</td></tr><tr><td>8</td><td>BS</td><td>退格</td><td>24</td><td>CAN</td><td>取消</td></tr><tr><td>9</td><td>HT</td><td>水平制表符</td><td>25</td><td>EM</td><td>介质中断</td></tr><tr><td>10</td><td>LF</td><td>换行键</td><td>26</td><td>SUB</td><td>替换</td></tr><tr><td>11</td><td>VT</td><td>垂直制表符</td><td>27</td><td>ESC</td><td>换码符</td></tr><tr><td>12</td><td>FF</td><td>换页键</td><td>28</td><td>FS</td><td>文件分隔符</td></tr><tr><td>13</td><td>CR</td><td>回车键</td><td>29</td><td>GS</td><td>组分隔符</td></tr><tr><td>14</td><td>SO</td><td>移出</td><td>30</td><td>RS</td><td>记录分离符</td></tr><tr><td>15</td><td>SI</td><td>移入</td><td>31</td><td>US</td><td>单元分隔符</td></tr></tbody></table><h2 id="2-ascii-可打印字符-字符编码-32-127"><a class="markdownIt-Anchor" href="#2-ascii-可打印字符-字符编码-32-127"></a> 2、ASCII 可打印字符 （字符编码: 32-127）</h2><p>可打印字符共95个。</p><p>1）32是空格。</p><p>2）48～57为0到9十个阿拉伯数字；</p><p>3）65～90为26个大写英文字母；</p><p>4）97～122号为26个小写英文字母；</p><p>5）其余为一些标点符号、运算符号等；</p><p>6）第127个字符表示的是键盘上的删除命令。</p><table><thead><tr><th>十进制</th><th>符号</th><th>中文解释</th><th>十进制</th><th>符号</th><th>中文解释</th></tr></thead><tbody><tr><td>32</td><td></td><td>空格</td><td>80</td><td>P</td><td>大写字母 P</td></tr><tr><td>33</td><td>!</td><td>感叹号</td><td>81</td><td>Q</td><td>大写字母 Q</td></tr><tr><td>34</td><td>&quot;</td><td>双引号</td><td>82</td><td>R</td><td>大写字母 R</td></tr><tr><td>35</td><td>#</td><td>井号</td><td>83</td><td>S</td><td>大写字母 S</td></tr><tr><td>36</td><td>$</td><td>美元符</td><td>84</td><td>T</td><td>大写字母 T</td></tr><tr><td>37</td><td>%</td><td>百分号</td><td>85</td><td>U</td><td>大写字母 U</td></tr><tr><td>38</td><td>&amp;</td><td>与</td><td>86</td><td>V</td><td>大写字母 V</td></tr><tr><td>39</td><td>’</td><td>单引号</td><td>87</td><td>W</td><td>大写字母 W</td></tr><tr><td>40</td><td>(</td><td>左括号</td><td>88</td><td>X</td><td>大写字母 X</td></tr><tr><td>41</td><td>)</td><td>右括号</td><td>89</td><td>Y</td><td>大写字母 Y</td></tr><tr><td>42</td><td>*</td><td>星号</td><td>90</td><td>Z</td><td>大写字母 Z</td></tr><tr><td>43</td><td>+</td><td>加号</td><td>91</td><td>[</td><td>左中括号</td></tr><tr><td>44</td><td>,</td><td>逗号</td><td>92</td><td>\</td><td>反斜杠</td></tr><tr><td>45</td><td>-</td><td>连字号或减号</td><td>93</td><td>]</td><td>右中括号</td></tr><tr><td>46</td><td>.</td><td>句点或小数点</td><td>94</td><td>^</td><td>音调符号</td></tr><tr><td>47</td><td>/</td><td>斜杠</td><td>95</td><td>_</td><td>下划线</td></tr><tr><td>48</td><td>0</td><td>0</td><td>96</td><td>`</td><td>重音符</td></tr><tr><td>49</td><td>1</td><td>1</td><td>97</td><td>a</td><td>小写字母 a</td></tr><tr><td>50</td><td>2</td><td>2</td><td>98</td><td>b</td><td>小写字母 b</td></tr><tr><td>51</td><td>3</td><td>3</td><td>99</td><td>c</td><td>小写字母 c</td></tr><tr><td>52</td><td>4</td><td>4</td><td>100</td><td>d</td><td>小写字母 d</td></tr><tr><td>53</td><td>5</td><td>5</td><td>101</td><td>e</td><td>小写字母 e</td></tr><tr><td>54</td><td>6</td><td>6</td><td>102</td><td>f</td><td>小写字母 f</td></tr><tr><td>55</td><td>7</td><td>7</td><td>103</td><td>g</td><td>小写字母 g</td></tr><tr><td>56</td><td>8</td><td>8</td><td>104</td><td>h</td><td>小写字母 h</td></tr><tr><td>57</td><td>9</td><td>9</td><td>105</td><td>i</td><td>小写字母 i</td></tr><tr><td>58</td><td>:</td><td>冒号</td><td>106</td><td>j</td><td>小写字母 j</td></tr><tr><td>59</td><td>;</td><td>分号</td><td>107</td><td>k</td><td>小写字母 k</td></tr><tr><td>60</td><td>&lt;</td><td>小于</td><td>108</td><td>l</td><td>小写字母 l</td></tr><tr><td>61</td><td>=</td><td>等号</td><td>109</td><td>m</td><td>小写字母 m</td></tr><tr><td>62</td><td>&gt;</td><td>大于</td><td>110</td><td>n</td><td>小写字母 n</td></tr><tr><td>63</td><td>?</td><td>问号</td><td>111</td><td>o</td><td>小写字母 o</td></tr><tr><td>64</td><td>@</td><td>电子邮件符号</td><td>112</td><td>p</td><td>小写字母 p</td></tr><tr><td>65</td><td>A</td><td>大写字母 A</td><td>113</td><td>q</td><td>小写字母 q</td></tr><tr><td>66</td><td>B</td><td>大写字母 B</td><td>114</td><td>r</td><td>小写字母 r</td></tr><tr><td>67</td><td>C</td><td>大写字母 C</td><td>115</td><td>s</td><td>小写字母 s</td></tr><tr><td>68</td><td>D</td><td>大写字母 D</td><td>116</td><td>t</td><td>小写字母 t</td></tr><tr><td>69</td><td>E</td><td>大写字母 E</td><td>117</td><td>u</td><td>小写字母 u</td></tr><tr><td>70</td><td>F</td><td>大写字母 F</td><td>118</td><td>v</td><td>小写字母 v</td></tr><tr><td>71</td><td>G</td><td>大写字母 G</td><td>119</td><td>w</td><td>小写字母 w</td></tr><tr><td>72</td><td>H</td><td>大写字母 H</td><td>120</td><td>x</td><td>小写字母 x</td></tr><tr><td>73</td><td>I</td><td>大写字母 I</td><td>121</td><td>y</td><td>小写字母 y</td></tr><tr><td>74</td><td>J</td><td>大写字母 J</td><td>122</td><td>z</td><td>小写字母 z</td></tr><tr><td>75</td><td>K</td><td>大写字母 K</td><td>123</td><td>{</td><td>左大括号</td></tr><tr><td>76</td><td>L</td><td>大写字母 L</td><td>124</td><td>|</td><td>垂直线</td></tr><tr><td>77</td><td>M</td><td>大写字母 M</td><td>125</td><td>}</td><td>右大括号</td></tr><tr><td>78</td><td>N</td><td>大写字母 N</td><td>126</td><td>~</td><td>波浪号</td></tr><tr><td>79</td><td>O</td><td>大写字母 O</td><td>127</td><td></td><td>删除</td></tr></tbody></table><h2 id="3-转义字符"><a class="markdownIt-Anchor" href="#3-转义字符"></a> 3、转义字符</h2><p>对于 ASCII编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，也无法从键盘输入，C语言又定义了一种简单的书写方式，即转义字符的形式来表示。</p><p>转义字符完整的列表如下：</p><table><thead><tr><th><strong>转义字符</strong></th><th><strong>意义</strong></th><th><strong>ASCII码值</strong></th><th><strong>使用频率</strong></th></tr></thead><tbody><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头。</td><td>10</td><td>每天都用</td></tr><tr><td>\’</td><td>单引号。</td><td>39</td><td>常用</td></tr><tr><td>\&quot;</td><td>双引号。</td><td>34</td><td>常用</td></tr><tr><td>\\</td><td>反斜杠。</td><td>92</td><td>常用</td></tr><tr><td>\r</td><td>回车(CR)</td><td>13</td><td>windows平台常用，linux平台不常用。</td></tr><tr><td>\t</td><td>水平制表(HT) 。</td><td>9</td><td>20年前常用，现在不用。</td></tr><tr><td>\v</td><td>垂直制表(VT)。</td><td>11</td><td>20年前常用，现在不用。</td></tr><tr><td>\a</td><td>响铃(BEL)。</td><td>7</td><td>20年前常用，现在不用。</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列。</td><td>8</td><td>20年前常用，现在不用。</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头。</td><td>12</td><td>20年前常用，现在不用。</td></tr></tbody></table><p>\n是最常用的转义字符，表示换行，让文本从下一行的开头输出，前面的章节中已经多次使用。</p><p>\r\n用于windows平台DOS格式文件的换行。</p><p>单引号、双引号、反斜杠是特殊的字符，不能直接表示。</p><p>单引号是字符类型的开头和结尾，要使用\'表示。</p><p>双引号是字符串的开头和结尾，要使用\&quot;表示。</p><p>反斜杠是转义字符的开头，要使用[\\表示](file:///\表示)。</p><p><strong>示例（book67.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book67.c，此程序演示C语言的转义字符。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出&#x27;单引号\&#x27;的方法。\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出双引号\&quot;的方法。\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出反斜杠\\的方法。\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;单引号&#x27;不转义也能输出。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><h1 id="在这里插入图片描述二-字符就是整数"><a class="markdownIt-Anchor" href="#在这里插入图片描述二-字符就是整数"></a> <img src="https://img-blog.csdnimg.cn/20200303181724545.png" alt="在这里插入图片描述" /><br />二、字符就是整数</h1><p><strong>字符和整数没有本质的区别</strong>。可以给 char变量一个字符，也可以给它一个整数；反过来，可以给 int变量一个整数，也可以给它一个字符。</p><p>char 变量在内存中存储的是字符对应的 ASCII 码值。如果以 %c 输出，会根据 ASCII码表转换成对应的字符，如果以 %d 输出，那么还是整数。</p><p>int 变量在内存中存储的是整数本身，如果以 %c 输出时，也会根据 ASCII码表转换成对应的字符。</p><p>也就是说，ASCII 码表将整数和字符关联起来了。</p><p>char类型占内存一个字节，signed char取值范围是-128-127，unsigned char取值范围是0-255。</p><p>如果整数大于255，那么整数还是字符吗？</p><p><strong>描述再准确一些，在char的取值范围内（0-255），字符和整数没有本质区别。</strong></p><p><strong>字符肯定是整数，0-255范围内的整数是字符，大于255的整数不是字符。</strong></p><p><strong>示例（book68.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book68.c，此程序演示字符与整数的关系</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a =  <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">  <span class="type">char</span> b =  <span class="number">70</span>;</span><br><span class="line">  <span class="type">int</span>  c =  <span class="number">71</span>;</span><br><span class="line">  <span class="type">int</span>  d = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a=%c, a=%d\n&quot;</span>, a, a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b=%c, b=%d\n&quot;</span>, b, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;c=%c, c=%d\n&quot;</span>, c, c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;d=%c, d=%d\n&quot;</span>, d, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303181818443.png" alt="在这里插入图片描述" /></p><p>在ASCII码表中，E、F、G、H 的值分别是 69、70、71、72。</p><h1 id="三-常用的库函数"><a class="markdownIt-Anchor" href="#三-常用的库函数"></a> 三、常用的库函数</h1><p>以下是常用的字符函数，必须掌握。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalpha</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalnum</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）或数字（&#x27;0&#x27;-&#x27;9&#x27;），返回非0值,否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isdigit</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是数字（&#x27;0&#x27;-&#x27;9&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">islower</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isupper</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回相应的小写字母（&#x27;a&#x27;-&#x27;z&#x27;）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toupper</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回相应的大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）</span></span><br></pre></td></tr></table></figure><p>以下是不常用的字符函数，极少使用，了解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isascii</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是字符（ASCII码中的0-127）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">iscntrl</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是作废字符（0x7F）或普通控制字符（0x00-0x1F），返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isprint</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是可打印字符（含空格）（0x20-0x7E）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ispunct</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是标点字符（0x00-0x1F）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isspace</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是空格（&#x27; &#x27;），水平制表符（&#x27;/t&#x27;）,回车符（&#x27;/r&#x27;），走纸换行（&#x27;/f&#x27;），垂直制表符（&#x27;/v&#x27;），换行符（&#x27;/n&#x27;），返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isxdigit</span><span class="params">(<span class="type">int</span> ch)</span></span>; <span class="comment">// 若ch是16进制数（&#x27;0&#x27;-&#x27;9&#x27;,&#x27;A&#x27;-&#x27;F&#x27;,&#x27;a&#x27;-&#x27;f&#x27;）返回非0值，否则返回0。</span></span><br></pre></td></tr></table></figure><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）研究ascii码表，重点关心几个问题：</p><p>（1）字符是整数，整数可以进行加减运算，字符可以吗？</p><p>（2）字母’A’-‘Z’、‘a’-‘z’和数字’0’-'9’的ascii码值是不是连续的？</p><p>（3）字母’A’和’a’、'Z’和’z’的ascii码值的差是多少？</p><p>2）根据上面的研究结果，编写函数，实现字符操作常用的库函数的功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISALPHA</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISALNUM</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）或数字（&#x27;0&#x27;-&#x27;9&#x27;），返回非0值,否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISDIGIT</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是数字（&#x27;0&#x27;-&#x27;9&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISLOWER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISUPPER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TOLOWER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回相应的小写字母（&#x27;a&#x27;-&#x27;z&#x27;）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TOUPPER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回相应的大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）</span></span><br></pre></td></tr></table></figure><p>3）自定义一个函数，函数名是ctoi，利用ASCII码进行加减运算，把字符的’0’、‘1’、‘2’、‘3’、‘4’、‘5’、‘6’、‘7’、‘8’、'9’转换为整数的0、1、2、3、4、5、6、7、8、9。不允许用if和switch语句，只能用ASCII码运算，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ctoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> chr)</span></span>;  <span class="comment">// chr为用字符方式表示的数字，函数的返回值为数字的整数。</span></span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;0&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;0&#x27;</span>));    <span class="comment">// 输出结果是&#x27;0&#x27; is 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;9&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;9&#x27;</span>));    <span class="comment">// 输出结果是&#x27;9&#x27; is 9</span></span><br></pre></td></tr></table></figure><p>4）编写示例程序，测试char和unsigned char赋值超过取值范围的后果。</p><p>5）%不是转义字符，要输出%怎么办？</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言整数</title>
      <link href="/post/2e0adcd5.html"/>
      <url>/post/2e0adcd5.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-整数的概念"><a class="markdownIt-Anchor" href="#一-整数的概念"></a> 一、整数的概念</h1><p>整数是我们生活中常用的数据类型，也是编程中常用的一种数据，C语言使用int关键字来定义整数变量（int是 integer 的简写）。</p><p>在定义变量的时候，可以加signed、unsigned、short和long四种修饰符。</p><p><strong>signed</strong>：有符号的，可以表示正数和负数。</p><p><strong>unsigned</strong>：无符号的，只能表示正数，例如数组的下标、人的身高等。</p><p><strong>short</strong>：短的，现在主流的64位操作系统下，整数占用内存4个字节，使用 4<br />个字节保存较小的整数绰绰有余，会空闲出两个字节来，这些字节就白白浪费掉了。在C语言被发明的早期，或者在单片机和嵌入式系统中，内存都是非常稀缺的资源，所有的程序都在尽可能节省内存。</p><p><strong>long</strong>：长的，更长的整数。</p><h1 id="二-整数的取值范围"><a class="markdownIt-Anchor" href="#二-整数的取值范围"></a> 二、整数的取值范围</h1><p>整数的取值范围与计算机操作系统和C语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围。</p><p>一个字节有8个位，表示的数据的取值范围是2<sup>8</sup>-1，即255。</p><p>如果占用的内存是两个字节，无符号型取值范围是2<sup>8</sup>ⅹ2<sup>8</sup>-1。</p><p>如果占用的内存是四个字节，无符号型取值范围是2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>-1。</p><p>如果占用的内存是八个字节，无符号型取值范围是2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>-1。</p><p>如果是有符号，取值范围减半，因为符号占一个位。</p><p>下面用一个示例代码来测试各种整数占用内存的大小。</p><p><strong>示例（book60.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book60.c，此程序演示整数占用内存的大小和取值范围。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">short</span> si;   <span class="comment">// 短整数</span></span><br><span class="line">  <span class="type">int</span>   ii;   <span class="comment">// 整数</span></span><br><span class="line">  <span class="type">long</span>  li;   <span class="comment">// 长整数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof short is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof int is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof long is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303170955332.png" alt="在这里插入图片描述" /></p><p>sizeof是C语言中保留关键字，是一种运算符，不是函数，sizeof实际上是获取了数据在内存中所占用的存储空间，以字节为单位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;       <span class="comment">// sizeof(int)和sizeof(ii)都可以。</span></span><br></pre></td></tr></table></figure><p>根据book60.c的测试结果，我们可以得到各种整数的取值范围。</p><table><thead><tr><th>类型简写</th><th>类型全称</th><th>长度</th><th>取值范围</th></tr></thead><tbody><tr><td>short</td><td>[signed] short [int]</td><td>2字节</td><td>-32768~32767</td></tr><tr><td>unsigned short</td><td>unsigned short [int]</td><td>2字节</td><td>0~65535</td></tr><tr><td>int</td><td>[signed] int</td><td>4字节</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned int</td><td>unsigned [int]</td><td>4字节</td><td>0~4294967295</td></tr><tr><td>long</td><td>[signed] long [int]</td><td>8字节</td><td>-9223372036854775808~ 9223372036854775807</td></tr><tr><td>unsigned long</td><td>unsigned long [int]</td><td>8字节</td><td>0~18446744073709551615</td></tr></tbody></table><p>注意：</p><p>1）计算机用最高位1位来表达符号，unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍。</p><p>2）在写程序的时候，上表中括号[]的单词可以省略不书写。</p><p>3）在写程序的时候，给整数变量赋值不能超出变量的取值范围，编译的时候会出现类似以下的错误，程序运行也可能产生不可预后的后果。</p><p><img src="https://img-blog.csdnimg.cn/20200303171125136.png" alt="在这里插入图片描述" /></p><p>4）现在计算机的内存不值钱，建议程序员少用short，慎用int，多用long，内存不是问题，程序的稳定高于一切。</p><h1 id="三-整数的输出"><a class="markdownIt-Anchor" href="#三-整数的输出"></a> 三、整数的输出</h1><p>以下表格中，重点记住第一、二行十进制的输出格式，二十年来，八进制数我从来没有用过，十六进制数只在显示内存的地址时见过，所以大家不必关心八进制和十六进制的相关知识，了解即可。</p><p><img src="https://img-blog.csdnimg.cn/20200303175428412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意一个坑：输出格式控制符的类型最好与变量的类型一一对应，否则会出现意外的后果，示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">32767</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i %hd,%d\n&quot;</span>,i,i);</span><br><span class="line"><span class="type">int</span> j=<span class="number">32768</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j %hd,%d\n&quot;</span>,j,j);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i <span class="number">32767</span>,<span class="number">32767</span></span><br><span class="line">j <span class="number">-32768</span>,<span class="number">32768</span>     <span class="comment">// 得到了意外的输出结果，32768超出了short的取值范围。</span></span><br></pre></td></tr></table></figure><p>%hd用于输出短整数，最大值是32767，可以输出32767，但不能正常的输出32768。</p><h1 id="四-二进制数-八进制数和十六进制数的书写"><a class="markdownIt-Anchor" href="#四-二进制数-八进制数和十六进制数的书写"></a> 四、二进制数、八进制数和十六进制数的书写</h1><p>一个数字默认就是十进制的，表示一个十进制数字不需要任何特殊的格式。但是，表示一个二进制、八进制或者十六进制数字就不一样了，为了和十进制数字区分开来，必须采用某种特殊的写法，具体来说，就是在数字前面加上特定的字符，也就是加前缀。</p><h2 id="1-二进制"><a class="markdownIt-Anchor" href="#1-二进制"></a> 1、二进制</h2><p>二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是合法的二进制</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0b101</span>;      <span class="comment">// 换算成十进制为 5</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0b</span>110010;  <span class="comment">// 换算成十进制为 -50</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0B</span>100001;   <span class="comment">// 换算成十进制为 33</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是非法的二进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">101010</span>;  <span class="comment">// 无前缀 0B，相当于十进制</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0B</span>410;    <span class="comment">// 4不是有效的二进制数字</span></span><br></pre></td></tr></table></figure><p>请注意，标准的C语言并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。</p><h2 id="2-八进制"><a class="markdownIt-Anchor" href="#2-八进制"></a> 2、八进制</h2><p>八进制由 0~7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母o），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是合法的八进制数</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">015</span>;      <span class="comment">// 换算成十进制为 13</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0101</span>;    <span class="comment">// 换算成十进制为 -65</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0177777</span>;  <span class="comment">// 换算成十进制为 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是非法的八进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">256</span>;  <span class="comment">// 无前缀 0，相当于十进制</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">03</span>A2;  <span class="comment">// A不是有效的八进制数字</span></span><br></pre></td></tr></table></figure><h2 id="3-十六进制"><a class="markdownIt-Anchor" href="#3-十六进制"></a> 3、十六进制</h2><p>十六进制由数字 0~9、字母 A~F 或a~f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是合法的十六进制</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0X2A</span>;   <span class="comment">// 换算成十进制为 42</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0XA0</span>;  <span class="comment">// 换算成十进制为 -160</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0xffff</span>;   <span class="comment">// 换算成十进制为 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是非法的十六进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">5</span>A;    <span class="comment">// 没有前缀 0X，是一个无效数字</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0X3</span>H;  <span class="comment">// H不是有效的十六进制数字</span></span><br></pre></td></tr></table></figure><h2 id="4-需要注意的坑"><a class="markdownIt-Anchor" href="#4-需要注意的坑"></a> 4、需要注意的坑</h2><p><strong>在现实生活和工作中，我们在写十进制数的时候，为了对齐或其它原因，在数值前面加0是无关紧要的，但是，在C语言中，不要在十进制数前加0，会被计算机误认为是八进制数。</strong></p><h1 id="五-常用的库函数"><a class="markdownIt-Anchor" href="#五-常用的库函数"></a> 五、常用的库函数</h1><p>C语言提供了几个常用的库函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;  <span class="comment">// 把字符串nptr转换为int整数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;     <span class="comment">// 把字符串nptr转换为long整数</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">abs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> j)</span></span>;            <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">labs</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">int</span> j)</span></span>;     <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure><p><strong>示例（book61.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book61.c，此程序演示整数的atoi atol abs labs函数的使用</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// 如果不包含这个头文件，会出现意外的结果。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>  ii;</span><br><span class="line">  <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">  ii=<span class="built_in">atoi</span>(<span class="string">&quot;-2147483647&quot;</span>);</span><br><span class="line">  ll=<span class="built_in">atol</span>(<span class="string">&quot;-9223372036854775807&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ll=%ld\n&quot;</span>,ll);</span><br><span class="line"></span><br><span class="line">  ii=<span class="built_in">abs</span>(ii);</span><br><span class="line">  ll=<span class="built_in">labs</span>(ll);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ll=%ld\n&quot;</span>,ll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303171958780.png" alt="在这里插入图片描述" /></p><h1 id="六-数据类型的别名"><a class="markdownIt-Anchor" href="#六-数据类型的别名"></a> 六、数据类型的别名</h1><p>C语言允许程序员使用 typedef关键字来给数据类型定义一个别名，别名一般有两个特点：1）名称更短；2）更符合程序员的习惯。</p><p>例如unsigned int起个size_t的别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="type">size_t</span> ii; 等同于 <span class="type">unsigned</span> <span class="type">int</span> ii;</span><br></pre></td></tr></table></figure><p>我们来看看strlen函数的帮助，strlen的返回值就是size_t类型。</p><p><img src="https://img-blog.csdnimg.cn/20200303172117989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="七-随机数"><a class="markdownIt-Anchor" href="#七-随机数"></a> 七、随机数</h1><p>在实际开发中，会用到随机数这个功能，例如编写游戏类的程序时就需要用到随机数。</p><h2 id="1-生成随机数"><a class="markdownIt-Anchor" href="#1-生成随机数"></a> 1、生成随机数</h2><p>在C语言中，我们使用 &lt;stdlib.h&gt; 头文件中的 srand和rand 函数来生成随机数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span>;   <span class="comment">// 随机数生成器的初始化函数</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">rand</span><span class="params">()</span></span>;                        <span class="comment">// 获一个取随机数</span></span><br></pre></td></tr></table></figure><p>srand函数初始化随机数发生器（俗称种子），在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同，通常我们采用&lt;time.h&gt; 头文件中的 time 函数即可得到一个精确到秒的时间作为种子。</p><p><strong>示例（book63.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book63.c，此程序用于演示随机数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  <span class="comment">// 播下随机种子</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)  <span class="comment">// 生成5个随机数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 获取随机数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303172317661.png" alt="在这里插入图片描述" /></p><h2 id="2-生成一定范围随机数"><a class="markdownIt-Anchor" href="#2-生成一定范围随机数"></a> 2、生成一定范围随机数</h2><p>在实际开发中，需求往往是一定范围内的随机数，对于产生一定范围的随机数，就需要使用一定的技巧，常用的方法是取模运算（取余数），再加上一个加法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">50</span>;   <span class="comment">// 产生0~49的随机数</span></span><br></pre></td></tr></table></figure><p>如果要规定上下限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">51</span> + <span class="number">100</span>;   <span class="comment">// 产生100~150的随机数</span></span><br></pre></td></tr></table></figure><p>取模即取余数，rand()%51+100，rand()%51是产生 0~50 的随机数，后面+100保证 a最小只能是 100，最大就是 50+100=150。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>1）编写示例程序，判断short、unsigned short、int、unsigned int、long、unsigned long占用内存的字节数。</p><p>2）选择题：请问int的取值范围是多少？</p><p>（A）二十多亿 (B) -2147483648~2147483647 © 0~4294967295</p><p>3）选择题：请问long的取值范围是多少？</p><p>（A）很多个亿 (B) 足够大 © -9223372036854775808~9223372036854775807</p><p>4）编写示例程序，从界面上输入数字的字符串，存放在字符串变量中，然后用atoi函数转换为整数，加上100后再输出到屏幕。</p><p>5）在C语言中，还有一种long long int的整数，各位写一个程序，测试它占用内存的字节数和取值范围，并思考long long int类型是否具备实用价值。</p><p>6）编写示例程序，测试short、unsigned short、int、unsigned、long、unsigned long赋值超出了取值范围的后果。</p><p>7）重写整数的abs和labs库函数，实现其功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">ABS</span><span class="params">(<span class="type">const</span> <span class="type">int</span> j)</span></span>;                 <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">LABS</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">int</span> j)</span></span>;           <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure><p>8）利用已经学习的知识，自定义一个函数，函数名是ctoi，把字符的’0’、‘1’、‘2’、‘3’、‘4’、‘5’、‘6’、‘7’、‘8’、'9’转换为整数的0、1、2、3、4、5、6、7、8、9。函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ctoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> chr)</span></span>;</span><br><span class="line">chr为用字符方式表示的数字，函数的返回值为数字的整数。</span><br></pre></td></tr></table></figure><p>提示：采用if或switch语句，判断chr的值，直接返回结果。</p><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;0&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;0&#x27;</span>));    <span class="comment">// 输出结果是&#x27;0&#x27; is 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;9&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;9&#x27;</span>));    <span class="comment">// 输出结果是&#x27;9&#x27; is 9</span></span><br></pre></td></tr></table></figure><p><strong>以下作业题难度较大，如果无法完成，不要过于纠结，以后功力提升了再做。</strong></p><p>9）自定义一个函数，函数名是POW，利用已经学习的知识，求一个数的n次幂，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x的y次幂，函数返回值为x的y次幂。</span></span><br><span class="line"><span class="function"><span class="type">long</span>  <span class="title">POW</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x,<span class="type">const</span> <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;POW(2,3) is %lu\n&quot;</span>,<span class="built_in">POW</span>(<span class="number">2</span>,<span class="number">3</span>));      <span class="comment">// 输出结果是8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;POW(10,3) is %lu\n&quot;</span>,<span class="built_in">POW</span>(<span class="number">10</span>,<span class="number">5</span>));    <span class="comment">// 输出结果是100000</span></span><br></pre></td></tr></table></figure><p>10）编写示例程序，把字符串里的数字全部加起来，例如字符串是&quot;90576483975423&quot;，全部加起来结果是72。</p><p>11）重写整数的atoi和atol库函数，实现其功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">ATOI</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;  <span class="comment">// 把字符串nptr转换为int整数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ATOL</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;     <span class="comment">// 把字符串nptr转换为long整数</span></span><br></pre></td></tr></table></figure><p>提示：例如字符串的&quot;12305&quot;，转为整数12305，拆开就是10000+2000+300+0+5，即1*104+2*103+3*102+0*101+5*100</p><p>12）生成五十二个随机数，存放在数组中，范围是1-52，不允许重复，最后在屏幕上显示出来。</p><p>13）编写一个扑克的发牌程序，一副牌除了大小王，还有52张牌，随机洗牌，再发给四个人。</p><p>提示：</p><p>（1）把一副牌的全部牌面可以用1-52的数值表示，数组是一个好选择；</p><p>（2）洗牌就是生成范围在1-52之间不重复的随机数。</p><p>（3）定义四个数组，代表四个人，把洗好的52个数按顺序赋给四个数组就行了。如果不想定义四个数组，用一个二维数组也行。</p><p>（4）把四个数组的值显示出来，就是每个人的牌面。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针</title>
      <link href="/post/cd7b170d.html"/>
      <url>/post/cd7b170d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-变量的地址"><a class="markdownIt-Anchor" href="#一-变量的地址"></a> 一、变量的地址</h1><p>内存变量简称变量，在C语言中，每定义一个变量，系统就会给变量分配一块内存，而内存是有地址的。如果把计算机的内存区域比喻成一个大宾馆，每块内存的地址就像宾馆房间的编号。</p><p>C语言采用运算符&amp;来获取变量的地址。请看下面的示例。</p><p><strong>示例（book50.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book50.c，此程序用于演示获取变量的地址</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">10</span>;</span><br><span class="line">  <span class="type">char</span>   cc=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="type">double</span> dd=<span class="number">100.56</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;变量ii的地址是：%p\n&quot;</span>,&amp;ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;变量cc的地址是：%p\n&quot;</span>,&amp;cc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;变量dd的地址是：%p\n&quot;</span>,&amp;dd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303163622948.png" alt="在这里插入图片描述" /></p><p>注意：</p><p>1）在printf函数中，输出内存地址的格式控制符是%p，地址采用十六进制的数字显示。</p><p>2）book50程序运行了两次，每次输出的结果不一样，原因很简单，程序每次运行的时候，向系统申请内存，系统随机分配内存，就像您去宾馆开房，如果您不提前预约指定房号，每次得到的房间编号大概率不会相同。</p><h1 id="二-指针"><a class="markdownIt-Anchor" href="#二-指针"></a> 二、指针</h1><p>指针是一种特别变量，全称是指针变量，专用于存放其它变量在内存中的地址编号，指针在使用之前要先声明，语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datatype *varname;</span><br></pre></td></tr></table></figure><p>datatype 是指针的基类型，它必须是一个有效的C数据类型（int、char、double或其它自定义的数据类型），varname 是指针的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个场景中，星号是用来表示这个变量是指针。以下是有效的指针声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>     *ip;    <span class="comment">// 一个整型的指针</span></span><br><span class="line"><span class="type">char</span>    *cp;   <span class="comment">// 一个字符型的指针</span></span><br><span class="line"><span class="type">double</span> *dp;   <span class="comment">// 一个 double 型的指针</span></span><br></pre></td></tr></table></figure><h1 id="三-对指针赋值"><a class="markdownIt-Anchor" href="#三-对指针赋值"></a> 三、对指针赋值</h1><p>不管是整型、浮点型、字符型，还是其他的数据类型的内存变量，它的地址都是一个十六进制数，可以理解为内存单元的编号。我们用整数型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；用双精度型指针存放双精度型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址。</p><p>把指针指向具体的内存变量的地址，就是对指针赋值。</p><p><strong>示例book51.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book51.c，此程序用于演示指针变量</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">10</span>;</span><br><span class="line">  <span class="type">char</span>   cc=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="type">double</span> dd=<span class="number">100.56</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>    *pii=<span class="number">0</span>;  <span class="comment">// 定义整数型指针并初始化</span></span><br><span class="line">  <span class="type">char</span>   *pcc=<span class="number">0</span>;  <span class="comment">// 定义字符型指针并初始化</span></span><br><span class="line">  <span class="type">double</span> *pdd=<span class="number">0</span>;  <span class="comment">// 定义双精度型指针并初始化</span></span><br><span class="line"></span><br><span class="line">  pii=&amp;ii;  <span class="comment">// 数型指针并指向变量ii</span></span><br><span class="line">  pcc=&amp;cc;  <span class="comment">// 字符型指针并指向变量cc</span></span><br><span class="line">  pdd=&amp;dd;  <span class="comment">// 双精度型指针并指向变量dd</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出指针变量的值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pii的值是：%p\n&quot;</span>,pii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pcc的值是：%p\n&quot;</span>,pcc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pdd的值是：%p\n&quot;</span>,pdd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030316563339.png" alt="在这里插入图片描述" /></p><h1 id="四-通过指针操作内存变量"><a class="markdownIt-Anchor" href="#四-通过指针操作内存变量"></a> 四、通过指针操作内存变量</h1><p>定义了指针变量，并指向了内存变量的地址，就可以通过指针来操作内存变量（在指针前加星号*），效果与使用变量名相同。</p><p><strong>示例（book52.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book52.c，此程序演示指针的使用。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>    *pii=<span class="number">0</span>;  <span class="comment">// 定义整数型指针并初始化</span></span><br><span class="line"></span><br><span class="line">  pii=&amp;ii;  <span class="comment">// 数型指针指向变量ii</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过指针操作内存变量，改变内存变量的值</span></span><br><span class="line">  *pii=<span class="number">20</span>;    <span class="comment">// 同ii=20;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pii的值是：%p\n&quot;</span>,pii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pii的值是：%d\n&quot;</span>,*pii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii的值是：%d\n&quot;</span>,ii);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165713337.png" alt="在这里插入图片描述" /></p><h1 id="五-再来讨论函数的参数传递"><a class="markdownIt-Anchor" href="#五-再来讨论函数的参数传递"></a> 五、再来讨论函数的参数传递</h1><p>在我们之前讲的函数的参数章节中，book49.c演示了函数的参数传递，主程序调用funcld函数的时候，传递的是变量的值，现在把它修改一下。</p><p><strong>示例（book55.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book55.c，此程序演示函数参数的传递和指针</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明funcld函数，p是一个指针变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> *p)</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置一：a是一个变量，变量的地址是%p，a的值是 %d\n&quot;</span>,&amp;a,a);</span><br><span class="line">  <span class="built_in">funcld</span>(&amp;a);   <span class="comment">// 调用函数，传递变量a的地址的值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置二：a是一个变量，变量的地址是%p，a的值是 %d\n&quot;</span>,&amp;a,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置三：p是一个指针 %p, 指向的内存的地址是 %d\n&quot;</span>,p,*p);</span><br><span class="line">  *p=<span class="number">20</span>;   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置四：p是一个指针 %p, 指向的内存的地址是 %d\n&quot;</span>,p,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165801592.png" alt="在这里插入图片描述" /></p><p>book55.c演示了函数参数和指针的使用，主程序把变量a的地址传递给函数funcld，funcld函数的参数p是一个指针，接存放变量a的地址。在函数funcld中，根据指针中的地址直接操作内存，从而修改了主程序中变量a的值。</p><p>我们已经使用scanf函数很多次了，调用scanf函数的时候，需要在变量前面加符号&amp;，其实就是把变量的地址传给scanf函数，scanf函数根据传进去的地址直接操作内存，改变内存中的值，完成了对变量的赋值。</p><h1 id="六-空指针"><a class="markdownIt-Anchor" href="#六-空指针"></a> 六、空指针</h1><p>空指针就是说指针没有指向任何内存变量，指针的值是空，所以不能操作内存，否则可能会引起程序的崩溃。</p><p><strong>示例（book56.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book56.c，此程序演示操作空指针引起程序的崩溃</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> *pi=<span class="number">0</span>;  <span class="comment">// 定义一个指针</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pi的值是 %p\n&quot;</span>,pi);</span><br><span class="line"></span><br><span class="line">  *pi=<span class="number">10</span>;  <span class="comment">// 试图对空指针进行赋值操作，必将引起程序的崩溃</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165839327.png" alt="在这里插入图片描述" /></p><p>段错误（Core Dump），就是程序崩溃掉了。</p><h1 id="七-数组的地址"><a class="markdownIt-Anchor" href="#七-数组的地址"></a> 七、数组的地址</h1><p>在C语言中，数组占用的内存空间是连续的，数组名是数组元素的首地址，也是数组的地址。</p><p><strong>示例（book57.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book57.c，此程序数组的地址</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(name,<span class="string">&quot;C语言技术网(www.freecplus.net)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;name[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,&amp;name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,&amp;name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165923151.png" alt="在这里插入图片描述" /></p><p>从以上的示例可以看出，数组名、对数组取地址和数组元素的首地址是同一回事。在应用开发中，程序员一般用数组名，书写最简单。</p><h1 id="八-地址的运算"><a class="markdownIt-Anchor" href="#八-地址的运算"></a> 八、地址的运算</h1><p>地址可以用加（+）和减（-）来运算，加1表示下一个存储单元的地址，减1表示上一个存储单元的地址，一般情况下，地址的运算适用于数组，对单个变量的地址运算没有意义。</p><p><strong>示例（book58.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book58.c，此程序演示地址的运算。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span>   cc[<span class="number">4</span>];   <span class="comment">// 字符数组</span></span><br><span class="line">  <span class="type">int</span>    ii[<span class="number">4</span>];   <span class="comment">// 整数数组</span></span><br><span class="line">  <span class="type">double</span> dd[<span class="number">4</span>];   <span class="comment">// 浮点数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用地址相加的方式显示数组全部元素的的址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,cc,cc+<span class="number">1</span>,cc+<span class="number">2</span>,cc+<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,ii,ii+<span class="number">1</span>,ii+<span class="number">2</span>,ii+<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,dd,dd+<span class="number">1</span>,dd+<span class="number">2</span>,dd+<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303170018581.png" alt="在这里插入图片描述" /></p><p>大家请注意，第一行输出的每个地址的增量是1，第二行的每个地址的增量是4，第三行的每个地址的增量是8，为什么会这样？因为数组cc是char型，一个存储单元是1个字节，数组ii是int型，一个存储单元是4个字节，数组ll是long型，一个存储单元是8个字节，地址加1指的是下一个存储单元，不是数学意义中的1。</p><p>在应用开发中，地址的运算很重要，主要用于字符串操作，在以后的字符串章节中我将详细介绍。</p><h1 id="九-指针占用内存情况"><a class="markdownIt-Anchor" href="#九-指针占用内存情况"></a> 九、指针占用内存情况</h1><p>指针也是一种内存变量，是内存变量就要占用内存空间，在C语言中，任何类型的指针占用8字节的内存（32位操作系统4字节）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(int *) is %d.\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span> *));        <span class="comment">// 输出：sizeof(int *) is 8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(char *) is %d.\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">char</span> *));      <span class="comment">// 输出：sizeof(char *) is 8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(double *) is %d.\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">double</span> *));  <span class="comment">// 输出：sizeof(double *) is 8</span></span><br></pre></td></tr></table></figure><p>输出的结果都是8。</p><h1 id="十-指针的其它知识"><a class="markdownIt-Anchor" href="#十-指针的其它知识"></a> 十、指针的其它知识</h1><p>本章节介绍的知识已经包括了指针99%的用法，还有一些的知识点如指针的指针、函数指针等，这些概念难以理解，应用场景极少。学习的方法应该是循序渐进，等功力增长之后，那些复杂的概念其实也很容易。如果在这里就把人搞晕了，就没办法继续学习下去。</p><h1 id="十一-小结"><a class="markdownIt-Anchor" href="#十一-小结"></a> 十一、小结</h1><p>操作变量可以用变量名，也可以用变量的地址。</p><p>指针用一句话可以概括，就是用来存放变量的地址，是一种中间状态的变量。</p><p>变量的地址是变量的地址，指针是指针，地址和指针之间的关系像水与水桶的关系，表达的时候要严谨一些，不要把地址说成指针，也不要把指针说成地址。</p><p>指针就这么简单，您自己不要把自己晕了就行。</p><h1 id="十二-课后作业"><a class="markdownIt-Anchor" href="#十二-课后作业"></a> 十二、课后作业</h1><p>1、编写示例程序，把本章节的知识全部演示一遍，必须充分理解每一个细节，指针对C/C++程序员极其重要，没有指针，程序没法写。</p><p>2、系统会为变量分配内存，也会为常量分配内存，有内存就有地址，试试以下代码，如果不能理解就跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pstr=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pstr=%p\n&quot;</span>,pstr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pstr=%s\n&quot;</span>,pstr);     <span class="comment">// 不会出现段错误（Core dump）</span></span><br><span class="line"><span class="built_in">strcpy</span>(pstr,<span class="string">&quot;杨玉环&quot;</span>);          <span class="comment">// 会出现段错误（Core dump）</span></span><br></pre></td></tr></table></figure><h1 id="十三-版权声明"><a class="markdownIt-Anchor" href="#十三-版权声明"></a> 十三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言变量的作用域</title>
      <link href="/post/1f6773fc.html"/>
      <url>/post/1f6773fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-变量的作用域"><a class="markdownIt-Anchor" href="#一-变量的作用域"></a> 一、变量的作用域</h1><p>作用域是程序中定义的变量存在（或生效）的区域，超过该区域变量就不能被访问。C语言中有四种地方可以定义变量。</p><p>1）在所有函数外部定义的是全局变量。</p><p>2）在头文件中定义的是全局变量。</p><p>3）在函数或语句块内部定义的是局部变量。</p><p>4）函数的参数是该函数的局部变量。</p><p>顺便解释一下，函数的声明和函数的定义是两个概念，但是，变量的定义和变量的声明是同一概念，或定义变量和声明变量也行，取决于程序员的表达习惯。</p><h1 id="二-全局变量"><a class="markdownIt-Anchor" href="#二-全局变量"></a> 二、全局变量</h1><p>全局变量是定义在函数外部，通常是在程序的顶部（其它地方也可以）。全局变量在整个程序生命周期内都是有效的，在定义位置之后的任意函数中都能访问。</p><p>全局变量在主程序退出时由系统收回内存空间。</p><p><strong>示例（book37.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book37.c，此程序用于演示全局变量的作用域</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.141592</span>; <span class="comment">// 全局变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; <span class="comment">// 声明一个自定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置一 pi=%f\n&quot;</span>,pi);</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置二 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置三 pi=%f\n&quot;</span>,pi);</span><br><span class="line">  pi=<span class="number">3.141593</span>;  <span class="comment">// 改变pi的值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置四 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，pi为全局变量，定义在main()和func1()之外，位于程序的顶部，在main()和func1()函数中都可以访问它。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030316292489.png" alt="在这里插入图片描述" /></p><h1 id="三-局部变量"><a class="markdownIt-Anchor" href="#三-局部变量"></a> 三、局部变量</h1><p>在某个函数或语句块的内部声明的变量称为局部变量，它们只能在该函数或语句块内部的语句使用。</p><p>局部变量在函数或语句块外部是不可用的。</p><p>局部变量在函数返回或语句块结束时由系统收回内存空间。</p><h1 id="四-函数的参数"><a class="markdownIt-Anchor" href="#四-函数的参数"></a> 四、函数的参数</h1><p>函数的参数被当作该函数内的局部变量。</p><p>建议各位再阅读《C语言函数》的” 九、函数参数的传递”章节。</p><h1 id="五-注意事项"><a class="markdownIt-Anchor" href="#五-注意事项"></a> 五、注意事项</h1><p>局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量。</p><p><strong>示例（book39.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book39.c，此程序演示局部变量与全局变量重名的情况.</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.141592</span>; <span class="comment">// 全局变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; <span class="comment">// 声明一个自定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置一 pi=%f\n&quot;</span>,pi);</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置二 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> pi=<span class="number">3.141593</span>; <span class="comment">// 全局变量声明</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置三 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，定义了全局变量pi，在func1()函数中，定义了局部变量pi，func1()函数运行的时候，会使用自己的局部变量pi，不会使用全局变量pi，所以main函数中位置二输出pi的值是仍然3.141592。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303163005938.png" alt="在这里插入图片描述" /></p><h1 id="六-课后作业"><a class="markdownIt-Anchor" href="#六-课后作业"></a> 六、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数</title>
      <link href="/post/cfb62513.html"/>
      <url>/post/cfb62513.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-函数的概念"><a class="markdownIt-Anchor" href="#一-函数的概念"></a> 一、函数的概念</h1><h2 id="1-函数的概念"><a class="markdownIt-Anchor" href="#1-函数的概念"></a> 1、函数的概念</h2><p>每个C程序都至少有一个函数，即main主函数  ，如果程序的任务比较简单，全部的代码都写在main函数中，但是，在实际开发中，程序的任务往往比较复杂，如果全部的代码都写在main函数中，main函数体将非常庞大臃肿，代码重复。</p><p>我们可以把程序的任务分工到不同的子函数中，main更关心业务逻辑和处理流程，需要执行某任务的时候，调用子函数就可以了。</p><h2 id="2-函数的分类"><a class="markdownIt-Anchor" href="#2-函数的分类"></a> 2、函数的分类</h2><p>为了方使理解，我们把函数分为库函数和自定义函数（子函数）。</p><p>库函数是C语言提供的，实现了某些基本的功能，例如scanf、printf，在程序中可以直接使用。</p><p>自定义函数是程序员为了完成某项任务而编写的函数，目的是为了实现某项的功能或让主程序更简洁。自定义函数在使用之前，必须先声明和定义。</p><h1 id="二-自定义函数的声明"><a class="markdownIt-Anchor" href="#二-自定义函数的声明"></a> 二、自定义函数的声明</h1><p>自定义函数的声明包括了<strong>返回值</strong>、<strong>函数名</strong>和<strong>参数列表</strong>。有些程序员把函数声明说成是函数原型，只是用词不同，意思是一样的。</p><p>C语言中的声明函数的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure><p>1）返回值的数据类型return_type：函数执行完任务后的返回值，可以是int、char、double或其它自定义的数据类型。如果函数只执行任务而不返回值，return_type用关键字 void表示，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure><p>2）函数名function_name：函数名是标识符，命名规则与变量相同。</p><p>3）参数列表parameter list：当函数被调用时，调用者需要向函数传递参数。参数列表包括参数的数据类型和书写顺序。参数列表是可选的，也就是说，函数可以没有参数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>函数声明示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断超女身材函数的声明</span></span><br><span class="line"><span class="comment">// 函数名：checksc</span></span><br><span class="line"><span class="comment">// 参数：height，身高，单位cm。</span></span><br><span class="line"><span class="comment">// 返回值：0-不合格；1-娇小；2-标准；3-高挑</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>声明了一个函数，返回值是int类型，函数名是checksc，函数只有一个参数int height，注意，函数的声明语句最后的分号不能少。</p><p>如果把自定义函数比喻成工具，函数的声明就是这个工具的设计图纸。</p><h1 id="三-自定义函数的定义"><a class="markdownIt-Anchor" href="#三-自定义函数的定义"></a> 三、自定义函数的定义</h1><p>自定义函数是工具，如果想让这个工具能被使用，光有设计图纸还不行，还要把工具制造出来，函数的定义就是这个工具的实际主体，是为了实现函数的功能而编写的代码。</p><p>C语言中的函数定义的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span>       <span class="comment">// 注意，不要在函数定义的最后加分号。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 实现函数功能的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义的return_type、function_name和parameter list必须与函数声明一致。</p><p>函数主体包含为了完成任务需要执行语句的集合，放在花括号内。</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断超女身材函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">160</span>) &amp;&amp; (height&lt;<span class="number">165</span>) ) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 娇小</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">165</span>) &amp;&amp; (height&lt;<span class="number">175</span>) ) <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">// 标准</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">175</span>) &amp;&amp; (height&lt;<span class="number">180</span>) ) <span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">// 高挑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 不合格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-自定义函数代码的组织"><a class="markdownIt-Anchor" href="#四-自定义函数代码的组织"></a> 四、自定义函数代码的组织</h1><h2 id="1-非通用能功的函数"><a class="markdownIt-Anchor" href="#1-非通用能功的函数"></a> 1、非通用能功的函数</h2><p>如果自定义函数只在调用者程序中使用，可以在调用者程序中声明和定义，声明一般为调用者程序的上部，定义一般在调用者程序的下部，这并不是C语言的规定，而是为了让程序更方便阅读，程序员约定的写法。</p><p><strong>示例（book45.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book45.c，此程序演示自定义函数在主程序中声明和定义</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断超女身材函数的声明</span></span><br><span class="line"><span class="comment">// 函数名：checksc</span></span><br><span class="line"><span class="comment">// 参数：height，身高，单位cm。</span></span><br><span class="line"><span class="comment">// 返回值：0-不合格；1-娇小；2-标准；3-高挑</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> ii,jj;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入超女的身高（单位：厘米）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ii);</span><br><span class="line"></span><br><span class="line">  jj=<span class="built_in">checksc</span>(ii);   <span class="comment">// 调用checksc函数判断身材</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;不合格。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;娇小。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;标准。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;高挑。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断超女身材函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">160</span>) &amp;&amp; (height&lt;<span class="number">165</span>) ) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 娇小</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">165</span>) &amp;&amp; (height&lt;<span class="number">175</span>) ) <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">// 标准</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">175</span>) &amp;&amp; (height&lt;<span class="number">180</span>) ) <span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">// 高挑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 不合格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book45.c中，判断超女身材的函数（checksc）不是公共的功能，只在选秀程序使用，所以它的声明和定义都写在book45.c中。</p><h2 id="2-通用能功的函数"><a class="markdownIt-Anchor" href="#2-通用能功的函数"></a> 2、通用能功的函数</h2><p>如果自定义函数是一个通用的功能模块，可以在公共的头文件中声明，在公共的程序文件中定义。</p><p>如果某程序需要调用公共的函数，在调用者程序中用#include指令包含公共的头文件，编译的时候把调用者程序和公共的程序文件一起编译。</p><p>在以下的示例中，函数min和max是公共的函数，在_public.h头文件中声明，在_public.c程序文件中定义，在book46.c程序中被调用。</p><p><strong>1）公共的头文件（_public.h）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：_public.h，公共功能函数声明的头文件</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明min函数，用于比较两个整数的大小，取小者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明max函数，用于比较两个整数的大小，取大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>2）公共的程序文件（_public.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：_public.c，公共功能函数声明的程序文件</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_public.h&quot;</span>  <span class="comment">// 包含自定义函数声明的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于比较两个整数的大小，函数返回较小者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span>   <span class="comment">// min函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ii1&lt;ii2) <span class="keyword">return</span> ii1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ii2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于比较两个整数的大小，函数返回较大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span>   <span class="comment">// max函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ii1&gt;ii2) <span class="keyword">return</span> ii1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ii2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）调用者程序文件（book46.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 程序名：book46.c，此程序演示了在主程序的外部文件中声明和定义函数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_public.h&quot;</span>  <span class="comment">// 把_public.h头文件包含进来</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> xx,yy,imin,imax;</span><br><span class="line"></span><br><span class="line">  xx=<span class="number">50</span>; yy=<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">  imin=<span class="built_in">min</span>(xx,yy);</span><br><span class="line">  imax=<span class="built_in">max</span>(xx,yy);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;imin=%d,imax=%d\n&quot;</span>,imin,imax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）编译运行</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303160551935.png" alt="在这里插入图片描述" /></p><h2 id="3-注意事项"><a class="markdownIt-Anchor" href="#3-注意事项"></a> 3、注意事项</h2><p>1）在book46.c的第5行<code>#include &quot;_public.h&quot;</code>，这里包含头文件是用双引号，不是尖括号&lt;&gt;，这两者的差别如下：</p><p><code>#include &lt;&gt;</code> 用于包含系统提供的头文件，编译的时候，gcc在系统的头文件目录中寻找头文件。</p><p><code>#include &quot;&quot;</code> 用于包含程序员自定义的头文件，编译的时候，gcc先在当前目录中寻找头文件，如果找不到，再到系统的头文件目录中寻找。</p><p>2）编译程序的时候，要把调用者程序和公共程序文件一起编译，否则编译器会报错。</p><p><img src="https://img-blog.csdnimg.cn/20200303160926738.png" alt="在这里插入图片描述" /></p><p>3）C语言对公共函数的头文件（_public.h）和程序文件（_public.c）的命名没有规定，由程序员自己命名，为了增加程序的可读性，尽可能采用一些有意义的文件名。</p><h1 id="五-库函数"><a class="markdownIt-Anchor" href="#五-库函数"></a> 五、库函数</h1><p>C语言提供了很多标准函数（C standard library），简称库函数，调用这些函数可以完成一些基本的功能，例如printf、scanf、memset、strcpy等。C语言的库函数有几百个，常用的不超过30%,在以后的章节中我将详细介绍常用库函数的应用场景和使用方法。</p><p>C语言标准库函数的声明的头文件存放在/usr/include目录中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;asset.h&gt;     &lt;ctype.h&gt;       &lt;errno.h&gt;     &lt;<span class="type">float</span>.h&gt;    &lt;limits.h&gt;</span><br><span class="line">&lt;locale.h&gt;    &lt;math.h&gt;     &lt;setjmp.h&gt;   &lt;signal.h&gt;     &lt;stdarg.h&gt;</span><br><span class="line">&lt;stddef.h&gt;   &lt;stdlib.h&gt;   &lt;stdio.h&gt;      &lt;string.h&gt;      &lt;time.h&gt;</span><br></pre></td></tr></table></figure><p>C语言库函数的定义的文件是<code>/usr/lib/gcc/x86_64-redhat-linux/4.4.4/libgcc.a</code>（不同编译器的版本目录名有所不同），这是一个打包好的库文件，把程序文件打包成库文件的方法以后再详细介绍。</p><p>我们用gcc编译程序的时候并没有把libgcc.a包含进来，那是因为gcc编译器缺省会包含它，但是，程序员自定义函数的程序文件就没有这种待遇，需要手工的包含进来与程序一起编译。</p><h1 id="六-需要包含哪些头文件"><a class="markdownIt-Anchor" href="#六-需要包含哪些头文件"></a> 六、需要包含哪些头文件</h1><p>我们在使用库函数的时候，如果不包含它的头文件，编译时会出现警告或错误，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200303161107208.png" alt="在这里插入图片描述" /><br />那么，在我们编写的程序中，应该包含哪些头文件呢？有两种方法，一是上百度上查资料，二是使用Linux系统提供的帮助，以strcpy函数为例，在命令行下输入man strcpy回车，如下：<br /><img src="https://img-blog.csdnimg.cn/20200303161137980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>man显示了函数的声明的头文件（第5行），函数的参数、使用方法和返回值。</p><p>注意了，如果程序中调用了库函数但没有包含它头文件，编译的时候不一定是警告，也可能是报错，函数无法识别等，这个要看编译器，不同C语言的编译器的处理方式不一样。</p><h1 id="七-调用函数的方法"><a class="markdownIt-Anchor" href="#七-调用函数的方法"></a> 七、调用函数的方法</h1><p>库函数是系统提供的工具，自定义函数是程序员自己补充的工具，对使用者来说都一样，没有区别。</p><p>在C语言中，函数的调用非常灵活，可以独占一行语句，也可以当成常量赋值给变量，也可以当成函数的参数。</p><p>如果函数的返回值是void，表示该函数的调用一定会成功，一般用单行书写，独占一条语句。</p><p>如果函数的返回值不是void，可以不关心它的返回值，也可以当成常量用于任何表达式中。</p><p><strong>示例（book47.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book47.c，此程序演示了函数的灵活调用。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_public.h&quot;</span>  <span class="comment">// 把_public.h头文件包含进来</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="built_in">max</span>(<span class="number">30</span>,<span class="number">45</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">max</span>(<span class="number">30</span>,<span class="number">20</span>);   <span class="comment">// 没有接收返回值，max的活白干了。</span></span><br><span class="line"></span><br><span class="line">  <span class="number">55</span>;      <span class="comment">// 这是什么鬼？</span></span><br><span class="line"></span><br><span class="line">  i=<span class="built_in">max</span>(<span class="built_in">min</span>(<span class="number">45</span>,<span class="number">38</span>),<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  i=<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">min</span>(<span class="number">45</span>,<span class="number">38</span>),<span class="number">50</span>),<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;30和50相比，更大的值是%d。\n&quot;</span>,<span class="built_in">max</span>(<span class="number">30</span>,<span class="number">50</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可能对这个代码不理解，一句话：如果函数的返回值是整数，就可以把函数当成整数来用，如果返回值是小数，就可以把函数当成小数来用，……。</p><h1 id="八-函数调用的过程"><a class="markdownIt-Anchor" href="#八-函数调用的过程"></a> 八、函数调用的过程</h1><p>在程序中调用子函数时，程序的流程进入子函数的代码中，当子函数返回时（或到达函数的结束括号时），程序的流程回到调用者程序。</p><p><strong>示例（book48.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *  程序名：book48.c，此程序演示了函数的调用的过程</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明func函数，无返回值无参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;即将调用func函数。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;调用func函数已完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);    <span class="comment">// sleep是C语言的库函数，睡眠</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已经过去了%d秒。\n&quot;</span>,ii+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161320905.png" alt="在这里插入图片描述" /></p><h1 id="九-函数参数的传递"><a class="markdownIt-Anchor" href="#九-函数参数的传递"></a> 九、函数参数的传递</h1><p>函数的参数可以理解为函数内部的变量，参数传递就是调用者程序把变量（或常量）的值复制一份给函数的参数，简单说来就是复制的过程。一旦完成数据的复制，调用者程序的变量和函数的参数就再也没有瓜葛了，所以，在函数调用的过程中，函数内部变量的值发生改变并不会影响调用者程序的变量的值。</p><p>我们在调用函数的时候，不关心函数参数的名称，函数参数的名称是函数自己的事情，是函数的内部变量，只在函数内部使用，与调用者无关。</p><p><strong>示例（book49.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book49.c，此程序演示了函数参数的传递</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> b)</span></span>;   <span class="comment">// 声明函数funcld，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;调用funcld前a的值是%d.\n&quot;</span>,a);</span><br><span class="line">  <span class="built_in">funcld</span>(a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;调用funcld后a的值是%d.\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;赋值前b的值是%d.\n&quot;</span>,b);</span><br><span class="line">  b=<span class="number">20</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;赋值后b的值是%d.\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161452306.png" alt="在这里插入图片描述" /></p><p>关于函数的参数，在很多教程中有很多说法，如“形参”、“实参”、“值传递”、“地址传递”等，这些说法把简单的概念复杂化了，大家不必理会。</p><h1 id="十-const约束"><a class="markdownIt-Anchor" href="#十-const约束"></a> 十、const约束</h1><p>const 是 constant 的缩写，意思是“恒定不变的”，它是定义只读变量的关键字。用 const 定义只读变量的方法很简单，就在定义变量时前面加 const 即可，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span>  <span class="type">double</span>  pi = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p>用 const 定义的变量的值是不允许改变的，不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值，如果程序中试图改变它的值，编译的时候就会报错。</p><p>在变量前加const约束，主要用于定义函数的参数，表示该参数在函数中是只读取，不允许改变，如果函数中试图改变它的值，编译的时候就会报错。</p><p><strong>例如：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161546613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>编译如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161558260.png" alt="在这里插入图片描述" /></p><p>为什么要在函数的参数前加const？有两个目的：1）防止程序员犯错，如果程序员犯了错误，编译器就能发现；2）增加了源代码的可读性。在实际开发中，函数的参数不加const不会有任何问题，但是，程序员一般都会为只读变量加上const约束，这是一个好的习惯。</p><h1 id="十一-应用经验"><a class="markdownIt-Anchor" href="#十一-应用经验"></a> 十一、应用经验</h1><h2 id="1-如何寻找函数"><a class="markdownIt-Anchor" href="#1-如何寻找函数"></a> 1、如何寻找函数</h2><p>在我的课程中，会介绍常用库函数的使用方法，但也有漏掉的。查资料能力是程序员的基本技能，它可以提升您解决问题的能力。</p><p>例如要查找C语言复制字符串功能的函数，在百度上输入“C语言复制字符串”搜索就可以了，您想查什么就输入什么。</p><p><img src="https://img-blog.csdnimg.cn/20200303161618819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>然后，打开多几个网页看看，基本上能找到答案。</p><p>注意一个问题，网上的内容太多太杂乱，大部分文章是初学者发的博客，重点关注百度百科的文章。</p><h2 id="2-测试函数的功能"><a class="markdownIt-Anchor" href="#2-测试函数的功能"></a> 2、测试函数的功能</h2><p>以strcpy函数为例，函数的声明如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>函数功能：字符串复制。</p><p>函数名：strcpy。</p><p>dest参数：目标字符串。</p><p>src参数：待复制的内容，有const约束。</p><p>返回值：返回dest，这是提高函数可用性的常用的处理方法。</p><p>用代码测试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,<span class="built_in">strcpy</span>(strname,<span class="string">&quot;西施&quot;</span>));</span><br></pre></td></tr></table></figure><p>然后，看看输出的结果是不是“=西施=”，用=号夹住输出的内容是为了看清楚有没有其它的字符。</p><h1 id="十二-课后作业"><a class="markdownIt-Anchor" href="#十二-课后作业"></a> 十二、课后作业</h1><p>1）编写示例程序，自定义一个根据超女的胸围判断身材的函数，判断标准由您定，类似book45.c。</p><p>2）C语言的库函数肯定是不够用的，程序员必须要有自己的函数库，从本章节就开始准备，创建您自己的函数库的头文件和程序文件，头文件和程序文件的命名由您定，先放两个函数进去，声明如下，然后写示例程序调用它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明max函数，取两个数值的较大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> ii1,<span class="type">int</span> ii2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明min函数，取两个数值的较小者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> ii1,<span class="type">int</span> ii2)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个自定义函数的功能虽然简单，但是，千里之行，始于足下，慢慢积累。</p><p>3）本章节的内容非常重要，建议大家看多几遍视频，用程序测试每个知识点，充分的理解它。</p><h1 id="十三-版权声明"><a class="markdownIt-Anchor" href="#十三-版权声明"></a> 十三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数组</title>
      <link href="/post/8a19dc2c.html"/>
      <url>/post/8a19dc2c.html</url>
      
        <content type="html"><![CDATA[<p>先来看一个需求，超女选秀一共有5人参加，输入每位超女的体重并保存在变量中，最后计算出超女的的平均体重。</p><p><strong>示例(book40.c)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book40.c，此程序用于演示没有数组的情况下的多个变量求和</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> aa,bb,cc,dd,ee;  <span class="comment">// 定义5个变量存放5名超女的体重</span></span><br><span class="line">  aa=bb=cc=dd=ee=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第1名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;aa);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第2名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;bb);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第3名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;cc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第4名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;dd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第5名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;ee);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;超女的平均体重是：%lf\n&quot;</span>,(aa+bb+cc+dd+ee)/<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有100名超女，这个程序将会很长很烦锁。</p><h1 id="一-数组"><a class="markdownIt-Anchor" href="#一-数组"></a> 一、数组</h1><p>数组（array）是一组数据类型相同的变量，可以存放一组数据，它定义的语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[数组长度];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> money[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>money是一个数组，包含了20个元素，每个元素都一个double类型的变量，可以通过下标访问数组中元素（element），数组下标的编号从0开始，数组的第1个元素是money[0]，第2个元素是money[1]，以此类推，直到第20个元素money[19]。</p><p>给每个元素赋double类型的值，可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">money[<span class="number">0</span>] = <span class="number">10.55</span>;</span><br><span class="line">money[<span class="number">1</span>] = <span class="number">32.54</span>;</span><br><span class="line">money[<span class="number">2</span>] = <span class="number">2055.65</span>;</span><br><span class="line">……</span><br><span class="line">money[<span class="number">19</span>] = <span class="number">2055.65</span>;</span><br></pre></td></tr></table></figure><p>定义数组的时候，数组的长度必须是整数，可以是常量，也可以是变量。</p><p>数据的下标也必须是整数，可以是常量，也可以是变量。</p><p>使用数组元素和使用同类型的变量一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;money[<span class="number">4</span>]);   <span class="comment">// 把一个值读入数组的第5个元素</span></span><br></pre></td></tr></table></figure><p>数组的类型可以是任意数据类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>      no[<span class="number">22</span>];　   <span class="comment">// 可储存22个int类型整数的数组</span></span><br><span class="line"><span class="type">char</span>    actors[<span class="number">26</span>];　<span class="comment">// 可储存26个字符的数组</span></span><br><span class="line"><span class="type">double</span> big[<span class="number">500</span>];　　<span class="comment">// 可储存500个double类型整数的数组</span></span><br></pre></td></tr></table></figure><h1 id="二-占用内存的大小"><a class="markdownIt-Anchor" href="#二-占用内存的大小"></a> 二、占用内存的大小</h1><p>我们已经知道如何获取单个变量占用内存大小的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;       <span class="comment">// 定义一个整型变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ii)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(ii));     <span class="comment">// 输出结果：sizeof(ii)=4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ii)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">// 输出结果：sizeof(ii)=4</span></span><br></pre></td></tr></table></figure><p>数组是有多个变量组成，占用内存总空间的大小为多个变量占用的内存空间之和，用sizeof（数组名）就可以得到整个数组占用内存的大小，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii[<span class="number">10</span>];    <span class="comment">// 定义一个整型数组变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ii)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(ii));     <span class="comment">// 输出结果：sizeof(ii)=40</span></span><br></pre></td></tr></table></figure><h1 id="三-数组的初始化"><a class="markdownIt-Anchor" href="#三-数组的初始化"></a> 三、数组的初始化</h1><p>采用memset函数对数组进行初始化，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> no[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(no,<span class="number">0</span>,<span class="built_in">sizeof</span>(no));</span><br></pre></td></tr></table></figure><p>第一个参数是数组名，第二个参数填0，第三个参数是数组占用的内存总空间，用sizeof(变量名)获取。</p><h1 id="四-注意事项"><a class="markdownIt-Anchor" href="#四-注意事项"></a> 四、注意事项</h1><p>1）定义数组的时候，数组的长度必须是整数，可以用常量和变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> numbers[size];</span><br></pre></td></tr></table></figure><p>2）使用数组的时候，数组的下标也必须是整数，可以用常量和变量。</p><p>3）使用数组的时候，编译器不会检查数组的下标是否正确，但是在程序中下标一定不能越界，如果程序运行时数组下标越界，就相当于访问了其它程序的内存，可能会导致程序异常中断（Core dump），后果非常严重。</p><p>示例（book41.c）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book41.c，此程序演示数组下标越界的后果</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> sum[<span class="number">5</span>];    <span class="comment">// 定义一维数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">100</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br><span class="line">    sum[ii]=ii;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030315195384.png" alt="在这里插入图片描述" /></p><p>段错误，就是程序非法操作内存，引起程序的崩溃。</p><p>如果数组的下标越界了，是不是一定会引起程序的崩溃呢？不一定，如果把book41.c的循环改为6，可能就不会出现段错误。</p><h1 id="五-在for循环中数组"><a class="markdownIt-Anchor" href="#五-在for循环中数组"></a> 五、在for循环中数组</h1><p>在学习了数组的知识以后，本章节开始时的那个需求有了更好的解决方法，程序book40.c必须修改。</p><p><strong>示例（book42.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book42.c，此程序演示采用for循环语句和数组结合使用</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">0</span>;           <span class="comment">// 用于循环的计数器</span></span><br><span class="line">  <span class="type">int</span>    total=<span class="number">5</span>;        <span class="comment">// 超女的总人数，初始化为5</span></span><br><span class="line">  <span class="type">double</span> weight[total];  <span class="comment">// 定义数组，用于存放超女的体重</span></span><br><span class="line">  <span class="type">double</span> sum=<span class="number">0</span>;          <span class="comment">// 存放超女体重的和</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="built_in">sizeof</span>(weight));    <span class="comment">// 初始化数组为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环输入超女的体重，并计算体重的总和</span></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;total;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d名超女的体重：&quot;</span>,ii+<span class="number">1</span>);   <span class="comment">// 输入提示信息</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;weight[ii]);    <span class="comment">// 接受从键盘输入的体重</span></span><br><span class="line">    sum=sum+weight[ii];          <span class="comment">// 计算超女体重的和</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;超女的平均体重是：%lf\n&quot;</span>,sum/total);  <span class="comment">// 输出平均体重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303152119212.png" alt="在这里插入图片描述" /></p><p>for循环提供了一个简单直接的方法来使用数组下标，使用数组和for循环处理数据，这比使用5个单独的scanf语句方便得多。不管是5个还是100个超女，程序也不会再增加代码。</p><h1 id="六-二维数组"><a class="markdownIt-Anchor" href="#六-二维数组"></a> 六、二维数组</h1><p>二维数组定义的语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[第一维的长度][第二维的长度];</span><br></pre></td></tr></table></figure><p>在我们现实生活中，二维数组到处都是，例如超女选秀，一共有5个小组，每组4人，如果要指明某位超女，必须同时指明该超女的小组编号和她在组内序号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> girl[<span class="number">5</span>][<span class="number">4</span>];</span><br><span class="line">girl[<span class="number">0</span>][<span class="number">0</span>]    girl[<span class="number">0</span>][<span class="number">1</span>]    girl[<span class="number">0</span>][<span class="number">2</span>]    girl[<span class="number">0</span>][<span class="number">3</span>] </span><br><span class="line">girl[<span class="number">1</span>][<span class="number">0</span>]    girl[<span class="number">1</span>][<span class="number">1</span>]    girl[<span class="number">1</span>][<span class="number">2</span>]    girl[<span class="number">1</span>][<span class="number">3</span>]</span><br><span class="line">girl[<span class="number">2</span>][<span class="number">0</span>]    girl[<span class="number">2</span>][<span class="number">1</span>]    girl[<span class="number">2</span>][<span class="number">2</span>]    girl[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line">girl[<span class="number">3</span>][<span class="number">0</span>]    girl[<span class="number">3</span>][<span class="number">1</span>]    girl[<span class="number">3</span>][<span class="number">2</span>]    girl[<span class="number">3</span>][<span class="number">3</span>]</span><br><span class="line">girl[<span class="number">4</span>][<span class="number">0</span>]    girl[<span class="number">4</span>][<span class="number">1</span>]    girl[<span class="number">4</span>][<span class="number">2</span>]    girl[<span class="number">4</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>也可以将二维数组看成一个坐标系，有 x 轴和 y 轴，要想在一个平面中确定一个点，必须同时指定 x 和 y 值。</p><p>二维数组的初始化也是用memset，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(girl,<span class="number">0</span>,<span class="built_in">sizeof</span>(girl));</span><br></pre></td></tr></table></figure><p>把本章节刚开始的那个需求增加一点难度：超女选秀有3个组，每组有5名选手，请提供一个界面，输入每个超女的体重，最后计算每组的超女的平均体重。</p><p><strong>示例（book43.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book43.c，此程序演示采用for循环语句和二维数组结合使用</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">0</span>;          <span class="comment">// 用于组别循环的计数器</span></span><br><span class="line">  <span class="type">int</span>    jj=<span class="number">0</span>;          <span class="comment">// 用于超女人数循环的计数器</span></span><br><span class="line">  <span class="type">int</span>    <span class="keyword">class</span>=<span class="number">3</span>;       <span class="comment">// 小组总数，初始化为3</span></span><br><span class="line">  <span class="type">int</span>    total=<span class="number">5</span>;       <span class="comment">// 每个组超女的总人数，初始化为5</span></span><br><span class="line">  <span class="type">double</span> weight[<span class="keyword">class</span>][total];  <span class="comment">// 定义二维数组，存放超女的体重</span></span><br><span class="line">  <span class="type">double</span> sum[<span class="keyword">class</span>];    <span class="comment">// 定义一维数组存放超女体重的和</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="built_in">sizeof</span>(weight));   <span class="comment">// 初始化数组为0</span></span><br><span class="line">  <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="built_in">sizeof</span>(sum));          <span class="comment">// 初始化数组为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用两个循环，第一级循环为小组数，第二级循环为超女人数</span></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="keyword">class</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (jj=<span class="number">0</span>;jj&lt;total;jj++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d组第%d名超女的体重：&quot;</span>,ii+<span class="number">1</span>,jj+<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;weight[ii][jj]);    <span class="comment">// 接受从键盘输入的体重</span></span><br><span class="line">      sum[ii]=sum[ii]+weight[ii][jj];  <span class="comment">// 计算小组超女体重的和</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303152310597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="七-多维数组"><a class="markdownIt-Anchor" href="#七-多维数组"></a> 七、多维数组</h1><p>从二维数组可以类推出多维数组的用法，在实际开发中，二维以上的数组应用场景很少。</p><p>对初学者来说，建议先不要把这个问题复杂化，能掌握一维和二维数组就可以了，等功力提升之后，会发现多维数组其实也很容易。</p><h1 id="八-字符串"><a class="markdownIt-Anchor" href="#八-字符串"></a> 八、字符串</h1><h2 id="1-字符串的概念"><a class="markdownIt-Anchor" href="#1-字符串的概念"></a> 1、字符串的概念</h2><p>字符串就是一个以空字符’\0’结束的字符数组，是一个特别的字符数组，这是约定，是规则。</p><p>空字符’\0’也可以直接写成0。</p><p><img src="https://img-blog.csdnimg.cn/20200303152347745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>因为字符串需要用0结束，所以在定义字符串的时候，要预留多一个字节来存放0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];  <span class="comment">// 定义一个最多存放20个字符或10个汉字的字符串</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串的初始化"><a class="markdownIt-Anchor" href="#2-字符串的初始化"></a> 2、字符串的初始化</h2><p>字符串是数组，当然可以用初始化数组的方法来初始化字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br></pre></td></tr></table></figure><h2 id="3-字符串的赋值"><a class="markdownIt-Anchor" href="#3-字符串的赋值"></a> 3、字符串的赋值</h2><p>如果想在strword中存入字符串“hello”，可以用strcpy函数，也可以采用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(strword,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 或者用以下代码</span></span><br><span class="line"><span class="type">char</span> strword[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strword,<span class="number">0</span>,<span class="built_in">sizeof</span>(strword));</span><br><span class="line">strword[<span class="number">0</span>]=<span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">strword[<span class="number">1</span>]=<span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">strword[<span class="number">2</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">strword[<span class="number">3</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">strword[<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">strword[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;      <span class="comment">// 或者 name[5]=0;</span></span><br></pre></td></tr></table></figure><h2 id="4-关于字符串结束符0的讨论"><a class="markdownIt-Anchor" href="#4-关于字符串结束符0的讨论"></a> 4、关于字符串结束符0的讨论</h2><p>您可能会问，如果字符串不用0结束，会有什么样的结果，我们用代码来演示一下。</p><p><strong>示例（book44.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book44.c，此程序用于演示字符串没有用0结束的后果</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">3</span>];</span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"></span><br><span class="line">  name[<span class="number">0</span>]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  name[<span class="number">1</span>]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  name[<span class="number">2</span>]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s=\n&quot;</span>,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303152730327.png" alt="在这里插入图片描述" /></p><p>可以看到，输出abc之后，有乱码，并且每次执行程序输出的结果不可预知。</p><p>您可能还会问，如果字符串以0结束了，但是后面的内容并不是0，怎么办？<strong>后面的内容将被丢弃。</strong></p><h2 id="5-字符串数组"><a class="markdownIt-Anchor" href="#5-字符串数组"></a> 5、字符串数组</h2><p>以0结束的一维字符数组是一个字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];       <span class="comment">// 可以存放20个字符的字符串</span></span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;我真的可以存十个汉字&quot;</span>);</span><br></pre></td></tr></table></figure><p>给一维字符数组加上一维，就是字符串数组了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">10</span>][<span class="number">21</span>];   <span class="comment">// 10个字符串，每个字符串可以存放20个字符</span></span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">0</span>],<span class="string">&quot;坦已&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">1</span>],<span class="string">&quot;褒似&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">2</span>],<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">3</span>],<span class="string">&quot;王昭君&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">4</span>],<span class="string">&quot;貂婵&quot;</span>);</span><br><span class="line">……</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">9</span>],<span class="string">&quot;陈圆圆&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="十-课后作业"><a class="markdownIt-Anchor" href="#十-课后作业"></a> 十、课后作业</h1><p>1）编写示例程序，从界面上输入一个字符串，计算字符串的长度。如果输入的是&quot;abcdaaf&quot;，显示的结果是7。</p><p>2）编写示例程序，从界面上输入一个字符串，把字符串的每个字符从左到右一个一个的显示出来，如果输入的是&quot;abcdaaf&quot;，显示的结果是：a b c d a a f。</p><p>3）编写示例程序，从界面上输入一个字符串，把字符串的每个字符从右到左一个一个的显示出来，如果输入的是&quot;abcdaaf&quot;，显示的结果是：f a a d c b a。</p><p>4）编写示例程序，某班有10个学生，定义一个一维数组，从界面上输入每个学生的成绩，最后显示这个班的平均成绩。</p><p>5）编写示例程序，某年级有两个班，每班有8名学生，定义一个二维数组，从界面上输入每个学生的成绩，最后显示每个班的平均成绩和年级的平均成绩。</p><p>6）编写示例程序，定义一个可以存放10个字符串的数组，字符串的有效长度是30个字符，从界面上输入10个字符串并存放在数组中，然后把这10个字符串显示出来。</p><p><strong>以下题难难度较大，可以等到以后功力提升的时候再做。</strong></p><p>7）如果还觉得不过隐，可以挑战一下三维数组，某学校有两个年级，每个年级有三个班，每个班有四名学生，从界面上输入每个学生的成绩，最后显示每个班的平均成绩、年级的平均成绩和全校的平均成绩。</p><p><strong>别玩三维以上的数组，没什么意义。</strong></p><h1 id="十一-版权声明"><a class="markdownIt-Anchor" href="#十一-版权声明"></a> 十一、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言循环结构</title>
      <link href="/post/c5f99b02.html"/>
      <url>/post/c5f99b02.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-程序结构"><a class="markdownIt-Anchor" href="#一-程序结构"></a> 一、程序结构</h1><p>在C语言程序中，一共有三种程序结构：顺序结构、选择结构(if和switch分支结构)、循环结构；</p><p>1）顺序结构</p><p>从头到尾一句接着一句的执行下去，直到执行完最后一句；</p><p>2）选择结构</p><p>执行到某个节点时，根据判断条件的结果来决定执行分支的方向，由if和switch实现。</p><p>3）循环结构</p><p>循环结构有一个循环体，循环体里是一段代码。对于循环结构来说，判断循环的条件，来决定是否继续执行循环体，由while、do while和for来实现。</p><h1 id="二-while循环"><a class="markdownIt-Anchor" href="#二-while循环"></a> 二、while循环</h1><p>while循环的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是，先计算<strong>表达式</strong>的值，当值为真时（非0即是真），执行<strong>语句块</strong>，执行完<strong>语句块</strong>后，回到循环首部再次计算<strong>表达式</strong>的值，如果为真，又执行一次<strong>语句块</strong>……，这个过程会一直重复，直到<strong>表达式</strong>的值为假，就不再执行<strong>语句块</strong>。</p><p>循环也常常出现在我们的生活中，以超女选秀为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超女已准备出场</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (是否有未出场的超女)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 判断超女的年龄</span></span><br><span class="line">  <span class="comment">// 判断超女的身材</span></span><br><span class="line">  <span class="comment">// 判断超女的颜值</span></span><br><span class="line">  <span class="comment">// 送往后宫</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超女选秀就是一个循环，<strong>是否有未出场的超女</strong>是循环首部要判断的条件，它的取值会随着循环次数的增加而改变，<strong>判断超女的年龄、判断超女的身材、判断超女的颜值、送往后宫</strong>是循环体，随着循环次数的增加，全部的超女已出场，循环体不再执行。</p><h1 id="三-do-while循环"><a class="markdownIt-Anchor" href="#三-do-while循环"></a> 三、do while循环</h1><p>do while循环的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;  <span class="keyword">while</span> (表达式)</span><br></pre></td></tr></table></figure><p>do while先执行一次循环，然后再判断表达式的值，如果为真，再执行一次循环体，如此重复下去。</p><p>在实际开发中，几乎不用 do while，所以就不讲它了。</p><h1 id="四-循环的跳转"><a class="markdownIt-Anchor" href="#四-循环的跳转"></a> 四、循环的跳转</h1><p>continue和break两个关键字用在循环体中，用于控制循环体代码的执行流程。</p><p>continue跳转到循环的首部。</p><p>break跳出循环。</p><p>以超女选秀为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超女已准备出场</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (是否有未出场的超女)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 判断超女的年龄</span></span><br><span class="line">  <span class="keyword">if</span> (年龄小于<span class="number">16</span>岁) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">// 判断超女的身材</span></span><br><span class="line">  <span class="keyword">if</span> (身材不火辣) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">// 判断超女的颜值</span></span><br><span class="line">  <span class="keyword">if</span> (颜值不漂亮) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">// 判断已选出的超女数量，如果已经有10位了，就不要再选了</span></span><br><span class="line">  <span class="keyword">if</span> (已选出的超女数量等于<span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送往后宫</span></span><br></pre></td></tr></table></figure><p>超女出场后，先看看身份证上的年龄，如果不够16岁，没到法定年龄，评委就会说直接下一个，即continue，这个不够16岁的小姑娘直接回家。</p><p>如果本次选秀的任务是选出10位超女，如果选出的超女已经有10位了，活动结束，即break，没选上的和没出场的直接回家。</p><h1 id="五-while循环的应用"><a class="markdownIt-Anchor" href="#五-while循环的应用"></a> 五、while循环的应用</h1><p>利用一个循环，把用户每次从键盘输入的数据累加起来，如果总和超过了5000，循环结束。</p><p><strong>示例（book31.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book31.c，此程序用于演示while循环 </span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> times=<span class="number">0</span>;   <span class="comment">// 记录用户输入数据的次数</span></span><br><span class="line">  <span class="type">int</span> value=<span class="number">0</span>;   <span class="comment">// 用户每次从键盘输入的数据</span></span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;     <span class="comment">// 记录用户输入数据的和</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (sum&lt;<span class="number">5000</span>)  <span class="comment">// 如果sum的值小于5000，进入循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;value);        <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">    times++;                   <span class="comment">// 用户输入数据的次数自增1</span></span><br><span class="line">    sum=sum+value;             <span class="comment">// 记录用户输入数据的和</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;您一共输入了%d个数据，和为%d。\n&quot;</span>,times,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303145623106.png" alt="在这里插入图片描述" /></p><h1 id="六-for循环"><a class="markdownIt-Anchor" href="#六-for循环"></a> 六、for循环</h1><p>for循环的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>;表达式;语句<span class="number">2</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>1）for循环开始时，会先执行<strong>语句1</strong>，而且在整个循环过程中只执行一次<strong>语句1</strong>。</p><p>2）接着判断<strong>表达式</strong>的条件，如果条件成立，就执行一次循环体中的<strong>语句块</strong>。</p><p>3）<strong>语句块</strong>执行完后，接下来会执行<strong>语句2</strong>。</p><p>4）重复第2）步和第3），直到<strong>表达式</strong>的条件不成立才结束for循环。</p><p>注意：</p><p>1）在for循环中，<strong>语句1</strong>、<strong>表达式</strong>和<strong>语句2</strong>都可以为空，for (;;)等同于while (1)。</p><p>2）continue和break两个关键字也可以用在for循环体中。</p><p>for循环一般与计数器一起使用。例如：把1到100之间的数值累加起来。</p><p><strong>示例（book33.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book33.c，此程序用于演示for循环</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">1</span>;      <span class="comment">// 用于for循环的计数器</span></span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;     <span class="comment">// 记录1到100的累积值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">1</span>;ii&lt;=<span class="number">100</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum=sum+ii;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1到100的累积值为%d。\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303145839138.png" alt="在这里插入图片描述" /></p><h1 id="七-for循环嵌套"><a class="markdownIt-Anchor" href="#七-for循环嵌套"></a> 七、for循环嵌套</h1><p>我们再来看超女选秀例子，超女共分为3组，每组有4位超女，主持人利用for循环嵌套来安排超女们出场。</p><p><strong>示例（book35.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book35.c，此程序用于演示for循环的嵌套</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;         <span class="comment">// 超女分组编号的计数器</span></span><br><span class="line">  <span class="type">int</span> jj=<span class="number">0</span>;         <span class="comment">// 每组超女序号的计数器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">1</span>;ii&lt;=<span class="number">3</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (jj=<span class="number">1</span>;jj&lt;=<span class="number">4</span>;jj++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;第%d组的第%d位超女出场。\n&quot;</span>,ii,jj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303145956691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="八-循环的选择"><a class="markdownIt-Anchor" href="#八-循环的选择"></a> 八、循环的选择</h1><p>for循环可以实现while循环的功能，while循环也可以实现for循环的功能，没有那个更好的说法，要看应用场景。</p><p><strong>for循环更合适事先知道循环总次数的场景，一般与计数器或数组结合一起使用，数组的知识我们在后面介绍。</strong></p><p><strong>while循环更合适事先不知道循环总次数的场景，以达到某个目标为目，例如超女选秀，报名有多少人没关系，已选够10位或没人可选是循环的结束。</strong></p><h1 id="九-死循环"><a class="markdownIt-Anchor" href="#九-死循环"></a> 九、死循环</h1><p>死循环是指循环的条件永远为真。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现死循环的情况有两种：1）程序的逻辑错误；2）程序员故意为之。第一种情况就不说了，程序员自己去解决，第二种是程序功能的需要，但是程序员仍有其它的办法让程序中止，这么说可能难以理解，没关系，在以后的课程中将会介绍。</p><p>如果您的程序不小心进入了死循环，可以用Ctrl+c中止。</p><h1 id="十-应用技巧"><a class="markdownIt-Anchor" href="#十-应用技巧"></a> 十、应用技巧</h1><p>1）for循环的计数器，习惯的写法是for (ii=0;ii&lt;=10;ii++)，表示从0、1……到10，从小到大的方式计数，但是在某些应用场景中，可能需要从大到小的方式计数，for (ii=10;ii&gt;=0;ii–)，也是可以的。</p><p>2）for循环的计数器，习惯的写法是for (ii=0;ii&lt;=10;ii++)，表示从0、1……到10，从小到大一次增加1的方式，但是在某些应用场景中，计数器不一定是增加ii++，ii=ii+2也是可以的。</p><h1 id="十一-课后作业"><a class="markdownIt-Anchor" href="#十一-课后作业"></a> 十一、课后作业</h1><p>1）采用一个while循环，把1到100之间的数值累加起来，实现book33.c程序的功能。</p><p>2）采用一个for循环，把用户每次从键盘输入的数值累加起来，如果总和超过了5000，循环结束，实现book31.c程序的功能。</p><p>3）采用您认为更合适的循环，输出九九乘法表，如下：<br /><img src="https://img-blog.csdnimg.cn/20200314094948289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />4）采用一个while循环，接受键盘输入的整数，如果输入的整数大于100，丢弃；如果输入的整数小于等100，把每次输入值累加起来，如果输入的整数值为0，跳出循环。最后显示输入了的有效的数据（大于0小于等于100的数）的个数，并显示有效数据的总和。</p><p>5）采用一个循环，输出0到100之间的偶数。</p><p>6）采用一个循环，输出0到100之间的能整除5的数字。</p><p>7）一共有5名超女，采用一个循环，在界面上输入超女数据，按下列要求选出妃子、宫女和杂役。循环结束后，显示选秀结果（妃子、宫女、杂役的人数）。</p><p>妃子：（1）年龄18-25岁；（2）身高165-178cm；（3）身材火辣；（4）颜值漂亮。</p><p>宫女：（1）年龄18-30岁；（2）身高160-165cm；（3）身材火辣或者普通；（4）颜值一般。</p><p>嬷嬷：（1）年龄35-40岁；（2）身高155-165cm；（3）身材普通或者飞机场；（4）颜值一般。</p><h1 id="十二-版权声明"><a class="markdownIt-Anchor" href="#十二-版权声明"></a> 十二、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言switch分支结构</title>
      <link href="/post/d98a7bd.html"/>
      <url>/post/d98a7bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-if-else的不足"><a class="markdownIt-Anchor" href="#一-if-else的不足"></a> 一、if else的不足</h1><p>C语言虽然没有限制 if else 能够处理的分支数量，但当分支过多时，用 if else处理会不太方便，而且容易出现 if else配对出错的情况。例如，输入一个整数，输出该整数对应的星期几的中文表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">2</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">3</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">4</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">5</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">6</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码摘自book22.c。</p><p>对于这种情况，实际开发中一般使用 switch 语句代替，请看下面的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不解释这段代码的含义，但这样看起来舒服多了。</p><h1 id="二-switch语句"><a class="markdownIt-Anchor" href="#二-switch语句"></a> 二、switch语句</h1><p>switch 是另外一种选择结构的语句，用来代替简单的、拥有多个分枝的 if else语句，基本格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 整型数值<span class="number">1</span>: 语句 <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> 整型数值<span class="number">2</span>: 语句 <span class="number">2</span>;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">case</span> 整型数值n: 语句 n;</span><br><span class="line">  <span class="keyword">default</span>: 语句 n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的执行过程是：</p><p>1）首先计算<strong>表达式</strong>的值，假设为<strong>value</strong>。</p><p>2） 从第一个 case 开始，比较<strong>value</strong>和<strong>整型数值1</strong>，如果它们相等，就执行冒号后面的所有语句，也就是从<strong>语句1</strong>一直执行到语句<strong>n+1</strong>，而不管后面的case 是否匹配成功。</p><p>3） 如果<strong>value</strong> 和<strong>整型数值1</strong>不相等，就跳过冒号后面的<strong>语句1</strong>，继续比较第二个case、第三个case……一旦发现和某个整型数值相等了，就会执行后面所有的语句。假设<strong>value</strong>和<strong>整型数值5</strong>相等，那么就会从<strong>语句5</strong>一直执行到<strong>语句n+1</strong>。</p><p>4）如果直到最后一个整型数值n都没有找到相等的值，那么就执行 default 后的<strong>语句n+1</strong>。</p><p>需要重点强调的是，当和某个整型数值匹配成功后，会执行该分支以及后面所有分支的语句。</p><p><strong>示例（book29.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book29.c，此程序演示条件分支控制语句用switch代替多个if else </span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    day=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量用于接受键盘输入的数字</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入0-6之间的数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (day)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303143655613.png" alt="在这里插入图片描述" /></p><p>输入4，发现和第四个分支匹配成功，于是就执行第四个分支以及后面的所有分支。这显然不是我们想要的结果，我们希望只执行第四个分支，而跳过后面的其他分支。为了达到这个目标，必须要在每个分支最后添加break;语句。</p><p>break 是C语言中的一个关键字，专门用于跳出 switch 语句。所谓“跳出”，是指一旦遇到break，就不再执行switch中的任何语句，包括当前分支中的语句和其他分支中的语句；也就是说，整个switch执行结束了，接着会执行整个 switch 后面的代码。</p><p><strong>示例（book30.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book30.c，此程序演示条件分支控制语句用switch中break的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    day=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量用于接受键盘输入的数字</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入0-6之间的数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (day)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303143742801.png" alt="在这里插入图片描述" /></p><h1 id="三-注意事项"><a class="markdownIt-Anchor" href="#三-注意事项"></a> 三、注意事项</h1><ol><li>case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能包含任何变量。请看下面的例子。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (result)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:      <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>+<span class="number">9</span>:     <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，表达式8+9==17是整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:     <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，字符可以转换为整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:     <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，字符可以转换为整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>:  <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，字符可以转换为整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3.14</span>:    <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 错误，不能为小数</span></span><br><span class="line">  <span class="keyword">case</span> ii:      <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 错误，不能采用变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>default 不是必须的。当没有 default 时，如果所有case都匹配失败，那么就什么都不执行。</li></ol><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>编写示例程序，在界面上输入数字的月份（1-12），采用switch语句，输出对应月份的英文单词的简写和全称。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言if分支结构</title>
      <link href="/post/f33ab266.html"/>
      <url>/post/f33ab266.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-关系运算符"><a class="markdownIt-Anchor" href="#一-关系运算符"></a> 一、关系运算符</h1><p>在讲if条件分支结构之前，先了解关系运算（Relational<br />Operators），用于判断条件，决定程序的流程。</p><table><thead><tr><th>关系</th><th>数学中的表示</th><th>C语言的表示</th></tr></thead><tbody><tr><td>小于</td><td>&lt;</td><td>&lt;</td></tr><tr><td>小于等于</td><td>≤</td><td>&lt;=</td></tr><tr><td>大于</td><td>&gt;</td><td>&gt;</td></tr><tr><td>大于等于</td><td>≥</td><td>&gt;=</td></tr><tr><td>等于</td><td>=</td><td>==</td></tr><tr><td>不等于</td><td>≠</td><td>!=</td></tr></tbody></table><p>C语言的基本数据类型有char、int、double，我们暂时认为只有char和int适用于上述关系运算符，double和字符串（字符数组）的关系运算以后再讨论。</p><p>注意了：</p><p>1）“=”是赋值，“==”才是判断两个数是否相等，不能混用。</p><p>2）C语言没有“之间”、“中间”、“之内”或“在某范围内”的关系运算符，例如年龄在25-30岁之间，只能表达为：<strong>年龄大于等于25岁</strong> 并且 <strong>年龄小于等于30岁</strong>。</p><h1 id="二-条件判断"><a class="markdownIt-Anchor" href="#二-条件判断"></a> 二、条件判断</h1><p>在我们的生活中，不是全部的事情都按顺序进行的，需要根据客观条件做出判断和选择，例如超女选秀，限制了16岁才能参加，16岁以下是不能参加的。这时候程序就需要做出判断，判断报名者的年龄是否满16岁，并给出提示。</p><p>在C语言中，使用if和else关键字对条件进行判断，先看下面的代码。</p><p><strong>示例（book20.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book20.c，此程序演示条件分支控制语句if else的使用。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    age=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量age，存放用户输入的年龄</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入您的年龄：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;age);              <span class="comment">// 接受从键盘输入的年龄数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">16</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果用户已满18岁，执行这段代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;亲，您已成年，可以报名超女选秀，祝您好运！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果用户小于16岁，执行这段代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这位童鞋，不好意思哦，等您16岁之后再来吧！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303120324443.png" alt="在这里插入图片描述" /></p><p>这段代码中，age&gt;=18是需要判断的条件，&gt;=表示“大于等于”，等价于数学中的≥。</p><p>if 和 else 是C语言的关键字，if就是“如果”，else就是“否则”，用来对条件进行判断，并根据判断结果执行不同的语句。总结起来，if else的结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件)</span><br><span class="line">&#123;</span><br><span class="line">  语句块<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是，如果判断条件成立，那么执行语句块1，否则执行语句块2。其执行过程可表示为下图：</p><p><img src="https://img-blog.csdnimg.cn/20200303120409313.png" alt="在这里插入图片描述" /><br />所谓语句块（Statement Block），就是由{}包围的一个或多个语句的集合。如果语句块中只有一条语句，也可以省略{ }，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">16</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;亲，您已成年，可以报名超女选秀，祝您好运！\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;这位童鞋，不好意思哦，等您16岁之后再来吧！\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">16</span>)  <span class="built_in">printf</span>(<span class="string">&quot;亲，您已成年，可以报名超女选秀，祝您好运！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;这位童鞋，不好意思哦，等您16岁之后再来吧！\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于if else语句可以根据不同的情况执行不同的代码，所以也叫分支结构或选择结构，上面的代码中，就有两个分支。</p><p>注意，不要在if (判断条件)后面加分号，以下是错误的，初学者容易犯这种错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>如果这么写，表示条件成立后，执行一条空语句。</p><h1 id="三-只使用if语句"><a class="markdownIt-Anchor" href="#三-只使用if语句"></a> 三、只使用if语句</h1><p>有的时候，我们需要在满足某种条件时进行一些操作，而不满足条件时就不进行任何操作，这个时候我们可以只使用if 语句。也就是说，if else 不必同时出现。</p><p>单独使用 if 语句的形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件)</span><br><span class="line">  &#123;</span><br><span class="line">    语句块</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>意思是，如果判断条件成立就执行语句块，否则直接跳过。其执行过程可表示为下图：</p><p><img src="https://img-blog.csdnimg.cn/20200303120735211.png" alt="在这里插入图片描述" /></p><p>例如超女选秀，被淘汰的超女，活动组织方给被淘汰的超女发放路费，标准是2000元/人，但是，节目的赞助方有个富二代，决定给颜值漂亮的超女多发500元。</p><p><strong>示例（book21.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book21.c，此程序演示条件分支控制语句只有if没有else的情况。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    yz=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量存放超女的颜值：1-漂亮；2-一般</span></span><br><span class="line">  <span class="type">int</span>    money=<span class="number">2000</span>;  <span class="comment">// 发放路费的基本金额</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请问超女的颜值（1-漂亮；2-一般）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;yz);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (yz == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果超女颜值漂亮，多给500元的路费</span></span><br><span class="line">    money=money+<span class="number">500</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此超女发放金额为%d元。\n&quot;</span>,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303120856862.png" alt="在这里插入图片描述" /></p><h1 id="四-多个if-else语句"><a class="markdownIt-Anchor" href="#四-多个if-else语句"></a> 四、多个if else语句</h1><p>if else 语句也可以多个同时使用，构成多个分支，形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式一)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块一</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式二)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块二</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式三)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块三</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式n)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   全部的条件都不符时执行此语句块x</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>意思是，从上到下依次检测判断条件，当某个判断条件成立时，则执行其对应的语句块，然后跳出整个if else 语句之外继续执行其他代码。如果所有判断条件都不成立，则执行语句块x。</p><p>也就是说，一旦遇到能够成立的判断条件，则不再执行其他的语句块，所以最终只能有一个语句块被执行。</p><p>例如，使用多个 if else 语句判断输入的数字表达的星期数。</p><p><strong>示例（book22.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book22.c，此程序演示条件分支控制语句有多个 if else的情况。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    day=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量用于接受键盘输入的数字</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入0-6之间的数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line">  <span class="keyword">if</span> (day == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030312113742.png" alt="在这里插入图片描述" /></p><p>建议大家慎用 else if这种程序结构，因为这种程序结构容易把人搞晕，解决这类需求有其它更好的方法，例如后面章节中将要学习的switch比else if 更合适。</p><h1 id="五-if语句的嵌套"><a class="markdownIt-Anchor" href="#五-if语句的嵌套"></a> 五、if语句的嵌套</h1><p>if语句也可以嵌套使用，例如：</p><p><strong>示例（book23.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book23.c，此程序演示条件分支控制语句有多个if嵌套的情况。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b;   <span class="comment">// 定义两个整数变量，用于比较大小</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入两个数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a == b)      <span class="comment">// 两个数相等的情况</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a(%d) 等于 (%d)\n&quot;</span>,a,b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>             <span class="comment">// 两个数不相等的情况</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)     <span class="comment">// a大于b的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a(%d) 大于 b(%d)\n&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">// 剩下的就是a小于b的情况了</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a(%d) 小于 b(%d)\n&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303121300645.png" alt="在这里插入图片描述" /></p><h1 id="六-保持良好的编程习惯"><a class="markdownIt-Anchor" href="#六-保持良好的编程习惯"></a> 六、保持良好的编程习惯</h1><p>if 语句嵌套时，要注意 if 和 else 的配对问题，C语言规定，else 总是与它前面最近的if配对。各位一定要保持良好的编程习惯，空格、缩进、对齐，{}成对的书写等，不良的代码习惯会把自己搞晕。</p><h1 id="七-逻辑运算符"><a class="markdownIt-Anchor" href="#七-逻辑运算符"></a> 七、逻辑运算符</h1><p>在日常生活中，要做出某个决定，需要判断的条件往往不止一个，需要判断多个条件，例如超女选秀，参与选秀的女孩子有以下基本数据：</p><p>年龄：取值16-50岁。<br />身高：取值150cm-190cm。<br />身材：1-火辣；2-普通；3-飞机场。<br />颜值：1-漂亮；2-一般；3-歪瓜裂枣。</p><p>女神标准是：1）年龄25-30岁；2）身高165cm-175cm；3）身材火辣；4）颜值漂亮。</p><p>大脑中的逻辑是这样的：<strong>年龄25-30岁</strong> 并且 <strong>身高165cm-175cm</strong> 并且 <strong>身材火辣</strong> 并且 <strong>颜值漂亮</strong>。</p><p>降低点要求吧，颜值可以选<strong>漂亮</strong>和<strong>一般</strong>，如果是<strong>一般</strong>，整整容也不是个问题。</p><p>于是逻辑修改为：<strong>年龄25-30岁</strong> 并且 身高1<strong>65cm-175cm</strong> 并且 <strong>身材火辣</strong>并且（<strong>颜值漂亮</strong> 或者 <strong>颜值一般</strong>）。</p><p>用C程序来表达大概如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (年龄 &gt;= <span class="number">25</span>) 并且 (年龄 &lt;= <span class="number">30</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (身高 &gt;= <span class="number">165</span>) 并且 (身高 &lt;= <span class="number">175</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (身材 == 火辣)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (颜值 == 漂亮) 或者 (颜值 == 一般) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言用“&amp;&amp;”表示“并且”，用“||”表示“或者”，官方用语就是逻辑运算符。</p><p>代码修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (年龄 &gt;= <span class="number">25</span>) &amp;&amp; (年龄 &lt;= <span class="number">30</span>) )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( (身高 &gt;= <span class="number">165</span>) &amp;&amp; (身高 &lt;= <span class="number">175</span>) )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (身材 == 火辣)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span> ( (颜值 == 漂亮) || (颜值 == 一般) )</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>示例（book25.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book25.c，此程序演示条件分支控制语句if与逻辑运算符。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>  age=<span class="number">0</span>;        <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height=<span class="number">0</span>;     <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">int</span>  sc=<span class="number">0</span>;         <span class="comment">// 身材，1-火辣；2-普通；3-飞机场。</span></span><br><span class="line">  <span class="type">int</span>  yz=<span class="number">0</span>;         <span class="comment">// 颜值，1-漂亮；2-一般；3-歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄、身高、身材（1-火辣；2-普通；3-飞机场）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;age,&amp;height,&amp;sc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入颜值（1-漂亮；2-一般；3-歪瓜裂枣）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;yz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (age &gt;= <span class="number">25</span>) &amp;&amp; (age &lt;= <span class="number">30</span>) )    <span class="comment">// 年龄在25-30之间</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (height &gt;= <span class="number">165</span>) &amp;&amp; (height &lt;= <span class="number">175</span>) )  <span class="comment">// 身高在165-175之间</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (sc == <span class="number">1</span>)    <span class="comment">// 身材，1-火辣</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (yz == <span class="number">1</span>) || (yz == <span class="number">2</span>) )   <span class="comment">// 颜值，1-漂亮或者2-一般</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;超女选秀不合格，发放五两银子后送回家。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200303121555380.png" alt="在这里插入图片描述" /></p><h1 id="八-逻辑表达式的书写"><a class="markdownIt-Anchor" href="#八-逻辑表达式的书写"></a> 八、逻辑表达式的书写</h1><p>在book25.c中，采用了if嵌套的方法，其实可以采用一个复杂的if逻辑表达式一次性完成全部的判断，采用括号、对齐、空格、换行有助于更清晰的表达复杂的逻辑表达式。</p><p><strong>示例（book26.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book26.c，此程序演示条件分支控制语句if与逻辑运算符。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>  age=<span class="number">0</span>;        <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height=<span class="number">0</span>;     <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">int</span>  sc=<span class="number">0</span>;         <span class="comment">// 身材，1-火辣；2-普通；3-飞机场。</span></span><br><span class="line">  <span class="type">int</span>  yz=<span class="number">0</span>;         <span class="comment">// 颜值，1-漂亮；2-一般；3-歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄、身高、身材（1-火辣；2-普通；3-飞机场）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;age,&amp;height,&amp;sc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入颜值（1-漂亮；2-一般；3-歪瓜裂枣）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;yz);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( ( (age &gt;= <span class="number">25</span>) &amp;&amp; (age &lt;= <span class="number">30</span>)         ) &amp;&amp;     <span class="comment">// 年龄在25-30之间</span></span><br><span class="line">       ( (height &gt;= <span class="number">165</span>) &amp;&amp; (height &lt;= <span class="number">175</span>) ) &amp;&amp;     <span class="comment">// 身高在165-175之间</span></span><br><span class="line">       ( (sc == <span class="number">1</span>)                          ) &amp;&amp;     <span class="comment">// 身材，1-火辣</span></span><br><span class="line">       ( (yz == <span class="number">1</span>) || (yz == <span class="number">2</span>)             ) )      <span class="comment">// 颜值，1-漂亮或者2-一般</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女选秀不合格，发放五两银子后送回家。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>book26.c采用一个if表达式就实现了全部逻辑的判断功能，效果与book25.c相同，如果实在理解不了，就采用book25.c中的表达方式吧，不急，慢慢来。</p><h1 id="九-不得不说的逻辑非"><a class="markdownIt-Anchor" href="#九-不得不说的逻辑非"></a> 九、不得不说的逻辑非</h1><p>逻辑运算符有三种，在上述的章节中，我们讲了&amp;&amp;和||，还有一个!没讲，在我看来，这个运算符就不应该存在，它很容易搞乱人的思维。</p><p>大家可以先看看它是怎么回事，也可以写代码测试一下它的用法，然后就忘了它。</p><p>!就是非，取相反的意思。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  (age==<span class="number">25</span>)         <span class="comment">// 判断年龄是25岁</span></span><br></pre></td></tr></table></figure><p>等同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  (!(age!=<span class="number">25</span>))        <span class="comment">// 判断年龄不是25岁再取反</span></span><br></pre></td></tr></table></figure><p>这是吃饱了撑着。</p><h1 id="十-三目运算符"><a class="markdownIt-Anchor" href="#十-三目运算符"></a> 十、三目运算符</h1><p>三目运算符本来是运算符章节中的内容，我认为在本章节介绍更合适。</p><p>三目运算符也叫三元运算符，这个运算符的符号是由一个问号和一个冒号组成。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>语义：</p><p>先执行表达式1，如果表达式1的结果如果为真，那么执行表达式2，并且这个整体的运算式的结果是表达式2的结果；如果表达式1的结果如果为假，执行表达式3，运算式的结果是表达式3的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">a=<span class="number">7</span>;</span><br><span class="line">b=<span class="number">6</span>;</span><br><span class="line">c=(a&gt;b)?a:b;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b) c=a;</span><br><span class="line"><span class="keyword">else</span> c=b;</span><br></pre></td></tr></table></figure><p>我不建议采用三目运算符，过于复杂的三目运算难以理解。</p><p>比如判断year是不是闰年，是则返回1，不是返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year=(year%<span class="number">100</span>==<span class="number">0</span>)?(year%<span class="number">400</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>):(year%<span class="number">4</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>晕了吧。</p><h1 id="十一-课后作业"><a class="markdownIt-Anchor" href="#十一-课后作业"></a> 十一、课后作业</h1><p>1）指出以下代码的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a=<span class="number">30</span>;</span><br><span class="line">b=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a 大于 b\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a=b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a 等于 b\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）写程序测试表达式的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"></span><br><span class="line">a=<span class="number">30</span>;</span><br><span class="line">b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">c=(a &gt; b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,c);</span><br><span class="line"></span><br><span class="line">c=(a &lt; b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,(a &lt; b));</span><br><span class="line"></span><br><span class="line">c=(a=<span class="number">50</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,c);</span><br></pre></td></tr></table></figure><p>3）以下表达是什么意思？</p><p>if (0) 是什么意思？</p><p>if (1) 是什么意思？</p><p>if (20) 是什么意思？</p><p>4）以下表达是什么意思？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">35</span>;    <span class="comment">// 是什么意思？</span></span><br></pre></td></tr></table></figure><p>5）将超女选秀进行到底，在界面上输入超女数据后，按下列要求选出妃子、宫女和杂役。</p><p>妃子：（1）年龄18-25岁；（2）身高165-178cm；（3）身材火辣；（4）颜值漂亮。</p><p>宫女：（1）年龄18-30岁；（2）身高160-165cm；（3）身材火辣或者普通；（4）颜值一般。</p><p>嬷嬷：（1）年龄35-40岁；（2）身高155-165cm；（3）身材普通或者飞机场；（4）颜值一般。</p><h1 id="十二-版权声明"><a class="markdownIt-Anchor" href="#十二-版权声明"></a> 十二、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符</title>
      <link href="/post/933f0bc1.html"/>
      <url>/post/933f0bc1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-c语言的运算符"><a class="markdownIt-Anchor" href="#一-c语言的运算符"></a> 一、C语言的运算符</h1><p>C语言有六种运算符，如下：</p><p>1）算术运算符；</p><p>2）赋值运算符；</p><p>3）sizeof运算符；</p><p>4）关系运算符；</p><p>5）逻辑运算符；</p><p>6）位运算符。</p><p>本章将只介绍算术运算符、赋值运算符和sizeof运算符，关系运算符和逻辑运算符放在其它章节中介绍，位运算符极少使用，了解即可，不深入学习。</p><h1 id="二-算术运算符"><a class="markdownIt-Anchor" href="#二-算术运算符"></a> 二、算术运算符</h1><p>下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 18，变量 B 的值为5，则：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td><strong>+</strong></td><td>两个数相加</td><td>A+B 将得到 23</td></tr><tr><td><strong>-</strong></td><td>一个数减另一个数</td><td>A-B 将得到 13</td></tr><tr><td><strong>*</strong></td><td>两个数相乘</td><td>A*B 将得到 90</td></tr><tr><td><strong>/</strong></td><td>分子除以分母</td><td>A/B 将得到 3.6</td></tr><tr><td><strong>%</strong></td><td>余数运算符，整除后的余数</td><td>B%A 将得到 3</td></tr><tr><td><strong>++</strong></td><td>自增运算符，整数值增加 1</td><td>A++ 将得到 19</td></tr><tr><td><strong>–</strong></td><td>自减运算符，整数值减少 1</td><td>A-- 将得到 17</td></tr></tbody></table><p><strong>示例（book15.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book15.c，此程序演示算术运算符的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span>    A=<span class="number">18</span>;      <span class="comment">// 定义变量A，赋值18</span></span><br><span class="line">  <span class="type">double</span>    B=<span class="number">5</span>;       <span class="comment">// 定义变量B，赋值5</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A的值是：%lf\n&quot;</span>,A);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;B的值是：%lf\n&quot;</span>,B);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A+B的值是：%lf\n&quot;</span>,A+B);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A-B的值是：%lf\n&quot;</span>,A-B);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A*B的值是：%lf\n&quot;</span>,A*B);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A/B的值是：%lf\n&quot;</span>,A/B);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//printf(&quot;A除B的余数是：%lf\n&quot;,A%B);</span></span><br><span class="line"></span><br><span class="line">  A++;  <span class="comment">// 自增1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A自增后的值是：%lf\n&quot;</span>,A);</span><br><span class="line"></span><br><span class="line">  B--;  <span class="comment">// 自减1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;B自减后的值是：%lf\n&quot;</span>,B);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303114816363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />变量的自增或自减有两种写法：</p><p>变量名++； // 表示在本次使用变量后再自增；</p><p>++变量名; // 表示在本次使用变量前自增；</p><p>变量名–； // 表示在本次使用变量后再自增；</p><p>--变量名; // 表示在本次使用变量前自减；</p><p><strong>示例（book16.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book16.c，此程序演示算术运算符++和--的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">0</span>;      <span class="comment">// 定义变量ii并初始化</span></span><br><span class="line"></span><br><span class="line">  ii=<span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii++的值是：%d\n&quot;</span>,ii++);  <span class="comment">// 在使用后自增</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii的值是：%d\n&quot;</span>,ii);</span><br><span class="line"></span><br><span class="line">  ii=<span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;++ii的值是：%d\n&quot;</span>,++ii);  <span class="comment">// 在使用前自增</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii的值是：%d\n&quot;</span>,ii);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303114921749.png" alt="在这里插入图片描述" /></p><h1 id="三-赋值运算符"><a class="markdownIt-Anchor" href="#三-赋值运算符"></a> 三、赋值运算符</h1><p>下表列出了 C 语言支持的赋值运算符：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td><strong>=</strong></td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td><strong>+=</strong></td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr><tr><td><strong>-=</strong></td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr><tr><td><strong>*=</strong></td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C *= A 相当于 C = C * A</td></tr><tr><td><strong>/=</strong></td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr><tr><td><strong>%=</strong></td><td>求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。</td><td>C %= A 相当于 C = C % A</td></tr></tbody></table><p>赋值运算符支持的是C语言的基本数据类型，包括char、int和double，字符串（字符数组）不能使用赋值运算符。</p><p><strong>示例（book17.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book17.c，此程序演示赋值运算符的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    C=<span class="number">0</span>;     <span class="comment">// 定义变量C并初始化</span></span><br><span class="line">  <span class="type">int</span>    A=<span class="number">21</span>;    <span class="comment">// 定义变量A并初始化</span></span><br><span class="line"></span><br><span class="line">  C=A;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符  = 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C+=A;  <span class="comment">// C=C+A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 += 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C-=A;  <span class="comment">// C=C-A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 -= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C*=A;  <span class="comment">// C=C*A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 *= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C/=A;  <span class="comment">// C=C/A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 /= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C=<span class="number">200</span>;</span><br><span class="line">  C%=A;  <span class="comment">// C=C%A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 %= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303115042632.png" alt="在这里插入图片描述" /></p><h1 id="四-sizeof运算符"><a class="markdownIt-Anchor" href="#四-sizeof运算符"></a> 四、sizeof运算符</h1><p>sizeof是C语言的关键字，它用来计算变量（或数据类型）在当前系统中占用内存的字节数。</p><p>sizeof不是函数，产生这样的疑问是因为sizeof的书写确实有点像函数，sizeof有两种写法：</p><p><strong>用于数据类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(数据类型);</span><br></pre></td></tr></table></figure><p>数据类型必须用括号括住。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符型变量占用的内存是=%d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">char</span>));   <span class="comment">// 输出：字符型变量占用的内存是=1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;整型变量占用的内存是=%d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 输出：整型变量占用的内存是=4</span></span><br></pre></td></tr></table></figure><p><strong>用于变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(变量名);</span><br><span class="line"><span class="keyword">sizeof</span> 变量名;</span><br></pre></td></tr></table></figure><p>变量名可以不用括号括住，带括号的用法更普遍，大多数程序员采用这种形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii占用的内存是=%d\n&quot;</span>,<span class="built_in">sizeof</span>(ii));   <span class="comment">// 输出：ii占用的内存是=4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii占用的内存是=%d\n&quot;</span>,<span class="keyword">sizeof</span> ii);   <span class="comment">// 输出：ii占用的内存是=4</span></span><br></pre></td></tr></table></figure><h1 id="五-运算符的优先级"><a class="markdownIt-Anchor" href="#五-运算符的优先级"></a> 五、运算符的优先级</h1><p>在±*/四则运算符中，*/的优先级高于±，在C语言中，其它的运算符都有优先级，我不想介绍它们的优先级，我写了二十年的程序，也记不住各种运算符的优先级的关系。</p><p>我不建议程序员记住各种运算符的优先级，而是用括号解决全部的问题，括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = a + (b * c);</span><br></pre></td></tr></table></figure><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言输入和输出</title>
      <link href="/post/91c8d2d2.html"/>
      <url>/post/91c8d2d2.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-数据输入"><a class="markdownIt-Anchor" href="#一-数据输入"></a> 一、数据输入</h1><p>编写程序的主要目的就是为了处理数据。数据从哪里来？数据的来源有很多种方式，如从磁盘文件中读取数据、从数据库中读取数据、从网页中抓取数据等，还有一种原始的方式就是从键盘输入数据。</p><p>在C语言中，有三个函数可以从键盘获得用户输入。</p><p>getchar：输入单个字符，保存到字符变量中。</p><p>gets：输入一行数据，保存到字符串变量中。</p><p>scanf：格式化输入函数，一次可以输入多个数据，保存到多个变量中。</p><h1 id="二-数据输出"><a class="markdownIt-Anchor" href="#二-数据输出"></a> 二、数据输出</h1><p>在C语言中，有三个函数可以把数据输出到屏幕。</p><p>putchar：输出单个字符。</p><p>puts：输出字符串。</p><p>printf：格式化输出函数，可输出常量、变量等。</p><h1 id="三-断章取义"><a class="markdownIt-Anchor" href="#三-断章取义"></a> 三、断章取义</h1><p>三十年前，个人电脑还不流行的时候，软件主要用C语言编写，包括操作界面，数据的输入和输出函数都很重要。现在，数据的输入和展示由网页和APP等软件去完成，C程序主要用于数据处理和网络通信，程序运行在后台，没有操作界面。所以，getchar、gets、scanf这几个函数几乎不用。</p><p>各位是初学者，出于教学的需要，采用scanf从键盘输入数据，便于演示程序的功能，所以我们只需要学习scanf函数的简单用法即可，getchar和gets函数无需关注。</p><p>C语言的输入函数已不重要，但输出函数仍然非常重要。</p><p>putchar和puts函数没什么用，已经被淡忘，那就忘了吧。</p><p>printf函数非常重要，以后我们将深入学习，本章节只讨论它的简单用法。</p><p>现在，只剩下scanf和printf函数了。</p><h1 id="四-printf输出"><a class="markdownIt-Anchor" href="#四-printf输出"></a> 四、printf输出</h1><p>printf函数是格式化输出函数, 用于向屏幕输出数据。</p><p>printf函数的调用方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式化字符串,参数列表);</span><br></pre></td></tr></table></figure><h2 id="1-输出描述性的文字"><a class="markdownIt-Anchor" href="#1-输出描述性的文字"></a> 1、输出描述性的文字</h2><p>把输出的文字用双引号包含起来，文字中的\n表示换行，多个\n可以换多行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我心匪席，不可卷也，我心匪石，不可转也。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码将在屏幕上输出文字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我心匪席，不可卷也，我心匪石，不可转也。</span><br></pre></td></tr></table></figure><p>出输文字之后，再输出一个换行。</p><h2 id="2-输出整数"><a class="markdownIt-Anchor" href="#2-输出整数"></a> 2、输出整数</h2><p>输出整数型常量或变量用%d表示，在参数中列出待输出的整数常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我年龄是%d岁。\n&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我年龄是%d岁。\n&quot;</span>,age);</span><br></pre></td></tr></table></figure><h2 id="3-输出字符"><a class="markdownIt-Anchor" href="#3-输出字符"></a> 3、输出字符</h2><p>输出字符型常量或变量用%c表示，在参数中列出待输出的字符常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我姓别是：%c。\n&quot;</span>,<span class="string">&#x27;x&#x27;</span>);        <span class="comment">// 姓别：x-男；y-女</span></span><br><span class="line"><span class="type">char</span> xb=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我姓别是：%c。\n&quot;</span>,xb);</span><br></pre></td></tr></table></figure><h2 id="4-输出浮点数"><a class="markdownIt-Anchor" href="#4-输出浮点数"></a> 4、输出浮点数</h2><p>输出的浮点型常量或变量用%lf表示，在参数中列出待输出的浮点型常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我体重是%lf公斤。\n&quot;</span>,<span class="number">62.5</span>);</span><br><span class="line"><span class="type">double</span> weight=<span class="number">62.5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我体重是%lf公斤。\n&quot;</span>, weight);</span><br></pre></td></tr></table></figure><h2 id="5-输出字符串"><a class="markdownIt-Anchor" href="#5-输出字符串"></a> 5、输出字符串</h2><p>输出字符串常量或变量用%s表示，在参数中列出待输出的字符串常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的姓名是%s。\n&quot;</span>,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的姓名是%s。\n&quot;</span>,name);</span><br></pre></td></tr></table></figure><h2 id="6-输出多个内容"><a class="markdownIt-Anchor" href="#6-输出多个内容"></a> 6、输出多个内容</h2><p>调用一次printf函数可以输出多个常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line"><span class="type">char</span> xb=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">double</span> weight=<span class="number">62.5</span>;</span><br><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\n&quot;</span>,name,xb,age,weight);</span><br></pre></td></tr></table></figure><p>注意，printf函数第一个参数（格式化字符串）的格式与后面的参数列表（常量或变量的列表）要一一对应，一个萝卜一个坑的填进去，不能多，不能少，顺序也不能错，否则会产生意外的结果。</p><h2 id="7-示例book12c"><a class="markdownIt-Anchor" href="#7-示例book12c"></a> 7、示例（book12.c）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book12.c，此程序演示printf函数输出变量的内容</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line">  <span class="type">char</span> xb=<span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">  <span class="type">double</span> weight=<span class="number">45.5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line">  <span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%f公斤。\n&quot;</span>,name,xb,age,weight);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030310553992.png" alt="在这里插入图片描述" /></p><h1 id="五-scanf输入"><a class="markdownIt-Anchor" href="#五-scanf输入"></a> 五、scanf输入</h1><p>scanf函数是格式化输入函数，用于接受从键盘输入的数据，用户输入数据完成后，按回车键（Enter）结束输入。</p><p>scanf函数的调用方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(格式化字符串,参数列表);</span><br></pre></td></tr></table></figure><p>注意，不要在scanf的格式化字符串的最后加\n。</p><h2 id="1-输入整数"><a class="markdownIt-Anchor" href="#1-输入整数"></a> 1、输入整数</h2><p>输入整数的格式用%d表示，在参数中列出整数型变量名，用于保存输入的数据。</p><p>在输入数据之前，一般要先输出一句话提示用户。下同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您的年龄：&quot;</span>);   <span class="comment">// 提示文字不要换行，让用户在后面输入，下同。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;age);     <span class="comment">// 在变量名前要加符号&amp;，先不要问原因，以后再介绍。</span></span><br></pre></td></tr></table></figure><h2 id="2-输入字符"><a class="markdownIt-Anchor" href="#2-输入字符"></a> 2、输入字符</h2><p>输入字符的格式用%c表示，在参数中列出字符型变量名，用于保存输入的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> xb=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您姓别：&quot;</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;xb);     <span class="comment">// 在变量名前要加符号&amp;</span></span><br></pre></td></tr></table></figure><h2 id="3-输入浮点数"><a class="markdownIt-Anchor" href="#3-输入浮点数"></a> 3、输入浮点数</h2><p>输入浮点数的格式用%lf表示，在参数中列出浮点型变量名，用于保存输入的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> weight=<span class="number">62.5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您体重：&quot;</span>);  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;weight);     <span class="comment">// 在变量名前要加符号&amp;。</span></span><br></pre></td></tr></table></figure><h2 id="4-输入字符串"><a class="markdownIt-Anchor" href="#4-输入字符串"></a> 4、输入字符串</h2><p>输入字符串的格式用%s表示，在参数中列出字符串变量名，用于保存输入的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您姓名：&quot;</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);     <span class="comment">// 注意了，字符串变量名前可以不加符号&amp;，不要问原因，以后再介绍。</span></span><br></pre></td></tr></table></figure><h2 id="5-输入多个内容"><a class="markdownIt-Anchor" href="#5-输入多个内容"></a> 5、输入多个内容</h2><p>调用一次scanf函数可以输入多个数据，全部的数据输入完成后按回车键结束输入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> xb=<span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> weight=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %c %d %lf&quot;</span>,name,&amp;xb,&amp;age,&amp;weight);   <span class="comment">// 只有name变量前没加&amp;。</span></span><br></pre></td></tr></table></figure><p>scanf函数第一个参数（格式化字符串）的格式与后面的参数列表（变量的列表）要一一对应，一个萝卜一个坑的填进去，不能多，不能少，顺序也不能错，否则会产生意外的结果。</p><h2 id="6-示例book13c"><a class="markdownIt-Anchor" href="#6-示例book13c"></a> 6、示例（book13.c）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book13.c，此程序演示scanf函数输入数据。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> xb=<span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> weight=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s %c %d %lf&quot;</span>,name,&amp;xb,&amp;age,&amp;weight); <span class="comment">// 只有name变量前没加&amp;，其它的都加了。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;您的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\n&quot;</span>,name,xb,age,weight);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303110138950.png" alt="在这里插入图片描述" /></p><h1 id="六-注意事项"><a class="markdownIt-Anchor" href="#六-注意事项"></a> 六、注意事项</h1><p>1）本章节只学习scanf和printf函数最简单的用法。</p><p>2）scanf函数只是在C程序基本知识的学习中才用到，在实际开发中基本上不用。</p><p>3）printf不是一个函数，是一系列函数，功能强大，变化很多，应用广泛，极其重要，以后我们将深入的学习它。</p><p>4）scanf函数的变量列表，除了字符串，其它的变量前面都要加&amp;，表示取地址，如果不加，程序编译不会报错，但运行时会出现意想不到的后果（1-赋值不成功；2-段错误Core dump）。</p><p>5）printf函数的变量列表，变量名前都不需要加&amp;。</p><h1 id="七-课后作业"><a class="markdownIt-Anchor" href="#七-课后作业"></a> 七、课后作业</h1><p>编写示例程序，从键盘输入您喜欢的女（男）神的姓名、性别、年龄、身高（cm）、体重（kg）、和您最喜欢她的身体部位，把输入的数据存放在变量中，然后在屏幕上把变量的值显示出来。</p><p>要求：</p><p>1）姓名用字符串变量存放；</p><p>2）性别用一个字符变量存放（x-男，y-女）；</p><p>3）年龄和身高用整数变量存放；</p><p>4）体重用浮点型变量存放；</p><p>5）身体部位用字符串存放。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言常量、变量和关键字</title>
      <link href="/post/2e37bf79.html"/>
      <url>/post/2e37bf79.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-一切都是数据"><a class="markdownIt-Anchor" href="#一-一切都是数据"></a> 一、一切都是数据</h1><p>对计算机来说，图片、文字、音乐、视频等一切都是数据，在计算机中以二进制的0和1存储。</p><p>我们编写程序的目的就是告诉计算机如何输入、处理、传输、存储和展示数据。</p><p>数据分为静态数据和动态数据。</p><h2 id="1-静态数据"><a class="markdownIt-Anchor" href="#1-静态数据"></a> 1、静态数据</h2><p>永久性的数据，存储在永久的介质中，如硬盘、磁带、U盘、光盘等，只要介质没坏数据都是存在的，电脑关机重启后依然存在。</p><h2 id="2-动态数据临时数据"><a class="markdownIt-Anchor" href="#2-动态数据临时数据"></a> 2、动态数据（临时数据）</h2><p>程序在运行过程中，动态产生的的临时数据，一般存储在内存中，程序退出或者电脑关机时这些临时数据会被清除。</p><p>为什么不把动态数据存放到硬盘？因为计算机访问内存的速度比访问硬盘快很多。硬盘的存储空间比内存大，价格比内存便宜。</p><h1 id="二-常量"><a class="markdownIt-Anchor" href="#二-常量"></a> 二、常量</h1><p>常量或常数，表示固定不变的数据，是具体的数据。</p><p>1）字符常量，如’6’，‘a’，‘F’，不能是中文，例如’女’，因为一个汉字和全角的符号占两个字节（GBK编码）。</p><p>2）整型常量，如6，27，-299。</p><p>3）浮点型常量，如5.43，-2.3，5.67，6.0。</p><p>4）字符串常量，如&quot;625&quot;，“女”，“<a href="http://www.freecplus.net">www.freecplus.net</a>”，“西施”。</p><h1 id="三-变量"><a class="markdownIt-Anchor" href="#三-变量"></a> 三、变量</h1><p><strong>常量是数据，变量是存放数据的容器</strong>，和常量在称呼上只差一个字，但不是兄弟关系，而是水与水桶的关系。</p><p>变量使用前必须先进行声明（或定义），向操作系统申请一块内存空间，用于存放数据。</p><h2 id="1-整数型-字符型-浮点型变量"><a class="markdownIt-Anchor" href="#1-整数型-字符型-浮点型变量"></a> 1、整数型、字符型、浮点型变量</h2><p>变量的声明，也称之为变量的定义，或定义变量，或声明变量，这些都是程序员的习惯叫法，实际上都是同一个意思。</p><p>定义整数型变量用关键字int，它是单词integer（整数）的缩写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   ii;           <span class="comment">// 定义整数型变量，用于存放整数。</span></span><br></pre></td></tr></table></figure><p>定义字符型变量用关键字char，它是单词character（字符）的缩写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>  cc;          <span class="comment">// 定义字符型变量，用于存放字符。</span></span><br></pre></td></tr></table></figure><p>定义浮点型变量用关键字float或double，float的精度不够，实际开发中建议弃用。double，双精度，很精确的意思。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> money;   <span class="comment">// 定义浮点型变量，用于存放浮点数。</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串变量"><a class="markdownIt-Anchor" href="#2-字符串变量"></a> 2、字符串变量</h2><p>在C语言中，没有“字符串”这个数据类型，而是用字符数组来存放字符串，并提供了丰富的库函数来操作字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];       <span class="comment">// 定义一个可以存放20字符的字符串。</span></span><br></pre></td></tr></table></figure><p>注意几个细节：</p><p>1）如果要定义一个存放20个英文的字符串，数组的长度应该是20+1，原因以后再讨论。</p><p>2）中文的汉字和标点符号需要两个字符宽度来存放。</p><p>例如name[21]可以存放20个英文字符，或10个中文字符。</p><p>3）字符串不是C语言的基本数据类型，不能用“=”赋值，不能用“&gt;”和“&lt;”比较大小，不能用“+”拼接，不能用==和!=判断两个字符串是否相同，要用函数，具体方法我以后再介绍，现在了解就可以。</p><h2 id="3-变量的命名"><a class="markdownIt-Anchor" href="#3-变量的命名"></a> 3、变量的命名</h2><p>变量名属于标识符，需要符合标识符的命名规范，具体如下：</p><p>1）变量名的第一个字符必须是字母或下划线，不能是数字和其它字符。</p><p>2） 变量名中的字母是区分大小写的。比如 a 和 A 是不同的变量名，num和Num也是不同的变量名。</p><p>3）变量名绝对不可以是C语言的关键字。</p><p>4）关于变量的命名，为了便于理解，尽可能用英文单词或多个英文单词的简写，太短不能表达含义，太长了书写麻烦，如果英语不好，那就用中文拼英的第一个字母，例如身份证号码，cardid、userid都可以，sfzhm也行，不要怕被笑话，英语不好的程序员很多。</p><h1 id="四-c语言的关键字"><a class="markdownIt-Anchor" href="#四-c语言的关键字"></a> 四、C语言的关键字</h1><p>关键字也称为保留字，共32个，这些单词在C语言中有特别的含义，程序员不能把它用于变量或函数的命名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ：声明自动变量</span><br><span class="line"><span class="keyword">break</span>：跳出当前循环</span><br><span class="line"><span class="keyword">case</span>：开关语句分支</span><br><span class="line"><span class="type">char</span> ：声明字符型变量或函数返回值类型</span><br><span class="line"><span class="type">const</span> ：声明只读变量</span><br><span class="line"><span class="keyword">continue</span>：结束当前循环，开始下一轮循环</span><br><span class="line"><span class="keyword">default</span>：开关语句中的“默认”分支</span><br><span class="line"><span class="keyword">do</span> ：循环语句的循环体</span><br><span class="line"><span class="type">double</span> ：声明双精度浮点型变量或函数返回值类型</span><br><span class="line"><span class="keyword">else</span> ：条件语句否定分支（与 <span class="keyword">if</span> 连用）</span><br><span class="line"><span class="keyword">enum</span> ：声明枚举类型</span><br><span class="line"><span class="keyword">extern</span>：声明变量或函数是在其它文件或本文件的其他位置定义</span><br><span class="line"><span class="type">float</span>：声明浮点型变量或函数返回值类型</span><br><span class="line"><span class="keyword">for</span>：一种循环语句</span><br><span class="line"><span class="keyword">goto</span>：无条件跳转语句</span><br><span class="line"><span class="keyword">if</span>:条件语句</span><br><span class="line"><span class="type">int</span>： 声明整型变量或函数</span><br><span class="line"><span class="type">long</span> ：声明长整型变量或函数返回值类型</span><br><span class="line"><span class="keyword">register</span>：声明寄存器变量</span><br><span class="line"><span class="keyword">return</span> ：子程序返回语句（可以带参数，也可不带参数）</span><br><span class="line"><span class="type">short</span> ：声明短整型变量或函数</span><br><span class="line"><span class="type">signed</span>：声明有符号类型变量或函数</span><br><span class="line"><span class="keyword">sizeof</span>：计算数据类型或变量长度（即所占字节数）</span><br><span class="line"><span class="type">static</span> ：声明静态变量</span><br><span class="line"><span class="keyword">struct</span>：声明结构体类型</span><br><span class="line"><span class="keyword">switch</span> :用于开关语句</span><br><span class="line"><span class="keyword">typedef</span>：用以给数据类型取别名</span><br><span class="line"><span class="type">unsigned</span>：声明无符号类型变量或函数</span><br><span class="line"><span class="keyword">union</span>：声明共用体类型</span><br><span class="line"><span class="type">void</span> ：声明函数无返回值或无参数，声明无类型指针</span><br><span class="line"><span class="keyword">volatile</span>：说明变量在程序执行中可被隐含地改变</span><br><span class="line"><span class="keyword">while</span> ：循环语句的循环条件</span><br></pre></td></tr></table></figure><p>C语言的关键字无需背诵，如果程序用不小心用了关键字给变量命名，编译时会报错，用多了就熟悉了。</p><h1 id="五-变量的初始化"><a class="markdownIt-Anchor" href="#五-变量的初始化"></a> 五、变量的初始化</h1><p>变量在定义后，操作系统为它分配了一块内存，但并不会把这块内存打扫干静，也就是说内存中可能有垃圾数据，建议在使用之间对其初始化（打扫干静）。</p><p>变量初始化是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p><h2 id="1-整数型-字符型-浮点型变量初始化"><a class="markdownIt-Anchor" href="#1-整数型-字符型-浮点型变量初始化"></a> 1、整数型、字符型、浮点型变量初始化</h2><p>对整数型、字符型、浮点型变量来说，初始化就是给它们赋0值。</p><p>可以在定义的时候立即初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   ii=<span class="number">0</span>;          <span class="comment">// 定义整数型变量并初始化</span></span><br><span class="line"><span class="type">char</span>  cc=<span class="number">0</span>;          <span class="comment">// 定义字符型变量并初始化</span></span><br><span class="line"><span class="type">double</span> money=<span class="number">0</span>;     <span class="comment">// 定义浮点型变量并初始化</span></span><br></pre></td></tr></table></figure><p>也可以先定义，然后再初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   ii;          <span class="comment">// 定义整数型变量</span></span><br><span class="line"><span class="type">char</span>  cc;          <span class="comment">// 定义字符型变量</span></span><br><span class="line"><span class="type">double</span> money;     <span class="comment">// 定义浮点型变量</span></span><br><span class="line">ii=<span class="number">0</span>;              <span class="comment">// 初始化ii为0</span></span><br><span class="line">cc=<span class="number">0</span>;              <span class="comment">// 初始化cc为0</span></span><br><span class="line">money=<span class="number">0</span>;          <span class="comment">// 初始化money为0</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串变量的初始化"><a class="markdownIt-Anchor" href="#2-字符串变量的初始化"></a> 2、字符串变量的初始化</h2><p>对字符串变量来说，初始化就是把内容清空，本质上也是赋0值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];                    <span class="comment">// 定义一个可以存放20字符的字符串</span></span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));   <span class="comment">// 清空字符串name中的内容</span></span><br></pre></td></tr></table></figure><p>注意了，字符串变量的初始化与其它类型不同，要用memset函数，先不要问为什么，就这么抄，以后再解释，先不要花时间和精力去研究它。</p><h1 id="六-变量的赋值"><a class="markdownIt-Anchor" href="#六-变量的赋值"></a> 六、变量的赋值</h1><p>把常量的值赋给变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ii=<span class="number">10</span>;                  <span class="comment">// 整数型变量赋值10</span></span><br><span class="line">cc=<span class="string">&#x27;A&#x27;</span>;                 <span class="comment">// 字符型变量赋值&#x27;A&#x27;</span></span><br><span class="line">money=<span class="number">1500.87</span>;         <span class="comment">// 浮点型变量赋值1500.87</span></span><br><span class="line"><span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);   <span class="comment">// 对字符串变量赋值&quot;西施&quot;</span></span><br></pre></td></tr></table></figure><p>把变量的值赋给变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii1=ii;               <span class="comment">// 定义变量ii1并把ii的值赋给它</span></span><br><span class="line"><span class="type">char</span> cc1=cc;              <span class="comment">// 定义变量cc1并把cc的值赋给它</span></span><br><span class="line"><span class="type">double</span> money1=money;    <span class="comment">// 定义变量money1并把money的值赋给它</span></span><br><span class="line"><span class="type">char</span> name1[<span class="number">21</span>];          <span class="comment">// 定义字符串变量name1</span></span><br><span class="line"><span class="built_in">strcpy</span>(name1,name);     <span class="comment">// 把name的值赋给name1</span></span><br></pre></td></tr></table></figure><p>注意了，字符串变量的赋值与其它类型不同，不能用=号，要用strcpy函数，先不要问为什么，就这么抄，以后再解释，先不要花时间和精力去研究它。</p><p><strong>示例（book6.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book6.c，此程序演示变量的赋值</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>   ii=<span class="number">0</span>;       <span class="comment">// 定义整数型变量并初始化</span></span><br><span class="line">  <span class="type">char</span>  cc=<span class="number">0</span>;       <span class="comment">// 定义字符型变量并初始化</span></span><br><span class="line">  <span class="type">double</span> money=<span class="number">0</span>;   <span class="comment">// 定义浮点型变量并初始化</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];    <span class="comment">// 定义字符串变量</span></span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));  <span class="comment">// 字符串初始化</span></span><br><span class="line"></span><br><span class="line">  ii=<span class="number">10</span>;                 <span class="comment">// 整数型变量赋值10</span></span><br><span class="line">  cc=<span class="string">&#x27;A&#x27;</span>;                <span class="comment">// 字符型变量赋值&#x27;A&#x27;</span></span><br><span class="line">  money=<span class="number">1500.87</span>;        <span class="comment">// 浮点型变量赋值1500.87</span></span><br><span class="line">  <span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 对字符串变量赋值&quot;西施&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii=%d=\n&quot;</span>,ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cc=%c=\n&quot;</span>,cc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;money=%f=\n&quot;</span>,money);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s=\n&quot;</span>,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303101117549.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-I5nH0mha-1583200921673)(media/6f29d51b7872a6778b09dea8098346c5.png)" /></p><h1 id="七-多变量操作"><a class="markdownIt-Anchor" href="#七-多变量操作"></a> 七、多变量操作</h1><h2 id="1-多个变量的定义"><a class="markdownIt-Anchor" href="#1-多个变量的定义"></a> 1、多个变量的定义</h2><p>定义多个变量可以书写多条语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;</span><br><span class="line"><span class="type">int</span> jj;</span><br></pre></td></tr></table></figure><p>相同类型变量的定义可以书写为一条语句，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii,jj;</span><br></pre></td></tr></table></figure><h2 id="2-多个变量的赋值"><a class="markdownIt-Anchor" href="#2-多个变量的赋值"></a> 2、多个变量的赋值</h2><p>整数、字符和浮点型变量可以用一条语句对多个变量赋相同的值，如果要赋不同的值，只能用多条语句了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ii=jj=<span class="number">10</span>;     <span class="comment">// 对ii和jj赋相同的值10</span></span><br><span class="line">ii=jj=<span class="number">30</span>;     <span class="comment">// 对ii和jj赋相同的值30</span></span><br><span class="line">ii=<span class="number">10</span>;        <span class="comment">// 对ii赋值10</span></span><br><span class="line">jj=<span class="number">30</span>;        <span class="comment">// 对jj赋值30</span></span><br></pre></td></tr></table></figure><p>不论值是否相同，一条语句只能对一个字符串变量赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);          <span class="comment">// 对字符串变量name赋值&quot;西施&quot;</span></span><br><span class="line"><span class="built_in">strcpy</span>(name1,<span class="string">&quot;西施&quot;</span>);         <span class="comment">// 对字符串变量name1赋值&quot;西施&quot;</span></span><br><span class="line"><span class="built_in">strcpy</span>(name,name1,<span class="string">&quot;西施&quot;</span>);   <span class="comment">// 这是个天才的想法，但行不通，不符合strcpy函数的语法。</span></span><br></pre></td></tr></table></figure><p>这是个天才的想法，但行不通，不符合strcpy函数的语法。</p><h1 id="八-const约束"><a class="markdownIt-Anchor" href="#八-const约束"></a> 八、const约束</h1><p>const 是 constant 的缩写，意思是“恒定不变的”，它是定义只读变量的关键字。用 const定义只读变量的方法很简单，就在定义变量时前面加 const 即可，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span>  <span class="type">double</span>  pi = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p>用 const定义的变量的值是不允许改变的，不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值，如果程序中试图改变它的值，编译的时候就会报错。</p><p><strong>示例（book7.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book7.c，此程序演示只读变量</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> pi=<span class="number">3.1415926</span>;   <span class="comment">// 定义只读变量</span></span><br><span class="line"></span><br><span class="line">  pi=<span class="number">3.1415927</span>;    <span class="comment">// 试图改变只读变量的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030310162317.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mOpT1nRN-1583200921676)(media/0b957a8f97ddcc35f9aa2aeaed5a83cf.png)" /></p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>本章节介绍的是一些基本概念，各位只要理解了这些概念就行了，编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深理解和映象。</p><p>还有一个注意事项，C语言很多知识点是交叉的，如果课程中出现的内容是没有介绍的知识点，先照抄就行，不要去纠结它的细节，以后在合适的时机再介绍它。</p><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据类型</title>
      <link href="/post/a51a74ec.html"/>
      <url>/post/a51a74ec.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-基本类型"><a class="markdownIt-Anchor" href="#一-基本类型"></a> 一、基本类型</h1><p>C语言的基本数据类型包括字符型、整数型、浮点型。</p><h2 id="1-字符型char"><a class="markdownIt-Anchor" href="#1-字符型char"></a> 1、字符型（char）</h2><p>描述单个字符（一个字节），用半角的单引号包含起来，如’a’、‘A’、‘1’、'$'等，键盘能输入的英文和半角的符号都是字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span>   <span class="string">&#x27;B&#x27;</span>   <span class="string">&#x27;C&#x27;</span> ...... <span class="string">&#x27;Z&#x27;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>   <span class="string">&#x27;b&#x27;</span>   <span class="string">&#x27;c&#x27;</span> ...... <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span>   <span class="string">&#x27;1&#x27;</span>   <span class="string">&#x27;2&#x27;</span> ...... <span class="string">&#x27;9&#x27;</span></span><br><span class="line"><span class="string">&#x27;~&#x27;</span>   <span class="string">&#x27;!&#x27;</span>   <span class="string">&#x27;@&#x27;</span> ...... <span class="string">&#x27;+&#x27;</span></span><br></pre></td></tr></table></figure><p>中文的汉字和标点符号是两个字节（GBK编码），不能算一个字符，以下都是非法的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;好&#x27;</span></span><br><span class="line"><span class="string">&#x27;。&#x27;</span></span><br><span class="line"><span class="string">&#x27;，&#x27;</span></span><br><span class="line"><span class="string">&#x27;￥&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-整型int"><a class="markdownIt-Anchor" href="#2-整型int"></a> 2、整型（int）</h2><p>描述整数，整数在计算机上是准确表示的，如123、500、0、-10等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">500</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-10</span></span><br></pre></td></tr></table></figure><h2 id="3-浮点型float"><a class="markdownIt-Anchor" href="#3-浮点型float"></a> 3、浮点型（float）</h2><p>描述实数，有小数位，如10.0、123.55、3459.98、-50.3，实数在计算机上一般是近似表示的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="number">123.55</span></span><br><span class="line"><span class="number">345.98</span></span><br><span class="line"><span class="number">-50.3</span></span><br></pre></td></tr></table></figure><h1 id="二-字符串"><a class="markdownIt-Anchor" href="#二-字符串"></a> 二、字符串</h1><p>描述多个字符，用半角的双引号包含起来，可以是英文、数字、中文、标点符号，半角全角的都可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;西施&quot;</span></span><br><span class="line"><span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。&quot;</span></span><br><span class="line"><span class="string">&quot;我有100块钱。&quot;</span></span><br><span class="line"><span class="string">&quot;1998&quot;</span></span><br></pre></td></tr></table></figure><h1 id="三-构造类型"><a class="markdownIt-Anchor" href="#三-构造类型"></a> 三、构造类型</h1><p>由基本类型通过一定的构造方法构造出来的类型，包括数组和结构体，在以后的章节将详细介绍它们。</p><h1 id="四-指针类型"><a class="markdownIt-Anchor" href="#四-指针类型"></a> 四、指针类型</h1><p>指针可以存放内存变量和常量地址，主要用于函数的参数传递，极其重要，如果没有指针，C程序员将非常难受，在以后的章节将详细介绍它。</p><h1 id="五-其它数据类型"><a class="markdownIt-Anchor" href="#五-其它数据类型"></a> 五、其它数据类型</h1><p>C语言还有其它数据类型，如复数类型（_Complex）、虚数类型（_Imaginary）、布尔型（_bool）、这些数据类型的应用场景极少，我就不介绍了。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序的基本结构</title>
      <link href="/post/a0664f6d.html"/>
      <url>/post/a0664f6d.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-c语言基础知识的学习方法"><a class="markdownIt-Anchor" href="#一-c语言基础知识的学习方法"></a> 一、C语言基础知识的学习方法</h1><p>1）我的课程内容是精心整理的，某些知识点可能没有提到应用场景，但绝对不会是没用的知识。课程中没有提到的知识可以了解一下，但不必深入学习，意义不大。</p><p>2）学习不要贪快，欲速则不达的道理大家应该明白，学习的重点是培养写程序的感觉。</p><p><strong>3）不要记笔记，不要记关键字，不要记函数的参数，忘了就忘了，忘了是因为没有经过实战，所以，到了项目实战课程的时候，忘了内容很自然的会全部想起来。</strong></p><p>4）不要用手机看视频，看着看着就想睡觉，学习的过程是边看边写，没有看出来的程序员。赵括，知道不？就是那个空读兵书不成器的家伙，只看书看视频不写程序，和赵括没什么不同。</p><p>5）程序员的指法很重要，翘着二郎腿，嘴里叨着烟，挥舞一指禅，一副吊儿郎当的样子，是成不了程序员的。</p><p>6）学习的过程中遇到的问题，如果三十分钟解决不了，不要纠缠，在群里向大家请教。但是，反对遇到问题不经思考就提问的方式。</p><p><strong>7）开始学习C语言之前，必须先熟悉Linux环境，掌握Linux常用命令和vi的基本用法。</strong></p><p><strong>8）高手都是从菜鸟开始的，只要您按视频教程一步一个脚印的学习，一定能成为优秀的程序员。</strong></p><h1 id="二-c语言程序开发的流程"><a class="markdownIt-Anchor" href="#二-c语言程序开发的流程"></a> 二、C语言程序开发的流程</h1><p>现阶段，我们编写的C程序比较简单，程序开发的流程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200302211129430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-安装c语言的编译器"><a class="markdownIt-Anchor" href="#三-安装c语言的编译器"></a> 三、安装C语言的编译器</h1><p>Linux下C语言的编译器是gcc，以root用户登录，执行以下命令安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  <span class="literal">-y</span>  install  gcc</span><br></pre></td></tr></table></figure><p>注意，如果您的服务器没有安装gcc，以上命令就会安装最新版本的gcc，如果已经安装了gcc，就会更新到最新版本，所以，以上命令不管执行多少次都没有问题。</p><p>安装gcc的前提条件是服务器必须可以访问互联网。</p><h1 id="四-c程序的基本结构"><a class="markdownIt-Anchor" href="#四-c程序的基本结构"></a> 四、C程序的基本结构</h1><p>C 程序主要包括以下部分：</p><p>1）注释（说明文字）</p><p>2）预处理指令</p><p>3）主函数入口</p><p>4）主函数体</p><p><strong>示例（book1.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book1.c，此程序用于演示C程序的基本结构。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理指令，把头文件stdio.h包含进来。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// standard input output</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数main，这里是程序执行的起点。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 调用printf函数在屏幕上输出文字。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// main函数返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们讲解一下上面这段程序。</p><h2 id="1-程序的注释"><a class="markdownIt-Anchor" href="#1-程序的注释"></a> 1、程序的注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book1.c，此程序用于演示C程序的基本结构。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 预处理指令，把头文件stdio.h包含进来。</span></span><br><span class="line"><span class="comment">// standard input output</span></span><br><span class="line"><span class="comment">// 主函数main，这里是程序执行的起点。</span></span><br><span class="line"><span class="comment">// 调用printf函数在屏幕上输出文字。</span></span><br><span class="line"><span class="comment">// main函数返回</span></span><br></pre></td></tr></table></figure><p>以上是C程序的注释（说明文字），注释的目的是为了提高程序的可读性，是给程序员看的，不是给计算机看的，编译器编译程序时将忽略它。</p><p>/* */用于注释多行文字，/*是开始，*/是结束。</p><p>// 用于注释一行文字，可以独占一行，也可以放在代码的后面。</p><h2 id="2-预处理指令"><a class="markdownIt-Anchor" href="#2-预处理指令"></a> 2、预处理指令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// standard input output</span></span></span><br></pre></td></tr></table></figure><p>这一行是（编译）预处理指令，告诉 C<br />语言编译器在编译之前要包含stdio.h文件，程序中使用了printf函数，如果不包含它的头文件，编译时会出现警告或报错。</p><h2 id="3-主函数的入口"><a class="markdownIt-Anchor" href="#3-主函数的入口"></a> 3、主函数的入口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>main是主函数，程序从这里开始执行。在同一程序中，main函数只能有一个。</p><h2 id="4-主函数体"><a class="markdownIt-Anchor" href="#4-主函数体"></a> 4、主函数体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// main函数返回</span></span><br></pre></td></tr></table></figure><p>主函数体的代码在一对花括号，本程序的主函数体有两行代码。</p><p>第一行代码调用了printf函数，printf函数的功能是把内容输出到屏幕，这里是输出一行文字，文字结尾的\n表示换行，多个\n就可以输出多个换行。</p><p>第二行代码return 0;表示主函数返回，程序退出。</p><p>注意，main函数体中的<strong>空行和每行代码前面的空格</strong>是为了提高程序的可读性，对程序的功能没有任何影响。</p><h1 id="五-编译并执行-c-程序"><a class="markdownIt-Anchor" href="#五-编译并执行-c-程序"></a> 五、编译并执行 C 程序</h1><p>在Linux的命令行下用gcc命令编译源程序book1.c。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o book1 book1.c</span><br></pre></td></tr></table></figure><p>编译完成后，将生成目标程序book1（可执行程序名由-o参数指定），加./执行它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book1</span><br></pre></td></tr></table></figure><p>执行的结果是在屏幕上输出一行文字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200302211648572.png" alt="在这里插入图片描述" /></p><h1 id="六-知识总结"><a class="markdownIt-Anchor" href="#六-知识总结"></a> 六、知识总结</h1><p>/**/ 多行注释。</p><p>// 单行注释。</p><p>#include 包含其它文件的预处理指令。</p><p>main 程序执行的起点。</p><p>{} 函数体、语句块的开始和结束。</p><p>() 函数的参数放在括号中。</p><p>“” 字符串放在双引号中。</p><p>\n 换行符。</p><p>; 分号，一行代码的结束。</p><p>1）以上都是C语言的语法约定，是规则，不可改变，不能质疑，必须遵守；</p><p>2）C语言严格区分大小写；</p><p>3）中文的全角标点符号C语言无法识别，编译时会报错；</p><p>4）C程序以分号“; ”表示一条语言的结束，多条语句可以书写在一行。</p><p>5）如果某行代码只有分号“; ”，表示一条空语句，什么也不做。</p><h1 id="七-课后作业"><a class="markdownIt-Anchor" href="#七-课后作业"></a> 七、课后作业</h1><p>1）请写一个最简单的C程序，实现什么功能无所谓，代码越少越好。</p><p>2）有一个坑，中国程序经常掉进去，但美国程序却不会，请问这是个什么坑？</p><p>3）在屏幕中输出诗经《我是一只傻傻鸟》，源程序命名为book2.c，执行的效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200302211704931.png" alt="在这里插入图片描述" /></p><p>4）请在屏幕中间用符号“*”拼出一个大大的字母H，源程序命名为book3.c，执行的效果如下：</p><p><img src="https://img-blog.csdnimg.cn/2020030221172381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
