<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Learn-Vim(the Smart Way) 中文翻译</title>
      <link href="/posts/972ef649.html"/>
      <url>/posts/972ef649.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p><a href="https://github.com/iggredible/Learn-Vim">英文版本仓库地址</a></p><p>本中文版基于2021-10-15英文版进行翻译和更新，基础英文版本保存在 <code>./The_original_En_version</code> 下，如果后续英文版有更新，可以将最新版本与该版本比对后，再进行差分翻译。</p><h2 id="这是什么"><a class="markdownIt-Anchor" href="#这是什么"></a> 这是什么?</h2><p><em>学习 Vim（智能方式）</em> 是一本学习Vim中优秀部分知识的书。</p><p>有很多种方法可以去学习Vim：<code>vimtutor</code>就是一个很棒的教程，另外还有<code>help</code>拥有您所想的所有参考信息。但是在日常使用中，对于绝大部分用户的需求而言，<code>vimtutor</code>讲得太浅不能满足需要，而<code>:help</code>所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。</p><p>本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><p><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></p><h3 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h3><ul><li><a href="https://blog.ilyfikaros.com/posts/d25eff46/">Ch 0 - 请先阅读</a></li></ul><h3 id="第一部分聪明地学习vim"><a class="markdownIt-Anchor" href="#第一部分聪明地学习vim"></a> 第一部分：聪明地学习Vim</h3><ul><li><a href="https://blog.ilyfikaros.com/posts/d7470566/">Ch 1 - 起步</a></li><li><a href="https://blog.ilyfikaros.com/posts/e5aa9cfc/">Ch 2 - 缓冲区，窗口和选项卡</a></li><li><a href="https://blog.ilyfikaros.com/posts/32c07678/">Ch 3 - 打开和搜索文件</a></li><li><a href="https://blog.ilyfikaros.com/posts/0584a475/">Ch 4 - Vim 语法</a></li><li><a href="https://blog.ilyfikaros.com/posts/25eb02e8/">Ch 5 - 移动文件</a></li><li><a href="https://blog.ilyfikaros.com/posts/f92aab20/">Ch 6 - 插入模式</a></li><li><a href="https://blog.ilyfikaros.com/posts/83932852/">Ch 7 - 点命令</a></li><li><a href="https://blog.ilyfikaros.com/posts/49130c49/">Ch 8 - 寄存器</a></li><li><a href="https://blog.ilyfikaros.com/posts/7e0645cb/">Ch 9 - 宏</a></li><li><a href="https://blog.ilyfikaros.com/posts/49fd3ee8/">Ch 10 - 撤消</a></li><li><a href="https://blog.ilyfikaros.com/posts/ba239799/">Ch 11 - 可视模式</a></li><li><a href="https://blog.ilyfikaros.com/posts/36365707/">Ch 12 - 搜索和替换</a></li><li><a href="https://blog.ilyfikaros.com/posts/fbe80173/">Ch 13 - 全局命令</a></li><li><a href="https://blog.ilyfikaros.com/posts/e58db16f/">Ch 14 - 外部命令</a></li><li><a href="https://blog.ilyfikaros.com/posts/d3de6571/">Ch 15 - 命令行模式</a></li><li><a href="https://blog.ilyfikaros.com/posts/514bd033/">Ch 16 - 标签</a></li><li><a href="https://blog.ilyfikaros.com/posts/d7f38bdd/">Ch 17 - 折叠</a></li><li><a href="https://blog.ilyfikaros.com/posts/a575da65/">Ch 18 - Git</a></li><li><a href="https://blog.ilyfikaros.com/posts/520a0cad/">Ch 19 - 编译</a></li><li><a href="https://blog.ilyfikaros.com/posts/26a705fd/">Ch 20 - 视图、会话和 Viminfo</a></li><li><a href="https://blog.ilyfikaros.com/posts/0783c3af/">Ch 21 - 多文件操作</a></li></ul><h3 id="第二部分聪明地定制vim"><a class="markdownIt-Anchor" href="#第二部分聪明地定制vim"></a> 第二部分：聪明地定制Vim</h3><ul><li><a href="https://blog.ilyfikaros.com/posts/29ce7871/">Ch 22 - Vimrc</a></li><li><a href="https://blog.ilyfikaros.com/posts/ad9bd3e0/">Ch 23 - Vim软件包</a></li><li><a href="https://blog.ilyfikaros.com/posts/2d5c14f7/">Ch 24 - Vim Runtime</a></li></ul><h1 id="许可和版权"><a class="markdownIt-Anchor" href="#许可和版权"></a> 许可和版权</h1><p>这些材料全部归 ©2020 Igor Irianto 所有。</p><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png" /></a><br /></p><p>这项作品已获得<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">&lt;&lt;知识共享署名-非商业性-相同方式共享 4.0 版&gt;&gt;</a>的许可。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch24-Vim Runtime</title>
      <link href="/posts/2d5c14f7.html"/>
      <url>/posts/2d5c14f7.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在前面的章节中，我提到Vim会自动查找一些特殊的路径，比如在<code>~/.vim/</code> 中的 <code>pack/</code>(第23章) <code>compiler/</code>（第19章）。这些都是Vim runtime路径的例子。</p><p>除了上面提到的两个，Vim还有更多runtime路径。在本章，您将学习关于Vim runtime路径的高层次概述。本章的目标是向您展示它们什么时候被调用。知道这些知识能够帮您更进一步理解和定制Vim。</p><h2 id="runtime路径"><a class="markdownIt-Anchor" href="#runtime路径"></a> Runtime路径</h2><p>在一台Unix机器中，其中一个vim runtime路径就是 <code>$HOME/.vim/</code> （如果您用的是其他操作系统，比如Windows，您的路径可能有所不同）。要查看不同的操作系统有什么样的runtime路径，查阅 <code>:h runtimepath</code>。在本章，我将使用 <code>~/.vim/</code> 作为默认的runtime路径。</p><h2 id="plugin脚本"><a class="markdownIt-Anchor" href="#plugin脚本"></a> Plugin脚本</h2><p>Vim有一个runtime路径 plugin，每次Vim启动时都会执行这个路径中的所有脚本。不要把这个名字 “plugin” 和Vim的外部插件（external plugins，比如NERDTree, fzf.vim, 等)搞混了。</p><p>进入 <code>~/.vim/</code> 目录，然后创建 <code>plugin/</code> 子目录。 创建两个文件： <code>donut.vim</code> 和 <code>chocolate.vim</code>。</p><p>在 <code>~/.vim/plugin/donut.vim</code>里面:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;donut!&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>~/.vim/plugin/chocolate.vim</code>里面:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;chocolate!&quot;</span></span><br></pre></td></tr></table></figure><p>现在关闭Vim。下次您启动Vim，您将会看到 <code>&quot;donut!&quot;</code> 和 <code>:chocolate!</code> 的显示。此 plugin runtime路径可以用来执行一些初始化脚本。</p><h2 id="文件类型检测"><a class="markdownIt-Anchor" href="#文件类型检测"></a> 文件类型检测</h2><p>在开始之前，为保证检测能正常运行，确保在您的vimrc中至少包含了下列的行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure><p>查阅 <code>:h filetype-overview</code> 了解更多信息。本质上，这条代码开启Vim的文件类型检测。</p><p>当您打开一个新的文件，Vim通常知道这个文件是什么类型。如果您有一个文件 <code>hello.rb</code>，运行 <code>:set filetype?</code> 会返回正确的相应 <code>filetype=ruby</code>。</p><p>Vim知道如何检测 “常见” 的文件类型（Ruby, Python, Javascript, 等）。但如果是一个自定义文件会怎样呢？您需要告诉Vim去检测它，并给它指派一个正确的文件类型。</p><p>有两种检测方法：使用文件名和使用文件内容</p><h3 id="文件名检测"><a class="markdownIt-Anchor" href="#文件名检测"></a> 文件名检测</h3><p>文件名检测使用一个文件的文件名来检测文件类型。当您打开 <code>hello.rb</code>文件时，Vim依靠扩展名 <code>.rb</code> 知道它是一个Ruby文件。</p><p>有两种方法实现文件名检测：一是使用 <code>ftdetect</code> runtime目录，二是使用 <code>filetype.vim</code> runtime文件。我们两个都看一看。</p><h4 id="ftdetect"><a class="markdownIt-Anchor" href="#ftdetect"></a> <code>ftdetect/</code></h4><p>让我们创建一个古怪（但优雅）的名字，<code>hello.chocodonut</code>。当您打开它后运行 <code>:set filetype?</code> ，因为它的后缀名不是常见的文件名，Vim不知道它是什么类型，会返回 <code>filetype=</code>。</p><p>您需要指示Vim将所有以 <code>.chocodonut</code>结尾的文件设置为 &quot;chocodonut&quot;类型的文件。在runtime路径根目录(<code>~/.vim/</code>)创建一个子目录，名为 <code>ftdetect/</code> 。在子目录里面，再创建一个名叫 <code>chocodonut.vim</code> 的文件（<code>~/.vim/ftdetect/chocodonut.vim</code>），在文件里面，添加：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile,BufRead *.chocodonut set filetype=chocodonut</span><br></pre></td></tr></table></figure><p>当您创建新buffer或打开新buffer时，事件<code>BufNewFile</code> 和 <code>BufRead</code> 就会被触发。 <code>*.chocodonut</code> 意思是只有当新打开的buffer文件名后缀是 <code>.chocodonut</code> 时事件才会被触发。最后，<code>set filetype=chocodonut</code> 命令将文件类型设置为chocodonut类型。</p><p>重启Vim。新建一个 <code>hello.chocodonut</code> 文件然后运行 <code>:set filetype?</code>。它将返回 <code>filetype=chocodonut</code>.</p><p>好极了！只要您想，您可以将任意多的文件放置在 <code>ftdetect/</code> 中。以后，如果您想扩展您的 donut 文件类型，你可以添加 <code>ftdetect/strawberrydonut.vim</code>, <code>ftdetect/plaindonut.vim</code> 等等。</p><p>在Vim中，实际上有两种方法设置文件类型。其中给一个是您刚刚使用的 <code>set filetype=chocodonut</code>。另一种方法是运行 <code>setfiletype chocodonut</code>。前一个命令 <code>set filetype=chocodonut</code> 将 <em>总是</em> 设置文件类型为chocodonut。 而后者<code>setfiletype chocodonut</code>只有当文件类型尚未设置时，才会将文件类型设置为chocodonut。</p><h4 id="文件类型文件"><a class="markdownIt-Anchor" href="#文件类型文件"></a> 文件类型文件</h4><p>第二种文件类型检测需要你创建一个名为 <code>filetype.vim</code>的文件，并将它放置在根目录(<code>~/.vim/filetype.vim</code>)。在文件内添加一下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile,BufRead *.plaindonut set filetype=plaindonut</span><br></pre></td></tr></table></figure><p>创建一个名为 <code>hello.plaindonut</code> 的文件。当你打开它后运行 <code>:set filetype?</code> Vim会显示正确的自定义文件类型 <code>filetype=plaindonut</code>。</p><p>太好了，修改生效了。另外，如果您仔细看看 <code>filetype.vim</code> ，您会发现当您打开<code>hello.plaindonut</code>时，这个文件文件运行了多次。为防止这一点，您可以添加一个守卫，让主脚本只运行一次。更新 <code>filetype.vim</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">exists</span>(<span class="string">&quot;did_load_filetypes&quot;</span>)</span><br><span class="line">  finish</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">augroup donutfiletypedetection</span><br><span class="line">  autocmd! BufRead,BufNewFile *.plaindonut setfiletype plaindonut</span><br><span class="line">augroup END</span><br></pre></td></tr></table></figure><p><code>finish</code> 是一个Vim命令，用来停止执行剩余的脚本。表达式<code>&quot;did_load_filetypes&quot;</code> 并 <em>不是</em> 一个Vim内置函数。它实际上是<code>$VIMRUNTIME/filetype.vim</code> 中的一个全局变量。如果您好奇，运行<code>:e $VIMRUNTIME/filetype.vim</code>。您将会发现以下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">exists</span>(<span class="string">&quot;did_load_filetypes&quot;</span>)</span><br><span class="line">  finish</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">let did_load_filetypes = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当Vim调用这个文件时，它会定义 <code>did_load_filetypes</code> 变量，并将它设置为 1 。在Vim中，1 表示真。你可以试着读完 <code>filetype.vim</code> 剩余的内容，看看您是否能够理解当Vim调用它时干了什么。</p><h3 id="文件类型脚本"><a class="markdownIt-Anchor" href="#文件类型脚本"></a> 文件类型脚本</h3><p>让我们学习如何基于文件内容检测文件类型。</p><p>假设您有一个无扩展名的文件的集合。这些文件唯一相同的地方是，第一行都是以 “donutify” 开头。您现在想给这些文件指派一个 <code>donut</code> 的文件类型。创建新文件，起名为 <code>sugardonut</code>, <code>glazeddonut</code>, 还有 <code>frieddonut</code>（没有扩展名）。在每个文件中，添加下列内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donutify</span><br></pre></td></tr></table></figure><p>当您在<code>sugardonut</code>中运行 <code>:set filetype?</code>，Vim无法知道应该给这个文件指派什么文件类型，会返回 <code>filetype=</code>。</p><p>在runtime根目录，添加一个 <code>scripts.vim</code> 文件(<code>~/.vim/scripts.vim</code>)，在文件中，添加一下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> did_filetype()</span><br><span class="line">  finish</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> getline(<span class="number">1</span>) =~ <span class="string">&#x27;^\\&lt;donutify\\&gt;&#x27;</span></span><br><span class="line">  setfiletype donut</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>函数 <code>getline(1)</code> 返回文件第一行的内容。它检查第一行是否以 “donutify” 开头。函数 <code>did_filetype()</code> 是Vim的内置函数，当一个与文件类型相关的事件发生至少一次时，它返回真。它用来做守卫，防止文件类型事件反复运行。</p><p>打开文件 <code>sugardonut</code> 然后运行 <code>:set filetype?</code>，Vim现在返回 <code>filetype=donut</code>。如果您打开另外一个donut文件 (<code>glazeddonut</code> 和 <code>frieddonut</code>)，Vim同样会将它们的文件类型定义为 <code>donut</code> 类型。</p><p>注意，<code>scripts.vim</code> 仅当Vim打开一个未知文件类型的文件时才会运行。如果Vim打开一个已知文件类型的文件，<code>scripts.vim</code> 将不会运行。</p><h2 id="文件类型插件"><a class="markdownIt-Anchor" href="#文件类型插件"></a> 文件类型插件</h2><p>如果您想让Vim仅当您打开一个 chocodonut 文件时才运行 chocodonut 相关的特殊脚本，而当您打开的是 plaindonut 文件时，Vim就不运行这些脚本。能否做到呢？</p><p>您可以使用文件类型插件runtime路径(<code>~/.vim/ftplugin/</code>)来完成这个功能。Vim会在这个目录中查找一个文件，这个文件的文件名与您打开的文件类型一样。创建一个文件，起名为<code>chocodonut.vim</code> (<code>~/.vim/ftplugin/chocodonut.vim</code>):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;Calling from chocodonut ftplugin&quot;</span></span><br></pre></td></tr></table></figure><p>创建另一个 ftplugin 文件，起名为<code>plaindonut.vim</code> (<code>~/.vim/ftplugin/plaindonut.vim</code>):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;Calling from plaindonut ftplugin&quot;</span></span><br></pre></td></tr></table></figure><p>现在，每次您打开一个 chocodonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/chocodonut.vim</code>中的脚本。每次您打开 plaindonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/plaindonut.vim</code> 中的脚本。</p><p>一个警告：每当一个buffer的文件类型被设置时(比如，<code>set filetype=chocodonut</code>)，上述脚本就会运行一次。如果您打开3个不同的 chocodonut 文件，该脚本将运行 <em>总共</em> 3次。</p><h2 id="缩进文件"><a class="markdownIt-Anchor" href="#缩进文件"></a> 缩进文件</h2><p>Vim有一个 缩进runtime路径，其工作方式与ftplugin类似，Vim也会在这个目录中查找一个与打开的文件类型名字一样的文件。缩进runtime路径的目的是存储缩进相关的代码。如果您有文件 <code>~/.vim/indent/chocodonut.vim</code>，它仅当您打开一个 chocodonut 类型的文件时执行。您可以将 chocodonut 文件中缩进相关的代码存储在这里。</p><h2 id="颜色"><a class="markdownIt-Anchor" href="#颜色"></a> 颜色</h2><p>Vim 有一个颜色runtime路径 (<code>~/.vim/colors/</code>) ，用来存储颜色主题。这个目录中的任何文件都会在命令行命令 <code>:color</code> 中显示出来。</p><p>如果您有一个文件 <code>~/.vim/colors/beautifulprettycolors.vim</code>，当您运行 <code>:color</code> 然后按 Tab，您将会看到 <code>beautifulprettycolors</code> 出现在颜色选项中。  如果您想添加自己的颜色主题，就放在这个地方。</p><p>如果您想看其他人做的颜色主题，有一个好地方值得推荐：<a href="https://vimcolors.com/">vimcolors</a>。</p><h2 id="语法高亮"><a class="markdownIt-Anchor" href="#语法高亮"></a> 语法高亮</h2><p>Vim有一个语法runtime路径 (<code>~/.vim/syntax/</code>)，用来定义语法高亮。</p><p>假设您有一个文件 <code>hello.chocodonut</code>，在文件里面有以下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(donut <span class="string">&quot;tasty&quot;</span>)</span><br><span class="line">(donut <span class="string">&quot;savory&quot;</span>)</span><br></pre></td></tr></table></figure><p>虽然Vim现在知道了正确的文件类型，但所有的文本都是相同的颜色。让我们添加语法高亮规则，使 “donut” 关键词高亮显示。创建一个新的 chocodonut 语法文件 <code>~/.vim/syntax/chocodonut.vim</code>，在文件中添加：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax keyword donutKeyword donut</span><br><span class="line"></span><br><span class="line">highlight <span class="keyword">link</span> donutKeyword Keyword</span><br></pre></td></tr></table></figure><p>现在重新打开 <code>hello.chocodonut</code> 文件，关键词 <code>donut</code> 已经高亮显示了。</p><p>本章不会详细介绍语法高亮。它是一个庞大的主题。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p><p><a href="https://github.com/sheerun/vim-polyglot">vim-polyglot</a> 插件非常的棒，它提供了很多流行的编程语言的语法高亮。</p><h2 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档</h2><p>如果您写了一个插件，您还得创建一个您自己的文档。您可以使用文档runtime路径完成这个。</p><p>让我们为 chocodonut 和 plaindonut 关键字创建一个基本文档。创建文件 <code>donut.txt</code> (<code>~/.vim/doc/donut.txt</code>)。在文件中，添加一下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*chocodonut* Delicious chocolate donut</span><br><span class="line"></span><br><span class="line">*plaindonut* No choco goodness but still delicious nonetheless</span><br></pre></td></tr></table></figure><p>如果您试着搜索 <code>chocodonut</code> 或 <code>plaindonut</code> (<code>:h chocodonut</code> 或 <code>:h plaindonut</code>)，您找不到任何东西。</p><p>首先，你需要运行 <code>:helptags</code>来创建新的帮助入口。运行 <code>:helptags ~/.vim/doc/</code></p><p>现在，如果您运行 <code>:h chocodonut</code> 或 <code>:h plaindonut</code>，您将找到上面那些新的帮助入口。注意，现在文件是只读的，而且类型是 “help”。</p><h2 id="延时加载脚本"><a class="markdownIt-Anchor" href="#延时加载脚本"></a> 延时加载脚本</h2><p>到现在，本章您学到的所有runtime路径都是自动运行的。如果您想手动加载一个脚本，可使用 autoload runtime路径。</p><p>创建一个目录名为 autoload(<code>~/.vim/autoload/</code>)。在目录中，创建一个新文件，起名为 <code>tasty.vim</code> (<code>~/.vim/autoload/tasty.vim</code>)。在文件中：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;tasty.vim global&quot;</span></span><br><span class="line"></span><br><span class="line">function tasty<span class="comment">#donut()</span></span><br><span class="line">  echo <span class="string">&quot;tasty#donut&quot;</span></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><p>注意，函数名是 <code>tasty#donut</code> 而不是 <code>donut()</code>。要想使用autoload功能，井号(<code>#</code>)是必须的。在使用autoload功能时，函数的命名惯例是：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fileName<span class="comment">#functionName()</span></span><br><span class="line">  ...</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><p>在本例中，文件名是 <code>tasty.vim</code>，而函数名是<code>donut</code>。</p><p>要调用一个函数，可以使用 <code>call</code> 命令。让我们call这个函数 <code>:call tasty#donut()</code>。</p><p>您第一次调用这个函数时，您应当会 <em>同时</em> 看到两条信息 (“tasty.vim global” 和 “tasty#donut”) 。后面再调用 <code>tasty#donut</code> 函数，将只会显示 “testy#donut”。</p><p>当您在Vim中打开一个文件，不像前面说的runtime路径，autoload脚本不会被自动加载。仅当您显式地调用 <code>tasty#donut()</code>，Vim才会查找文件<code>tasty.vim</code>，然后加载文件中的内容，包括函数 <code>tasty#donut()</code>。有些函数会占用大量资源，但我们又不常用，这时候 Autoload runtime路径就是最佳的解决方案。</p><p>您可以在autoload目录任意添加嵌套的目录。如果您有一个runtime路径 <code>~/.vim/autoload/one/two/three/tasty.vim</code>，您可以使用<code>:call one#two#three#tasty#donut()</code>来调用函数。</p><h2 id="after脚本"><a class="markdownIt-Anchor" href="#after脚本"></a> After脚本</h2><p>Vim有一个 after runtime路径 (<code>~/.vim/after/</code>) ，它的结构是 <code>~/.vim/</code>的镜像。在此目录中的任何脚本都会最后执行，所以开发者通常使用这个路径来重载脚本。</p><p>比如，如果您想重载 <code>plugin/chocolate.vim</code> 中的脚本，您可以创建<code>~/.vim/after/plugin/chocolate.vim</code>来放置重载脚本。Vim将会先运行 <code>~/.vim/plugin/chocolate.vim</code>， <em>然后运行</em> <code>~/.vim/after/plugin/chocolate.vim</code></p><h2 id="vimruntime"><a class="markdownIt-Anchor" href="#vimruntime"></a> $VIMRUNTIME</h2><p>Vim有一个环境变量 <code>$VIMRUNTIME</code> 用来加载默认脚本和支持文件。您可以运行 <code>:e $VIMRUNTIME</code>查看。</p><p>它的结构应该看起来很熟悉。它包含的很多runtime路径都是我们本章前面学过的。</p><p>回想第22章，当您打开Vim时，它会在6个不同的位置查找vimrc文件。当时我说最后一个位置就是 <code>$VIMRUNTIME/default.vim</code>，如果Vim在前5个位置查找用户vimrc文件失败，就会使用<code>default.vim</code> 作为vimrc。</p><p>不知您是否尝试过，运行Vim是不加载比如vim-polyglot之类的语法插件，但您的文件依然有语法高亮?这是因为当Vim在runtime路径查找语法文件失败时，会从<code>$VIMRUNTIME</code> 的语法目录中查找语法文件。</p><p>查阅 <code>:h $VIMRUNTIME</code>了解更多信息。</p><h2 id="runtimepath选项"><a class="markdownIt-Anchor" href="#runtimepath选项"></a> Runtimepath选项</h2><p>运行 <code>:set runtimepath?</code>，可以查看您的runtime路径。</p><p>如果您使用 Vim-Plug 或其他流行的第三方插件管理器，它应该会显示一个目录列表。比如，我的显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimepath=~/.vim,~/.vim/plugged/vim-signify,~/.vim/plugged/base16-vim,~/.vim/plugged/fzf.vim,~/.vim/plugged/fzf,~/.vim/plugged/vim-gutentags,~/.vim/plugged/tcomment_vim,~/.vim/plugged/emmet-vim,~/.vim/plugged/vim-fugitive,~/.vim/plugged/vim-sensible,~/.vim/plugged/lightline.vim, ...</span><br></pre></td></tr></table></figure><p>插件管理器做了一件事，就是将每个插件添加到runtime路径中。每个runtime路径都有一个类似 <code>~/.vim/</code>的目录结构。</p><p>如果您有一个目录 <code>~/box/of/donuts/</code>，然后您想将这个目录添加到您的runtime路径中，您可以在vimrc中添加以下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rtp+=$HOME/box/of/donuts/</span><br></pre></td></tr></table></figure><p>如果在 <code>~/box/of/donuts/</code> 里面，您有一个plugin目录 (<code>~/box/of/donuts/plugin/hello.vim</code>) 以及ftplugin目录 (<code>~/box/of/donuts/ftplugin/chocodonut.vim</code>)，当您打开Vim时，Vim将会运行 <code>plugin/hello.vim</code> 中所有脚本。同样，当您打开一个 chocodonut 文件时，Vim 将会运行 <code>ftplugin/chocodonut.vim</code>。</p><p>自己试着做一下：创建一个任意目录，然后将它添加到您的 runtimepath中。添加一些我们本章学到的runtime路径。确保它们按预期工作。</p><h2 id="聪明地学习runtime"><a class="markdownIt-Anchor" href="#聪明地学习runtime"></a> 聪明地学习Runtime</h2><p>花点时间阅读本章，还有认真研究一下这些runtime路径。看一下真实环境下runtime路径是如何使用的。浏览一下您最喜欢的Vim插件仓库，仔细研究一下它的目录结构，您应该能够理解它们中的绝大部分。试着领会重点并跟着做。现在您已经理解了Vim的目录结构，您可以准备学习Vimscript了。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/ad9bd3e0/">Ch 23 - Vim软件包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch23-Vim软件包</title>
      <link href="/posts/ad9bd3e0.html"/>
      <url>/posts/ad9bd3e0.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在前面的章节中，我提到使用第三方插件管理器来安装插件。从Vim 8开始，Vim自带了一个内置的插件管理器，名叫 <em>软件包（packages）</em>。在本章，您将学习如何使用Vim软件包来安装插件。</p><p>要看您的Vim编译版本是否能够使用软件包，运行 <code>:version</code>。然后查看是否有 <code>+packages</code>属性。另外，您也可以运行 <code>:echo has('packages')</code>（如果返回1，表示可以使用软件包）。</p><h2 id="包目录"><a class="markdownIt-Anchor" href="#包目录"></a> 包目录</h2><p>在根目录下查看您是否有一个 <code>~/.vim</code> 文件夹。如果没有就新建一个。在文件夹里面，创建一个子文件夹取名 <code>pack</code>(<code>~/.vim/pack/</code>)。Vim会在这个子文件夹内自动搜索插件。</p><h2 id="两种加载方式"><a class="markdownIt-Anchor" href="#两种加载方式"></a> 两种加载方式</h2><p>Vim软件包有两种加载机制：自动加载和手动加载。</p><h3 id="自动加载"><a class="markdownIt-Anchor" href="#自动加载"></a> 自动加载</h3><p>要想让Vim启动时自动加载插件，你需要将它们放置在 <code>start/</code>子目录中。路径看起来像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/start/</span><br></pre></td></tr></table></figure><p>现在您可能会问，为什么在<code>pack/</code> 和 <code>start/</code> 之间有一个 <code>*</code> ？这个星号可以是任意名字。让我们将它取为<code>packdemo/</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/packdemo/start/</span><br></pre></td></tr></table></figure><p>记住，如果您忽略这一点，用下面的路径代替的话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/start/</span><br></pre></td></tr></table></figure><p>软件包系统是不会正常工作的。 必须在<code>pack/</code> 和 <code>start/</code>之间添加一个名字才能正常运行。</p><p>在这个示例中，让我们尝试安装 [NERDTree](<a href="https://github.com/preservim/nThe">https://github.com/preservim/nThe</a> package system won’t work. It is imperative to put a name between <code>pack/</code> and <code>start/</code>.erdtree) 插件。用任意方法进入 <code>start/</code> 目录（<code>cd ~/.vim/pack/packdemo/start/</code>），然后将NERDTree的仓库克隆下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/preservim/nerdtree.git</span><br></pre></td></tr></table></figure><p>完成了！您已经完成了安装。下一次您启动Vim，您可以立即执行 NERDTree 命令 <code>:NERDTreeToggle</code>。</p><p>在 <code>~/.vim/pack/*/start/</code> 目录中，您想克隆多少插件仓库就克隆多少。Vim将会自动加载每一个插件。如果您删除了克隆的仓库（<code>rm -rf nerdtree</code>），那么插件就失效了。</p><h3 id="手动加载"><a class="markdownIt-Anchor" href="#手动加载"></a> 手动加载</h3><p>要想在Vim启动时手动加载插件，您得将相关插件放置在 <code>opt/</code> 目录中，类似于自动加载，这个路径看起来像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/opt/</span><br></pre></td></tr></table></figure><p>让我们继续使用前面的 <code>packdemo/</code> 这个名字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/packdemo/opt/</span><br></pre></td></tr></table></figure><p>这一次，让我们安装<a href="https://github.com/vim/killersheep">killersheep</a> 游戏（需要Vim8.2以上版本）。进入<code>opt/</code> 目录(<code>cd ~/.vim/pack/packdemo/opt/</code>) 然后克隆仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vim/killersheep.git</span><br></pre></td></tr></table></figure><p>启动Vim。执行游戏的命令是 <code>:KillKillKill</code>。试着运行一下。Vim将会提示这不是一个有效的编辑命令。您需要首先 <em>手动</em> 加载插件，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:packadd killersheep</span><br></pre></td></tr></table></figure><p>现在再运行一下 <code>:KillKillKill</code> 。命令已经可以使用了。</p><p>您可能好奇，“为什么我需要手动加载插件？启动时自动加载岂不是更好？”</p><p>很好的问题。有时候有些插件我们并不是所有的时候都在用，比如 KillerSheep 游戏。您可能不会想要加载10个不同的游戏导致Vim启动变慢。但是偶尔当您觉得乏味的时候，您可能想要玩几个游戏，使用手动加载一些非必须的插件。</p><p>您也可以使用这个方法有条件的加载插件。可能您同时使用了Neovim和Vim，有一些插件是为NeoVim优化过的。您可以添加类似下列的内容到您的vimrc中：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> has(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">  packadd! neovim-only-plugin</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  packadd! generic-vim-plugin</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h2 id="组织管理软件包"><a class="markdownIt-Anchor" href="#组织管理软件包"></a> 组织管理软件包</h2><p>回想一下，要使用Vim的软件包系统必须有以下需求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/start/</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/opt/</span><br></pre></td></tr></table></figure><p>实际上，<code>*</code>星号可以使 <em>任意</em> 名字，这个名字就可以用来管理您的插件。假设您想将您的插件根据类型（颜色、语法、游戏）分组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/colors/</span><br><span class="line">~/.vim/pack/syntax/</span><br><span class="line">~/.vim/pack/games/</span><br></pre></td></tr></table></figure><p>您仍然可以使用各个目录下的 <code>start/</code> 和 <code>opt/</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/colors/start/</span><br><span class="line">~/.vim/pack/colors/opt/</span><br><span class="line"></span><br><span class="line">~/.vim/pack/syntax/start/</span><br><span class="line">~/.vim/pack/syntax/opt/</span><br><span class="line"></span><br><span class="line">~/.vim/pack/games/start/</span><br><span class="line">~/.vim/pack/games/opt/</span><br></pre></td></tr></table></figure><h2 id="聪明地添加插件"><a class="markdownIt-Anchor" href="#聪明地添加插件"></a> 聪明地添加插件</h2><p>您可能好奇，Vim软件包是否让一些流行的插件管理器，比如 vim-pathogen, vundle.vim, dein.vim, a还有vim-plug面临淘汰？</p><p>答案永远是：“看情况而定。”</p><p>我仍然使用vim-plug，因为使用它添加、删除、更新插件很容易。如果您使用了很多插件，插件管理器的好处更加明显，因为使用它可以对很多插件进行同时更新。有些插件管理器同时也提供了一些异步功能。</p><p>如果您是极简主义者，可以尝试一下Vim软件包。如果您是一名插件重度使用者，您可能需要一个插件管理器。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/29ce7871/">Ch 22 - Vimrc</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/2d5c14f7/">Ch 24 - Vim Runtime</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch22-Vimrc</title>
      <link href="/posts/29ce7871.html"/>
      <url>/posts/29ce7871.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在先前的章节中，您学习了如何使用Vim。在本章，您将学习如何组织和配置Vimrc。</p><h2 id="vim如何找到vimrc"><a class="markdownIt-Anchor" href="#vim如何找到vimrc"></a> Vim如何找到Vimrc</h2><p>对于Vimrc，常见的理解是在根目录下添加一个 <code>.vimrc</code> 点文件（根据您使用的操作系统，文件路径名可能不同）。</p><p>实际上，Vim在多个地方查找vimrc文件。下面是Vim检查的路径：</p><ul><li><code>$VIMINIT</code></li><li><code>$HOME/.vimrc</code></li><li><code>$HOME/.vim/vimrc</code></li><li><code>$EXINIT</code></li><li><code>$HOME/.exrc</code></li><li><code>$VIMRUNTIME/default.vim</code></li></ul><p>当您启动Vim时，它将在上面列出的6个位置按顺序检查vimrc文件，第一个被找到的vimrc文件将被加载，而其余的将被忽略。</p><p>首先，Vim将查找环境变量 <code>$VIMINIT</code>。如果没有找到，Vim将检查 <code>$HOME/.vimrc</code>。如果还没找到，VIm就检查 <code>$HOME/.vim/vimrc</code>。如果Vim找到了vimrc文件，它就停止查找，并使用 <code>$HOME/.vim/vimrc</code>。</p><p>关于第一个位置，<code>$VIMINIT</code> 是一个环境变量。默认情况下它是未定义的。如果您想将 <code>~/dotfiles/testvimrc</code> 作为 <code>$VIMINTI</code> 的值，您可以创建一个包含那个vimrc路径的环境变量。当您运行 <code>export VIMINIT='let $MYVIMRC=&quot;$HOME/dotfiles/testvimrc&quot; | source $MYVIMRC'</code>后，VIm将使用 <code>~/dotfiles/testvimrc</code> 作为您的vimrc文件。</p><p>第二个位置，<code>$HOME/.vimrc</code> 是很多Vim用户习惯使用的路径。<code>$HOME</code> 大部分情况下是您的根目录（<code>~</code>）。如果您有一个 <code>~/.vimrc</code> 文件，Vim将使用它作为您的vimrc文件。</p><p>第三个，<code>$HOME/.vim/vimrc</code>，位于 <code>~/.vim</code> 目录中。您可能已经有了一个 <code>~/.vim</code> 目录用于存放插件、自定义脚本、或视图文件。注意这里的vimrc文件名没有“点”（<code>$HOME/.vim/.vimrc</code> 不会被识别，但 <code>$HOME/.vim/vimrc</code>能被识别）。</p><p>第四个，<code>$EXINIT</code> 工作方式与 <code>$VIMINIT</code> 类似。</p><p>第五个，<code>$HOME/.exrc</code> 工作方式与 <code>$HOME/.vimrc</code> 类似。</p><p>第六个，<code>$VIMRUNTIME/defaults.vim</code> 是Vim编译时自带的默认vimrc文件。在我的电脑中，我是使用Homebrew安装的Vim8.2，所以我的路径是（<code>/usr/local/share/vim/vim82</code>）。如果Vim在前5个位置都没有找到vimrc文件，它将使用这个Vim自带的vimrc文件。</p><p>在本章剩余部分，我将假设vimrc使用的路径是 <code>~/.vimrc</code>。</p><h2 id="应该把什么放在vimrc中"><a class="markdownIt-Anchor" href="#应该把什么放在vimrc中"></a> 应该把什么放在Vimrc中？</h2><p>我刚开始配置Vimrc时，曾问过一个问题，“我究竟该把什么放在Vimrc文件中？”。</p><p>答案是，“任何您想放的东西”。 直接复制粘贴别人的vimrc文件的确是一个诱惑，但您应当抵制这个诱惑。如果您仍然坚持使用别人的vimrc文件，确保您知道这个vimrc干了什么，为什么他/她要用这些设置？以及他/她如何使用这些设置？还有最重要的是，这个vimrc文件是否符合你的实际需要？别人使用并不代表您也要使用。</p><h2 id="vimrc基础内容"><a class="markdownIt-Anchor" href="#vimrc基础内容"></a> Vimrc基础内容</h2><p>简单地说，一个vimrc是以下内容的集合：</p><ul><li>插件</li><li>设置</li><li>自定义函数</li><li>自定义命令</li><li>键盘映射</li></ul><p>当然还有一些上面没有提到的内容，但总体说，已经涵盖了绝大部分使用场景。</p><h3 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h3><p>在前面的章节中，我曾提到很多不同的插件，比如<a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>, <a href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a>, 还有 <a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a>.</p><p>十年前，管理插件插件是一个噩梦。但随着很多现代插件管理器的开发，现在安装插件可以在几秒内完成。我现在正在使用<a href="https://github.com/junegunn/vim-plug">vim-plug</a>作为我的插件管理器，所以我在本节中将使用它。相关概念和其他流行的插件管理器应该是类似的。我强烈建议您多试试几个插件管理器，比如：</p><ul><li><a href="https://github.com/VundleVim/Vundle.vim">vundle.vim</a></li><li><a href="https://github.com/tpope/vim-pathogen">vim-pathogen</a></li><li><a href="https://github.com/Shougo/dein.vim">dein.vim</a></li></ul><p>除了上面列出的，还有很多插件管理器，可以随便看看。要想安装 vim-plug，如果您使用的是Unix，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>要添加新的插件，将您的插件名(比如，<code>Plug 'github-username/repository-name'</code>) 放置在 <code>call plug#begin()</code> 和 <code>call plug#end()</code> 之间的行中. 所以，如果您想安装 <code>emmet-vim</code> 和 <code>nerdtree</code>，将下面的片段放到您的vimrc中：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="comment">#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line">  Plug <span class="string">&#x27;mattn/emmet-vim&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure><p>然后保存修改，加载当前vimrc (<code>:source %</code>), 然后运行 <code>:PlugInstall</code> 安装插件。</p><p>如果以后您想删除不使用的插件，您只需将插件名从 <code>call</code> 代码块之间移除，保存并加载，然后运行 <code>:PlugClean</code> 命令将它从机器上删除。</p><p>Vim 8 有自己的内置包管理器。您可以查阅 <code>:h packages</code> 了解更多信息。在后面一章中，我将向您展示如何使用它。</p><h3 id="设置"><a class="markdownIt-Anchor" href="#设置"></a> 设置</h3><p>在任意一个vimrc文件中都可以看到大量的 <code>set</code> 选项。 如果您在命令行模式中运行 set 命令，它只是暂时的。当您关闭Vim，设置就会丢失。比如，为了避免您每次运行Vim时都必须在命令行模式运行 <code>:set relativenumber number</code> 命令，您可以将这个命令添加在vimrc中：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set relativenumber number</span><br></pre></td></tr></table></figure><p>有一些设置需要您赋予一个值，比如 <code>set tabstop=2</code>。想了解一个设置可以接收什么类型的值，可以查看帮助页。</p><p>您也可以使用 <code>let</code> 来代替 <code>set</code>（确保在选项前添加一个 <code>&amp;</code>号）。使用 <code>let</code> ，您可以使用表达式进行赋值。比如，要想仅当某个路径存在时，才将该路径赋予 <code>'dictionary'</code> 选项：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s:english_dict = <span class="string">&quot;/usr/share/dict/words&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filereadable(s:english_dict)</span><br><span class="line">  let &amp;dictionary=s:english_dict</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>在后面的章节中您将了解关于Vimscript赋值和条件的知识。</p><p>要查看Vim中所有可用的选项，查阅 <code>:h E355</code>。</p><h3 id="自定义函数"><a class="markdownIt-Anchor" href="#自定义函数"></a> 自定义函数</h3><p>Vimrc是一个很好的用来放置自定义函数的地方。在后面的章节中您将学习如何写您自己的Vimscript函数。</p><h3 id="自定义命令"><a class="markdownIt-Anchor" href="#自定义命令"></a> 自定义命令</h3><p>您可以使用 <code>command</code> 创建一个自定义命令行命令。</p><p>比如，创建一个用于显示今天日期的基本命令 <code>GimmeDate</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:command! GimmeDate echo call(&quot;strftime&quot;, [&quot;%F&quot;])</span><br></pre></td></tr></table></figure><p>当您运行 <code>:GimmeDate</code> 时，Vim将显示一个类似 &quot;2021-01-1&quot;的日期。</p><p>要创建一个可以接收输入的基本命令，您可以使用 <code>&lt;args&gt;</code> 。如果您想向 <code>GimmeDate</code> 传递一个时间/日期格式参数：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:command! GimmeDate echo call(<span class="string">&quot;strftime&quot;</span>, [&lt;args&gt;])</span><br><span class="line"></span><br><span class="line">:GimmeDate <span class="string">&quot;%F&quot;</span></span><br><span class="line"><span class="string">&quot; 2020-01-01</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:GimmeDate &quot;</span>%H:%M<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> <span class="number">11</span>:<span class="number">30</span></span><br></pre></td></tr></table></figure><p>如果您想限定参数的数目，您可以使用 <code>-nargs</code> 标志。<code>-nargs=0</code> 表示没有参数，<code>-nargs=1</code> 表示传递1个参数，<code>-nargs=+</code> 表示至少1个参数，<code>-nargs=*</code> 表示传递任意数量的参数，<code>-nargs=?</code> 表示传递0个或1个参数。如果您想传递n个参数，使用 <code>-nargs=n</code>（这里 <code>n</code> 是一个任意整数）。</p><p><code>&lt;args&gt;</code> 有两个变体：<code>&lt;f-args&gt;</code> 和 <code>&lt;q-args&gt;</code> 。前者用来向Vimscript函数传递参数，后者用来将用户输入自动转换为字符串。</p><p>使用 <code>args</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:command! -nargs=<span class="number">1</span> Hello echo <span class="string">&quot;Hello &quot;</span> . &lt;args&gt;</span><br><span class="line">:Hello <span class="string">&quot;Iggy&quot;</span></span><br><span class="line"><span class="string">&quot; returns &#x27;Hello Iggy&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:Hello Iggy</span></span><br><span class="line"><span class="string">&quot;</span> Undefined variable error</span><br></pre></td></tr></table></figure><p>使用 <code>q-args</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:command! -nargs=<span class="number">1</span> Hello echo <span class="string">&quot;Hello &quot;</span> . &lt;<span class="keyword">q</span>-args&gt;</span><br><span class="line">:Hello Iggy</span><br><span class="line"><span class="string">&quot; returns &#x27;Hello Iggy&#x27;</span></span><br></pre></td></tr></table></figure><p>使用 <code>f-args</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:function! PrintHello(person1, person2)</span><br><span class="line">:  echo <span class="string">&quot;Hello &quot;</span> . a:person1 . <span class="string">&quot; and &quot;</span> . a:person2</span><br><span class="line">:endfunction</span><br><span class="line"></span><br><span class="line">:command! -nargs=* Hello call PrintHello(&lt;f-args&gt;)</span><br><span class="line"></span><br><span class="line">:Hello Iggy1 Iggy2</span><br><span class="line"><span class="string">&quot; returns &quot;</span>Hello Iggy1 <span class="keyword">and</span> Iggy2<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>当您学了关于Vimscript函数的章节后，上面的函数将更有意义。</p><p>查阅 <code>:h command</code> 和 <code>:args</code> 了解更多关于command和args的信息。</p><h3 id="键盘映射"><a class="markdownIt-Anchor" href="#键盘映射"></a> 键盘映射</h3><p>如果您发现您重复地执行一些相同的复杂操作，那么为这些复杂操作建立一个键盘映射将会很有用：</p><p>比如，在我的vimrc文件中有2个键盘映射：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;silent&gt; &lt;C-f&gt; :GFiles&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">nnoremap &lt;Leader&gt;tn :call ToggleNumber()&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>在第一个中，我将 <code>Ctrl-F</code> 映射到 <a href="https://github.com/junegunn/fzf.vim">fzf.vim</a> 插件的 <code>:Gfiles</code> 命令(快速搜索Git文件)上。在第二个中，我将 <code>&lt;leader&gt;tn</code> 映射到调用一个自定义函数 <code>ToggleNumber</code> （切换 <code>norelativenumber</code> 和 <code>relativenumber</code> 选项）。<code>Ctrl-f</code> 映射覆盖了Vim的原生的页面滚动。如果发生冲突，您的映射将会覆盖Vim的设置。因为从几乎从来不用Vim原生的页面滚动功能，所以我认为可以安全地覆盖它。</p><p>另外，在 <code>&lt;Leader&gt;tn</code> 中的 “leader” 键到底是什么?</p><p>Vim有一个leader键用来辅助键盘映射。比如，我将 <code>&lt;leader&gt;tn</code> 映射为运行 <code>ToggleNumber()</code> 函数。如果没有leader键，我可能会用 <code>tn</code>，但Vim中的 <code>t</code> 已经用做其他功能（&quot;till&quot;搜索导航命令）了。有了leader键，我现在先按定义好的leader键作为开头，然后按 <code>tn</code>，而不用干扰已经存在的命令。您可以设置leader键作为您映射的连续按键的第一个按键。默认Vim使用反斜杠作为leader键（所以 <code>&lt;Leader&gt;tn</code> 会变成 “反斜杠-t-n”）。</p><p>我个人喜欢使用空格 <code>&lt;Space&gt;</code> 作为leader键，代替默认的反斜杠。要想改变您的leader键，将下面的文本添加到您的vimrc中：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mapleader = <span class="string">&quot;\&lt;space&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>上面的 <code>nnoremap</code> 命令可以分解为三个部分：</p><ul><li><code>n</code> 表示普通模式。</li><li><code>nore</code> 表示禁止递归。</li><li><code>map</code> 是键盘映射命令。</li></ul><p>如果不想使用 <code>nnoremap</code>，您至少也得使用 <code>nmap</code> (<code>nmap &lt;silent&gt; &lt;C-f&gt; :Gfiles&lt;CR&gt;</code>)。但是，最好还是使用禁止递归的版本，这样是为了避免键盘映射时潜在的无限循环风险。</p><p>如果您进行键盘映射时不使用禁止递归，下面例子演示了会发生什么。假设您想给 <code>B</code> 添加一个键盘映射，用来在一行的末尾添加一个分号，然后跳回前一个词组（回想一下，<code>B</code> 是Vim普通模式的一个导航命令，用来跳回前一个词组)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap B A;&lt;esc&gt;B</span><br></pre></td></tr></table></figure><p>当您按下 <code>B</code> …哦豁，Vim开始失控了，开始无止尽的添加<code>;</code>（用 <code>Ctrl-c</code>终止）。为什么会发生这样的情况？因为在键盘映射 <code>A;&lt;esc&gt;B</code>中，这个 <code>B</code>不再是Vim原生的导航命令，它已经被映射到您刚才创建的键盘映射中了。这是您实际上执行的操作序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A;&lt;esc&gt;A;&lt;esc&gt;A;&lt;esc&gt;A;esc&gt;...</span><br></pre></td></tr></table></figure><p>要解决这个问题，您需要指定键盘映射禁止递归：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap B A;&lt;esc&gt;B</span><br></pre></td></tr></table></figure><p>现在再按一下 <code>B</code> 试试。这一次它成功地在行尾添加了一个 <code>;</code>，然后跳回到前一个词组。这个映射中的 <code>B</code> 就表示Vim原生的 <code>B</code>了。</p><p>Vim针对不同的模式有不同的键盘映射命令。如果您想创建一个插入模式下的键盘映射 <code>jk</code>，用来退出插入模式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure><p>其他模式的键盘映射命令有：<code>map</code>（普通、可视、选择、以及操作符等待模式）， <code>vmap</code>（可视、选择）， <code>smap</code>（选择）， <code>xmap</code>（可视）， <code>omap</code>（操作符等待模式）， <code>map!</code>（插入、命令行）， <code>lmap</code>（插入，命令行，Lang-arg模式）， <code>cmap</code>（命令行）， 还有<code>tmap</code>（终端任务）。在这里我不会详细的讲解它们，要了解更多信息，查阅 <code>:h map.txt</code>。</p><p>创建最直观、最一致、最易于记忆的键盘映射。</p><h2 id="组织管理vimrc"><a class="markdownIt-Anchor" href="#组织管理vimrc"></a> 组织管理Vimrc</h2><p>一段时候键，您的vimrc文件就会变大且复杂得难以阅读。有两种方法让您的vimrc文件保持整洁：</p><ul><li>将您的vimrc文件划分为几个文件</li><li>折叠您的vimrc文件</li></ul><h3 id="划分您的vimrc"><a class="markdownIt-Anchor" href="#划分您的vimrc"></a> 划分您的vimrc</h3><p>您可以使用Vim的 <code>:source</code> 命令将您的vimrc文件划分为多个文件。这个命令可以根据给定的文件参数，读取文件中的命令行命令。</p><p>让我们在 <code>~/.vim</code> 下创建一个子文件夹，取名为 <code>/settings</code>（<code>~/.vim/settings</code>）。名字可以取为任意您喜欢的名字。</p><p>然后你在这个文件夹下创建4个文件：</p><ul><li>第三方插件 (<code>~/.vim/settings/plugins.vim</code>).</li><li>通用设置 (<code>~/.vim/settings/configs.vim</code>).</li><li>自定义函数 (<code>~/.vim/settings/functions.vim</code>).</li><li>键盘映射 (<code>~/.vim/settings/mappings.vim</code>) .</li></ul><p>在 <code>~/.vimrc</code> 里面添加:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source $HOME/.vim/settings/plugins.vim</span><br><span class="line">source $HOME/.vim/settings/configs.vim</span><br><span class="line">source $HOME/.vim/settings/functions.vim</span><br><span class="line">source $HOME/.vim/settings/mappings.vim</span><br></pre></td></tr></table></figure><p>在 <code>~/.vim/settings/plugins.vim</code> 里面:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="comment">#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line">  Plug <span class="string">&#x27;mattn/emmet-vim&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure><p>在 <code>~/.vim/settings/configs.vim</code> 里面:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">set relativenumber</span><br><span class="line">set number</span><br></pre></td></tr></table></figure><p>在 <code>~/.vim/settings/functions.vim</code> 里面:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function! ToggleNumber()</span><br><span class="line">  <span class="keyword">if</span>(&amp;relativenumber == <span class="number">1</span>)</span><br><span class="line">    set norelativenumber</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    set relativenumber</span><br><span class="line">  endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure><p>在 <code>~/.vim/settings/mappings.vim</code> 里面:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inoremap jk &lt;esc&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;C-f&gt; :GFiles&lt;CR&gt;</span><br><span class="line">nnoremap &lt;Leader&gt;tn :call ToggleNumber()&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>这样您的vimrc文件依然能够正常工作，但现在它只有4行了。</p><p>使用这样的设置，您可以轻易知道到哪去修改配置。如果您要添加一些键盘映射，就将它们添加在 <code>/mappings.vim</code> 文件中。以后，当您的vimrc变大时，您总是可以新建几个子文件来缩小它的大小。比如，如果您想为主题配色创建相关设置，您可以添加 <code>~/.vim/settings/themes.vim</code>。</p><h3 id="保持单独的一个vimrc文件"><a class="markdownIt-Anchor" href="#保持单独的一个vimrc文件"></a> 保持单独的一个Vimrc文件</h3><p>如果您倾向于保持一个单独的vimrc文件，以使它更加便于携带，您可以使用标志折叠让它保持有序。在vimrc文件的顶部添加一下内容：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; setup folds &#123;&#123;&#123;</span></span><br><span class="line"><span class="string">augroup filetype_vim</span></span><br><span class="line"><span class="string">  autocmd!</span></span><br><span class="line"><span class="string">  autocmd FileType vim setlocal foldmethod=marker</span></span><br><span class="line"><span class="string">augroup END</span></span><br><span class="line"><span class="string">&quot;</span> &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>Vim能够检测当前buffer所属的文件类型 (<code>:set filetype?</code>). 如果发现属于 <code>vim</code> 类型，您可以使用标志折叠。回想一个标志折叠的用法，它使用 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 来指明折叠的开始和结束。</p><p>添加 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 标志将您的vimrc文件其他部分折叠起来。(别忘了使用 <code>&quot;</code> 对标志进行注释):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; setup folds &#123;&#123;&#123;</span></span><br><span class="line"><span class="string">augroup filetype_vim</span></span><br><span class="line"><span class="string">  autocmd!</span></span><br><span class="line"><span class="string">  autocmd FileType vim setlocal foldmethod=marker</span></span><br><span class="line"><span class="string">augroup END</span></span><br><span class="line"><span class="string">&quot;</span> &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; plugins &#123;&#123;&#123;</span></span><br><span class="line"><span class="string">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line"><span class="string">  Plug &#x27;mattn/emmet-vim&#x27;</span></span><br><span class="line"><span class="string">  Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br><span class="line"><span class="string">&quot;</span> &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; configs &#123;&#123;&#123;</span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string">set relativenumber</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">&quot;</span> &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; functions &#123;&#123;&#123;</span></span><br><span class="line"><span class="string">function! ToggleNumber()</span></span><br><span class="line"><span class="string">  if(&amp;relativenumber == 1)</span></span><br><span class="line"><span class="string">    set norelativenumber</span></span><br><span class="line"><span class="string">  else</span></span><br><span class="line"><span class="string">    set relativenumber</span></span><br><span class="line"><span class="string">  endif</span></span><br><span class="line"><span class="string">endfunc</span></span><br><span class="line"><span class="string">&quot;</span> &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; mappings &#123;&#123;&#123;</span></span><br><span class="line"><span class="string">inoremap jk &lt;esc&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;silent&gt; &lt;C-f&gt; :GFiles&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;tn :call ToggleNumber()&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span> &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>您的vimrc文件将会看起来类似下面：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-- <span class="number">6</span> lines: setup folds -----</span><br><span class="line"></span><br><span class="line">+-- <span class="number">6</span> lines: plugins ---------</span><br><span class="line"></span><br><span class="line">+-- <span class="number">5</span> lines: configs ---------</span><br><span class="line"></span><br><span class="line">+-- <span class="number">9</span> lines: functions -------</span><br><span class="line"></span><br><span class="line">+-- <span class="number">5</span> lines: mappings --------</span><br></pre></td></tr></table></figure><h2 id="启动vim时加载不加载vimrc和插件"><a class="markdownIt-Anchor" href="#启动vim时加载不加载vimrc和插件"></a> 启动Vim时加载/不加载Vimrc和插件</h2><p>如果您要启动Vim时，既不加载Vimrc，也不加载插件，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -u NONE</span><br></pre></td></tr></table></figure><p>如果您要启动Vim时，不加载Vimrc，但加载插件，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -u NORC</span><br></pre></td></tr></table></figure><p>如果您要启动Vim时，加载Vimrc，但不加载插件，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --noplugin</span><br></pre></td></tr></table></figure><p>如果您要Vim启动加载一个 <em>其他的</em> vimrc, 比如 <code>~/.vimrc-backup</code>, 运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -u ~/.vimrc-backup</span><br></pre></td></tr></table></figure><h2 id="聪明地配置vimrc"><a class="markdownIt-Anchor" href="#聪明地配置vimrc"></a> 聪明地配置Vimrc</h2><p>Vimrc是定制Vim时的一个重要组件，学习构建您的Vimrc最好是首先阅读他人的vimrc文件，然后逐渐地建立自己的。最好的vimrc并不是谁谁谁使用的，而是最适合您的工作需要和编辑风格的。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/0783c3af/">Ch 21 - 多文件操作</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/ad9bd3e0/">Ch 23 - Vim软件包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch21-多文件操作</title>
      <link href="/posts/0783c3af.html"/>
      <url>/posts/0783c3af.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>多文件编辑更新是一个值得掌握、非常有用的编辑工具。前面您已经学会了如何使用 <code>cfdo</code> 命令在多个文本中进行更新。本章，您将学到如何在Vim中进行多文件编辑的更多不同方法。</p><h2 id="在多个文件中执行命令的几种方法"><a class="markdownIt-Anchor" href="#在多个文件中执行命令的几种方法"></a> 在多个文件中执行命令的几种方法</h2><p>要在多个文件中执行命令，Vim有8种方法：</p><ul><li>参数列表 (<code>argdo</code>)</li><li>缓冲区列表 (<code>bufdo</code>)</li><li>窗口列表 (<code>windo</code>)</li><li>tab 列表(<code>tabdo</code>)</li><li>快速修复列表 (<code>cdo</code>)</li><li>文件方式的快速修复列表 (<code>cfdo</code>)</li><li>位置列表 (<code>ldo</code>)</li><li>文件方式的位置列表 (<code>lfdo</code>)</li></ul><p>实际上，大部分时间您可能只会用到1种或2种（就我个人而言，我使用 <code>cdo</code> 和 <code>argdo</code>比其他的多得多），但了解所有可行方法还是很有用的，这样您就可以选择一个最符合您个人编辑风格的方法。</p><p>学习所有8个命令可能听起来让人有点打退堂鼓。但实际上，这些命令工作方式很相似。学习了其中一个后，再学习剩余的将容易的多。它们的运行方式都大体相同：分别创建一个列表(列表中的元素根据命令有所不同)，然后向列表传递一个您想执行的命令。</p><h2 id="参数列表"><a class="markdownIt-Anchor" href="#参数列表"></a> 参数列表</h2><p>参数列表是最基础的列表。它创建一个文件列表。要想为 file1, file2, file3创建文件列表，您可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args file1 file2 file3</span><br></pre></td></tr></table></figure><p>您也可以传递一个通配符（<code>*</code>），所以如果您想为当前目录下所有的 <code>.js</code> 文件创建一个列表，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args *.js</span><br></pre></td></tr></table></figure><p>如果您想为当前目录下所有以 “a” 开头的Javascript文件创建列表，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args a*.js</span><br></pre></td></tr></table></figure><p>（<code>*</code>）通配符匹配当前目录下的1个或多个任意文件名中的字符。但如果您想在某个目录下进行递归搜索怎么办呢？您可以使用双通配符（<code>**</code>）。要得到您当前位置下所有子目录中的Javascript文件，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args **/*.js</span><br></pre></td></tr></table></figure><p>您运行了 <code>args</code> 命令后，您的当前buffer将会切换到列表中的第一个文件。运行 <code>:args</code>可以查看您刚才创建的文件列表。当您创建好了您的列表后，您就可以遍历它们了。<code>:first</code> 将让您跳至列表中的第一个文件。<code>:last</code> 将跳到最后一个文件。运行<code>:next</code>可以在列表中一次向前移动一个文件。运行 <code>:prev</code>可以在列表中一次向后移动一个文件。运行<code>:wnext</code> 和 <code>:wprev</code>命令，在向前/向后移动文件的同时还会保存修改。查阅 <code>: arglist</code> 了解更多导航命令。</p><p>参数列表在定位某个特定类型的文件或少量文件时特别有用。假如您需要将所有 <code>yml</code> 文件中的<code>donut</code> 更新为 <code>pancake</code>。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:args **/*.yml</span><br><span class="line">:argdo %s/donut/pancake/g | update</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意如果您再次执行 <code>args</code> 命令，它将覆盖先前的列表。比如，如果您先前运行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args file1 file2 file3</span><br></pre></td></tr></table></figure><p>假设这些文件都是存在的，那么现在您的列表为 <code>file1</code>, <code>file2</code>,以及 <code>file3</code>。然后再运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args file4 file5</span><br></pre></td></tr></table></figure><p>您的初始列表 <code>file1</code>, <code>file2</code>, <code>file3</code>将被覆盖为 <code>file4</code>, <code>file5</code>。如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code> ，而您想将 <code>file4</code>, <code>file5</code> 添加到初始列表中，请使用 <code>:arga</code>命令。运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:arga file4 file5</span><br></pre></td></tr></table></figure><p>现在您的列表为<code>file1</code>, <code>file2</code>, <code>file3</code>, <code>file4</code>, <code>file5</code>。</p><p>如果您运行 <code>:arga</code> 时没有给任何参数，Vim会添加当前buffer到参数列表中。例如，如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code>，而您当前buffer是 <code>file5</code>，运行 <code>:arga</code> 将添加 <code>file5</code> 到您的列表中。</p><p>在前面的命令（<code>:argdo %s/donut/pancake/g</code>）中您已经看到过了，当您创建好列表后就可以向它传递任意命令行命令。其他的一些示例：</p><ul><li>删除参数列表所有文件内包含 “dessert” 的行, 运行 <code>:argdo g/dessert/d</code>.</li><li>在参数列表每个文件中执行宏a(假设您已经在a中录好了一个宏)，运行 <code>:argdo norm @a</code>.</li><li>向参数列表所有文件的第一行插入&quot;hello &quot;+文件名 ，运行 <code>:argdo 0put='hello ' . @%</code>（译者注：在英文版中，原作者给出的命令是 <code>:argdo 0put='hello ' .. @:</code>，貌似这个命令有问题）。</li></ul><p>把所有工作完成后，别忘了使用 <code>:update</code> 命令保存(<code>:update</code>只会保存当前buffer，要保存列表所有文件的修改，请用 <code>:argdo update</code>)。</p><p>有时候您仅仅需要在参数列表的前n个文件执行某条命令。如果是这种情况，只需要向 <code>argdo</code> 命令传递一个地址就可以了。比如，要在列表的前3个文件执行替换命令，运行：<code>:1,3argdo %s/donut/pancake/g</code>。</p><h2 id="缓冲区列表"><a class="markdownIt-Anchor" href="#缓冲区列表"></a> 缓冲区列表</h2><p>因为每次您创建新文件或打开文件时，Vim将它保存在一个buffer中（除非您显式地删除它），所以当您编辑新文件时，缓冲区列表就有组织地被创建了。如果您已经打开了3个文件：<code>file1.rb file2.rb file3.rb</code>，您的缓冲区列表就已经有了3个元素。运行 <code>:buffers</code>（或者<code>:ls</code>、或<code>:files</code>）可以显示缓冲区列表。要想向前或向后遍历缓冲区列表，可以使用 <code>:bnext</code> <code>:bprev</code>。要想跳至列表中第一个或最后一个buffer，可使用 <code>:bfirst</code> 和 <code>:blast</code>。</p><p>另外，这里有一个和本章内容不相关，但是很酷的缓冲区技巧：如果您的缓冲区有大量的文件，您可以使用 <code>:ball</code> 显示所有缓冲区。<code>:ball</code> 命令默认使用水平分割窗口进行显示，如果想使用垂直分割的窗口显示，运行：<code>:vertical ball</code></p><p>回到本章主题。在缓冲区列表中执行某个操作的方法与参数列表操作非常相似。当您创建好缓冲区列表后，您只需要在您想执行的命令前用 <code>:bufdo</code> 代替 <code>:argdo</code>就可以了。例如，如果您想将缓冲区列表内每个文件中所有的 “donut” 替换为 &quot;pancake&quot;并保存修改，可以运行：<code>:bufdo %s/donut/pancake/g | update</code>。</p><h2 id="窗口列表和选项卡tab列表"><a class="markdownIt-Anchor" href="#窗口列表和选项卡tab列表"></a> 窗口列表和选项卡（Tab）列表</h2><p>窗口列表、选项卡列表的操作和参数列表、缓冲区列表同样非常相似。唯一的区别在于它们的内容和语法。</p><p>窗口操作作用在每一个打开的窗口上，使用的命令是 <code>:windo</code>。选项卡（Tab）操作作用在每一个打开的选项卡上，使用的命令是 <code>:tabdo</code>。可以查询 <code>:h list-repeat</code>, <code>:h :windo</code>和<code>:h :tabdo</code>，了解更多信息。</p><p>比如，如果您打开了4个窗口（您可以使用 <code>Ctrl-w v</code>打开一个垂直分割的窗口，也可以使用 <code>Ctrl-w s</code>打开一个水平分割的窗口），然后您运行 <code>:windo 0put = 'hello' . @%</code>，Vim将在所有打开的窗口的第一行输出 “hello”+文件名。</p><h2 id="快速修复列表"><a class="markdownIt-Anchor" href="#快速修复列表"></a> 快速修复列表</h2><p>在前面的章节中（第3章和第19章），我曾提到过快速修复（quickfix）。快速修复有很多作用，很多流行的插件都在使用快速修复提供的功能，因此值得花时间去理解它。</p><p>如果您是Vim新手，快速修复对于您可能是个新概念。回想以前您执行代码编译的时候，编译期间您可能遇到过错误，而这些错误都显示在一个特殊的窗口。这就是快速修复(quickfix)的由来。当您编译您的代码的时候，Vim会在快速修复窗口显示错误信息，您可以稍后去解决。许多现代语言已经不再需要进行显式地编译，但快速修复并没有被淘汰。现在，人们使用快速修复来做各种各样的事，比如显示虚拟终端的输入、存储搜索结果等。我们重点研究后者，存储搜索结果。</p><p>除编译命令外，某些特定的Vim命令也依赖快速修复接口。其中一种就是搜索命令，其使用过程中大量的使用了快速修复窗口，<code>:vimgrep</code> 和 <code>:grep</code> 都默认使用快速修复。</p><p>比如，如果您需要在所有的Javascript文件中递归地搜索 “donut”，您可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vimgrep /donut/ **/*.js</span><br></pre></td></tr></table></figure><p>“donut”的搜索结果存储在快速修复窗口中。要查看快速修复窗口的结果，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:copen</span><br></pre></td></tr></table></figure><p>要关闭快速修复窗口，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:cclose</span><br></pre></td></tr></table></figure><p>在快速修复列表中向前或向后遍历，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:cnext</span><br><span class="line">:cprev</span><br></pre></td></tr></table></figure><p>跳至第一个或最后一个匹配的元素，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:cfirst</span><br><span class="line">:clast</span><br></pre></td></tr></table></figure><p>在前面我提到过，有两种快速修复命令：<code>cdo</code> 和 <code>cfdo</code> 。它们有什么区别？<code>cdo</code> 在修复列表中的每一个元素上执行命令，而 <code>cfdo</code> 在修复列表中的每一个文件上执行命令。</p><p>让我讲清楚一点，假设运行完上面的 <code>vimgrep</code> 命令后，您找到以下结果：</p><ul><li>1 result in <code>file1.js</code></li><li>10 results in <code>file2.js</code></li></ul><p>如果您运行 <code>:cfdo %s/donut/pancake/g</code>, 这个命令将会在 <code>file1.js</code> 和 <code>file2.js</code> 上分别有效地运行一次<code>%s/donut/pancake/g</code>. 它执行的次数与 <em>匹配结果中文件的数量</em> 相同。因为搜索结果中有2个文件，因此Vim在 <code>file1.js</code> 上运行一次替换命令，在 <code>file2.js</code> 上再运行一次替换命令。 尽管在第二个文件中有10个搜索结果，但 <code>cfdo</code> 只关注快速修复列表中有多少个文件。</p><p>而如果您运行 <code>:cdo %s/donut/pancake/g</code> ，这个命令将会在 <code>file1.js</code> 上有效运行一次，然后在 <code>file2.js</code> 上运行10次。它执行的次数与 <em>快速修复列表中元素的数量</em> 相同。因为在 <code>file1.js</code> 上找到1个匹配结果，在 <code>file2.js</code> 上找到10个匹配结果，因此它执行的总次数是11次。</p><p>由于您要在列表中运行的命令是 <code>%s/donut/pancake/g</code> ，所以使用 <code>cfdo</code>命令是比较合理的。而使用 <code>cdo</code> 是不合理的，因为它将在 <code>file2.js</code> 中运行10次 <code>%s/donut/pancake/g</code>命令（<code>%s</code>已经是一个针对整个文件的替换操作）。一个文件运行一次 <code>%s</code> 就足够了。如果您使用 <code>cdo</code>，则传给它的命令应当改为 <code>s/donut/pancake/g</code> 才是合理的。</p><p>那到底什么时候该用 <code>cfdo</code>？什么时候该用 <code>cdo</code>？这应当想一想您要传递的命令的作用域，要看命令作用域是整个文件（比如 <code>:%s</code> 或 <code>:g</code>）？还是某一行（比如 <code>:s</code> 或 <code>:!</code>）？</p><h2 id="位置列表"><a class="markdownIt-Anchor" href="#位置列表"></a> 位置列表</h2><p>位置列表在某种意义上和快速修复列表很像。Vim也使用一个特殊的窗口来显示位置列表的信息。区别在于：您任何时候都只能有1个快速修复列表，而位置列表则是，有多少个窗口就可以有多少个位置列表。</p><p>假设您打开了两个窗口，其中一个窗口显示 <code>food.txt</code> ，而另一个显示 <code>drinks.txt</code>。在 <code>food.txt</code>里面，运行一个位置列表搜索命令 <code>:lvimgrep</code> （<code>:vimgrep</code>命令关于位置列表的一个变体）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:lvim /bagel/ **/*.md</span><br></pre></td></tr></table></figure><p>Vim将为 <code>food.txt</code>所在 <em>窗口</em>创建一个位置列表，用于存储所有的bagel搜索结果。用 <code>:lopen</code>命令可以查看位置列表。现在转到另一个窗口 <code>drinks.txt</code>，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:lvimgrep /milk/ **/*.md</span><br></pre></td></tr></table></figure><p>Vim将为 <code>drinks.txt</code>所在 <em>窗口</em>再创建一个 <em>单独</em>的位置列表，用于存储所有关于milk的搜索结果。</p><p>对于每个不同的窗口中您运行的位置命令，Vim都会单独创建一个位置列表。如果您有10个不同的窗口，您就可以有最多10个不同的位置列表。对比前面介绍的快速修复列表，快速修复列表任何时候都只能有1个。就算您有10个不同的窗口，您也只能有1个快速修复列表。</p><p>大多数位置列表命令都和快速修复列表命令相似，唯一不同就是位置列表命令有一个 <code>l-</code>前缀，比如： <code>:lvimgrep</code>, <code>:lgrep</code>, 还有 <code>:lmake</code>。在快速修复列表命令中与之对应的是: <code>:vimgrep</code>, <code>:grep</code>, 以及 <code>:make</code>。操作位置列表窗口的方式和快速修复窗口也很相似：<code>:lopen</code>, <code>:lclose</code>, <code>:lfirst</code>, <code>:llast</code>, <code>:lnext</code>, 还有<code>:lprev</code>，与之对应快速修复版本是：<code>:copen</code>, <code>:cclose</code>, <code>:cfirst</code>, <code>:clast</code>, <code>:cnext</code>, and <code>:cprev</code>。</p><p>两个位置列表参数的多文件操作命令也和快速修复列表的多文件操作命令也很类似：<code>:ldo</code> 和 <code>:lfdo</code>。<code>:ldo</code> 对位置列表中每一个元素执行命令，而 <code>:lfdo</code> 对位置列表中每一个文件执行命令。可以查阅 <code>:h location-list</code>了解更多信息。</p><h2 id="在vim中运行多文件操作命令"><a class="markdownIt-Anchor" href="#在vim中运行多文件操作命令"></a> 在Vim中运行多文件操作命令</h2><p>在编辑工作中，知道如何进行多文件操作是一个非常有用的技能。当您需要在多个文件中改变一个变量名字的时候，您肯定想一个操作就全部搞定。Vim有8种不同的方法支持你完成这个事。</p><p>事实上，您可能并不会用到所有8种方法。您会慢慢倾向于其中1中或2种。当您刚开始时，选择其中1个（我个人建议从参数列表开始 <code>:argdo</code>）并掌握它。当您习惯了其中1个，然后再学下一个。您将会发现，学习第二个、第三个、第四个时要容易多了。记得要创造性的使用，即将它和其他各种不同命令组合起来使用。坚持练习直到您可以不经思考地高效的使用它。让它成为您的肌肉记忆。</p><p>就像前面已经说过的，您现在已经掌握了Vim的编辑功能。恭喜您！</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/26a705fd/">Ch 20 - 视图、会话和 Viminfo</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/29ce7871/">Ch 22 - Vimrc</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch20-视图、会话和 Viminfo</title>
      <link href="/posts/26a705fd.html"/>
      <url>/posts/26a705fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><h1 id="第20章-视图-会话和-viminfo"><a class="markdownIt-Anchor" href="#第20章-视图-会话和-viminfo"></a> 第20章 视图、会话和 Viminfo</h1><p>当您做了一段时间的项目后，您可能会发现这个项目逐渐形了成自己的设置、折叠、缓冲区、布局等，就像住了一段时间公寓后，精心装饰了它一样。问题是，关闭 Vim 后，所有的这些更改都会丢失。如果能保留这些更改，等到下次打开 Vim 时，一切恢复如初，岂不美哉？</p><p>本章中，您将学习如何使用 视图、会话 和 Viminfo 来保存项目的“快照”。</p><h2 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h2><p>视图是这三个部分（视图、会话、Viminfo）中的最小子集，它是单个窗口相关设置的集合。如果您长时间在一个窗口上工作，并且想要保留其映射和折叠，您可以使用视图。</p><p>我们来创建一个 <code>foo.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo1</span><br><span class="line">foo2</span><br><span class="line">foo3</span><br><span class="line">foo4</span><br><span class="line">foo5</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure><p>在这个文件中，做三次修改：</p><ol><li>在第 1 行，创建一个手动折叠 <code>zf4j</code>（折叠接下来 4 行）。</li><li>更改 <code>number</code> 设置：<code>setlocal nonumber norelativenumber</code>。这会移除窗口左侧的数字指示器。</li><li>创建本地映射，每当按一次 <code>j</code> 时，向下两行：<code>:nnoremap &lt;buffer&gt; j jj</code>。</li></ol><p>您的文件看起来应该像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-- 5 lines: foo1 -----</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure><h3 id="配置视图属性"><a class="markdownIt-Anchor" href="#配置视图属性"></a> 配置视图属性</h3><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viewoptions?</span><br></pre></td></tr></table></figure><p>默认情况下会显示（根据您的 vimrc 可能会有所不同）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewoptions=folds,cursor,curdir</span><br></pre></td></tr></table></figure><p>我们来配置 <code>viewoptions</code>。要保留的三个属性分别是折叠、映射和本地设置选项。如果您的设置和我的相似，那么您已经有了 <code>folds</code> 选项。运行下列命令使视图记住 <code>localoptions</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viewoptions+=localoptions</span><br></pre></td></tr></table></figure><p>查阅 <code>:h viewoptions</code> 可了解 <code>viewoptions</code> 的其他可用选项。现在运行 <code>:set viewoptions?</code>，您将看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewoptions=folds,cursor,curdir,localoptions</span><br></pre></td></tr></table></figure><h3 id="保存视图"><a class="markdownIt-Anchor" href="#保存视图"></a> 保存视图</h3><p>在 <code>foo.txt</code> 窗口经过适当折叠并设置了 <code>nonumber norelativenumber</code> 选项后，现在我们来保存视图。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview</span><br></pre></td></tr></table></figure><p>Vim 创建了一个视图文件。</p><h3 id="视图文件"><a class="markdownIt-Anchor" href="#视图文件"></a> 视图文件</h3><p>您可能会想“Vim 将这个视图文件保存到哪儿了呢？”，运行下列命令就可以看到答案了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viewdir?</span><br></pre></td></tr></table></figure><p>默认情况下会显示 <code>~/.vim/view</code>（根据您的操作系统，可能会有不同的路径。查阅 <code>:h viewdir</code> 获得更多信息）。如果您运行的是基于Unix的操作系统，想修改该路径，可以在您的 vimrc 中添加下列内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set viewdir=$HOME/else/where</span><br></pre></td></tr></table></figure><h3 id="加载视图文件"><a class="markdownIt-Anchor" href="#加载视图文件"></a> 加载视图文件</h3><p>关闭并重新打开 <code>foo.txt</code>，您会看到原来的文本，没有任何改变。这是预期行为。运行下列命令可以加载视图文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure><p>现在您将看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-- 5 lines: foo1 -----</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure><p>那些折叠、本地设置以及映射都恢复了。如果您细心还可以发现，光标位于上一次您运行 <code>:mkview</code> 时所处的行上。只要您有 <code>cursor</code> 选项，视图将记住光标位置。</p><h3 id="多个视图"><a class="markdownIt-Anchor" href="#多个视图"></a> 多个视图</h3><p>Vim 允许您保存 9 个编号的视图（1-9）。</p><p>假设您想用 <code>:9,10 fold</code> 来额外折叠最后两行，我们把这存为视图 1。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview 1</span><br></pre></td></tr></table></figure><p>如果您又想用 <code>:6,7 fold</code> 再折叠一次，并存为不同的视图，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview 2</span><br></pre></td></tr></table></figure><p>关闭并重新打开 <code>foo.txt</code> 文件，运行下列命令可以加载视图 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview 1</span><br></pre></td></tr></table></figure><p>要加载视图 2，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview 2</span><br></pre></td></tr></table></figure><p>要加载原始视图，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure><h3 id="自动创建视图"><a class="markdownIt-Anchor" href="#自动创建视图"></a> 自动创建视图</h3><p>有一件可能会发生的很倒霉的事情是，您花了很长时间在一个大文件中进行折叠，一不小心关闭了窗口，接着丢失了所有折叠信息。您可以在 vimrc 中添加下列内容，使得在关闭缓冲区后 Vim 能自动创建视图，防止此类灾难发生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufWinLeave *.txt mkview</span><br></pre></td></tr></table></figure><p>另外也能在打开缓冲区后自动加载视图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufWinEnter *.txt silent loadview</span><br></pre></td></tr></table></figure><p>现在，当您编辑 <code>txt</code> 文件时，不用再担心创建和加载视图了。但也注意，随着时间的推移，视图文件会不断积累，记得每隔几个月清理一次。</p><h2 id="会话"><a class="markdownIt-Anchor" href="#会话"></a> 会话</h2><p>如果说视图保存了某个窗口的设置，那么会话则保存了所有窗口（包括布局）的信息。</p><h3 id="创建新会话"><a class="markdownIt-Anchor" href="#创建新会话"></a> 创建新会话</h3><p>假设您在 <code>foobarbaz</code> 工程中编辑着 3 个文件：</p><p><code>foo.txt</code> 的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo1</span><br><span class="line">foo2</span><br><span class="line">foo3</span><br><span class="line">foo4</span><br><span class="line">foo5</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure><p><code>bar.txt</code> 的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bar1</span><br><span class="line">bar2</span><br><span class="line">bar3</span><br><span class="line">bar4</span><br><span class="line">bar5</span><br><span class="line">bar6</span><br><span class="line">bar7</span><br><span class="line">bar8</span><br><span class="line">bar9</span><br><span class="line">bar10</span><br></pre></td></tr></table></figure><p><code>baz.txt</code> 的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">baz1</span><br><span class="line">baz2</span><br><span class="line">baz3</span><br><span class="line">baz4</span><br><span class="line">baz5</span><br><span class="line">baz6</span><br><span class="line">baz7</span><br><span class="line">baz8</span><br><span class="line">baz9</span><br><span class="line">baz10</span><br></pre></td></tr></table></figure><p>假设您的窗口布局如下所示（适当地使用 <code>split</code> 和 <code>vsplit</code> 来放置）：</p><p><img src="/image/session-layout.png" alt="Session Layout" /></p><p>要保留这个外观，您需要保存会话。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mksession</span><br></pre></td></tr></table></figure><p>与默认存储在 <code>~/.vim/view</code> 的 <code>mkview</code> 不同，<code>mksession</code> 在当前目录存储会话文件（<code>Session.vim</code>）。如果好奇，您可以看看文件。</p><p>如果您想将会话文件另存他处，可以将参数传递给 <code>mksession</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mksession ~/some/where/else.vim</span><br></pre></td></tr></table></figure><p>使用 <code>!</code> 来调用命令可以覆盖一个已存在的会话文件（<code>:mksession! ~/some/where/else.vim</code>）。</p><h3 id="加载会话"><a class="markdownIt-Anchor" href="#加载会话"></a> 加载会话</h3><p>运行下列命令可以加载会话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:source Session.vim</span><br></pre></td></tr></table></figure><p>现在 Vim 看起来就像您离开它时的样子！或者，您也可以从终端加载会话文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -S Session.vim</span><br></pre></td></tr></table></figure><h3 id="配置会话属性"><a class="markdownIt-Anchor" href="#配置会话属性"></a> 配置会话属性</h3><p>您可以配置会话要保存的属性。若要查看当前哪些属性正被保存，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set sessionoptions?</span><br></pre></td></tr></table></figure><p>我的显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blank,buffers,curdir,folds,help,tabpages,winsize,terminal</span><br></pre></td></tr></table></figure><p>如果在保存会话时不想存储 <code>terminal</code>，可以运行下列命令将其从会话选项中删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set sessionoptions-=terminal</span><br></pre></td></tr></table></figure><p>如果要在保存会话时存储 <code>options</code>，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set sessionoptions+=options</span><br></pre></td></tr></table></figure><p>下面是一些 <code>sessionoptions</code> 可以存储的属性：</p><ul><li><code>blank</code> 存储空窗口</li><li><code>buffers</code> 存储缓冲区</li><li><code>folds</code> 存储折叠</li><li><code>globals</code> 存储全局变量（必须以大写字母开头，并且至少包含一个小写字母）</li><li><code>options</code> 存储选项和映射</li><li><code>resize</code> 存储窗口行列</li><li><code>winpos</code> 存储窗口位置</li><li><code>winsize</code> 存储窗口大小</li><li><code>tabpages</code> 存储选项卡</li><li><code>unix</code> 以 Unix 格式存储文件</li></ul><p>查阅 <code>:h 'sessionoptions'</code> 来获取完整列表。</p><p>会话是保存项目外部属性的好工具。但是，一些内部属性不存储在会话中，如本地标记、寄存器、历史记录等。要保存它们，您需要使用 Viminfo！</p><h2 id="viminfo"><a class="markdownIt-Anchor" href="#viminfo"></a> Viminfo</h2><p>如果您留意，在复制一个单词进寄存器 a，再退出并重新打开 Vim 后，您仍然可以看到存储在寄存器中的文本。这就是 Viminfo 的功劳。没有它，在您关闭 Vim 后，Vim 会忘记这些寄存器。</p><p>如果您使用 Vim 8 或更高版本，Vim 会默认启用 Viminfo。因此您可能一直在使用 Viminfo，而您对它毫不知情！</p><p>您可能会问：Viminfo 存储了什么？与会话有何不同？</p><p>要使用 Viminfo，您必须启用了 <code>+viminfo</code> 特性（<code>:version</code>）。Viminfo 存储着：</p><ul><li>命令行历史记录。</li><li>字符串搜索历史记录。</li><li>输入行历史记录。</li><li>非空寄存器的内容。</li><li>多个文件的标记。</li><li>文件标记，它指向文件中的位置。</li><li>上次搜索 / 替换模式（用于 “n” 和 “&amp;”）。</li><li>缓冲区列表。</li><li>全局变量。</li></ul><p>通常，会话存储“外部”属性，Viminfo 存储“内部”属性。</p><p>每个项目可以有一个会话文件，而 Viminfo 与会话不同，通常每台计算机只使用一个 Viminfo。Viminfo 是项目无关的。</p><p>对于 Unix，Viminfo 的默认位置是 <code>$HOME/.viminfo</code>（<code>~/.viminfo</code>）。如果您用其他操作系统，Viminfo 位置可能会有所不同。可以查阅 <code>:h viminfo-file-name</code>。每一次您做出的“内部”更改，如将文本复制进一个寄存器，Vim 都会自动更新 Viminfo 文件。</p><p><em>请确保您设置了 <code>nocompatible</code> 选项（<code>set nocompatible</code>），否则您的 Viminfo 将不起作用。</em></p><h3 id="读写-viminfo"><a class="markdownIt-Anchor" href="#读写-viminfo"></a> 读写 Viminfo</h3><p>尽管只使用一个 Viminfo 文件，但您还是可以创建多个 Viminfo 文件。使用 <code>:wviminfo</code> 命令（缩写为 <code>:wv</code>）来创建多个 Viminfo 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wv ~/.viminfo_extra</span><br></pre></td></tr></table></figure><p>要覆盖现有的 Viminfo 文件，向 <code>wv</code> 命令多添加一个叹号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wv! ~/.viminfo_extra</span><br></pre></td></tr></table></figure><p>Vim 默认情况下会读取 <code>~/.viminfo</code> 文件。运行 <code>:rviminfo</code>（缩写为 <code>:rv</code>）可以读取不同的 Vimfile 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rv ~/.viminfo_extra</span><br></pre></td></tr></table></figure><p>要在终端使用不同的 Viminfo 文件来启动 Vim，请使用 “i” 标志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -i viminfo_extra</span><br></pre></td></tr></table></figure><p>如果您要将 Vim 用于不同的任务，比如写代码和写作，您可以创建两个 Viminfo，一个针对写作优化，另一个为写代码优化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim -i viminfo_writing</span><br><span class="line"></span><br><span class="line">vim -i viminfo_coding</span><br></pre></td></tr></table></figure><h3 id="不使用-viminfo-启动-vim"><a class="markdownIt-Anchor" href="#不使用-viminfo-启动-vim"></a> 不使用 Viminfo 启动 Vim</h3><p>要不使用 Viminfo 启动 Vim，可以在终端运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -i NONE</span><br></pre></td></tr></table></figure><p>要永不使用 Viminfo，可以在您的 vimrc 文件添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set viminfo=&quot;NONE&quot;</span><br></pre></td></tr></table></figure><h3 id="配置-viminfo-属性"><a class="markdownIt-Anchor" href="#配置-viminfo-属性"></a> 配置 Viminfo 属性</h3><p>和 <code>viewoptions</code> 以及 <code>sessionoptions</code> 类似，您可以用 <code>viminfo</code> 选项指定要存储的属性。请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viminfo?</span><br></pre></td></tr></table></figure><p>您会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!,&#x27;100,&lt;50,s10,h</span><br></pre></td></tr></table></figure><p>看起来有点晦涩难懂。命令分解如下：</p><ul><li><code>!</code> 保存以大写字母开头、却不包含小写字母的全局变量。回想一下 <code>g:</code> 代表了一个全局变量。例如，假设您写了赋值语句 <code>let g:FOO = &quot;foo&quot;</code>，Viminfo 将存储全局变量 <code>FOO</code>。然而如果您写了 <code>let g:Foo = &quot;foo&quot;</code>，Viminfo 将不存储它，因为它包含了小写字母。没有 <code>!</code>，Vim 不会存储这些全局变量。</li><li><code>'100</code> 代表标记。在这个例子中，Viminfo 将保存最近 100 个文件的本地标记（a-z）。注意，如果存储的文件过多，Vim 会变得很慢，1000 左右就可以了。</li><li><code>&lt;50</code> 告诉 Viminfo 每个寄存器最多保存多少行（这个例子中是 50 行）。如果我复制 100 行文本进寄存器 a（<code>&quot;ay99j</code>）后关闭 Vim，下次打开 Vim 并从寄存器 a（<code>&quot;ap</code>）粘贴时，Vim 最多只粘贴 50 行；如果不指定最大行号， <em>所有</em> 行都将被保存；如果指定 0，什么都不保存了。</li><li><code>s10</code> 为寄存器设置大小限制（kb）。在这个例子中，任何大于 10kb 的寄存器都会被排除。</li><li><code>h</code> 禁用高亮显示（<code>hlsearch</code> 时）。</li></ul><p>可以查阅 <code>:h 'viminfo'</code> 来了解其他更多选项。</p><h2 id="聪明地使用视图-会话和-viminfo"><a class="markdownIt-Anchor" href="#聪明地使用视图-会话和-viminfo"></a> 聪明地使用视图、会话和 Viminfo</h2><p>Vim 能使用视图、会话和 Viminfo 来保存不同级别的 Vim 环境快照。对于微型项目，可以使用视图；对于大型项目，可以使用会话。您应该花些时间来查阅视图、会话和 Viminfo 提供的所有选项。</p><p>为您的编辑风格创建属于您自己的视图、会话和 Viminfo。如果您要换台计算机使用 Vim，只需加载您的设置，立刻就会感到就像在家里的工作环境一样！</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/520a0cad/">Ch 19 - 编译</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/0783c3af/">Ch 21 - 多文件操作</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch19-编译</title>
      <link href="/posts/520a0cad.html"/>
      <url>/posts/520a0cad.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>编译是许多编程语言的重要主题。在本章中，您将学习如何在 Vim 中编译。此外，您将看到如何利用好 Vim 的 <code>:make</code> 命令。</p><h2 id="从命令行编译"><a class="markdownIt-Anchor" href="#从命令行编译"></a> 从命令行编译</h2><p>您可以使用叹号运算符（<code>!</code>）进行编译。如果您需要使用 <code>g++</code> 来编译 <code>.cpp</code> 文件，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure><p>但要每次手动指定文件名和输出文件名会非常繁琐和容易出错。而 makefile 是条可行之路。</p><h2 id="make命令"><a class="markdownIt-Anchor" href="#make命令"></a> Make命令</h2><p>Vim 有运行 makefile 的 <code>:make</code> 命令。当您运行它时，Vim 会在当前目录查找 makefile 并执行它。</p><p>在当前目录创建一个文件名为 <code>makefile</code> ，然后添加下列内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">echo &quot;Hello all&quot;</span><br><span class="line">foo:</span><br><span class="line">echo &quot;Hello foo&quot;</span><br><span class="line">list_pls:</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>在 Vim 中运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make</span><br></pre></td></tr></table></figure><p>Vim 执行它的方式与从终端运行它的方式相同。<code>:make</code> 命令也接受终端中 <code>make</code> 命令的参数。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:make foo</span><br><span class="line">&quot; Outputs &quot;Hello foo&quot;</span><br><span class="line"></span><br><span class="line">:make list_pls</span><br><span class="line">&quot; Outputs the ls command result</span><br></pre></td></tr></table></figure><p>如果命令执行异常，<code>:make</code> 命令将使用 Vim 的 <code>quickfix</code> 来存储这些错误。现在试着运行一个不存在的目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make dontexist</span><br></pre></td></tr></table></figure><p>您应该会看到该命令执行错误。运行 <code>quickfix</code> 命令 <code>:copen</code> 可以打开 <code>quickfix</code> 窗口来查看该错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|| make: *** No rule to make target `dontexist&#x27;.  Stop.</span><br></pre></td></tr></table></figure><h2 id="使用-make-编译"><a class="markdownIt-Anchor" href="#使用-make-编译"></a> 使用 Make 编译</h2><p>让我们使用 makefile 来编译一个基本的 <code>.cpp</code> 程序。首先创建一个 <code>hello.cpp</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello!\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，更新 <code>makefile</code> 来编译和运行 <code>.cpp</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">echo &quot;build, run&quot;</span><br><span class="line">build:</span><br><span class="line">g++ hello.cpp -o hello</span><br><span class="line">run:</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>现在运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make build</span><br></pre></td></tr></table></figure><p><code>g++</code> 将编译 <code>./hello.cpp</code> 并且生成 <code>./hello</code>。接着运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make run</span><br></pre></td></tr></table></figure><p>您应该会看到终端上打印出了 <code>&quot;Hello!&quot;</code>。</p><h2 id="不同的make程序"><a class="markdownIt-Anchor" href="#不同的make程序"></a> 不同的Make程序</h2><p>当您运行 <code>:make</code> 时，Vim 实际上会执行 <code>makeprg</code> 选项所设置的任何命令，您可以运行 <code>:set makeprg?</code> 来查看它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeprg=make</span><br></pre></td></tr></table></figure><p><code>:make</code> 的默认命令是外部的 <code>make</code> 命令。若想修改 <code>:make</code> 命令，使每次运行它时执行 <code>g++ &lt;your-file-name&gt;</code>，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg=g++\ %</span><br></pre></td></tr></table></figure><p><code>\</code> 用于转义 <code>g++</code> 后的空格。Vim 中 <code>%</code> 符号代表当前文件。因此，<code>g++\ %</code> 命令等于运行 <code>g++ hello.cpp</code>。</p><p>转到 <code>./hello.cpp</code> 然后运行 <code>:make</code>，Vim 将编译 <code>hello.cpp</code> 并输出 <code>a.out</code>（因为您没有指定输出）。让我们重构一下，使用去掉扩展名的原始文件名来命名编译后的输出。运行下面的命令（或将它们添加到vimrc）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg=g++\ %\ -o\ %&lt;</span><br></pre></td></tr></table></figure><p>上面的命令分解如下：</p><ul><li><code>g++\\ %</code> 如上所述，等同于运行 <code>g++ &lt;your-file&gt;</code>。</li><li><code>-o</code> 输出选项。</li><li><code>%&lt;</code> 在 Vim 中代表了没有扩展名的当前文件名（如 <code>hello.cpp</code> 变成 <code>hello</code>）。</li></ul><p>当您在 <code>./hello.cpp</code> 中运行 <code>:make</code> 时，它将编译为 <code>./hello</code>。要在 <code>./hello.cpp</code> 中快速地执行 <code>./hello</code>，可以运行 <code>:!./%&lt;</code>。同样，它等同于运行 <code>:!./&lt;无后缀的当前文件名&gt;</code>。</p><p>查阅 <code>:h :compiler</code> 和 <code>:h write-compiler-plugin</code> 可以了解更多信息。</p><h2 id="保存时自动编译"><a class="markdownIt-Anchor" href="#保存时自动编译"></a> 保存时自动编译</h2><p>有了自动化编译，您可以让生活更加轻松。回想一下，您可以使用 Vim 的 <code>autocmd</code> 来根据某些事件自动执行操作。例如，要自动在每次保存后编译 <code>.cpp</code> 文件，您可以将下面内容添加到vimrc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufWritePost *.cpp make</span><br></pre></td></tr></table></figure><p>现在您每次保存 <code>.cpp</code> 文件后，Vim 都将自动执行 <code>make</code> 命令。</p><h2 id="切换编译器"><a class="markdownIt-Anchor" href="#切换编译器"></a> 切换编译器</h2><p>Vim 有一个 <code>:compiler</code> 命令可以快速切换编译器。您的 Vim 可能附带了一些预构建的编译配置。要检查您拥有哪些编译器，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e $VIMRUNTIME/compilers/&lt;tab&gt;</span><br></pre></td></tr></table></figure><p>您应该会看到一个不同编程语言的编译器列表。</p><p>若要使用 <code>:compiler</code> 命令，假设您有一个 ruby 文件 <code>hello.rb</code>，内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts &quot;Hello ruby&quot;</span><br></pre></td></tr></table></figure><p>回想一下，如果运行 <code>:make</code>，Vim 将执行赋值给 <code>makeprg</code> 的任何命令（默认是 <code>make</code>）。如果您运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:compiler ruby</span><br></pre></td></tr></table></figure><p>Vim 执行 <code>$VIMRUNTIME/compiler/ruby.vim</code> 脚本，并将 <code>makeprg</code> 更改为使用 <code>ruby</code> 命令。现在如果您运行 <code>:set makeprg?</code>，它会显示 <code>makeprg=ruby</code>（这取决于您 <code>$VIMRUNTIME/compiler/ruby.vim</code> 里的内容，如果您有其他自定义的 ruby 编译器，您的结果可能会有不同）。<code>:compiler &lt;your-lang&gt;</code> 命令允许您快速切换至其他编译器。如果您的项目使用多种语言，这会非常有用。</p><p>您不必使用 <code>:compiler</code> 或 <code>makeprg</code> 来编译程序。您可以运行测试脚本、分析文件、发送信号或任何您想要的内容。</p><h2 id="创建自定义编译器"><a class="markdownIt-Anchor" href="#创建自定义编译器"></a> 创建自定义编译器</h2><p>让我们来创建一个简单的 Typescript 编译器。先在您的设备上安装 Typescript（<code>npm install -g typescript</code>），安装完后您将有 <code>tsc</code> 命令。如果您之前没有尝试过 typescript，<code>tsc</code> 将 Typescript 文件编译成 Javascript 文件。假设您有一个 <code>hello.ts</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;hello&quot;;</span><br><span class="line">console.log(hello);</span><br></pre></td></tr></table></figure><p>运行 <code>tsc hello.ts</code> 后，它将被编译成 <code>hello.js</code>。然而，如果您的 <code>hello.ts</code> 文件中有如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;hello&quot;;</span><br><span class="line">hello = &quot;hello again&quot;;</span><br><span class="line">console.log(hello);</span><br></pre></td></tr></table></figure><p>这会抛出错误，因为不能更改一个 <code>const</code> 变量。运行 <code>tsc hello.ts</code> 的错误如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello.ts:2:1 - error TS2588: Cannot assign to &#x27;person&#x27; because it is a constant.</span><br><span class="line"></span><br><span class="line">2 person = &quot;hello again&quot;;</span><br><span class="line">  ~~~~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found 1 error.</span><br></pre></td></tr></table></figure><p>要创建一个简单的 Typescript 编译器，请在您的 <code>~/.vim/</code> 目录中新添加一个 <code>compiler</code> 目录（即 <code>~/.vim/compiler/</code>），接着创建 <code>typescript.vim</code> 文件（即 <code>~/.vim/compiler/typescript.vim</code>），并添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompilerSet makeprg=tsc</span><br><span class="line">CompilerSet errorformat=%f:\ %m</span><br></pre></td></tr></table></figure><p>第一行将 <code>makeprg</code> 设置为运行 <code>tsc</code> 命令。第二行将错误格式设置为显示文件（<code>%f</code>），后跟冒号（<code>:</code>）和转义的空格（<code>\ </code>），最后是错误消息（<code>%m</code>）。查阅 <code>:h errorformat</code> 可了解更多关于错误格式的信息。</p><p>您还可以阅读一些预制的编译器，看看它们是如何实现的。输入 <code>:e $VIMRUNTIME/compiler/&lt;some-language&gt;.vim</code> 查看。</p><p>有些插件可能会干扰 Typescript 文件，可以使用 <code>--noplugin</code> 标志以零插件的形式打开<code>hello.ts</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --noplugin hello.ts</span><br></pre></td></tr></table></figure><p>检查 <code>makeprg</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg?</span><br></pre></td></tr></table></figure><p>它应该会显示默认的 <code>make</code> 程序。要使用新的 Typescript 编译器，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:compiler typescript</span><br></pre></td></tr></table></figure><p>当您运行 <code>:set makeprg?</code> 时，它应该会显示 <code>tsc</code> 了。我们来测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make %</span><br></pre></td></tr></table></figure><p>回想一下，<code>%</code> 代表当前文件。看看您的 Typescript 编译器是否如预期一样工作。运行 <code>:copen</code> 可以查看错误列表。</p><h2 id="异步编译器"><a class="markdownIt-Anchor" href="#异步编译器"></a> 异步编译器</h2><p>有时编译可能需要很长时间。在等待编译时，您不会想眼睁睁盯着已冻结的 Vim 的。如果可以异步编译，就可以在编译期间继续使用 Vim 了，岂不美哉？</p><p>幸运的是，有插件来运行异步进程。有两个比较好的是：</p><ul><li><a href="https://github.com/tpope/vim-dispatch">vim-dispatch</a></li><li><a href="https://github.com/skywind3000/asyncrun.vim">asyncrun.vim</a></li></ul><p>在这一章中，我将介绍 vim-dispatch，但我强烈建议您尝试上述列表中所有插件。</p><p><em>Vim 和 NeoVim 实际上都支持异步作业，但它们超出了本章的范围。如果您好奇，可以查阅 <code>:h job-channel-overview.txt</code>。</em></p><h2 id="插件vim-dispatch"><a class="markdownIt-Anchor" href="#插件vim-dispatch"></a> 插件：Vim-dispatch</h2><p>Vim-dispatch 有几个命令，最主要的两个是 <code>:Make</code> 和 <code>:Dispatch</code>。</p><h3 id="异步make"><a class="markdownIt-Anchor" href="#异步make"></a> 异步Make</h3><p>Vim-dispatch 的 <code>:Make</code> 命令与 Vim 的 <code>:make</code> 相似，但它以异步方式运行。如果您正处于 Javascript 项目中，并且需要运行 <code>npm t</code>，可以将 <code>makeprg</code> 设置为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg=npm\\ t</span><br></pre></td></tr></table></figure><p>如果运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make</span><br></pre></td></tr></table></figure><p>Vim 将执行 <code>npm t</code>。但同时，您只能盯着冻结了的屏幕。有了 vim-dispatch，您只需要运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:Make</span><br></pre></td></tr></table></figure><p>Vim 将启用后台进程异步运行 <code>npm t</code>，同时您还能在 Vim 中继续编辑您的文本。棒极了！</p><h3 id="异步调度dispatch"><a class="markdownIt-Anchor" href="#异步调度dispatch"></a> 异步调度（Dispatch）</h3><p><code>:Dispatch</code> 命令的工作方式和 <code>:compiler</code> 及 <code>:!</code> 类似，它可以在Vim中运行任意外部命令。</p><p>假设您在 ruby spec 文件中，需要执行测试，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:Dispatch rspec %</span><br></pre></td></tr></table></figure><p>Vim 将对当前文件异步运行 <code>rspec</code> 命令。</p><h3 id="自动调度"><a class="markdownIt-Anchor" href="#自动调度"></a> 自动调度</h3><p>Vim-dispatch 有一个缓冲区变量<code>b:dispatch</code>，您可以配置它来自动执行特定命令，您可以利用 <code>autocmd</code>和它一起工作。如果在您的 vimrc 中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufEnter *_spec.rb let b:dispatch = &#x27;bundle exec rspec %&#x27;</span><br></pre></td></tr></table></figure><p>现在每当您进入（<code>BufEnter</code>）一个以 <code>_spec.rb</code> 结尾的文件，运行<code>:Dispatch</code> 将自动执行 <code>bundle exec rspec &lt;your-current-ruby-spec-file&gt;</code>。</p><h2 id="聪明地学习编译"><a class="markdownIt-Anchor" href="#聪明地学习编译"></a> 聪明地学习编译</h2><p>在本章中，您了解到可以使用 <code>make</code> 和 <code>compiler</code> 命令从Vim内部异步运行 <em>任何</em> 进程，以完善您的编程工作流程。Vim 拥有通过其他程序来扩展自身的能力，这使其变得强大。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/a575da65/">Ch 18 - Git</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/26a705fd/">Ch 20 - 视图、会话和 Viminfo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch18-Git</title>
      <link href="/posts/a575da65.html"/>
      <url>/posts/a575da65.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>Vim 和 Git 是两种实现不同功能的伟大工具。Vim 用于文本编辑，Git 用于版本控制。</p><p>在本章中，您将学习如何将 Vim 和 Git 集成在一起。</p><h2 id="差异比较"><a class="markdownIt-Anchor" href="#差异比较"></a> 差异比较</h2><p>在上一章中，您看到了如何运行 <code>vimdiff</code> 命令以显示多个文件之间的差异。</p><p>假设您有两个文件，<code>file1.txt</code> 和 <code>file2.txt</code>。</p><p><code>file1.txt</code> 的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">apples</span><br><span class="line"></span><br><span class="line">milk</span><br><span class="line">apple juice</span><br><span class="line"></span><br><span class="line">yogurt</span><br></pre></td></tr></table></figure><p><code>file2.txt</code> 的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">oranges</span><br><span class="line"></span><br><span class="line">milk</span><br><span class="line">orange juice</span><br><span class="line"></span><br><span class="line">yogurt</span><br></pre></td></tr></table></figure><p>若要查看两个文件之间的差异，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>或者也可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -d file1.txt file2.txt</span><br></pre></td></tr></table></figure><p align="center">  <img alt="Basic diffing with Vim" width="900" height="auto" src="/image/diffing-basic.png"></p><p><code>vimdiff</code> 并排显示两个缓冲区。左边是 <code>file1.txt</code>，右边是 <code>file2.txt</code>。不同的两行（apples 和 oranges）会被高亮显示。</p><p>假设您要使第二个缓冲区相应位置变成 apples，而不是 oranges。若想从 <code>file1.txt</code> 传输您当前位置（当前您在 <code>file1.txt</code>）的内容到 <code>file2.txt</code>，首先使用 <code>]c</code> 跳转到下一处差异（使用 <code>[c</code> 可跳回上一处差异），现在光标应该在 apples 上了。接着运行 <code>:diffput</code>。此时，这两个文件都是 apples 了。</p><p align="center">  <img alt="Finding files in FZF" width="900" height="auto" src="/image/diffing-apples.png"></p><p>如果您想从另一个缓冲区（orange juice，<code>file2.txt</code>）传输文本来替代当前缓冲区（apple juice，<code>file1.txt</code>），让您的光标仍然位于 <code>file1.txt</code> 的窗口中，首先使用 <code>]c</code> 跳转至下一处差异，此时光标应该在 apple juice 上。接着运行 <code>:diffget</code> 获取另一个缓冲区的 orange juice 来替代当前缓冲区中的 apple juice。</p><p><code>:diffput</code> 将文本从当前缓冲区 <em>输出</em> 到另一个缓冲区。<code>:diffget</code> 从另一个缓冲区 <em>获取</em> 文本到当前缓冲区。</p><p>如果有多个缓冲区，可以运行 <code>:diffput fileN.txt</code> 和 <code>:diffget fileN.txt</code> 来指定目标缓冲区 fileN。</p><h2 id="使用-vim-作为合并工具"><a class="markdownIt-Anchor" href="#使用-vim-作为合并工具"></a> 使用 Vim 作为合并工具</h2><blockquote><p>“我非常喜欢解决合并冲突。” ——佚名</p></blockquote><p>我不知道有谁喜欢解决合并冲突，但总之，合并冲突是无法避免的。在本节中，您将学习如何利用 Vim 作为解决合并冲突的工具。</p><p>首先，运行下列命令来将默认合并工具更改为 <code>vimdiff</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config merge.tool vimdiff</span><br><span class="line">git config merge.conflictstyle diff3</span><br><span class="line">git config mergetool.prompt false</span><br></pre></td></tr></table></figure><p>或者您也可以直接修改 <code>~/.gitconfig</code>（默认情况下，它应该处于根目录中，但您的可能在不同的位置）。上面的命令应该会将您的 <code>gitconfig</code> 改成如下设置的样子，如果您还没有运行上面的命令，您也可以手动更改您的 gitconfig。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">  editor = vim</span><br><span class="line">[merge]</span><br><span class="line">  tool = vimdiff</span><br><span class="line">  conflictstyle = diff3</span><br><span class="line">[difftool]</span><br><span class="line">  prompt = false</span><br></pre></td></tr></table></figure><p>让我们创建一个假的合并冲突来测试一下。首先创建一个目录 <code>/food</code>，并初始化 git 仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>添加 <code>breakfast.txt</code> 文件，内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">oranges</span><br></pre></td></tr></table></figure><p>添加文件并提交它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial breakfast commit&quot;</span><br></pre></td></tr></table></figure><p>接着，创建一个新分支 apples：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b apples</span><br></pre></td></tr></table></figure><p>更改 <code>breakfast.txt</code> 文件为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">apples</span><br></pre></td></tr></table></figure><p>保存文件，添加并提交更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Apples not oranges&quot;</span><br></pre></td></tr></table></figure><p>真棒！现在 master 分支有 oranges，而 apples 分支有 apples。接着回到 master 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>在 <code>breakfast.txt</code> 文件中，您应该能看到原来的文本 oranges。接着将它改成 grapes，因为它是现在的应季水果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">grapes</span><br></pre></td></tr></table></figure><p>保存、添加、提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Grapes not oranges&quot;</span><br></pre></td></tr></table></figure><p>嚯！这么多步骤！现在准备要将 apples 分支合并进 master 分支了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge apples</span><br></pre></td></tr></table></figure><p>您应该会看到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging breakfast.txt</span><br><span class="line">CONFLICT (content): Merge conflict in breakfast.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>没错，一个冲突！现在一起来用一下新配置的 <code>mergetool</code> 来解决冲突吧！运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure><p align="center">  <img alt="Three-way mergetool with Vim" width="900" height="auto" src="/image/mergetool-initial.png"></p><p>Vim 显示了四个窗口。注意一下顶部三个：</p><ul><li><code>LOCAL</code> 包含了 <code>grapes</code>。这是“本地”中的变化，也是您要合并的内容。</li><li><code>BASE</code> 包含了 <code>oranges</code>。这是 <code>LOCAL</code> 和 <code>REMOTE</code> 的共同祖先，用于比较它们之间的分歧。</li><li><code>REMOTE</code> 包含了 <code>apples</code>。这是要被合并的内容。</li></ul><p>底部窗口（也即第四个窗口），您能看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">grapes</span><br><span class="line">apples</span><br></pre></td></tr></table></figure><p>第四个窗口包含了合并冲突文本。有了这步设置，就能更轻松看到哪个环境发生了什么变化。您可以同时查看 <code>LOCAL</code>、<code>BASE</code> 和 <code>REMOTE</code> 的内容。</p><p>您的光标应该在第四个窗口的高亮区域。再运行 <code>:diffget LOCAL</code>，就可以<em>获取</em>来自 <code>LOCAL</code> 的改变（grapes）。同样，运行 <code>:diffget BASE</code> 可以获取来自 <code>BASE</code> 的改变（oranges），而运行 <code>:diffget REMOTE</code> 可以获取来自 <code>REMOTE</code> 的改变（apples）。</p><p>在这个例子中，我们试着获取来自 <code>LOCAL</code> 的改变。运行 <code>:diffget LO</code>（<code>LOCAL</code> 的简写），第四个窗口变成了 grapes。完成后，就可以保存并退出所有文件（<code>:wqall</code>）了。还不错吧？</p><p>稍加留意您会发现，现在多了一个 <code>breakfast.txt.orig</code> 文件。这是 Git 防止事与愿违而创建的备份文件。如果您不希望 Git 在合并期间创建备份文件，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global mergetool.keepBackup false</span><br></pre></td></tr></table></figure><h2 id="在-vim-中使用-git"><a class="markdownIt-Anchor" href="#在-vim-中使用-git"></a> 在 Vim 中使用 Git</h2><p>Vim 本身没有集成 Git，要在 Vim 中执行 Git 命令，一种方法是在命令行模式中使用 <code>!</code> 叹号运算符。</p><p>使用 <code>!</code> 可以运行任何 Git 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:!git status</span><br><span class="line">:!git commit</span><br><span class="line">:!git diff</span><br><span class="line">:!git push origin master</span><br></pre></td></tr></table></figure><p>您还可以使用 Vim 的特殊字符 <code>%</code> (当前缓冲区) 或 <code>#</code> (其他缓冲区)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:!git add %         &quot; git add current file</span><br><span class="line">:!git checkout #    &quot; git checkout the other file</span><br></pre></td></tr></table></figure><p>这里有一个Vim技巧，您可以用来添加不同Vim窗口中的多个文件，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windo !git add %</span><br></pre></td></tr></table></figure><p>然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!git commit &quot;添加了Vim窗口中的所有文件，酷&quot;</span><br></pre></td></tr></table></figure><p><code>windo</code>命令是VIm的 “do” 命令其中之一，类似于您前面看到的 <code>argdo</code> 。<code>windo</code> 将命令执行在每一个窗口中。</p><h2 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h2><p>这里有很多提供git支持的Vim插件。以下是 Vim 中较流行的 Git 相关插件列表（您读到这篇文章时可能又有更多）：</p><ul><li><a href="https://github.com/airblade/vim-gitgutter">vim-gitgutter</a></li><li><a href="https://github.com/mhinz/vim-signify">vim-signify</a></li><li><a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a></li><li><a href="https://github.com/junegunn/gv.vim">gv.vim</a></li><li><a href="https://github.com/jreybert/vimagit">vimagit</a></li><li><a href="https://github.com/sodapopcan/vim-twiggy">vim-twiggy</a></li><li><a href="https://github.com/tpope/vim-rhubarb">rhubarb</a></li></ul><p>其中最流行的是 vim-fugitive。本章的剩余部分，我将使用此插件来介绍几个 git 工作流。</p><h2 id="vim-fugitive"><a class="markdownIt-Anchor" href="#vim-fugitive"></a> Vim-Fugitive</h2><p>vim-fugitive 插件允许您在不离开 Vim 编辑器的情况下运行 git 命令行界面。您会发现，有些命令在 Vim 内部执行时会更好。</p><p>开始前，请先使用 Vim 插件管理器（<a href="https://github.com/junegunn/vim-plug">vim-plug</a>、<a href="https://github.com/VundleVim/Vundle.vim">vundle</a>、<a href="https://github.com/Shougo/dein.vim">dein.vim</a> 等）安装 vim-fugitive。</p><h2 id="git-status"><a class="markdownIt-Anchor" href="#git-status"></a> Git Status</h2><p>当您不带参数地运行 <code>:Git</code> 命令时，vim-fugitive 将显示一个 git 概要窗口，它显示了未跟踪、未暂存和已暂存的文件。在此 “<code>git status</code>” 模式下，您可以做一些操作：</p><ul><li><code>Ctrl-n</code> / <code>Ctrl-p</code> 转到下一个 / 上一个文件。</li><li><code>-</code> 暂存或取消暂存光标处的文件。</li><li><code>s</code> 暂存光标处的文件。</li><li><code>u</code> 取消暂存光标处的文件。</li><li><code>&gt;</code> / <code>&lt;</code> 内联显示或隐藏光标处文件的差异变化。</li></ul><p align="center">  <img alt="Finding files in FZF" width="900" height="auto" src="/image/fugitive-git.png"></p><p>查阅 <code>:h fugitive-staging-maps</code> 可获得更多信息。</p><h2 id="git-blame"><a class="markdownIt-Anchor" href="#git-blame"></a> Git Blame</h2><p>在当前文件运行 <code>:Git blame</code> 命令，vim-fugitive 可以显示一个拆分的问责窗口。这有助于追踪那些 BUG 是谁写的，接着就可以冲他/她怒吼（开个玩笑）。</p><p>在  <code>&quot;git blame&quot;</code> 模式下您可以做：</p><ul><li><code>q</code> 关闭问责窗口。</li><li><code>A</code> 调整作者列大小。</li><li><code>C</code> 调整提交列大小。</li><li><code>D</code> 调整日期/时间列大小。</li></ul><p>查阅 <code>:h :Git_blame</code> 可获得更多信息。</p><p align="center">  <img alt="Finding files in FZF" width="900" height="auto" src="/image/fugitive-git-blame.png"></p><h2 id="gdiffsplit"><a class="markdownIt-Anchor" href="#gdiffsplit"></a> Gdiffsplit</h2><p>当您运行 <code>:Gdiffsplit</code> 命令后，vim-fugitive 会执行 <code>vimdiff</code>，比对索引或工作树中的版本与当前文件最新更改的区别。如果运行 <code>:Gdiffsplit &lt;commit&gt;</code>，vim-fugitive 则会根据 <code>&lt;commit&gt;</code> 中的版本来执行 <code>vimdiff</code>。</p><p align="center">  <img alt="Finding files in FZF" width="900" height="auto" src="/image/fugitive-gdiffsplit.png"></p><p>由于您处于 <code>vimdiff</code> 模式中，因此您可以使用 <code>:diffput</code> 和 <code>:diffget</code> 来 <em>获取</em> 或 <em>输出</em> 差异。</p><h2 id="gwrite-和-gread"><a class="markdownIt-Anchor" href="#gwrite-和-gread"></a> Gwrite 和 Gread</h2><p>当您在更改文件后运行 <code>:Gwrite</code> 命令，vim-fugitive 将暂存更改，就像运行 <code>git add &lt;current-file&gt;</code> 一样。</p><p>当您在更改文件后运行 <code>:Gread</code> 命令，vim-fugitive 会将文件还原至更改前的状态，就像运行 <code>git checkout &lt;current-file&gt;</code> 一样。使用 <code>:Gread</code> 还有一个好处是操作可撤销。如果在运行 <code>:Gread</code> 后您改变主意，想要保留原来的更改，您只需要撤消（<code>u</code>），Vim 将撤回 <code>:Gread</code> 操作。要换作是在命令行中运行 <code>git checkout &lt;current-file&gt;</code>，就完成不了这种操作了。</p><h2 id="gclog"><a class="markdownIt-Anchor" href="#gclog"></a> Gclog</h2><p>当您运行 <code>:Gclog</code> 命令时，vim-fugitive 将显示提交历史记录，就像运行 <code>git log</code> 命令一样。Vim-fugitive 使用 Vim 的 quickfix 来完成此任务，因此您可以使用 <code>:cnext</code> 和 <code>:cprevious</code> 来遍历下一个或上一个日志信息。您还可以使用 <code>:copen</code> 和 <code>:cclose</code> 打开或关闭日志列表。</p><p align="center">  <img alt="Finding files in FZF" width="900" height="auto" src="/image/fugitive-git-log.png"></p><p>在 <code>&quot;git log&quot;</code> 模式中，您可以做两件事：</p><ul><li>查看树。</li><li>访问父级（上一个提交）。</li></ul><p>您可以像 <code>git log</code> 命令一样，传递参数给 <code>:Gclog</code> 命令。如果您项目的提交历史记录很长，只想看最后三个提交，则可以运行 <code>:Gclog -3</code>。如果需要根据提交日期来筛选记录，可以运行类似 <code>:Gclog --after=&quot;January 1&quot; --before=&quot;March 14&quot;</code> 的命令。</p><h2 id="vim-fugitive-的更多功能"><a class="markdownIt-Anchor" href="#vim-fugitive-的更多功能"></a> Vim-Fugitive 的更多功能</h2><p>以上只是寥寥几个 vim-fugitive 功能的例子，您可以查阅 <code>:h fugitive.txt</code> 来了解更多有关 vim-fugitive 的信息。大多数流行的 git 命令可能都有 vim-fugitive 的优化版本，您只需在文档中查找它们。</p><p>如果您处于 vim-fugitive 的“特殊模式”（如 <code>:Git</code> 或 <code>:Git blame</code> 模式）中，按下 <code>g?</code> 可以了解当前有哪些可用的快捷键，Vim-fugitive 将为您所处的模式显示相应的 <code>:help</code> 窗口。棒极了！</p><h2 id="聪明地学习-vim-和-git"><a class="markdownIt-Anchor" href="#聪明地学习-vim-和-git"></a> 聪明地学习 Vim 和 Git</h2><p>每个人都有不同的 git 工作流，可能 vim-fugitive 非常合适您的工作流（也可能不适合）。总之，我强烈建议您试试上面列出的所有插件。可能还有一些其他的我没有列出来，都可以去试一试。</p><p>要让Vim-git的集成工作得更好，一个显而易见的办法就是去深入了解git。Git 本身是一个很庞大的主题，我只向您展示了它其中很小的一部分。好了，接下来谈谈如何使用 Vim 编译您的代码。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/d7f38bdd/">Ch 17 - 折叠</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/520a0cad/">Ch 19 - 编译</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch17-折叠</title>
      <link href="/posts/d7f38bdd.html"/>
      <url>/posts/d7f38bdd.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在阅读文件时，经常会有一些不相关的文本会妨碍您理解。使用 Vim 折叠可以隐藏这些不必要的信息。</p><p>本章中，您将学习如何使用不同的折叠方法。</p><h2 id="手动折叠"><a class="markdownIt-Anchor" href="#手动折叠"></a> 手动折叠</h2><p>想象您正在折叠一张纸来覆盖一些文本，实际的文本不会消失，它仍在那儿。Vim 折叠的工作方式与此相同，它<em>折叠</em>一段文本，在显示时会隐藏起来，但实际上并不会真的删除它。</p><p>折叠操作符是<code>z</code>。（折叠纸张时，它看起来也像字母 “z”）。</p><p>假设有如下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fold me</span><br><span class="line">Hold me</span><br></pre></td></tr></table></figure><p>把光标放在第一行，输入 <code>zfj</code>。Vim 将这两行折叠成一行，同时会看到类似消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+-- 2 lines: Fold me -----</span><br></pre></td></tr></table></figure><p>上面的命令分解如下：</p><ul><li><code>zf</code> 是折叠操作符。</li><li><code>j</code> 是用于折叠操作符的动作。</li></ul><p>您可以使用 <code>zo</code> 打开/展开已折叠文本，使用 <code>zc</code> 关闭/收缩文本。</p><p>折叠是一个操作符，所以它遵循语法规则（<code>动词+名词</code>）。您可以在折叠运算符后，加上一个动作(motion)或文本对象。例如，使用 <code>zfip</code> 可以折叠内部段落；使用 <code>zfG</code> 可以折叠至文件末尾；使用 <code>zfa&#123;</code> 可以折叠 <code>&#123;</code> 和 <code>&#125;</code> 之间的文本。</p><p>您可以在可视模式下进行折叠。高亮您想要折叠的区域后 (<code>v</code>, <code>V</code>, 或 <code>Ctrl-v</code>)，再输入 <code>zf</code> 即可。</p><p>您也可以在命令行模式下，使用 <code>:fold</code> 命令执行一次折叠。若要折叠当前行及紧随其后的第二行，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:,+1fold</span><br></pre></td></tr></table></figure><p><code>,+1</code> 是要折叠的范围。如果不传递范围参数，默认当前行。<code>+1</code> 是代表下一行的范围指示器。运行 <code>:5,10fold</code> 可以折叠第5至10行。运行 <code>:,$fold</code> 可以折叠当前行至文件末尾。</p><p>还有许多其他折叠和展开的命令。我发现他们实在太多，以至于在刚起步时很难记住。最有用的一些命令是：</p><ul><li><code>zR</code> 展开所有折叠。</li><li><code>zM</code> 收缩所有折叠。</li><li><code>za</code> 切换折叠状态。</li></ul><p><code>zR</code> 和 <code>zM</code> 可用于任意行上，但 <code>za</code> 仅能用于已折叠/未折叠的行上。输入 <code>:h fold-commands</code> 可查阅更多有关折叠的指令。</p><h2 id="不同的折叠方法"><a class="markdownIt-Anchor" href="#不同的折叠方法"></a> 不同的折叠方法</h2><p>以上部分涵盖了 Vim 手动折叠的内容。实际上，Vim 有六种不同的折叠方法：</p><ol><li>手动折叠</li><li>缩进折叠</li><li>表达式折叠</li><li>语法折叠</li><li>差异折叠</li><li>标志折叠</li></ol><p>运行 <code>:set foldmethod?</code> 可查看您当前正在使用哪一种折叠方式。默认情况下，Vim 使用手动方式。</p><p>在本章的剩余部分，您将学习其他五种折叠方法。让我们从缩进折叠开始。</p><h2 id="缩进折叠"><a class="markdownIt-Anchor" href="#缩进折叠"></a> 缩进折叠</h2><p>要使用缩进折叠，需要将 <code>'foldmethod'</code> 选项更改为缩进：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=indent</span><br></pre></td></tr></table></figure><p>假设有如下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br></pre></td></tr></table></figure><p>运行 <code>:set foldmethod=indent</code> 后将看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">+-- 2 lines: Two -----</span><br></pre></td></tr></table></figure><p>使用缩进折叠后，Vim 将会查看每行的开头有多少空格，并将它与 <code>'shiftwidth'</code> 选项进行比较，以此来决定该行可折叠性。<code>'shiftwidth'</code> 返回每次缩进所需的空格数。如果运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth?</span><br></pre></td></tr></table></figure><p>Vim 的默认 <code>'shiftwidth'</code> 值为2。对于上面的文本而言，“Two” 和 “Two again” 的开头都有两个空格。当 Vim 看到了空格数 <em>且</em> <code>'shiftwidth'</code>值都为2时，Vim 认为该行的缩进折叠级别为1。</p><p>假设这次文本开头只有一个空格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line"> Two</span><br><span class="line"> Two again</span><br></pre></td></tr></table></figure><p>运行 <code>:set foldmethod=indent</code> 后，Vim 不再折叠已缩进的行了，因为这些行没有足够的空格。1个空格不会被视作一个缩进。然而，当您改变 <code>'shiftwidth' </code> 的值为1后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth=1</span><br></pre></td></tr></table></figure><p>文本现在可以折叠了！现在一个空格将被视为一个缩进。</p><p>现在，我们将 <code>'shiftwidth' </code> 以及文本开头的空格数都重新恢复为2后，另外添加一些内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br><span class="line">    Three</span><br><span class="line">    Three again</span><br></pre></td></tr></table></figure><p>运行折叠命令 (<code>zM</code>) 后可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">+-- 4 lines: Two -----</span><br></pre></td></tr></table></figure><p>展开已折叠的行 (<code>zR</code>)，接着移动光标至 “Three”，然后切换文本的折叠状态 (<code>za</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br><span class="line">+-- 2 lines: Three -----</span><br></pre></td></tr></table></figure><p>这是啥？叠中叠？</p><p>是的，您可以嵌套折叠。文本 “Two” 和 “Two again” 的折叠级别都为1，文本 “Three” 和 “Three again” 的折叠级别都为2。如果在一段可折叠文本中，具有另一段折叠级别更高的可折叠文本，则可以具有多个折叠层。</p><h2 id="表达式折叠"><a class="markdownIt-Anchor" href="#表达式折叠"></a> 表达式折叠</h2><p>表达式折叠允许您定义要匹配折叠的表达式。定义折叠表达式后，Vim 会计算每行的 <code>'foldexpr'</code> 值。这是必须配置的变量，它要返回适当的值。如果返回 0，则不折叠行。如果它返回 1，则该行的折叠级别为 1。如果它返回 2，则该线的折叠级别为 2。除了整数外还有其他的值，但我不打算介绍它们。如果你好奇，可以查阅<code>:h fold-expr</code>。</p><p>首先，更改折叠方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=expr</span><br></pre></td></tr></table></figure><p>假设您有一份早餐食品列表，并且想要折叠所有以 “p” 开头的早餐项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">donut</span><br><span class="line">pancake</span><br><span class="line">pop-tarts</span><br><span class="line">protein bar</span><br><span class="line">salmon</span><br><span class="line">scrambled eggs</span><br></pre></td></tr></table></figure><p>其次，更改 <code>foldexpr</code> 为捕获以 “p” 开头的表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldexpr=getline(v:lnum)[0]==\\&quot;p\\&quot;</span><br></pre></td></tr></table></figure><p>这表达式看起来有点吓人。我们来分解下：</p><ul><li><code>:set foldexpr</code> 设置 <code>'foldexpr'</code> 为自定义表达式。</li><li><code>getline()</code> 是 Vim 脚本的一个函数，它返回指定行的内容。如运行 <code>:echo getline(5)</code> 可以获取第5行的内容。</li><li><code>v:lnum</code> 是 Vim <code>'foldexpr'</code> 表达式的特殊变量。Vim 在扫描每一行时，都会将行号存储至 <code>v:lnum</code> 变量。在第5行，<code>v:lnum</code> 值为5。在第10行，<code>v:lnum</code>值为10。</li><li><code>[0]</code> 处于 <code>getline(v:lnum)[0]</code> 语境时，代表每一行的第一个字符。Vim 在扫描某一行时，<code>getline(v:lnum)</code> 返回该行的内容，而 <code>getline(v:lnum)[0]</code> 则返回这一行的第一个字符。例如，我们早餐食品列表的第一行是 “donut”，则 <code>getline(v:lnum)[0]</code> 返回 “d”；列表的第二行是 “pancake”，则 <code>getline(v:lnum)[0]</code> 返回 “p”。</li><li><code>==\\&quot;p\\&quot;</code> 是等式表达式的后半部分，它检查刚才表达式的计算结果是否等于 “p”。如果是，则返回1，否则返回0。在 Vim 的世界里，1代表真，0代表假。所以，那些以 “p” 开头的行，表达式都会返回1。回想一下本节的开始，如果 <code>'foldexpr'</code> 的值为1，则折叠级别为1。</li></ul><p>在运行这个表达式后，您将看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">donut</span><br><span class="line">+-- 3 lines: pancake -----</span><br><span class="line">salmon</span><br><span class="line">scrambled eggs</span><br></pre></td></tr></table></figure><h2 id="语法折叠"><a class="markdownIt-Anchor" href="#语法折叠"></a> 语法折叠</h2><p>语法折叠是由Vim的语法高亮决定的。如果您使用了语法高亮插件，比如<a href="https://github.com/sheerun/vim-polyglot">vim-polyglot</a>，那么装上插件就可以直接使用语法折叠。仅仅需要将<code>foldmethod</code>选项改为 <code>syntax</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=syntax</span><br></pre></td></tr></table></figure><p>假设您正在编辑一个JavaScript文件，而且您已经装好了 vim-polyglot 插件。如果您有以下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const nums = [</span><br><span class="line">  one,</span><br><span class="line">  two,</span><br><span class="line">  three,</span><br><span class="line">  four</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上述文本将会使用语法折叠折起来。当您为某个特定语言（位于 <code>syntax/</code> 目录中的语言即是典型例子）定义了语法高亮，您可以添加一个 <code>fold</code> 属性，使它支持折叠。下面是 vim-polyglot 中JavaScript语法文件中的一个片段。注意最后的 <code>fold</code> 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntax region  jsBracket                      matchgroup=jsBrackets            start=/\[/ end=/\]/ contains=@jsExpression,jsSpreadExpression extend fold</span><br></pre></td></tr></table></figure><p>本书不会详细介绍 <code>syntax</code> 功能。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p><h2 id="差异折叠"><a class="markdownIt-Anchor" href="#差异折叠"></a> 差异折叠</h2><p>Vim 可以对多个文件进行差异比较。</p><p>如果您有 <code>file1.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br></pre></td></tr></table></figure><p>以及 <code>file2.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">emacs is ok</span><br></pre></td></tr></table></figure><p>运行 <code>vimdiff file1.txt file2.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-- 3 lines: vim is awesome -----</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">[vim is awesome] / [emacs is ok]</span><br></pre></td></tr></table></figure><p>Vim 会自动折叠一些相同的行。运行 <code>vimdiff</code> 命令时，Vim 会自动使用 <code>foldmethod=diff</code>。此时如果运行 <code>:set foldmethod?</code>，它将返回 <code>diff</code>。</p><h2 id="标志折叠"><a class="markdownIt-Anchor" href="#标志折叠"></a> 标志折叠</h2><p>要使用标志折叠，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=marker</span><br></pre></td></tr></table></figure><p>假设有如下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#123;</span><br><span class="line">world</span><br><span class="line">vim</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>输入 <code>zM</code> 后会看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line">+-- 4 lines: -----</span><br></pre></td></tr></table></figure><p>Vim 将 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 视为折叠指示器，并折叠其中的内容。使用标志折叠时，Vim 会寻找由 <code>'foldmarker'</code> 选项定义的特殊标志，并标记折叠区域。要查看 Vim 使用的标志，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmarker?</span><br></pre></td></tr></table></figure><p>默认情况下，Vim 把 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 作为指示器。如果您想将指示器更改为其他诸如 “coffee1” 和 “coffee2” 的字符串，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmarker=coffee1,coffee2</span><br></pre></td></tr></table></figure><p>假设有如下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line">coffee1</span><br><span class="line">world</span><br><span class="line">vim</span><br><span class="line">coffee2</span><br></pre></td></tr></table></figure><p>现在，Vim 将使用 <code>coffee1</code> 和 <code>coffee2</code> 作为新折叠标志。注意，指示器必须是文本字符串，不能是正则表达式。</p><h2 id="持久化折叠"><a class="markdownIt-Anchor" href="#持久化折叠"></a> 持久化折叠</h2><p>当关闭 Vim 会话后，您将失去所有的折叠信息。假设您有 <code>count.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br></pre></td></tr></table></figure><p>手动从第三行开始往下折叠 (<code>:3,$fold</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">+-- 3 lines: three ---</span><br></pre></td></tr></table></figure><p>当您退出 Vim 再重新打开 <code>count.txt</code> 后，这些折叠都不见了！</p><p>要在折叠后保留它们，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview</span><br></pre></td></tr></table></figure><p>当打开 <code>count.txt</code> 后，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure><p>您的折叠信息都被保留下来了。然而，您需要手动运行 <code>mkview</code> 和 <code>loadview</code>。我知道，终有一日，我会忘记运行 <code>mkview</code> 就关闭文件了，接着便会丢失所有折叠信息。能不能自动实现这个呢？</p><p>当然能！要在关闭 <code>.txt</code> 文件时自动运行 <code>mkview</code>，以及在打开 <code>.txt</code> 文件后自动运行 <code>loadview</code>，将下列内容添加至您的 vimrc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufWinLeave *.txt mkview</span><br><span class="line">autocmd BufWinEnter *.txt silent loadview</span><br></pre></td></tr></table></figure><p>在上一章您已经见过 <code>autocmd</code> 了，它用于在事件触发时执行一条命令。这里的两个事件是：</p><ul><li><code>BufWinLeave</code> 从窗口中删除缓冲时。</li><li><code>BufWinEnter</code> 在窗口中加载缓冲时。</li></ul><p>现在，即使您在 <code>.txt</code> 文件内折叠内容后直接退出 Vim，下次再打开该文件时，您的折叠信息都能自动恢复。</p><p>默认情况下，当运行 <code>mkview</code> 时，Vim将折叠信息保存在<code>~/.vim/view</code> (Unix 系统)。您可以查阅 <code>:h 'viewdir'</code> 来了解更多信息。</p><h2 id="聪明地学习折叠"><a class="markdownIt-Anchor" href="#聪明地学习折叠"></a> 聪明地学习折叠</h2><p>当我刚开始使用 Vim 时， 我会跳过学习 Vim 折叠，因为我觉得它不太实用。然而，随着我码龄的增长，我越发觉得折叠功能大有用处。得当地使用折叠功能，文本结构可以更加清晰，犹如一本书籍的目录。</p><p>当您学习折叠时，请从手动折叠开始，因为它可以随学随用。然后逐渐学习不同的技巧来使用缩进和标志折叠。最后，学习如何使用语法和表达式折叠。您甚至可以使用后两个来编写您自己的 Vim 插件。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/514bd033/">Ch 16 - 标签</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/a575da65/">Ch 18 - Git</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch16-标签</title>
      <link href="/posts/514bd033.html"/>
      <url>/posts/514bd033.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>快速转到任意定义处，是文本编辑中一个非常有用的特性。在本章中，您将学习如何使用 Vim 标签来做到这一点。</p><h2 id="标签概述"><a class="markdownIt-Anchor" href="#标签概述"></a> 标签概述</h2><p>假设有人给了您一个新的代码库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one = One.new</span><br><span class="line">one.donut</span><br></pre></td></tr></table></figure><p><code>One</code>？<code>donut</code>？呃，对于当时编写代码的开发者而言，这些代码的含义可能显而易见。问题是当时的开发者已经不在了，现在要由您来理解这些费解的代码。而跟随有<code>One</code> 和 <code>donut</code>定义的源代码，是帮助您理解的一个有效方法。</p><p>您可以使用<code>fzf</code> 或 <code>grep</code>来搜索它们，但这种情况下，但使用标签将更快。</p><p>把标签想象成地址簿：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name    Address</span><br><span class="line">Iggy1   1234 Cool St, 11111</span><br><span class="line">Iggy2   9876 Awesome Ave, 2222</span><br></pre></td></tr></table></figure><p>当然，标签可不是存储着“姓名-地址”对，而是“定义-地址”对。</p><p>假设您在一个目录中有两个 Ruby 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## one.rb</span><br><span class="line">class One</span><br><span class="line">  def initialize</span><br><span class="line">    puts &quot;Initialized&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def donut</span><br><span class="line">    puts &quot;Bar&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## two.rb</span><br><span class="line">require &#x27;./one&#x27;</span><br><span class="line"></span><br><span class="line">one = One.new</span><br><span class="line">one.donut</span><br></pre></td></tr></table></figure><p>在普通模式下，您可以使用<code>Ctrl-]</code>跳转到定义。在<code>two.rb</code>中，转到<code>one.donut</code>所在行，将光标移到<code>donut</code>处，按下<code>Ctrl-]</code>。</p><p>哦豁，Vim 找不到标签文件，您需要先生成它。</p><h2 id="标签生成器"><a class="markdownIt-Anchor" href="#标签生成器"></a> 标签生成器</h2><p>现代 Vim 不自带标签生成器，您需要额外下载它。有几个选项可供选择：</p><ul><li>ctags = 仅用于 C，基本随处可见。</li><li>exuberant ctags = 最流行的标签生成器之一，支持许多语言。</li><li>universal ctags = 和 exuberant ctags 类似，但比它更新。</li><li>etags = 用于 Emacs，嗯……</li><li>JTags = Java</li><li><a href="http://ptags.py">ptags.py</a> = Python</li><li>ptags = Perl</li><li>gnatxref = Ada</li></ul><p>如果您查看 Vim 在线教程，您会发现许多都会推荐 <a href="http://ctags.sourceforge.net/">exuberant ctags</a>，它支持 <a href="http://ctags.sourceforge.net/languages.html">41 种编程语言</a>，我用过它，挺不错的。但自2009年以来一直没有维护，因此 Universal ctags 更好些，它和 exuberant ctags 相似，并仍在维护。</p><p>我不打算详细介绍如何安装 Universal ctags，您可以在 <a href="https://github.com/universal-ctags/ctags">universal ctags</a> 仓库了解更多说明。</p><p>假设您已经安装好了ctags，接下来，生成一个基本的标签文件。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R .</span><br></pre></td></tr></table></figure><p><code>R</code> 选项告诉 <code>ctags</code> 从当前位置 (<code>.</code>) 递归扫描文件。稍后，您应该在当前文件夹看到一个<code>tags</code> 文件，里面您将看到类似这样的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!_TAG_FILE_FORMAT2/extended format; --format=1 will not append ;&quot; to lines/</span><br><span class="line">!_TAG_FILE_SORTED1/0=unsorted, 1=sorted, 2=foldcase/</span><br><span class="line">!_TAG_OUTPUT_FILESEPslash/slash or backslash/</span><br><span class="line">!_TAG_OUTPUT_MODEu-ctags/u-ctags or e-ctags/</span><br><span class="line">!_TAG_PATTERN_LENGTH_LIMIT96/0 for no limit/</span><br><span class="line">!_TAG_PROGRAM_AUTHORUniversal Ctags Team//</span><br><span class="line">!_TAG_PROGRAM_NAMEUniversal Ctags/Derived from Exuberant Ctags/</span><br><span class="line">!_TAG_PROGRAM_URL&lt;https://ctags.io/&gt;/official site/</span><br><span class="line">!_TAG_PROGRAM_VERSION0.0.0/b43eb39/</span><br><span class="line">Oneone.rb/^class One$/;&quot;c</span><br><span class="line">donutone.rb/^  def donut$/;&quot;fclass:One</span><br><span class="line">initializeone.rb/^  def initialize$/;&quot;fclass:One</span><br></pre></td></tr></table></figure><p>根据 Vim 设置和 ctag 生成器的不同，您的<code>tags</code> 文件可能会有些不同。一个标签文件由两部分组成：标签元数据和标签列表。那些标签元数据 (<code>!TAG_FILE...</code>) 通常由 ctags 生成器控制。这里我不打算介绍它们，您可以随意查阅文档。标签列表是一个由所有定义组成的列表，由ctags建立索引。</p><p>现在回到 <code>two.rb</code>，将光标移至 <code>donut</code>，再输入<code>Ctrl-]</code>，Vim 将带您转到 <code>one.rb</code> 文件里<code>def donut</code> 所在的行上。成功啦！但 Vim 怎么做到的呢？</p><h2 id="解剖标签文件"><a class="markdownIt-Anchor" href="#解剖标签文件"></a> 解剖标签文件</h2><p>来看看<code>donut</code> 标签项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donutone.rb/^  def donut$/;&quot;fclass:One</span><br></pre></td></tr></table></figure><p>上面的标签项由四个部分组成：一个<code>tagname</code>、一个<code>tagfile</code>、一个<code>tagaddress</code>，以及标签选项。</p><ul><li><code>donut</code> 是 <code>tagname</code>。当光标在 “donut” 时，Vim 搜索标签文件里含有 “donut” 字符串的一行。</li><li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li><li><code>/^ def donut$/</code> 是 <code>tagaddress</code>。<code>/.../</code> 是模式指示器。<code>^</code> 代表一行中第一个元素，后面跟着两个空格，然后是<code>def donut</code>字符串，最后 <code>$</code> 代表一行中最后一个元素。</li><li><code>f class:One</code> 是标签选项，它告诉 Vim，<code>donut</code> 是一种函数 (<code>f</code>)，并且是 <code>One</code> 类的一部分。</li></ul><p>再看看另一个标签项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oneone.rb/^class One$/;&quot;c</span><br></pre></td></tr></table></figure><p>这一行和 <code>donut</code>也是一样的：</p><ul><li><code>One</code> 是 <code>tagname</code>。注意，对于标签，第一次扫描区分大小写。如果列表中有 <code>One</code> 和 <code>one</code>， Vim 会优先考虑 <code>One</code> 而不是 <code>one</code>。</li><li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li><li><code>/^class One$/</code> 是 <code>tagaddress</code> 。Vim 会查找以 <code>class</code> 开头 (<code>^</code>) 、以 <code>One</code> 结尾 (<code>$</code>) 的行。</li><li><code>c</code> 是可用标签选项之一。由于 <code>One</code> 是一个 ruby 类而不是过程，因此被标签为 <code>c</code>。</li></ul><p>标签文件的内容可能不尽相同，根据您使用的标签生成器而定。但至少，标签文件必须具有以下格式之一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.  &#123;tagname&#125; &#123;TAB&#125; &#123;tagfile&#125; &#123;TAB&#125; &#123;tagaddress&#125;</span><br><span class="line">2.  &#123;tagname&#125; &#123;TAB&#125; &#123;tagfile&#125; &#123;TAB&#125; &#123;tagaddress&#125; &#123;term&#125; &#123;field&#125; ..</span><br></pre></td></tr></table></figure><h2 id="标签文件"><a class="markdownIt-Anchor" href="#标签文件"></a> 标签文件</h2><p>您知道，在运行 <code>ctags -R .</code> 后，一个新 <code>tags</code> 文件会被创建。但是，Vim 是如何知道在哪儿查找标签文件的呢？</p><p>如果运行 <code>:set tags?</code>，您可能会看见 <code>tags=./tags,tags</code>（根据您的 Vim 设置，内容可能有所不同）。对于 <code>./tags</code>，Vim 会在当前文件所在路径查找所有标签；对于 <code>tags</code>，Vim 会在当前目录（您的项目根路径）中查找。</p><p>此外，对于 <code>./tags</code>，Vim 会在当前文件所在路径内查找一个标签文件，无论它被嵌套得有多深。接下来，Vim 会在当前目录（项目根路径）查找。Vim 在找到第一个匹配项后会停止搜索。</p><p>如果您的 <code>'tags'</code> 文件是 <code>tags=./tags,tags,/user/iggy/mytags/tags</code>，那么 Vim 在搜索完 <code>./tags</code> 和 <code>tags</code> 目录后，还会在 <code>/user/iggy/mytags</code> 目录内查找。所以您可以分开存放标签文件，不必将它们置于项目文件夹中。</p><p>要添加标签文件位置，只需要运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set tags+=path/to/my/tags/file</span><br></pre></td></tr></table></figure><h2 id="为大型项目生成标签"><a class="markdownIt-Anchor" href="#为大型项目生成标签"></a> 为大型项目生成标签：</h2><p>如果您尝试在大型项目中运行 ctag，则可能需要很长时间，因为 Vim 也会查看每个嵌套目录。如果您是 Javascript 开发者，您会知道 <code>node_modules</code> 非常大。假设您有五个子项目，每个都包含自己的 <code>node_modules</code> 目录。一旦运行 <code>ctags -R .</code>，ctags 将尝试扫描这5个 <code>node_modules</code>。但您可能不需要为 <code>node_modules</code> 运行 ctag。</p><p>如果要排除 <code>node_modules</code> 后执行 ctags，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --exclude=node_modules .</span><br></pre></td></tr></table></figure><p>这次应该只需要不到一秒钟的时间。另外，您还可以多次使用 <code>exclude</code> 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log .</span><br></pre></td></tr></table></figure><h2 id="标签导航"><a class="markdownIt-Anchor" href="#标签导航"></a> 标签导航</h2><p>仅使用 <code>Ctrl-]</code> 也挺好，但我们还可以多学几个技巧。其实，标签跳转键 <code>Ctrl-]</code> 还有命令行模式：<code>:tag my-tag</code>。如果您运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tag donut</span><br></pre></td></tr></table></figure><p>Vim 就会跳转至 <code>donut</code> 方法，就像在 “donut” 字符串上按 <code>Ctrl-]</code> 一样。您还可以使用 <code>&lt;Tab&gt;</code> 来自动补全参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tag d&lt;Tab&gt;</span><br></pre></td></tr></table></figure><p>Vim 会列出所有以 “d” 开头的标签。对于上面的命令，结果则是 “donut”。</p><p>在实际项目中，您可能会遇到多个同名的方法。我们来更新下这两个文件。先是 <code>one.rb</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## one.rb</span><br><span class="line">class One</span><br><span class="line">  def initialize</span><br><span class="line">    puts &quot;Initialized&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def donut</span><br><span class="line">    puts &quot;one donut&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def pancake</span><br><span class="line">    puts &quot;one pancake&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后 <code>two.rb</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## two.rb</span><br><span class="line">require &#x27;./one.rb&#x27;</span><br><span class="line"></span><br><span class="line">def pancake</span><br><span class="line">  &quot;Two pancakes&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">one = One.new</span><br><span class="line">one.donut</span><br><span class="line">puts pancake</span><br></pre></td></tr></table></figure><p>由于新添加了一些过程，因此编写完代码后，不要忘记运行 <code>ctags -R .</code>。现在，您有了两个 <code>pancake</code> 过程。如果您在 <code>two.rb</code> 内按下 <code>Ctrl-]</code>，会发生什么呢？</p><p>Vim 会跳转到 <code>two.rb</code> 内的 <code>def pancake</code>，而不是 <code>one.rb</code> 的 <code>def pancake</code>。这是因为 Vim 认为 <code>two.rb</code> 内部的 <code>pancake</code> 过程比其他的<code>pancake</code> 过程具有更高优先级。</p><h2 id="标签优先级"><a class="markdownIt-Anchor" href="#标签优先级"></a> 标签优先级</h2><p>并非所有的标签都有着相同的地位。一些标签有着更高的优先级。如果有重复的标签项，Vim 会检查关键词的优先级。顺序是：</p><ol><li>当前文件中完全匹配的静态标签。</li><li>当前文件中完全匹配的全局标签。</li><li>其他文件中完全匹配的全局标签。</li><li>其他文件中完全匹配的静态标签。</li><li>当前文件中不区分大小写匹配的静态标签。</li><li>当前文件中不区分大小写匹配的全局标签。</li><li>其他文件中区分大小写匹配的全局标签。</li><li>当前文件中不区分大小写匹配的静态标签。</li></ol><p>根据优先级列表，Vim 会对在同一个文件上找到的精确匹配项进行优先级排序。这就是为什么 Vim 会选择 <code>two.rb</code> 里的 <code>pancake</code> 过程而不是 <code>one.rb</code> 里的。但是，上述优先级列表有些例外，取决于您的<code>'tagcase'</code>、<code>'ignorecase'</code>、<code>'smartcase'</code> 设置。我不打算介绍它们，您可以自行查阅 <code>:h tag-priority</code>。</p><h2 id="选择性跳转标签"><a class="markdownIt-Anchor" href="#选择性跳转标签"></a> 选择性跳转标签</h2><p>如果可以选择要跳转到哪个标签，而不是始终转到优先级最高的，那就太好了。因为您可能想跳转到 <code>one.rb</code> 里的 <code>pancake</code> 方法，而不是 <code>two.rb</code> 里的。现在您可以使用 <code>:tselect</code> 做到它！运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tselect pancake</span><br></pre></td></tr></table></figure><p>您可以在屏幕底部看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## pri kind tag               file</span><br><span class="line">1 F C f    pancake           two.rb</span><br><span class="line">             def pancake</span><br><span class="line">2 F   f    pancake           one.rb</span><br><span class="line">             class:One</span><br><span class="line">             def pancake</span><br></pre></td></tr></table></figure><p>如果输入<code>2</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>one.rb</code> 里的<code>pancake</code> 过程。如果输入<code>1</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>two.rb</code> 里的。</p><p>注意<code>pri</code> 列，第一个匹配中该列是<code>F C</code>，第二个匹配中则是<code>F</code>。这就是 Vim 用来确定标签优先级的凭据。<code>F C</code>表示在当前 (<code>C</code>) 文件中完全匹配 (<code>F</code>) 的全局标签。<code>F</code> 表示仅完全匹配 (<code>F</code>) 的全局标签。<code>F C</code> 的优先级永远比 <code>F</code> 高。<em>（译注：<code>F</code>是<code>Fully-matched</code>，<code>C</code>是<code>Current file</code>）</em></p><p>如果运行<code>:tselect donut</code>，即使只有一个标签可选，Vim 也会提示您选择跳转到哪一个。有没有什么方法可以让 Vim 仅在有多个匹配项时才提示标签列表，而只找到一个标签时就立即跳转呢？</p><p>当然！Vim 有一个 <code>:tjump</code> 方法。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tjump donut</span><br></pre></td></tr></table></figure><p>Vim 将立即跳转到 <code>one.rb</code> 里的<code>donut</code> 过程，就像在运行 <code>:tag donut</code> 一样。现在试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tjump pancake</span><br></pre></td></tr></table></figure><p>Vim 将提示您从标签选项中选择一个，就像在运行<code>:tselect pancake</code>。<code>tjump</code> 能两全其美。</p><p><code>tjump</code> 在普通模式下有一个快捷键：<code>g Ctrl-]</code>。我个人喜欢<code>g Ctrl-]</code>胜过 <code>Ctrl-]</code>。</p><h2 id="标签的自动补全"><a class="markdownIt-Anchor" href="#标签的自动补全"></a> 标签的自动补全</h2><p>标签能有助于自动补全。回想下第6章“插入模式”，您可以使用 <code>Ctrl-x</code> 子模式来进行各式自动补全。其中有一个我没有提到过的自动补全子模式便是 <code>Ctrl-]</code>。如果您在插入模式中输入<code>Ctrl-x Ctrl-]</code>，Vim 将使用标签文件来自动补全。</p><p>在插入模式下输入<code>Ctrl-x Ctrl-]</code>，您会看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">donut</span><br><span class="line">initialize</span><br><span class="line">pancake</span><br></pre></td></tr></table></figure><h2 id="标签堆栈"><a class="markdownIt-Anchor" href="#标签堆栈"></a> 标签堆栈</h2><p>Vim 维持着一个标签堆栈，上面记录着所有您从哪儿来、跳哪儿去的标签列表。使用 <code>:tags</code> 可以看到这个堆栈。如果您首先跳转到<code>pancake</code>，紧接着是<code>donut</code>，此时运行<code>:tags</code>，您将看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">  1  1 pancake            10  ch16_tags/two.rb</span><br><span class="line">  2  1 donut               9  ch16_tags/two.rb</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>注意上面的 <code>&gt;</code> 符号，它代表着您当前在堆栈中的位置。要“弹出”堆栈，从而回到上一次的状态，您可以运行<code>:pop</code>。试试它，再运行<code>:tags</code>看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">  1  1 pancake            10  puts pancake</span><br><span class="line">&gt; 2  1 donut               9  one.donut</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意现在 <code>&gt;</code> 符号位于 <code>donut</code> 所在的第二行了。再 <code>pop</code> 一次，然后运行<code>:tags</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">&gt; 1  1 pancake            10  puts pancake</span><br><span class="line">  2  1 donut               9  one.donut</span><br></pre></td></tr></table></figure><p>在普通模式下，您可以按下 <code>Ctrl-t</code> 来达到和 <code>:pop</code> 一样的效果。</p><h2 id="自动生成标签"><a class="markdownIt-Anchor" href="#自动生成标签"></a> 自动生成标签</h2><p>Vim 标签最大的缺点之一是，每当进行重大改变时，您需要重新生成标签文件。如果您将<code>pancake</code> 过程重命名为 <code>waffle</code>，标签文件不知道 <code>pancake</code> 被重命名了，标签列表仍旧存储着 <code>pancake</code> 过程。运行<code>ctags -R .</code> 可以创建更新的标签文件，但这可能会很缓慢。</p><p>幸运的是，有几种可以自动生成标签的方法。这一小节不打算介绍一个简单明了的过程，而是提出一些想法，以便您可以扩展它们。</p><h2 id="在保存时生成标签"><a class="markdownIt-Anchor" href="#在保存时生成标签"></a> 在保存时生成标签</h2><p>Vim 有一个自动命令 (<code>autocmd</code>) 方法，可以在触发事件时执行任意命令。您可以使用这个方法，以便在每次保存时生成标签。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufWritePost *.rb silent !ctags -R .</span><br></pre></td></tr></table></figure><p>上面命令的分解如下：</p><ul><li><code>autocmd</code> 是 Vim 的自动命令方法，它接受一个事件名称、文件和一个命令。</li><li><code>BufWritePost</code> 是保存缓冲区时的一个事件。每次保存文件时将触发一次 <code>BufWritePost</code> 事件。</li><li><code>.rb</code> 是 ruby (<code>rb</code>) 文件的一种文件模式。</li><li><code>silent</code> 是您传递的命令的一部分。如果不输入它，每次触发自动命令时，Vim 都会提示  <code>press ENTER or type command to continue</code>。</li><li><code>!ctags -R .</code> 是要执行的命令。回想一下，<code>!cmd</code> 从 Vim 内部执行终端命令。</li></ul><p>现在，每次您保存一个 ruby 文件时，Vim 都会运行<code>ctags -R .</code>。</p><h2 id="使用插件"><a class="markdownIt-Anchor" href="#使用插件"></a> 使用插件</h2><p>有几种插件可以自动生成 ctags：</p><ul><li><a href="https://github.com/ludovicchabant/vim-gutentags">vim-gutentags</a></li><li><a href="https://github.com/szw/vim-tags">vim-tags</a></li><li><a href="https://github.com/xolox/vim-easytags">vim-easytags</a></li><li><a href="https://github.com/craigemery/vim-autotag">vim-autotag</a></li></ul><p>我使用 vim-gutentags。它的使用方法很简单，而且装上就可以直接使用。</p><h2 id="ctags-以及-git-钩子"><a class="markdownIt-Anchor" href="#ctags-以及-git-钩子"></a> Ctags 以及 Git 钩子</h2><p>Tim Pope 是一个写了很多非常棒的 Vim 插件的作者，他写了一篇博客，建议使用 git 钩子。<a href="https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html">可以看一看</a>。</p><h2 id="聪明地学习标签"><a class="markdownIt-Anchor" href="#聪明地学习标签"></a> 聪明地学习标签</h2><p>只要配置得当，标签是非常有用的。假设在一个新的代码库中，您想要搞清楚 <code>functionFood</code> 干了什么，您可以通过跳转到它的定义来搞懂它们。在那儿可以看到，它又调用了 <code>functionBreakfast</code>。继续跟踪，发现还调用了 <code>functionPancake</code>。现在您明白了，函数调用路径图长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionFood -&gt; functionBreakfast -&gt; functionPancake</span><br></pre></td></tr></table></figure><p>进一步可以知道，这段代码和早餐吃煎饼有关。</p><p>现在您已经知道如何使用标签，通过 <code>:h tags</code> 可以学习更多有关标签的知识。接下来让我们一起来探索另一个功能：折叠。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/d3de6571/">Ch 15 - 命令行模式</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/d7f38bdd/">Ch 17 - 折叠</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch15-命令行模式</title>
      <link href="/posts/d3de6571.html"/>
      <url>/posts/d3de6571.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在前三章中，您已经学习了如何使用搜索命令(<code>/</code>, <code>?</code>)、替换命令(<code>:s</code>)、全局命令(<code>:g</code>)，以及外部命令(<code>!</code>)。这些都是命令行模式命令的一些例子。</p><p>在本章中，您将学习命令行模式的更多技巧。</p><h2 id="进入和退出命令行模式"><a class="markdownIt-Anchor" href="#进入和退出命令行模式"></a> 进入和退出命令行模式</h2><p>命令行模式本身也是一种模式，就像普通模式、输入模式、可视模式一样。在这种模式中，光标将转到屏幕底部，此时您可以输入不同的命令。</p><p>有 4 种进入命令行模式的方式：</p><ul><li>搜索命令 (<code>/</code>, <code>?</code>)</li><li>命令行指令 (<code>:</code>)</li><li>外部命令 (<code>!</code>)</li></ul><p>您可以从正常模式或可视模式进入命令行模式。</p><p>若要离开命令行模式，您可以使用 <code>&lt;esc&gt;</code>、<code>Ctrl-c</code>、<code>Ctrl-[</code>。</p><p><strong>有时其他资料可能会将&quot;命令行指令&quot;称为&quot;Ex 命令&quot;，将&quot;外部命令&quot;称为&quot;过滤命令&quot;或者&quot;叹号运算符&quot;。</strong></p><h2 id="重复上一个命令"><a class="markdownIt-Anchor" href="#重复上一个命令"></a> 重复上一个命令</h2><p>您可以用 <code>@:</code> 来重复上一个命令行指令或外部命令。</p><p>如果您刚运行 <code>:s/foo/bar/g</code>，执行 <code>@:</code> 将重复该替换。如果您刚运行 <code>:.!tr '[a-z]' '[A-Z]'</code>，执行 <code>@:</code> 将重复上一次外部命令转换过滤。</p><h2 id="命令行模式快捷键"><a class="markdownIt-Anchor" href="#命令行模式快捷键"></a> 命令行模式快捷键</h2><p>在命令行模式中，您可以使用 <code>Left</code> 或 <code>Right</code> 方向键，来左右移动一个字符。</p><p>如果需要移动一个单词，使用 <code>Shift-Left</code> 或 <code>Shift-Right</code> (在某些操作系统中，您需要使用 <code>Ctrl</code> 而不是 <code>Shift</code>)。</p><p>使用 <code>Ctrl-b</code>移动到该行的开始，使用 <code>Ctrl-e</code>移动到该行的结束。</p><p>和输入模式类似，在命令行模式中，有三种方法可以删除字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure><p>最后，如果您想像编辑文本文件一样来编辑命令，可以使用 <code>Ctrl-f</code>。</p><p>这样还可以查看过往的命令，并在这种&quot;命令行编辑的普通模式&quot;中编辑它们，同时还能按下 <code>Enter</code> 来运行它们。</p><h2 id="寄存器和自动补全"><a class="markdownIt-Anchor" href="#寄存器和自动补全"></a> 寄存器和自动补全</h2><p>当处于命令行模式时，您可以像在插入模式中一样使用 <code>Ctrl-r</code> 从Vim寄存器中插入文本。如果您在寄存器 a 中存储了字符串 “foo” ，您可以执行 <code>Ctrl-r a</code> 从寄存器a中插入该文本。任何在插入模式中您可以从寄存器中获取的内容，在命令行模式中您也可以获取。</p><p>另外，您也可以按 <code>Ctrl-r Ctrl-w</code> 获取当前光标下的单词（按 <code>Ctrl-r Ctrl-A</code> 获取当前光标下的词组）。还可以按 <code>Ctrl-r Ctlr-l</code> 获取当前光标所在行。按 <code>Ctrl-r Ctrl-f</code> 获取光标下的文件名。</p><p>您也可以对已存在的命令使用自动补全。要自动补全 <code>echo</code> 命令，当处于命令行模式时，首先输入 “ec”，接着按下 <code>&lt;Tab&gt;</code>，此时您应该能在左下角看到一些 “ec” 开头的 Vim 命令（例如：<code>echo echoerr echohl echomsg econ</code>）。按下 <code>&lt;Tab&gt;</code> 或 <code>Ctrl-n</code> 可以跳到下一个选项。按下 <code>&lt;Shift-Tab&gt;</code> 或 <code>Ctrl-p</code> 可以回到上一个选项。</p><p>一些命令行指令接受文件名作为参数。<code>edit</code> 就是一个例子，这时候您也可以使用自动补全。当输入 <code>:e </code> 后（不要忘记空格了），按下 <code>&lt;Tab&gt;</code>，Vim 将列出所有相关的文件名，这样您就可以进行选择而不必完整的输入它们。</p><h2 id="历史记录窗口"><a class="markdownIt-Anchor" href="#历史记录窗口"></a> 历史记录窗口</h2><p>您可以查看命令行指令和搜索项的历史记录（要确保在运行 <code>vim --version</code> 时，Vim 的编译选项中含有<code>+cmdline_hist</code>）。</p><p>运行 <code>:his :</code> 来查看命令行指令的历史记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##  cmd History</span><br><span class="line">2  e file1.txt</span><br><span class="line">3  g/foo/d</span><br><span class="line">4  s/foo/bar/g</span><br></pre></td></tr></table></figure><p>Vim 列出了您运行的所有 <code>:</code> 命令。默认情况下，Vim 存储最后 50 个命令。运行 <code>:set history=100</code> 可以将 Vim 记住的条目总数更改为 100。</p><p>一个更有用的做法是使用命令行历史记录窗口，按<code>q:</code>将会打开一个可搜索、可编辑的历史记录窗口。假设按下<code>q:</code>后您有如下的表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">51  s/verylongsubstitutionpattern/pancake/g</span><br><span class="line">52  his :</span><br><span class="line">53  wq</span><br></pre></td></tr></table></figure><p>如果您当前任务是执行 <code>s/verylongsubstitutionpattern/donut/g</code>（“pancake&quot;换成了&quot;donut”），为什么不复用 <code>s/verylongsubstitutionpattern/pancake/g</code> 呢？毕竟，两条命令唯一不同的是替换的单词，“donut” vs “pancake” ，所有其他的内容都是相同的。</p><p>当您运行 <code>q:</code>后，在历史记录中找到 <code>s/verylongsubstitutionpattern/pancake/g</code>（在这个环境中，您可以使用Vim导航），然后直接编辑它！ 在历史记录窗口中将 “pancake” 改为 “donut” ，然后按 <code>&lt;Enter</code>。Vim立刻执行 <code>s/verylongsubstitutionpattern/donut/g</code> 命令，超级方便！</p><p>类似地，运行 <code>:his /</code> 或 <code>:his ?</code> 可以查看搜索记录。要想打开您可以直接搜索和编辑的搜索历史记录窗口，您可以运行 <code>q/</code> 和 <code>q?</code>。</p><p>要退出这个窗口，按 <code>Ctrl-c</code>, <code>Ctrl-w c</code>, 或输入 <code>:quit</code>。</p><h2 id="更多命令行指令"><a class="markdownIt-Anchor" href="#更多命令行指令"></a> 更多命令行指令</h2><p>Vim有几百个内置指令，要查看Vim的所有指令，执行 <code>:h ex-cmd-index</code> 或 <code>:h :index</code>。</p><h2 id="聪明地学习命令行模式"><a class="markdownIt-Anchor" href="#聪明地学习命令行模式"></a> 聪明地学习命令行模式</h2><p>对比其他三种模式，命令行模式就像是文本编辑中的瑞士军刀。寥举几例，您可以编辑文本、修改文件和执行命令。本章是命令行模式的零碎知识的集合。同时，Vim 模式的介绍也走向尾声。现在，您已经知道如何使用普通、输入、可视以及命令行模式，您可以比以往更快地使用 Vim 来编辑文本了。</p><p>是时候离开 Vim 模式，来了解如何使用 Vim 标记进行更快的导航了。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/e58db16f/">Ch 14 - 外部命令</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/514bd033/">Ch 16 - 标签</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch14-外部命令</title>
      <link href="/posts/e58db16f.html"/>
      <url>/posts/e58db16f.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在Unix系统内部，您会发现许多小型的，超专业化命令，每个命令只做一件事（而且能很好地完成）。您可以将这些命令链接在一起以共同解决一个复杂的问题。如果可以从Vim内部使用这些命令，那不是很好吗？</p><p>答案是肯定的!在本章中，您将学习如何扩展Vim以使其与外部命令无缝协作。</p><h2 id="bang-命令"><a class="markdownIt-Anchor" href="#bang-命令"></a> Bang 命令</h2><p>Vim有一个Bang(<code>!</code>)命令，可以执行三件事：</p><p>1.将外部命令的STDOUT读入当前缓冲区。<br />2.将缓冲区的内容作为STDIN写入外部命令。<br />3.从Vim内部执行外部命令。</p><p>让我们一个个认真看一下。</p><h2 id="将外部命令的标准输出stdout读入vim"><a class="markdownIt-Anchor" href="#将外部命令的标准输出stdout读入vim"></a> 将外部命令的标准输出STDOUT读入Vim</h2><p>将外部命令的STDOUT读入当前缓冲区的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !&#123;cmd&#125;</span><br></pre></td></tr></table></figure><p><code>:r</code>是Vim的读命令。如果不带<code>!</code>使用它，则可以使用它来获取文件的内容。如果当前目录中有文件<code>file1.txt</code>，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r file1.txt</span><br></pre></td></tr></table></figure><p>Vim会将<code>file1.txt</code>的内容放入当前缓冲区。</p><p>如果您运行的<code>:r</code>命令后面跟一个<code>!</code>和外部命令，则该命令的输出将插入到当前缓冲区中。要获取<code>ls</code>命令的结果，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !ls</span><br></pre></td></tr></table></figure><p>它返回类似下列的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line">file3.txt</span><br></pre></td></tr></table></figure><p>您可以从<code>curl</code>命令读取数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !curl -s &#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span><br></pre></td></tr></table></figure><p>r命令也接受一个地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:10r !cat file1.txt</span><br></pre></td></tr></table></figure><p>现在，将在第10行之后插入来自运行<code>cat file.txt</code>的STDOUT。</p><h2 id="将缓冲区内容写入外部命令"><a class="markdownIt-Anchor" href="#将缓冲区内容写入外部命令"></a> 将缓冲区内容写入外部命令</h2><p><code>:w</code>命令除了保存文件，还可以用来将当前缓冲区中的文本作为作为STDIN传递给外部命令。语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w !cmd</span><br></pre></td></tr></table></figure><p>如果您具有以下表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello Vim&quot;);</span><br><span class="line">console.log(&quot;Vim is awesome&quot;);</span><br></pre></td></tr></table></figure><p>确保在计算机中安装了<a href="https://nodejs.org/en/">node</a>，然后运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w !node</span><br></pre></td></tr></table></figure><p>Vim将使用<code>node</code>执行Javascript表达式来打印&quot;Hello Vim&quot;和&quot;Vim is awesome&quot;。</p><p>当使用<code>：w</code>命令时，Vim使用当前缓冲区中的所有文本，与global命令类似（大多数命令行命令，如果不给它传递范围，则仅对当前行执行该命令）。如果您通过<code>：w</code>来指定地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:2w !node</span><br></pre></td></tr></table></figure><p>&quot;Vim&quot;只使用第二行中的文本到<code>node</code>解释器中。</p><p><code>:w !node</code>和<code>:w! node</code>形式上区别很小，但功能上相隔千里。使用<code>:w !node</code>，您是将当前缓冲区中的文本&quot;写入&quot;到外部命令<code>node</code>中。用<code>:w! node</code>，则您将强制保存文件并将其命名为&quot;node&quot;。</p><h2 id="执行外部命令"><a class="markdownIt-Anchor" href="#执行外部命令"></a> 执行外部命令</h2><p>您可以使用bang命令从Vim内部执行外部命令。语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!cmd</span><br></pre></td></tr></table></figure><p>要以长格式查看当前目录的内容，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!ls -ls</span><br></pre></td></tr></table></figure><p>要终止在PID 3456上运行的进程，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!kill -9 3456</span><br></pre></td></tr></table></figure><p>您可以在不离开Vim的情况下运行任何外部命令，因此您可以专注于自己的任务。</p><h2 id="过滤文本"><a class="markdownIt-Anchor" href="#过滤文本"></a> 过滤文本</h2><p>如果给<code>!</code>范围，则可用于过滤文本。假设您有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hello vim</span><br></pre></td></tr></table></figure><p>让我们使用<code>tr</code> (translate)命令将当前行大写。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.!tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELLO VIM</span><br><span class="line">hello vim</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>.!</code> 在当前行执行filter命令。</li><li><code>!tr '[:lower:]' '[:upper:]'</code> 调用<code>tr</code>外部命令将所有小写字符替换为大写字符。</li></ul><p>必须传递范围以运行外部命令作为过滤器。如果您尝试在没有<code>.</code>的情况下运行上述命令(<code>:!tr '[:lower:]' '[:upper:]'</code>)，则会看到错误。</p><p>假设您需要使用awk命令删除两行的第二列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!awk &quot;&#123;print $1&#125;&quot;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>:%!</code>  在所有行(<code>%</code>)上执行filter命令。</li><li><code>awk &quot;&#123;print $1&#125;&quot;</code> 仅打印匹配项的第一列。</li></ul><p>您可以使用管道运算符（<code>|</code>）链接多个命令，就像在终端中一样。假设您有一个包含这些美味早餐的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name price</span><br><span class="line">chocolate pancake 10</span><br><span class="line">buttermilk pancake 9</span><br><span class="line">blueberry pancake 12</span><br></pre></td></tr></table></figure><p>如果您需要根据价格对它们进行排序，并且仅以均匀的间距显示菜单，则可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!awk &#x27;NR &gt; 1&#x27; | sort -nk 3 | column -t</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buttermilk pancake 9</span><br><span class="line">chocolate pancake 10</span><br><span class="line">blueberry pancake 12</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>:%!</code> 将过滤器应用于所有行(<code>%</code>)。</li><li><code>awk 'NR &gt; 1'</code> 仅从第二行开始显示文本。</li><li><code>|</code>链接下一个命令。</li><li><code>sort -nk 3</code>使用列3（<code>k 3</code>）中的值对数字进行排序（<code>n</code>）。</li><li><code>column -t</code>以均匀的间距组织文本。</li></ul><h2 id="普通模式命令"><a class="markdownIt-Anchor" href="#普通模式命令"></a> 普通模式命令</h2><p>在普通模式下，Vim有一个过滤运算符（<code>!</code>）。如果您有以下问候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">bonjour vim</span><br><span class="line">salve vim</span><br></pre></td></tr></table></figure><p>要大写当前行和下面的行，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!jtr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>!j</code> 运行常规命令过滤器运算符（<code>!</code>），目标是当前行及其下方的行。回想一下，因为它是普通模式运算符，所以适用语法规则&quot;动词+名词&quot;。</li><li><code>tr '[a-z]' '[A-Z]'</code>将小写字母替换为大写字母。</li></ul><p>filter normal命令仅适用于至少一行以上的motion或至少一行以上的文本对象。如果您尝试运行<code>!iwtr'[az]''[AZ]'</code>（在内部单词上执行<code>tr</code>），您会发现它在整个行上都应用了tr命令，而不是光标所在的单词。</p><h2 id="聪明地学习外部命令"><a class="markdownIt-Anchor" href="#聪明地学习外部命令"></a> 聪明地学习外部命令</h2><p>Vim不是IDE。它是一种轻量级的模式编辑器，通过设计可以高度扩展。由于这种可扩展性，您可以轻松访问系统中的任何外部命令。这样，Vim离成为IDE仅一步之遥。有人说Unix系统是有史以来的第一个IDE。</p><p>Bang 命令的有用程度与您知道多少个外部命令相关。如果您的外部命令知识有限，请不要担心。我还有很多东西要学。以此作为持续学习的动力。每当您需要过滤文本时，请查看是否存在可以解决问题的外部命令。不必担心掌握所有的命令。只需学习完成当前任务所需的内容即可。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/fbe80173/">Ch 13 - 全局命令</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/d3de6571/">Ch 15 - 命令行模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch13-全局命令</title>
      <link href="/posts/fbe80173.html"/>
      <url>/posts/fbe80173.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>到目前为止，您已经了解了如何使用点命令(<code>.</code>)重复上一次更改，如何使用宏(<code>q</code>)重复动作以及将文本存储在寄存器中(<code>&quot;</code>)。</p><p>在本章中，您将学习如何在全局命令中重复命令行命令。</p><h2 id="全局命令概述"><a class="markdownIt-Anchor" href="#全局命令概述"></a> 全局命令概述</h2><p>Vim的全局命令用于同时在多行上运行命令行命令。</p><p>顺便说一句，您之前可能已经听说过 “Ex命令” 一词。在本书中，我将它们称为命令行命令，但Ex命令和命令行命令是相同的。它们是以冒号（<code>:</code>）开头的命令。在上一章中，您了解了替代命令。这是一个Ex命令的示例。它们之所以称为Ex，是因为它们最初来自Ex文本编辑器。在本书中，我将继续将它们称为命令行命令。有关Ex命令的完整列表，请查看<code>:h ex-cmd-index</code>。</p><p>全局命令具有以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/pattern/command</span><br></pre></td></tr></table></figure><p><code>pattern</code>匹配包含该模式串的所有行，类似于替代命令中的模式串。<code>command</code>可以是任何命令行命令。全局命令通过对与<code>pattern</code>匹配的每一行执行<code>command</code>来工作。</p><p>如果您具有以下表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>要删除所有包含&quot;console&quot;的行，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/d</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br></pre></td></tr></table></figure><p>全局命令在与&quot;console&quot;模式串匹配的所有行上执行删除命令(<code>d</code>)。</p><p>运行<code>g</code>命令时，Vim对文件进行两次扫描。在第一次运行时，它将扫描每行并标记与<code>/console/</code>模式传教匹配的行。一旦所有匹配的行都被标记，它将进行第二次运行，并在标记的行上执行d命令。</p><p>如果要删除所有包含&quot;const&quot;的行，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/const/d</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><h2 id="逆向匹配"><a class="markdownIt-Anchor" href="#逆向匹配"></a> 逆向匹配</h2><p>要在不匹配的行上运行全局命令，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g!/&#123;pattern&#125;/&#123;command&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:v/&#123;pattern&#125;/&#123;command&#125;</span><br></pre></td></tr></table></figure><p>如果运行<code>:v/console/d</code>，它将删除 <strong>不</strong> 包含&quot;console&quot;的所有行。</p><h2 id="模式串"><a class="markdownIt-Anchor" href="#模式串"></a> 模式串</h2><p>全局命令使用与替代命令相同的模式串系统，因此本节将作为更新。随意跳到下一部分或继续阅读！</p><p>如果您具有以下表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>要删除包含&quot;one&quot;或&quot;two&quot;的行，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/one\|two/d</span><br></pre></td></tr></table></figure><p>要删除包含任何一位数字的行，请运行以下任一命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/[0-9]/d</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/\d/d</span><br></pre></td></tr></table></figure><p>如果您有表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const oneMillion = 1000000;</span><br><span class="line">const oneThousand = 1000;</span><br><span class="line">const one = 1;</span><br></pre></td></tr></table></figure><p>要匹配包含三到六个零的行，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/0\&#123;3,6\&#125;/d</span><br></pre></td></tr></table></figure><h2 id="传递范围参数"><a class="markdownIt-Anchor" href="#传递范围参数"></a> 传递范围参数</h2><p>您可以在<code>g</code>命令之前传递一个范围。您可以通过以下几种方法来做到这一点：</p><ul><li><code>:1,5/g/console/d</code>  删除第1行和第5行之间匹配字符串&quot;console&quot;的行。</li><li><code>:,5/g/console/d</code> 如果逗号前没有地址，则从当前行开始。它在当前行和第5行之间寻找字符串&quot;console&quot;并将该行删除。</li><li><code>:3,/g/console/d</code> 如果逗号后没有地址，则在当前行结束。它在第3行和当前行之间寻找字符串&quot;console&quot;并将该行删除。</li><li><code>:3g/console/d</code> 如果只传递一个地址而不带逗号，则仅在第3行执行命令。在第3行查找，如果包含字符串&quot;console&quot;，则将其删除。</li></ul><p>除了数字，您还可以将这些符号用作范围：</p><ul><li><code>.</code> 表示当前行。范围<code>.,3</code>表示当前行和第3行之间。</li><li><code>$</code> 表示文件的最后一行。 <code>3,$</code>范围表示在第3行和最后一行之间。</li><li><code>+n</code> 表示当前行之后的n行。您可以将其与<code>.</code>结合使用，也可以不结合使用。  <code>3,+1</code>或<code>3,.+1</code>表示在第3行和当前行之后的行之间。</li></ul><p>如果您不给它任何范围，默认情况下它将影响整个文件。这实际上不是常态。如果您不传递任何范围，Vim的大多数命令行命令仅在当前行上运行(两个值得注意的例外是：这里介绍的全局命令(<code>:g</code>)和save(<code>:w</code>)命令)。</p><h2 id="普通模式命令"><a class="markdownIt-Anchor" href="#普通模式命令"></a> 普通模式命令</h2><p>您可以将全局命令和<code>:normal</code>命令行命令一起运行。</p><p>如果您有以下文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const one = 1</span><br><span class="line">console.log(&quot;one: &quot;, one)</span><br><span class="line"></span><br><span class="line">const two = 2</span><br><span class="line">console.log(&quot;two: &quot;, two)</span><br><span class="line"></span><br><span class="line">const three = 3</span><br><span class="line">console.log(&quot;three: &quot;, three)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要添加&quot;;&quot;运行到每一行的末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/./normal A;</span><br></pre></td></tr></table></figure><p>让我们分解一下：</p><ul><li><code>:g</code> 是全局命令。</li><li><code>/./</code> 是“非空行”的模式。它匹配至少包含1个字符的行。因此将与包含“const”和“console”的行匹配。它不匹配空行。</li><li><code>normal A;</code> 运行<code>:normal</code>命令行命令。 <code>A;</code> 是普通模式命令，用于在该行的末尾插入&quot;;&quot;。</li></ul><h2 id="执行宏"><a class="markdownIt-Anchor" href="#执行宏"></a> 执行宏</h2><p>您也可以使用全局命令执行宏。宏只是普通模式下的操作，因此可以使用<code>:normal</code>来执行宏。如果您有以下表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>请注意，带有&quot;const&quot;的行没有分号。让我们创建一个宏，以在寄存器&quot;a&quot;的这些行的末尾添加逗号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0A;&lt;esc&gt;q</span><br></pre></td></tr></table></figure><p>如果您需要复习，请查看有关宏的章节。现在运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/const/normal @a</span><br></pre></td></tr></table></figure><p>现在，所有带有&quot;const&quot;的行的末尾将带有&quot;;&quot;。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>如果您一步一步按照示例做，您将会在第一行末尾看到两个分号。为避免这种情况，使用全局命令时，给一个范围参数，从第2行到最后一行, <code>:2,$g/const/normal @a</code>。</p><h2 id="递归全局命令"><a class="markdownIt-Anchor" href="#递归全局命令"></a> 递归全局命令</h2><p>全局命令本身是命令行命令的一种，因此您可以从技术上在全局命令中运行全局命令。</p><p>给定表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>如果您运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/g/two/d</span><br></pre></td></tr></table></figure><p>首先，<code>g</code>将查找包含模式&quot;console&quot;的行，并找到3个匹配项。然后，第二个&quot;g&quot;将从那三个匹配项中查找包含模式&quot;two&quot;的行。最后，它将删除该匹配项。</p><p>您也可以将<code>g</code>与<code>v</code>结合使用以找到正负模式。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/v/two/d</span><br></pre></td></tr></table></figure><p>与前面的命令不同，它将查找 <strong>不</strong> 包含&quot;two&quot;的行。</p><h2 id="更改定界符"><a class="markdownIt-Anchor" href="#更改定界符"></a> 更改定界符</h2><p>您可以像替代命令一样更改全局命令的定界符。规则是相同的：您可以使用任何单字节字符，但字母，数字，<code>&quot;</code>, <code>|</code>, 和 <code>\</code>除外。</p><p>要删除包含&quot;console&quot;的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g@console@d</span><br></pre></td></tr></table></figure><p>如果在全局命令中使用替代命令，则可以有两个不同的定界符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g@one@s+const+let+g</span><br></pre></td></tr></table></figure><p>此处，全局命令将查找包含&quot;one&quot;的所有行。 替换命令将从这些匹配项中将字符串&quot;const&quot;替换为&quot;let&quot;。</p><h2 id="默认命令"><a class="markdownIt-Anchor" href="#默认命令"></a> 默认命令</h2><p>如果在全局命令中未指定任何命令行命令，会发生什么？</p><p>全局命令将使用打印(<code>:p</code>)命令来打印当前行的文本。如果您运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console</span><br></pre></td></tr></table></figure><p>它将在屏幕底部打印所有包含&quot;console&quot;的行。</p><p>顺便说一下，这是一个有趣的事实。因为全局命令使用的默认命令是<code>p</code>，所以这使<code>g</code>语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/re/p</span><br></pre></td></tr></table></figure><ul><li><code>g</code> = 全局命令</li><li><code>re</code> = 正则表达式模式</li><li><code>p</code> = 打印命令</li></ul><p>这三个元素连起来拼写为 <strong>“grep”</strong>，与命令行中的<code>grep</code> 相同。但这 <strong>不</strong> 是巧合。 <code>g/re/p</code>命令最初来自Ed编辑器（一个行文本编辑器）。 <code>grep</code>命令的名称来自Ed。</p><p>您的计算机可能仍具有Ed编辑器。从终端运行<code>ed</code>（提示：要退出，请键入<code>q</code>）。</p><h2 id="反转整个缓冲区"><a class="markdownIt-Anchor" href="#反转整个缓冲区"></a> 反转整个缓冲区</h2><p>要翻转整个文件，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^/m 0 </span><br></pre></td></tr></table></figure><p><code>^</code>表示行的开始。使用<code>^</code>匹配所有行，包括空行。</p><p>如果只需要反转几行，请将其传递一个范围。要将第5行到第10行之间的行反转，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:5,10g/^/m 0</span><br></pre></td></tr></table></figure><p>要了解有关move命令的更多信息，请查看<code>:h :move</code>。</p><h2 id="汇总所有待办事项"><a class="markdownIt-Anchor" href="#汇总所有待办事项"></a> 汇总所有待办事项</h2><p>当我编码时，有时我会想到一个随机的绝妙主意。不想失去专注，我通常将它们写在我正在编辑的文件中，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">// TODO: 喂小狗</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure><p>跟踪所有已创建的TODO可能很困难。 Vim有一个<code>:t</code>（copy）方法来将所有匹配项复制到一个地址。要了解有关复制方法的更多信息，请查看<code>:h :copy</code>。</p><p>要将所有TODO复制到文件末尾以便于自省，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/TODO/t $</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">// TODO：喂小狗</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br><span class="line"></span><br><span class="line">// TODO：喂小狗</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure><p>现在，我可以查看我创建的所有TODO，另外找个时间来完成它们，或将它们委托给其他人，然后继续执行下一个任务。</p><p>如果不想复制，而是将所有的 TODO 移动到末尾，可以使用移动命令 <code>m</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/TODO/m $</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line"></span><br><span class="line">// TODO：喂小狗</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure><h2 id="黑洞删除"><a class="markdownIt-Anchor" href="#黑洞删除"></a> 黑洞删除</h2><p>回想一下寄存器那一章，已删除的文本存储在编号寄存器中（允许它们足够大）。每当运行<code>:g/console/d</code>时，Vim都会将删除的行存储在编号寄存器中。如果删除多行，所有编号的寄存器将很快被填满。为了避免这种情况，您可以使用黑洞寄存器（<code>&quot;_</code>） <strong>不</strong> 将删除的行存储到寄存器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/d _</span><br></pre></td></tr></table></figure><p>通过在<code>d</code>之后传递<code>_</code>，Vim不会将删除的行保存到任何寄存器中。</p><h2 id="将多条空行减少为一条空行"><a class="markdownIt-Anchor" href="#将多条空行减少为一条空行"></a> 将多条空行减少为一条空行</h2><p>如果您的文件带有多个空行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>您可以快速将多个空行减少为一条空行。运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^$/,/./-1j</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>一般情况下全局命令遵循下列格式：<code>:g/pattern/command</code>。但是，您也可以使用下面的格式：<code>:g/pattern1/,/pattern2/command</code>。用这种格式，Vim将会使<code>command</code>作用在<code>pattern1</code>和<code>pattern2</code>上。</p><p>记住上面说的格式，让我们根据<code>:g/pattern1/,/pattern2/command</code>这个格式分解一下命令<code>:g/^$/,/./-1j</code>：</p><ul><li><code>/pattern1/</code> 就是 <code>/^$/</code> 。它表示一个空行（一个没有任何字符的行）。</li><li><code>/pattern2/</code> 就是 <code>/./</code>（用-1作为行修正）。<code>/./</code>表示一个非空行（一个含有至少1个字符的行）。这里的 <code>-1</code> 意思是向上偏移1行。</li><li><code>command</code> 就是 <code>j</code>，一个联接命令(<code>:j</code>)。在这个示例中，该全局命令联接所有给定的行。</li></ul><p>顺便说一句，如果您想要将多个空行全部删去，运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^$/,/./j</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^$/-j</span><br></pre></td></tr></table></figure><p>您的文本将会减少为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure><p>（译者补充：<code>j</code>连接命令的格式是：<code>:[range]j</code>。比如：<code>:1,5j</code>将连接第1至5行。在前面的命令中<code>:g/pattern1/,/pattern2/-1j</code>，<code>/pattern1/</code>和<code>/pattern2</code>都是<code>j</code>命令的范围参数，表示连接空行至非空行上方一行，这样就会保留1个空行。在早前的英文版本中有关于<code>j</code>命令的介绍，不知为何在后面的更新中，原作者删除了关于<code>j</code>命令的介绍）</p><h2 id="高级排序"><a class="markdownIt-Anchor" href="#高级排序"></a> 高级排序</h2><p>Vim有一个<code>:sort</code>命令来对一个范围内的行进行排序。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">e</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>您可以通过运行<code>:sort</code>对它们进行排序。如果给它一个范围，它将只对该范围内的行进行排序。例如，<code>:3,5sort</code>仅在第三和第五行之间排序。</p><p>如果您具有以下表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const arrayB = [</span><br><span class="line">  &quot;i&quot;,</span><br><span class="line">  &quot;g&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const arrayA = [</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果需要排序数组中的元素，而不是数组本身，可以运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/\[/+1,/\]/-1sort</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const arrayB = [</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;g&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;i&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const arrayA = [</span><br><span class="line">  &quot;a&quot;</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这很棒！但是命令看起来很复杂。让我们分解一下。该命令依然遵循 <code>:g/pattern1/,/pattern2/command</code>这个格式。</p><ul><li><code>:g</code> 是全局命令</li><li><code>/\[/+1</code> 是第一个模式串，它匹配左方括号&quot;[&quot;。<code>+1</code>表示匹配行的下面1行。</li><li><code>/\[/-1</code> 是第二个模式串，它匹配右方括号&quot;]&quot;。<code>-1</code>表示匹配行的上面1行。</li><li><code>/\[/+1,/\]/-1</code> 表示在&quot;[“和”]&quot;之间的行。</li><li><code>sort</code> 是命令行命令：排序。</li></ul><h2 id="聪明地学习全局命令"><a class="markdownIt-Anchor" href="#聪明地学习全局命令"></a> 聪明地学习全局命令</h2><p>全局命令针对所有匹配的行执行命令行命令。有了它，您只需要运行一次命令，Vim就会为您完成其余的工作。要精通全局命令，需要做两件事：良好的命令行命令词汇表和正则表达式知识。随着您花费更多的时间使用Vim，您自然会学到更多的命令行命令。正则表达式知识需要更多的实际操作。但是一旦您适应了使用正则表达式，您将领先于很多其他人。</p><p>这里的一些例子很复杂。不要被吓到。真正花时间了解它们。认真阅读每个模式串，不要放弃。</p><p>每当需要在多个位置应用命令时，请暂停并查看是否可以使用<code>g</code>命令。寻找最适合工作的命令，并编写一个模式串以同时定位多个目标。</p><p>既然您已经知道全局命令的功能强大，那么让我们学习如何使用外部命令来增加工具库。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/36365707/">Ch 12 - 搜索和替换</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/e58db16f/">Ch 14 - 外部命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch12-搜索和替换</title>
      <link href="/posts/36365707.html"/>
      <url>/posts/36365707.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您得基于文本的共同模式搜索大量的内容。通过学习如何在搜索和替换中使用正则表达式而不是字面字符串，您将能够快速定位任何文本。</p><p>附带说明一下，在本章中，当谈论搜索时，我将主要使用<code>/</code>。您使用<code>/</code>进行的所有操作也可以使用<code>?</code>完成。</p><h2 id="智能区分大小写"><a class="markdownIt-Anchor" href="#智能区分大小写"></a> 智能区分大小写</h2><p>尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本&quot;Learn Vim&quot;，则很容易把字母的大小写输错，从而得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项<code>ignorecase</code>闪亮的地方。只需在 vimrc 中添加<code>set ignorecase</code>，所有搜索词就不区分大小写。现在，您不必再执行<code>/Learn Vim</code>了。 <code>/learn vim</code>将起作用。</p><p>但是，有时您需要搜索特定大小写的短语。一种方法是用 <code>set noignorecase</code> 关闭<code>ignorecase</code>选项，但是每次需要搜索区分大小写的短语时，都得反复地打开和关闭这个选项。</p><p>为避免反复开关<code>ignorecase</code>选项，Vim 有一个<code>smartcase</code>选项。您可以将<code>ignorecase</code>和<code>smartcase</code>选项结合起来，当您输入的搜索词全部是小写时，进行大小写不敏感搜索；而当搜索词 <strong>至少有1个大写字母时</strong>，进行大小写敏感搜索。</p><p>在您的 vimrc 中，添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set ignorecase smartcase</span><br></pre></td></tr></table></figure><p>如果您有这些文字:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">HELLO</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><ul><li><code>/hello</code> 匹配&quot;hello&quot;，“HELLO&quot;和&quot;Hello”。</li><li><code>/HELLO</code> 仅匹配&quot;HELLO&quot;。</li><li><code>/Hello</code> 仅匹配&quot;Hello&quot;。</li></ul><p>有一个缺点。因为现在当您执行<code>/hello</code>时，Vim 将进行大小写不敏感搜索,那如果只需要搜索小写字符串怎么办？您可以在搜索词前使用<code>\C</code>模式来告诉 Vim，后续搜索词将区分大小写。如果执行<code>/\Chello</code>，它将严格匹配&quot;hello&quot;，而不是&quot;HELLO&quot;或&quot;Hello&quot;。</p><h2 id="一行中的第一个和最后一个字符"><a class="markdownIt-Anchor" href="#一行中的第一个和最后一个字符"></a> 一行中的第一个和最后一个字符</h2><p>您可以使用<code>^</code>匹配行中的第一个字符，并使用<code>$</code>匹配行中的最后一个字符。</p><p>如果您有以下文字:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello</span><br></pre></td></tr></table></figure><p>您可以使用<code>/^hello</code>来定位第一个&quot;hello&quot;。 '^'后面的字符必须是一行中的第一个字符。 要定位最后一个&quot;hello&quot;，请运行<code>/hello$</code>。 ‘$’ 之前的字符必须是一行中的最后一个字符。</p><p>如果您有以下文字:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello friend</span><br></pre></td></tr></table></figure><p>运行<code>/hello$</code>将匹配不到任何内容，因为&quot;friend&quot;是该行的最后一项，而不是&quot;hello&quot;。</p><h2 id="重复搜索"><a class="markdownIt-Anchor" href="#重复搜索"></a> 重复搜索</h2><p>您可以使用<code>//</code>重复上一个搜索。如果您只是搜索<code>/hello</code>，则运行<code>//</code>等同于运行<code>/hello</code>。此快捷键可以为您节省一些按键操作，尤其是在您刚搜索了一个很长的字符串的情况下。另外，回想一下前面的章节，您还可以使用<code>n</code>和<code>N</code>分别以相同方向和相反方向重复上一次搜索。</p><p>如果您想快速回忆起 第<em>n</em>个最近使用的搜索字怎么办？您可以先按<code>/</code>，然后按<code>up</code>/<code>down</code>方向键（或<code>Ctrl-N</code>/<code>Ctrl-P</code>），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行<code>:history /</code>。</p><p>在搜索过程中到达文件末尾时，Vim 会抛出一个错误:<code>&quot;搜索到达底部,未找到匹配项:&#123;your-search&#125;&quot;</code>(<code>&quot;Search hit the BOTTOM without match for: &#123;your-search&#125;&quot;</code>)。有时这个特性能成为一个安全守卫，可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用<code>set wrapscan</code>选项使 Vim 在到达文件末尾时回到文件顶部进行搜索。要关闭此功能，请执行<code>set nowrapscan</code>。</p><h2 id="使用候选词搜索"><a class="markdownIt-Anchor" href="#使用候选词搜索"></a> 使用候选词搜索</h2><p>一次搜索多个单词属于日常操作。 如果您需要搜索&quot;hello vim&quot;或&quot;hola vim&quot;，而不是&quot;salve vim&quot;或&quot;bonjour vim&quot;，则可以使用<code>|</code>或运算符。</p><p>给予这样一段文本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure><p>要同时匹配&quot;hello&quot;和&quot;hola&quot;，可以执行<code>/hello\|hola</code>。 您必须使用（<code>\</code>）转义（<code>|</code>）或运算符，否则 Vim 将按字面意义搜索字符串&quot;|&quot;。</p><p>如果您不想每次都输入<code>\|</code>，则可以在搜索开始时使用<code>magic</code>语法（<code>\v</code>）:<code>/\vhello|hola</code>。 我不会在本章中详细介绍<code>magic</code>，但是有了<code>\v</code>，您就不必再转义特殊字符了。 要了解有关<code>\v</code>的更多信息，请随时查看<code>:h \v</code>。</p><h2 id="设置模式匹配的开始位置和结束位置"><a class="markdownIt-Anchor" href="#设置模式匹配的开始位置和结束位置"></a> 设置模式匹配的开始位置和结束位置</h2><p>也许您需要搜索的文本是复合词的一部分。如果您有这些文字:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11vim22</span><br><span class="line">vim22</span><br><span class="line">11vim</span><br><span class="line">vim</span><br></pre></td></tr></table></figure><p>如果您仅需要选择以&quot;11&quot;开始、以&quot;22&quot;结束的&quot;vim&quot;，您可以使用<code>\zs</code>（开始匹配）和<code>\ze</code>（结束匹配）运算符。 执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/11\zsvim\ze22</span><br></pre></td></tr></table></figure><p>Vim仍然会匹配整个模式&quot;11vim22&quot;，但是仅高亮显示介于<code>\zs</code>和<code>\ze</code>之间的内容。 另一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foobar</span><br><span class="line">foobaz</span><br></pre></td></tr></table></figure><p>如果需要在&quot;foobaz&quot;中搜索&quot;foo&quot;，而不是在&quot;foobar&quot;中搜索，请运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo\zebaz</span><br></pre></td></tr></table></figure><h2 id="搜索字符组"><a class="markdownIt-Anchor" href="#搜索字符组"></a> 搜索字符组</h2><p>到目前为止，您所有的搜索字都是字面内容。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符组<code>[ ]</code>。</p><p>如果您需要搜索任何数字，则可能不想每一次都输入<code>/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0</code>。相反，请使用<code>/[0-9]</code>来匹配一位数字。 <code>0-9</code>表达式表示 Vim 尝试匹配的数字范围是 0-9，因此，如果要查找 1 到 5 之间的数字，请使用<code>/[1-5]</code>。</p><p>数字不是 Vim 可以查找的唯一数据类型。您也可以执行<code>/[a-z]</code>来搜索小写字母，而<code>/[A-Z]</code>来搜索大写字母。</p><p>您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行<code>/[0-9a-fA-F]</code>。</p><p>要进行否定搜索，可以在字符范围括号内添加<code>^</code>。要搜索非数字，请运行<code>/[^0-9]</code>，Vim会匹配任何字符，只要它不是数字即可。请注意，范围括号内的脱符号（<code>^</code>）与行首位置符号（例如:<code>/^hello</code>）不同。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示&quot;一行中的第一个字符&quot;。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 <code>/^abc</code>匹配行中的第一个&quot;abc&quot;，而<code>/[^abc]</code>匹配除&quot;a&quot;，&quot;b&quot;或&quot;c&quot;以外的任何字符。</p><h2 id="搜索重复字符"><a class="markdownIt-Anchor" href="#搜索重复字符"></a> 搜索重复字符</h2><p>如果需要在此文本中搜索两位数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1aa</span><br><span class="line">11a</span><br><span class="line">111</span><br></pre></td></tr></table></figure><p>您可以使用<code>/[0-9][0-9]</code>来匹配两位数字字符，但是该方法难以扩展。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个<code>count</code>参数。</p><p>您可以将<code>count</code>传递给您的搜索。 它具有以下语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;n,m&#125;</span><br></pre></td></tr></table></figure><p>顺便说一句，当在 Vim 中使用它们时，这些<code>count</code>周围的花括号需要被转义。 <code>count</code> 运算符放在您要递增的单个字符之后。</p><p>这是<code>count</code>语法的四种不同变体:</p><ul><li><code>&#123;n&#125;</code>是精确匹配。 <code>/[0-9]\&#123;2\&#125;</code>匹配两个数字:“11”，以及&quot;111&quot;中的&quot;11&quot;。</li><li><code>&#123;n,m&#125;</code>是范围匹配。 <code>/[0-9]\&#123;2,3\&#125;</code>匹配 2 到 3 位数字:“11&quot;和&quot;111”。</li><li><code>&#123;,m&#125;</code>是上限匹配。 <code>/[0-9]\&#123;,3\&#125;</code>匹配最多 3 个数字:“1”，“11&quot;和&quot;111”。</li><li><code>&#123;n,&#125;</code>是下限匹配。 <code>/[0-9]\&#123;2,\&#125;</code>匹配最少 2 个或多个数字:“11&quot;和&quot;111”。</li></ul><p>计数参数<code>\&#123;0,\&#125;</code>（零或多个）和<code>\&#123;1,\&#125;</code>（一个或多个）是最常见的搜索模式，Vim 为它们提供了特殊的操作符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）。 如果执行<code>/[0-9]*</code>，功能与<code>/[0-9]\&#123;0,\&#125;</code>相同。 它搜索零个或多个数字，会匹配&quot;“，“1”，“123”。 顺便说一句，它也将匹配非数字，例如&quot;a”，因为在技术上，字母&quot;a&quot;中的数字个数为零。 在使用&quot;*“之前，请仔细考虑。 如果执行<code>/[0-9]\+</code>，则与<code>/[0-9]\&#123;1,\&#125;</code>相同。 它搜索一个或多个数字，将匹配&quot;1&quot;和&quot;12”。</p><h2 id="预定义的字符组"><a class="markdownIt-Anchor" href="#预定义的字符组"></a> 预定义的字符组</h2><p>Vim 为常见字符组（例如数字和字母）提供了简写。 我不会在这里逐一介绍，但可以在<code>:h /character-classes</code>中找到完整列表。 下面是有用的部分:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d    数字[0-9]</span><br><span class="line">\D    非数字[^ 0-9]</span><br><span class="line">\s    空格字符（空格和制表符）</span><br><span class="line">\S    非空白字符（除空格和制表符外的所有字符）</span><br><span class="line">\w    单词字符[0-9A-Za-z_]</span><br><span class="line">\l    小写字母[a-z]</span><br><span class="line">\u    大写字符[A-Z]</span><br></pre></td></tr></table></figure><p>您可以像使用普通字符组一样使用它们。 要搜索任何一位数字，可以使用<code>/\d</code>以获得更简洁的语法，而不使用<code>/[0-9]</code>。</p><h2 id="搜索示例在一对相似字符之间捕获文本"><a class="markdownIt-Anchor" href="#搜索示例在一对相似字符之间捕获文本"></a> 搜索示例：在一对相似字符之间捕获文本</h2><p>如果要搜索由双引号引起来的短语:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Vim is awesome!&quot;</span><br></pre></td></tr></table></figure><p>运行这个:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`/&quot;[^&quot;]\+&quot;`</span><br></pre></td></tr></table></figure><p>让我们分解一下:</p><ul><li><code>&quot;</code> 是字面双引号。它匹配第一个双引号。</li><li><code>[^&quot;]</code> 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。</li><li><code>\+</code>表示一个或多个。因为它的前面是<code>[^&quot;]</code>，因此 Vim 查找一个或多个不是双引号的字符。</li><li><code>&quot;</code> 是字面双引号。它与右双引号匹配。</li></ul><p>当看到第一个<code>&quot;</code>时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个<code>&quot;</code>模式并停止模式捕获。同时，两个双引号之间的所有非双引号字符都被<code>[^&quot;]\+</code> 模式捕获，在这个例子中是短语&quot;Vim is awesome!&quot;。这是一个通用模式（其实就是正则表达式）用于捕获 <strong>由一对类似的定界符包围的短语</strong>。</p><ul><li>要捕获被单引号包围的短语，你可以使用<code>/'[^']\+'</code></li><li>要捕获为0包围的短语，你可以使用<code>/0[^0]\+0</code></li></ul><h2 id="搜索示例捕获电话号码"><a class="markdownIt-Anchor" href="#搜索示例捕获电话号码"></a> 搜索示例：捕获电话号码</h2><p>如果要匹配以连字符(<code>-</code>)分隔的美国电话号码，例如<code>123-456-7890</code>，则可以使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\d\&#123;3\&#125;-\d\&#123;3\&#125;-\d\&#123;4\&#125;</span><br></pre></td></tr></table></figure><p>美国电话号码的组成是：首先是三位数字，其后是另外三位数字，最后是另外四位数字。 让我们分解一下:</p><ul><li><code>\d\&#123;3\&#125;</code>与精确重复三次的数字匹配</li><li><code>-</code>是字面的连字符</li></ul><p>为避免转义，可使用<code>\v</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;</span><br></pre></td></tr></table></figure><p>此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。</p><p>这涵盖了本章的搜索部分。 现在开始讲替换。</p><h2 id="基本替换"><a class="markdownIt-Anchor" href="#基本替换"></a> 基本替换</h2><p>Vim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/&#123;old-pattern&#125;/&#123;new-pattern&#125;/</span><br></pre></td></tr></table></figure><p>让我们从一个基本用法开始。 如果您有以下文字:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is good</span><br></pre></td></tr></table></figure><p>让我们用&quot;awesome&quot;代替&quot;good&quot;，因为 Vim 很棒。 运行<code>:s/good/awesome/.</code>您应该看到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br></pre></td></tr></table></figure><h2 id="重复最后一次替换"><a class="markdownIt-Anchor" href="#重复最后一次替换"></a> 重复最后一次替换</h2><p>您可以使用普通模式命令<code>&amp;</code>或运行<code>:s</code>来重复最后一个替代命令。 如果您刚刚运行<code>:s/good/awesome/</code>，则运行<code>&amp;</code>或<code>:s</code>将会重复执行。</p><p>另外，在本章前面，我提到您可以使用<code>//</code>来重复先前的搜索模式。 此技巧可用于替代命令。 如果<code>/good</code>是最近被替换的单词，那么将第一个替换模式参数留为空白，例如在<code>:s//awesome/</code>中，则与运行<code>:s/good/awesome/</code>相同。</p><h2 id="替换范围"><a class="markdownIt-Anchor" href="#替换范围"></a> 替换范围</h2><p>就像许多 Ex 命令一样，您可以将范围参数传递给替换命令。 语法为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]s/old/new/</span><br></pre></td></tr></table></figure><p>如果您有以下表达式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure><p>要将第3行到第5行中的&quot;let&quot;替换为&quot;const&quot;，您可以执行以下操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3,5s/let/const/</span><br></pre></td></tr></table></figure><p>下面是一些你可以使用的范围参数的变体:</p><ul><li><code>:,3/let/const/</code> - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换到第 3 行。</li><li><code>:1,s/let/const/</code> - 如果逗号后没有给出任何内容，它也代表当前行。 从第 1 行替换到当前行。</li><li><code>:3s/let/const/</code> - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。</li></ul><p>在 Vim 中，<code>%</code>通常表示整个文件。 如果运行<code>:%s/let/const/</code>，它将在所有行上进行替换。请记住这个范围参数语法，在后面章节中很多命令行命令都遵循这个语法。</p><h2 id="模式匹配"><a class="markdownIt-Anchor" href="#模式匹配"></a> 模式匹配</h2><p>接下来的几节将介绍基本的正则表达式。 丰富的模式知识对于掌握替换命令至关重要。</p><p>如果您具有以下表达式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure><p>要在数字周围添加一对双引号:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\d/&quot;\0&quot;/</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure><p>让我们分解一下命令:</p><ul><li><code>:%s</code> 定位整个文件以执行替换。</li><li><code>\d</code> 是 Vim 的预定义数字范围简写(类似使用<code>[0-9]</code>)。</li><li><code>&quot;\0&quot;</code> 双引号是双引号的字面值。 <code>\0</code>是一个特殊字符，代表&quot;整个匹配的模式&quot;。 此处匹配的模式是单个数字<code>\d</code>。</li></ul><p>另外，<code>&amp;</code>也同样代表&quot;整个匹配的模式&quot;，就像<code>\0</code>一样。 <code>:s/\d/&quot;&amp;&quot;/</code>也可以。</p><p>让我们考虑另一个例子。 给出以下表达式，您需要将所有的&quot;let&quot;和变量名交换位置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one let = &quot;1&quot;;</span><br><span class="line">two let = &quot;2&quot;;</span><br><span class="line">three let = &quot;3&quot;;</span><br><span class="line">four let = &quot;4&quot;;</span><br><span class="line">five let = &quot;5&quot;;</span><br></pre></td></tr></table></figure><p>为此，请运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\(\w\+\) \(\w\+\)/\2 \1/</span><br></pre></td></tr></table></figure><p>上面的命令包含太多的反斜杠，很难阅读。 使用<code>\v</code>运算符更方便:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\w+) (\w+)/\2 \1/</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure><p>太好了！ 让我们分解该命令:</p><ul><li><code>:%s</code> 定位文件中的所有行以执行替换操作</li><li><code>(\w+) (\w+)</code>对模式进行分组。<code>\w</code>是 Vim 预定义的单词字符范围简写(<code>[0-9A-Za-z_]</code>)之一。 包围<code>\w</code>的<code>()</code>将匹配的单词字符进行分组。 请注意两个分组之间的空间。 <code>(\w+) (\w+)</code> 捕获两个分组。 在第一行上，第一组捕获&quot;let&quot;，第二组捕获&quot;one&quot;。(英文版中，作者写成了：第一组捕获&quot;one&quot;，第二组捕获&quot;two&quot;，可能是作者不小心的错误)。</li><li><code>\2 \1</code> 以相反的顺序返回捕获的组。 <code>\2</code>包含捕获的字符串&quot;let&quot;，而<code>\1</code>包含字符串&quot;one&quot;。 使<code>\2 \1</code>返回字符串&quot;let one&quot;。</li></ul><p>回想一下，<code>\0</code>代表整个匹配的模式。 您可以使用<code>( )</code>将匹配的字符串分成较小的组。 每个组都由<code>\1</code>, <code>\2</code>, <code>\3</code>等表示。</p><p>让我们再举一个例子来巩固这一匹配分组的概念。 如果您有以下数字:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure><p>要颠倒顺序，请运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d)(\d)(\d)/\3\2\1/</span><br></pre></td></tr></table></figure><p>结果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">321</span><br><span class="line">654</span><br><span class="line">987</span><br></pre></td></tr></table></figure><p>每个<code>(\d)</code>都匹配一个数字并创建一个分组。 在第一行上，第一个<code>(\d)</code>的值为&quot;1&quot;，第二个<code>(\d)</code>的值为&quot;2&quot;，第三个<code>(\d)</code>的值为&quot;3&quot;。 它们存储在变量<code>\1</code>，<code>\2</code>和<code>\3</code>中。 在替换的后半部分，新模式<code>\3\2\1</code>在第一行上产生&quot;321&quot;值。</p><p>相反，如果您运行下面的命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d\d)(\d)/\2\1/</span><br></pre></td></tr></table></figure><p>您将获得不同的结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">312</span><br><span class="line">645</span><br><span class="line">978</span><br></pre></td></tr></table></figure><p>这是因为您现在只有两个组。 被<code>(\d\d)</code>捕获的第一组存储在<code>\1</code>内，其值为&quot;12&quot;。 由<code>(\d)</code>捕获的第二组存储在<code>\2</code>内部，其值为&quot;3&quot;。 然后，<code>\2\1</code>返回&quot;312&quot;。</p><h2 id="替换标志"><a class="markdownIt-Anchor" href="#替换标志"></a> 替换标志</h2><p>如果您有以下句子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure><p>要将所有 pancakes 替换为 donut，您不能只运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut</span><br></pre></td></tr></table></figure><p>上面的命令将仅替换第一个匹配项，返回的结果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate donut, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure><p>有两种解决方法。 一，您可以再运行两次替代命令。 二，您可以向其传递全局(<code>g</code>)标志来替换一行中的所有匹配项。</p><p>让我们谈谈全局标志。 运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut/g</span><br></pre></td></tr></table></figure><p>Vim 迅速将所有&quot;pancake&quot;替换为&quot;donut&quot;。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;    重用上一个替代命令中的标志。 必须作为第一个标志传递。</span><br><span class="line">g    替换行中的所有匹配项。</span><br><span class="line">c    要求替代确认。</span><br><span class="line">e    防止替换失败时显示错误消息。</span><br><span class="line">i    执行不区分大小写的替换</span><br><span class="line">I    执行区分大小写的替换</span><br></pre></td></tr></table></figure><p>我上面没有列出更多标志。 要了解所有标志，请查看<code>:h s_flags</code>。</p><p>顺便说一句，重复替换命令（<code>&amp;</code>和<code>:s</code>）不保留标志。 运行<code>&amp;</code>只会重复<code>:s/pancake/donut/</code>而没有<code>g</code>。 要使用所有标志快速重复最后一个替代命令，请运行<code>:&amp;&amp;</code>。</p><h2 id="更改定界符"><a class="markdownIt-Anchor" href="#更改定界符"></a> 更改定界符</h2><p>如果您需要用长路径替换 URL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mysite.com/a/b/c/d/e</span><br></pre></td></tr></table></figure><p>要用单词&quot;hello&quot;代替它，请运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/</span><br></pre></td></tr></table></figure><p>但是，很难说出哪些正斜杠（<code>/</code>）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或<code>&quot;</code>，<code>|</code>和<code>\</code>之外的字符）来更改定界符。让我们将它们替换为<code>+</code>。上面的替换命令可以重写为 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+</span><br></pre></td></tr></table></figure><p>现在，更容易看到分隔符在哪里。</p><h2 id="特殊替换"><a class="markdownIt-Anchor" href="#特殊替换"></a> 特殊替换</h2><p>您还可以修改要替换的文本的大小写。 给出以下表达式，您的任务是将所有变量名比如 “one”, “two”, &quot;three&quot;等，改成大写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure><p>请运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/\v(\w+) (\w+)/\1 \U\2/</span><br></pre></td></tr></table></figure><p>你会得到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ONE = &quot;1&quot;;</span><br><span class="line">let TWO = &quot;2&quot;;</span><br><span class="line">let THREE = &quot;3&quot;;</span><br><span class="line">let FOUR = &quot;4&quot;;</span><br><span class="line">let FIVE = &quot;5&quot;;</span><br></pre></td></tr></table></figure><p>这是该命令的细分:</p><ul><li><code>(\w+) (\w+)</code>捕获前两个匹配的分组，例如&quot;let&quot;和&quot;one&quot;。</li><li><code>\1</code>返回第一个组的值&quot;let&quot;</li><li><code>\U\2</code>大写(<code>\U</code>)第二组(<code>\2</code>)。</li></ul><p>该命令的窍门是表达式<code>\U\2</code>。<code>\U</code>将后面跟着的字符变为大写。</p><p>让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is the greatest text editor in the whole galaxy</span><br></pre></td></tr></table></figure><p>您可以运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/\&lt;./\U&amp;/g</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vim Is The Greatest Text Editor In The Whole Galaxy</span><br></pre></td></tr></table></figure><p>细目如下:</p><ul><li><code>:s</code> 替换当前行</li><li><code>\&lt;.</code> 由两部分组成:<code>\&lt;</code>匹配单词的开头，<code>.</code>匹配任何字符。 <code>\&lt;</code>运算符使后面跟着的字符表示单词的第一个字符。 由于<code>.</code>是下一个字符，因此它将匹配任意单词的第一个字符。</li><li><code>\U&amp;</code> 将后续符号子序列<code>&amp;</code>大写。 回想一下，<code>&amp;</code>（或<code>\0</code>）代表整个匹配。 这里它匹配单词的第一个字符。</li><li><code>g</code>全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。</li></ul><p>要了解替换的特殊替换符号（如<code>\u</code>和<code>\U</code>）的更多信息，请查看<code>:h sub-replace-special</code>。</p><h2 id="候选模式"><a class="markdownIt-Anchor" href="#候选模式"></a> 候选模式</h2><p>有时您需要同时匹配多个模式。 如果您有以下问候:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure><p>您仅需在包含单词&quot;hello&quot;或&quot;hola&quot;的行上用&quot;friend&quot;代替&quot;vim&quot;。回想一想本章前面的知识点，你可以使用<code>|</code> 来分隔可选的模式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(hello|hola) vim)/\1 friend/g</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello friend</span><br><span class="line">hola friend</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure><p>这是细分:</p><ul><li><code>%s</code> 在文件的每一行上运行替代命令。</li><li><code>(hello|hola)</code> 匹配*“hello&quot;或&quot;hola”，并将其视为一个组。</li><li><code>vim</code> 是字面意思&quot;vim&quot;。</li><li><code>\1</code> 是第一个匹配组，它是文本&quot;hello&quot;或&quot;hola&quot;。</li><li><code>friend</code> 是字面的“朋友&quot;。</li></ul><h2 id="指定替换模式的开始位置和结束位置"><a class="markdownIt-Anchor" href="#指定替换模式的开始位置和结束位置"></a> 指定替换模式的开始位置和结束位置</h2><p>回想一下，您可以使用<code>\zs</code>和<code>\ze</code>来指定一个匹配的开始位置和结束位置。这个技术在替换操作中同样有效，如果你有以下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake</span><br><span class="line">strawberry sweetcake</span><br><span class="line">blueberry hotcake</span><br></pre></td></tr></table></figure><p>要想将&quot;hotcake&quot;中的&quot;cake&quot;替换为&quot;dog&quot;，得到&quot;hotdog&quot;:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/hot\zscake/dog/g</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake</span><br><span class="line">strawberry sweetcake</span><br><span class="line">blueberry hotdog</span><br></pre></td></tr></table></figure><h2 id="贪婪与非贪婪"><a class="markdownIt-Anchor" href="#贪婪与非贪婪"></a> 贪婪与非贪婪</h2><p>您可以使用下面技巧，在某行中替换第n个匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.</span><br></pre></td></tr></table></figure><p>要想将第3个&quot;Mississippi&quot;替换为 “Arkansas”，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/\v(.&#123;-&#125;\zsMississippi)&#123;3&#125;/Arkansas/g</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>:s/</code> 替换命令。</li><li><code>\v</code> 魔术关键字，使您不必转义特殊字符。</li><li><code>.</code> 匹配任意单个字符。</li><li><code>&#123;-&#125;</code> 表示使用非贪婪模式匹配前面的0个或多个字符。</li><li><code>\zsMississippi</code> 使得从&quot;Mississippi&quot;开始捕获匹配。</li><li><code>(...)&#123;3&#125;</code> 查找第3个匹配</li></ul><p>在本章前面的内容中，你已经看到过<code>&#123;3&#125;</code>这样的语法。在本例中，<code>&#123;3&#125;</code>将精确匹配第3个匹配。这里的新技巧是<code>&#123;-&#125;</code>。它表示进行非贪婪匹配。它会找到符合给定模式的最短的匹配。在本例中，<code>(.&#123;-&#125;Mississippi)</code>匹配以任意字符开始、数量最少的&quot;Mississippi&quot;。对比<code>(.*Mississippi)</code>，后者会找到符合给定模式的最长匹配。</p><p>如果您使用<code>(.&#123;-&#125;Mississippi)</code>，你会得到5个匹配：“One Mississippi”, “Two Mississippi”,等。如果您使用<code>(.*Mississippi)</code>，您只会得到1个匹配：最后一个 “Mississippi”。<code>*</code>表示贪婪匹配，而<code>&#123;-&#125;</code>表示非贪婪匹配。要想了解更多，可以查看 <code>:h /\&#123;-</code> 和 <code>:h non-greedy</code>。</p><p>让我们看一个简单的例子。如果您有以下字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc1de1</span><br></pre></td></tr></table></figure><p>用贪婪模式匹配 “abc1de1” ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a.*1</span><br></pre></td></tr></table></figure><p>用非贪婪模式匹配 “abc1”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a.\&#123;-&#125;1</span><br></pre></td></tr></table></figure><p>因此，如果您需要将最长的匹配转为大写（贪婪模式），运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/a.*1/\U&amp;/g</span><br></pre></td></tr></table></figure><p>会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC1DE1</span><br></pre></td></tr></table></figure><p>如果您需要将最短的匹配转为大写（非贪婪模式），运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/a.\&#123;-&#125;1/\U&amp;/g</span><br></pre></td></tr></table></figure><p>会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC1de1</span><br></pre></td></tr></table></figure><p>如果您是第一次接触贪婪模式与非贪婪模式这两个概念，可能会把你绕晕。围绕不同的组合去实验，知道您明白这两个概念。</p><h2 id="跨多个文件替换"><a class="markdownIt-Anchor" href="#跨多个文件替换"></a> 跨多个文件替换</h2><p>最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: <code>food.txt</code> 和 <code>animal.txt</code>.</p><p><code>food.txt</code>内:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">corn dog</span><br><span class="line">hot dog</span><br><span class="line">chili dog</span><br></pre></td></tr></table></figure><p><code>animal.txt</code>内:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">large dog</span><br><span class="line">medium dog</span><br><span class="line">small dog</span><br></pre></td></tr></table></figure><p>假设您的目录结构如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├ food.txt</span><br><span class="line">├ animal.txt</span><br></pre></td></tr></table></figure><p>首先，用<code>:args</code>同时捕获&quot;food.txt&quot;和&quot;animal.txt&quot;到参数列表中。回顾前面的章节，<code>:args</code>可用于创建文件名列表。在 Vim 中有几种方法可以做到这一点，其中一种方法是在Vim内部运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args *.txt                  捕获当前位置的所有txt文件</span><br></pre></td></tr></table></figure><p>测试一下，当您运行<code>:args</code>时，您应该会看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[food.txt] animal.txt</span><br></pre></td></tr></table></figure><p>现在，所有的相关文件都已经存储在参数列表中，您可以用 <code>:argdo</code> 命令跨多文件替换，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo %s/dog/chicken/</span><br></pre></td></tr></table></figure><p>这条命令对所有<code>:args</code>列表中的文件执行替换操作。最终，存储修改的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo update</span><br></pre></td></tr></table></figure><p><code>:args</code> 和 <code>:argdo</code> 是两个有用的工具，用于跨多文件执行命令行命令。可以用其他命令结合尝试一下！</p><h2 id="用宏跨多个文件替换"><a class="markdownIt-Anchor" href="#用宏跨多个文件替换"></a> 用宏跨多个文件替换</h2><p>另外，您也可以用宏跨多个文件运行替代命令。执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:args *.txt</span><br><span class="line">qq</span><br><span class="line">:%s/dog/chicken/g</span><br><span class="line">:wnext</span><br><span class="line">q</span><br><span class="line">99@q</span><br></pre></td></tr></table></figure><p>以下是步骤的细分:</p><ul><li><code>:args *.txt</code> 会将相关文件列出到<code>:args</code>列表中。</li><li><code>qq</code> 启动&quot;q&quot;寄存器中的宏。</li><li><code>:%s/dog/chicken/g</code>在当前文件的所有行上用&quot;chicken&quot;替换&quot;dog&quot;。</li><li><code>:wnext</code> 写入（保存）文件，然后转到<code>args</code>列表中的下一个文件。就像同时运行<code>:w</code>和<code>:next</code>一样。</li><li><code>q</code> 停止宏录制。</li><li><code>99@q</code> 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。</li></ul><h2 id="以聪明的方式学习搜索和替换"><a class="markdownIt-Anchor" href="#以聪明的方式学习搜索和替换"></a> 以聪明的方式学习搜索和替换</h2><p>良好的搜索能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。要想掌握正则表达式，您必须在实践中去不断地使用它。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。</p><p>一种提高模式匹配技能的好方法是，每当您需要搜索一个模式串时（例如&quot;hello 123&quot;），不要直接查询文字的字面值(<code>/hello 123</code>)，去尝试使用模式串来搜索它(比如<code>/\v(\l+) (\d+)</code>)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。</p><p>既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/ba239799/">Ch 11 - 可视模式</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/fbe80173/">Ch 13 - 全局命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch11-可视模式</title>
      <link href="/posts/ba239799.html"/>
      <url>/posts/ba239799.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>高亮显示文本块并对其进行更改，是很多文本编辑器中的常见功能。 Vim也可以使用可视模式实现这一功能。在本章中，您将学习如何使用可视模式来有效地处理文本块。</p><h2 id="三种可视模式"><a class="markdownIt-Anchor" href="#三种可视模式"></a> 三种可视模式</h2><p>Vim有三种可视模式，分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v         逐字符可视模式</span><br><span class="line">V         逐行可视模式</span><br><span class="line">Ctrl-v    逐块可视模式</span><br></pre></td></tr></table></figure><p>如果您有下列文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>逐字符可视模式用于选择单个字符。在第一行的第一个字符上按<code>v</code>。然后使用<code>j</code>跳转至下一行。它高亮显示从&quot;one&quot;到光标位置的所有文本。现在，如果您按<code>gU</code>，Vim将高亮显示的字符转为大写。</p><p>逐行可视模式适用于整行。按<code>V</code>并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行<code>gU</code>，Vim将高亮显示的字符转为大写。</p><p>逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按<code>Ctrl-V</code>，Vim像逐字符可视模式一样高亮显示光标下的字符，但向下移动时，除非光标已经在行尾，否则不会高亮显示光标上方的整行，它跳转至下一行时高亮显示尽可能少的字符。尝试用<code>h/j/k/l</code>移动，并观察光标的移动。</p><p>在Vim窗口的左下方，您会看到显示<code>-- VISUAL --</code>，<code>-- VISUAL LINE --</code>或<code>-- VISUAL BLOCK --</code>以提示您所处的可视模式。</p><p>当您处于可视模式时，可以通过按<code>v</code>，<code>V</code>或<code>Ctrl-V</code>键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行<code>Ctrl-V</code>。试试吧！</p><p>有三种退出可视模式的方法：<code>esc</code>，<code>Ctrl-C</code>和与当前可视模式相同的键。后者的意思是，如果您当前处于逐行可视模式(<code>V</code>)，则可以通过再次按<code>V</code>退出它。如果您处于字符可视模式，则可以通过按<code>v</code>退出它。如果您处于逐块可视模式，请按<code>Ctrl-V</code>。</p><p>实际上，还有另一种进入可视模式的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gv    转到上一个可视模式</span><br></pre></td></tr></table></figure><p>它将在与上次相同的高亮显示的文本块上启动相同的可视模式。</p><h2 id="可视模式导航"><a class="markdownIt-Anchor" href="#可视模式导航"></a> 可视模式导航</h2><p>在可视模式下，您可以使用Vim动作(motion)扩展高亮显示的文本块。</p><p>让我们使用之前使用的相同文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>这次让我们从&quot;two&quot;行开始。按<code>v</code>进入字符可视模式(这里的方括号<code>[]</code>表示高亮显示的字符)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>按<code>j</code>，Vim将高亮显示从&quot;two&quot;行到&quot;three&quot;行的第一个字符的所有文本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure><p>假设您刚刚意识到还需要高亮显示&quot;one&quot;行，因此按<code>k</code>。令您沮丧的是，它现在排除了&quot;three&quot;高亮。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？</p><p>答案是肯定的。让我们先恢复光标到高亮显示&quot;two&quot;和&quot;three&quot;行的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree    &lt;-- 光标</span><br></pre></td></tr></table></figure><p>高亮区域跟随光标移动。如果要将其向上扩展到行&quot;one&quot;，则需要将光标移动到&quot;two&quot;，现在您的光标在&quot;three&quot;行上。这时可以用<code>o</code>或<code>O</code>切换光标位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two     &lt;-- 光标</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure><p>现在，当您按<code>k</code>时，它不再缩小选择，而是向上扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure><p>在可视模式中使用<code>o</code>或<code>O</code>，光标会在高亮选择区域的开头和结尾跳转，以便与您扩展高亮区域。</p><h2 id="可视模式语法"><a class="markdownIt-Anchor" href="#可视模式语法"></a> 可视模式语法</h2><p>可视模式与普通模式使用相同的操作符(operations)。</p><p>例如，如果您有以下文字，然后您想在可视模式中删除前两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>用逐行可视模式(<code>V</code>)高亮显示&quot;one&quot;和&quot;two&quot;行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>按下<code>d</code>键将删除选择，类似于普通模式。请注意，与普通模式的语法规则有所不同，动词+名词不适用可视模式。虽然存在相同的动词(<code>d</code>)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词(反过来了)，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。</p><p>在普通模式下，有一些命令不需要名词(motion)，例如<code>x</code>删除光标下方的单个字符，还有<code>r</code>替换光标下方的字符(<code>rx</code>将当前光标下的字符替换为<code>x</code>)。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。回到高亮显示的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>运行<code>x</code>会删除所有高亮显示的文本。</p><p>您可以使用此行为在markdown文本中快速创建标题。假设您需要快速下面的文本转换为一级markdown标题(“===”):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br></pre></td></tr></table></figure><p>首先，您使用<code>yy</code>复制文本，然后使用<code>p</code>粘贴文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">Chapter One</span><br></pre></td></tr></table></figure><p>现在转到第二行，以逐行可视模式选择它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">[Chapter One]</span><br></pre></td></tr></table></figure><p>在markdown中，您可以通过在文本下方添加一系列<code>=</code>来创建标题，因此您可以通过运行<code>r=</code>来替换整个高亮显示的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">===========</span><br></pre></td></tr></table></figure><p>要了解有关可视模式下的运算符的更多信息，请查看<code>:h visual-operators</code>。</p><h2 id="可视模式和ex命令"><a class="markdownIt-Anchor" href="#可视模式和ex命令"></a> 可视模式和Ex命令</h2><p>您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式,并想将前两行的&quot;const&quot;替换为&quot;let&quot;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;;</span><br><span class="line">const two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure><p>用 <em>任意</em> 可视模式高亮显示前两行，然后运行替换命令<code>:s/const/let/g</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;one&quot;;</span><br><span class="line">let two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure><p>请注意，我说过您可以使用 <em>任何</em> 可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。只要您在每行上至少选择一个字符，就会应用Ex命令。</p><h2 id="跨多行编辑"><a class="markdownIt-Anchor" href="#跨多行编辑"></a> 跨多行编辑</h2><p>您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;</span><br><span class="line">const two = &quot;two&quot;</span><br><span class="line">const three = &quot;three&quot;</span><br></pre></td></tr></table></figure><p>将光标放在第一行上：</p><ul><li>进入逐块可视模式，并向下两行(<code>Ctrl-V jj</code>)。</li><li>高亮显示到行尾(<code>$</code>)。</li><li>按(<code>A</code>) ，然后键入&quot;;&quot;。</li><li>退出可视模式(<code>esc</code>)。</li></ul><p>您应该看到在每一行后面附加的 “;”。666! 有两种方法可以从逐块可视模式进入输入模式：可以使用<code>A</code>在光标后输入文本，也可以使用<code>I</code>在光标前输入文本。请勿将它们与普通模式下的<code>A</code>和<code>I</code>混淆。(普通模式中，<code>A</code>表示在行尾添加内容，<code>I</code>表示在行尾非空字符前插入内容)。</p><p>另外，您也可以使用<code>:normal</code>命令在多行添加内容：<br />-高亮显示所有3行(<code>vjj</code>)。<br />-输入<code>:normal! A;</code>。</p><p>记住，<code>:normal</code>命令执行普通模式命令。您可以指示它运行<code>A;</code>在该行的末尾添加文本&quot;;&quot;。</p><h2 id="递增数字"><a class="markdownIt-Anchor" href="#递增数字"></a> 递增数字</h2><p>Vim有<code>Ctrl-X</code>和<code>Ctrl-A</code>命令来减少和增加数字。与可视模式一起使用时，可以跨多行递增数字。</p><p>如果您具有以下HTML元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：</p><ul><li>将光标移动到 <strong>第二行</strong>的 “1”。</li><li>启动逐块可视模式，并向下移动3行(<code>Ctrl-V 3j</code>)。这高亮显示剩余的&quot;1&quot;，现在除了第一行，所有的&quot;1&quot;应该已经高亮。</li><li>运行<code>g Ctrl-A</code>。</li></ul><p>您应该看到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-5&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>g Ctrl-A</code>在多行上递增数字。 <code>Ctrl-X/Ctrl-A</code>也可以增加字母。如果您运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set nrformats+=alpha</span><br></pre></td></tr></table></figure><p><code>nrformats</code>选项指示Vim将哪个基数视为<code>Ctrl-A</code>和<code>Ctrl-X</code>递增和递减的“数字”。通过添加<code>alpha</code>，现在将字母字符视为数字。如果您具有以下HTML元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>将光标放在第二个&quot;app-a&quot;上。使用与上述相同的技术(<code>Ctrl-V 3j</code> 然后 <code>g Ctrl-A</code>)增加ID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-b&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-c&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-d&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-e&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="选择最后一个可视模式区域"><a class="markdownIt-Anchor" href="#选择最后一个可视模式区域"></a> 选择最后一个可视模式区域</h2><p>前面章节中我提到了<code>gv</code>可以快速高亮显示上一个可视模式选择的内容。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&lt;    转到上一个可视模式高亮显示的第一个位置（行）(译者注，英文原版中&#x27;&lt;&#x27;前面的符号是`，但这应该是一个错误，应该是单引号&#x27;)</span><br><span class="line">&#x27;&gt;    转到上一个可视模式高亮显示的最后位置（行）</span><br></pre></td></tr></table></figure><p>之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：<code>:s/const/let/g</code>。当您这样做时，您应该看到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#x27;&lt;,&#x27;&gt;s/const/let/g</span><br></pre></td></tr></table></figure><p>您实际上是在使用(<code>'&lt;, '&gt;</code>) 标记作为范围来执行 <code>s/const/let/g</code>命令。这太有趣了！</p><p>您随时可以随时编辑这些标记。比如，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#x27;&lt;,$s/const/let/g</span><br></pre></td></tr></table></figure><h2 id="从插入模式进入可视模式"><a class="markdownIt-Anchor" href="#从插入模式进入可视模式"></a> 从插入模式进入可视模式</h2><p>您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-O v</span><br></pre></td></tr></table></figure><p>回想一下，在插入模式下运行<code>Ctrl-O</code>可以使您执行普通模式命令。在普通模式命令挂起模式下，运行<code>v</code>进入逐字可视模式。请注意，在屏幕的左下方，它显示为<code>--(insert) VISUAL--</code>。该技巧适用于任何可视模式运算符：<code>v</code>，<code>V</code>，和<code>Ctrl-V</code>。</p><h2 id="选择模式"><a class="markdownIt-Anchor" href="#选择模式"></a> 选择模式</h2><p>Vim具有类似于可视模式的模式，称为<em>选择模式</em>。与可视模式一样，它也具有三种不同的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gh         逐字符选择模式</span><br><span class="line">gH         逐行选择模式</span><br><span class="line">gCtrl-h    逐块选择模式</span><br></pre></td></tr></table></figure><p>选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。</p><p>在常规编辑器中，高亮显示文本块并键入字母（例如字母&quot;y&quot;）后，它将删除高亮显示的文本并插入字母&quot;y&quot;。如果您使用逐行选择模式(<code>gH</code>)高亮显示一行文本并键入&quot;y&quot;，它将删除高亮显示的文本并插入字母&quot;y&quot;，这与常规文本编辑器非常相似。</p><p>将此行为与可视模式进行对比：如果您使用逐行可视模式(<code>V</code>)高亮显示一行文本并键入&quot;y&quot;，则高亮显示的文本不会被删除且被字母&quot;y&quot;代替，而是仅将其复制(yank)。在选择模式中，你不能执行对高亮文本执行普通模式的命令。</p><p>我个人从未使用过选择模式，但是很高兴知道它的存在。</p><h2 id="以聪明的方式学习可视模式"><a class="markdownIt-Anchor" href="#以聪明的方式学习可视模式"></a> 以聪明的方式学习可视模式</h2><p>可视模式是Vim高亮显示文本的过程。</p><p>如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。假设您需要删除一个内部单词(inner word，请回顾前面的文本对象)，如果可以只用三个按键(<code>diw</code>)，为什么要使用四个按键<code>viwd</code>（先<code>v</code>进入可视模式，然后<code>iw</code>高亮一个内部单词，最后<code>d</code>删除）呢？前者更为直接和简洁。当然，有时使用可视模式是合适的，但总的来说，更倾向于直接的方法。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/49fd3ee8/">Ch 10 - 撤消</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/36365707/">Ch 12 - 搜索和替换</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch10-撤消</title>
      <link href="/posts/49fd3ee8.html"/>
      <url>/posts/49fd3ee8.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>所有人都会犯各种各样的输入错误。因此对于任何一个现代的软件来说，撤销都是一个很基本的功能。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持存取不同的文本形态，让你能控制你输入的所有文本。在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。</p><h2 id="撤销undo重做和行撤销undo"><a class="markdownIt-Anchor" href="#撤销undo重做和行撤销undo"></a> 撤销(undo)，重做和行撤销(UNDO)</h2><p>对于一个基本的 undo 操作，你可以执行 <code>u</code> 或者 <code>:undo</code>。</p><p>假设你有如下文本(注意&quot;one&quot;下面有一个空行)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后添加另一个文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure><p>如果你执行 <code>u</code>，Vim 会删除 “two”。</p><p>Vim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。</p><p>要取消上一次的撤销，可以执行 <code>Ctrl-r</code> 或者 <code>:redo</code>。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 <code>Ctrl-r</code> 来恢复被删除掉的文本。</p><p>Vim 也有另一个命令 <code>U</code> 可以实现 行撤销 (UNDO) 的功能，执行这个命令会撤销所有最新的修改。</p><p>那么，<code>U</code> 和 <code>u</code> 的区别是什么呢？首先，<code>U</code> 会删除 <em>最近修改的行中所有的</em> 的修改，而 <code>u</code> 一次仅删除一次修改。 其次，执行<code>u</code> 不会被算作一次修改操作，而执行 <code>U</code> 则会被算作一次修改。</p><p>让我们会的之前的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure><p>修改第二行的内容为 “three” (<code>ciwthree&lt;esc&gt;</code>):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>再次修改第二行的例子为 “four” (<code>ciwfour&lt;esc&gt;</code>):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>此时，如果你按下 <code>u</code>，你会看到 “three”。如果你再次按下 <code>u</code>，你会看到 “two”。然而，在第二行仍为 “four” 的时候，如果你按下 <code>U</code>，你会看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行 <code>U</code> 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 <code>U</code> 后 再次执行 <code>U</code> 会撤销 自己。假如你连续执行 <code>U</code>，那么你将看到第二行的文本不停地出现和消失。</p><p>就我个人而言，我几乎不会使用 <code>U</code>，因为很难记住文本最初的样子。（我几乎不使用它）</p><p>Vim 可以通过变量 <code>undolevels</code> 来选择最多可执行 undo 的次数。你可以通过 <code>:echo &amp;undolevels</code> 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 <code>:set undolevels=1000</code>。不用担心，你可以设置它为任何一个你想设置的值。</p><h2 id="断点插入操作"><a class="markdownIt-Anchor" href="#断点插入操作"></a> 断点插入操作</h2><p>在上文中我提到，<code>u</code> 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。</p><p>如果你执行 <code>ione two three&lt;esc&gt;</code> 之后，按下 <code>u</code>，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 <code>u</code>，你会丢失上一次输入的所有内容。 因此，假设你按下 <code>u</code> 只删除你上一次输入的一部分文本岂不是会更好。</p><p>幸运的是，你可以拆分它。当你在插入模式时，按下 <code>Ctrl-G u</code> 会生成一个断点。例如，如果你执行 <code>ione &lt;Ctrl-G u&gt;two &lt;Ctrl-G u&gt;three&lt;esc&gt;</code>，之后你按下<code>u</code>，你仅会失去文本 “three”，再次执行 <code>u</code>，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。</p><p>在插入模式中，执行删除操作时插入断点也非常有用。例如通过 <code>Ctrl-W</code> 删除光标前的单词时，以及 <code>Ctrl-U</code>删除光标前的所有文本时。一个朋友建议我使用如下的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap &lt;c-u&gt; &lt;c-g&gt;u&lt;c-u&gt;</span><br><span class="line">inoremap &lt;c-w&gt; &lt;c-g&gt;u&lt;c-w&gt;</span><br></pre></td></tr></table></figure><p>通过上述命令，你可以很轻松地恢复被删除的文本。</p><h2 id="撤销树"><a class="markdownIt-Anchor" href="#撤销树"></a> 撤销树</h2><p>Vim 将每一次修改存储在一个撤销树中。你打开一个空白文件，然后添加一段新文本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再插入一段新文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure><p>undo一次:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入一段不同的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>再次 undo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次插入另一段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>现在如果你执行 undo,您将丢失刚刚添加的文本 “four” :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你再次执行 undo 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 <code>g+</code>，你会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次执行 <code>g+</code> ，你将会看到一位老朋友:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure><p>让我们继续执行 <code>g+</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>再一次执行 <code>g+</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure><p>在 Vim 中，你每一次执行 <code>u</code> 去做一次修改时，Vim都会通过创建一个&quot;撤销分支&quot;来保存之前的文本内容。在本例中，你输入&quot;two&quot;后, 执行 <code>u</code>，然后输入&quot;three&quot;，你就创建了一个叶子分支,保存了含有&quot;two&quot;的文本状态。此时，撤销树已经包含了至少两个叶子节点，主节点包含文本&quot;three&quot;（最新），而另一undo分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了&quot;four&quot;，那么此时会生成三个节点，一个主节点包含文本&quot;four&quot;, 以及另外两个节点分别存储了&quot;three&quot;和&quot;two&quot;。</p><p>为了在几个不同的节点状态间进行切换，你可以执行 <code>g+</code> 去获取一个较新的状态，以及执行 <code>g-</code> 去获取一个教旧的状态。 <code>u</code>， <code>Ctrl-R</code>， <code>g+</code>， 和 <code>g-</code> 之间的区别是，<code>u</code> and <code>Ctrl-R</code> 只可以在 <em>main</em> 节点之间进行切换，而<code>g+</code> 和 <code>g-</code> 可以在 <em>所有</em> 节点之间进行切换。</p><p>Undo 树并不可以很轻松地可视化。我发现一个插件 <a href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。</p><h2 id="保存撤销记录"><a class="markdownIt-Anchor" href="#保存撤销记录"></a> 保存撤销记录</h2><p>当你通过 Vim 打开一个文件，并且立即按下 <code>u</code>，Vim 很可能会显示 “<em>Already at oldest change</em>” 的警告。</p><p>要想从最近的一次编辑工作中（在vim关闭文件再打开，算做一次新的编辑工作），在撤销历史中回滚，可以通过 <code>:wundo</code>命令使Vim 保存一份你的 undo 历史记录。</p><p>创建一个文件 <code>mynumbers.txt</code>. 输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure><p>插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure><p>插入新的一行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>现在，创建你的撤销记录文件。 语法为 <code>:wundo myundofile</code>。 如果你需要覆盖一个已存在的文件，在 <code>wundo</code> 之后添加 <code>!</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wundo! mynumbers.undo</span><br></pre></td></tr></table></figure><p>退出 Vim。</p><p>此时，在目录下，应该有<code>mynumbers.txt</code> 和 <code>mynumbers.undo</code> 两个文件。再次打开 <code>mynumbers.txt</code> 文件并且按下 <code>u</code>，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 <code>:rundo</code> 来加载 undo 历史。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rundo mynumbers.undo</span><br></pre></td></tr></table></figure><p>此时，如果你按下 <code>u</code>，Vim 会删除 “three”。再次按下 <code>u</code>可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。</p><p>如果你想要自动加载 undo 历史文件，你可以通过在你的 <code>.vimrc</code> 文件中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set undodir=~/.vim/undo_dir</span><br><span class="line">set undofile</span><br></pre></td></tr></table></figure><p>我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 <code>~/.vim</code> 目录下。 <code>undo_dir</code> 是随意的。 <code>set undofile</code> 告诉 Vim 打开 <code>undofile</code> 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用<code>undo_dir</code>目录前，请确保你已经创建了它）。</p><h2 id="时间旅行"><a class="markdownIt-Anchor" href="#时间旅行"></a> 时间旅行</h2><p>是谁说时间旅行不存在。 Vim 可以通过 <code>:earlier</code> 命令将文本恢复为之前的状态。</p><p>假如有如下文本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后你输入了另一行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure><p>如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s</span><br></pre></td></tr></table></figure><p>你可以使用 <code>:undolist</code> 去查看之前所做的修改。 <code>:earlier</code> 可以加上分钟 (<code>m</code>), 小时 (<code>h</code>), and 天 (<code>d</code>) 作为参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s    恢复到10秒前的状态</span><br><span class="line">:earlier 10m    恢复到10分钟前的状态</span><br><span class="line">:earlier 10h    恢复到10小时前的状态</span><br><span class="line">:earlier 10d    恢复到10天前的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外，它同样接受一个<code>计数</code>作为参数，告诉vim恢复到老状态的次数。比如，如果运行<code>:earlier 2</code>,Vim将恢复到2次修改前的状态。功能类似于执行<code>g-</code>两次。同样，你可以运行<code>:earlier 10f</code>命令告诉vim恢复到10次保存前的状态。</p><p>这些参数同样作用于<code>:earlier</code>命令的对应版本:<code>:later</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:later 10s    恢复到10秒后的状态</span><br><span class="line">:later 10m    恢复到10分钟后的状</span><br><span class="line">:later 10h    恢复到10小时后的状</span><br><span class="line">:later 10d    恢复到10天后的状态</span><br><span class="line">:later 10     恢复到新状态10次</span><br><span class="line">:later 10f    恢复到10次保存后的状态</span><br></pre></td></tr></table></figure><h2 id="聪明地学习撤销操作"><a class="markdownIt-Anchor" href="#聪明地学习撤销操作"></a> 聪明地学习撤销操作</h2><p><code>u</code> 和 <code>Ctrl-R</code> 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用<code>:earlier</code> 和 <code>:later</code>，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 <a href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。</p><p>在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/7e0645cb/">Ch 9 - 宏</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/ba239799/">Ch 11 - 可视模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch09-宏</title>
      <link href="/posts/7e0645cb.html"/>
      <url>/posts/7e0645cb.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。</p><p>在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。</p><h2 id="基本宏命令"><a class="markdownIt-Anchor" href="#基本宏命令"></a> 基本宏命令</h2><p>宏命令的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qa                     开始记录动作到寄存器 a</span><br><span class="line">q (while recording)    停止记录</span><br></pre></td></tr></table></figure><p>你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@a    Execute macro from register a</span><br><span class="line">@@    Execute the last executed macros</span><br></pre></td></tr></table></figure><p>假设你有如下的文本，你打算将每一行中的所有字母都变为大写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">vim</span><br><span class="line">macros</span><br><span class="line">are</span><br><span class="line">awesome</span><br></pre></td></tr></table></figure><p>将你的光标移动到 “hello” 栏的行首，并执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0gU$jq</span><br></pre></td></tr></table></figure><p>上面命令的分解如下：</p><ul><li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li><li><code>0</code> 移动到行首。</li><li><code>gU$</code> 将从光标到行尾的字母变为大写。</li><li><code>j</code> 移动到下一行。</li><li><code>q</code> 停止记录。</li></ul><p>调用 <code>@a</code> 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 <code>3@a</code> 去执行 <code>a</code> 命令3次。你也可以执行 <code>3@@</code> 去执行上一次执行过的宏命令3次。</p><h2 id="安全保护"><a class="markdownIt-Anchor" href="#安全保护"></a> 安全保护</h2><p>在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure><p>你想将每一行的第一个词变为大写，你可以使用如下的宏命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0W~jq</span><br></pre></td></tr></table></figure><p>上面命令的分解如下：</p><ul><li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li><li><code>0</code> 移动到行首。</li><li><code>W</code> 移动到下一个单词。</li><li><code>~</code> 将光标选中的单词变为大写。</li><li><code>j</code> 移动到下一行。</li><li><code>q</code> 停止记录。</li></ul><p>我喜欢对宏命令进行超过所需次数的调用，所以我通常使用 <code>99@a</code> 命令去执行该宏命令99次。使用该命令，Vim并不会真正执行这个宏99次，当 Vim 到达最后一行执行<code>j</code>时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。</p><p>实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。</p><h2 id="命令行执行宏"><a class="markdownIt-Anchor" href="#命令行执行宏"></a> 命令行执行宏</h2><p>在正常模式执行 <code>@a</code> 并不是宏命令调用的唯一方式。你也可以在命令行执行 <code>：normal @a</code> 。<code>：normal</code> 会将任何用户添加的参数作为命令去执行。例如添加 <code>@a</code>，和在 normal mode 执行 <code>@a</code> 的效果是一样的。</p><p><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。</p><h2 id="在多个文件中执行宏命令"><a class="markdownIt-Anchor" href="#在多个文件中执行宏命令"></a> 在多个文件中执行宏命令</h2><p>假如你有多个 <code>.txt</code> 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是<code>0W~j</code>(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？</p><p>第一个文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## savory.txt</span><br><span class="line">a. cheddar jalapeno donut</span><br><span class="line">b. mac n cheese donut</span><br><span class="line">c. fried dumpling</span><br></pre></td></tr></table></figure><p>第二个文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## sweet.txt</span><br><span class="line">a. chocolate donut</span><br><span class="line">b. chocolate pancake</span><br><span class="line">c. powdered sugar donut</span><br></pre></td></tr></table></figure><p>第三个文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## plain.txt</span><br><span class="line">a. wheat bread</span><br><span class="line">b. plain donut</span><br></pre></td></tr></table></figure><p>你可以这么做:</p><ul><li><code>:args *.txt</code> 查找当前目录下的所有 <code>.txt</code> 文件。</li><li><code>:argdo g/donut/normal @a</code> 在 <code>:args</code> 中包含的每一个文件里执行一个全局命令 <code>g/donut/normal @a</code>。</li><li><code>:argdo update</code> 在 <code>:args</code> 中包含的每一个文件里执行 <code>update</code> 命令,保存修改后的内容。</li></ul><p>也许你对全局命令 <code>:g/donut/normal @a</code> 不是很了解，该命令会执行 <code>/donut/</code>搜索命令，然后在所有匹配的行中执行<code>normal @a</code> 命令。我会在后面的章节中介绍全局命令。</p><h2 id="递归执行宏命令"><a class="markdownIt-Anchor" href="#递归执行宏命令"></a> 递归执行宏命令</h2><p>你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏寄存器来实现。假如你有如下文本，你希望改变第一个单词的大小写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure><p>如下命令会递归地执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qaqqa0W~j@aq</span><br></pre></td></tr></table></figure><p>上面命令的分解如下：</p><ul><li><code>qaq</code> 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。</li><li><code>qa</code> 开始录入宏命令到寄存器 “a”。</li><li><code>0</code> 移动到行首。</li><li><code>W</code> 移动到下一个单词。</li><li><code>~</code> 改变光标选中的单词的大小写。</li><li><code>j</code> 移动到下一行。</li><li><code>@a</code> 执行宏命令 “a”。当你记录该宏命令时，<code>@a</code> 应该是空白的，因为你刚刚调用了 <code>qaq</code>。</li><li><code>q</code> 停止记录。</li></ul><p>现在，让我们调用 <code>@a</code> 来查看 Vim 如何递归的调用该宏命令。</p><p>宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 <code>j</code> 命令时，发现已经没有下一行了，就会停止执行。</p><h2 id="增添一个已知宏"><a class="markdownIt-Anchor" href="#增添一个已知宏"></a> 增添一个已知宏</h2><p>如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来想该寄存器中添加内容。同样的，为了在寄存器&quot;a&quot;中添加更多的操作，你也可以使用大写字母&quot;A&quot;。</p><p>假设寄存器a中已经存储了这个宏命令:<code>qa0W~q</code>(该宏命令将某行的第二个词组的头一个字母执行改变大小写操作)，假设你想在这个基础上添加一些操作命令序列，使得每一行末尾添加一个句点，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qAA.&lt;esc&gt;q</span><br></pre></td></tr></table></figure><p>分解如下:</p><ul><li><code>qA</code> 开始在寄存器 “A” 中记录宏命令。</li><li><code>A.&lt;esc&gt;</code> 在行的末尾加上一个句点(这里的<code>A</code>是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。</li><li><code>q</code> 停止记录宏命令。</li></ul><p>现在，当你执行<code>@a</code>时，它不仅将第二个词组的首字母转变大小写，同时还在行尾添加一个句点。</p><h2 id="修改一个已知宏"><a class="markdownIt-Anchor" href="#修改一个已知宏"></a> 修改一个已知宏</h2><p>如果想在一个宏的中间添加新的操作该怎么办呢？</p><p>假设您在寄存器a中已经存有一个宏命令<code>0W~A.&lt;Esc&gt;</code>，即改变首字母大小写，并在行尾添加句号。如果您想在改变首字母大小写和行尾添加句号之间，在单词&quot;dount&quot;前面加入&quot;deep fried&quot;。（因为唯一比甜甜圈好的东西就是炸甜甜圈）。</p><p>我会重新使用上一节使用过的文本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure><p>首先，让我们通过 <code>:put a</code> 调用一个已经录制好的宏命令（假设你上一节中保存在寄存器a中的宏命令还在）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~A.^[</span><br></pre></td></tr></table></figure><p><code>^[</code> 是什么意思呢？不记得了吗，你之前执行过 <code>0W~A.&lt;esc&gt;</code>。 <code>^[</code> 是 Vim 的 <strong>内部指令</strong>，表示 <code>&lt;esc&gt;</code>。通过这些指定的特殊键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 <code>&lt;esc&gt;</code>，<code>&lt;backspace&gt;</code>，<code>&lt;enter&gt;</code>。还有一些其他的键值组合，但这不是本章的内容。</p><p>回到宏命令，在改变大小写之后的键后面（<code>~</code>），让我们添加（<code>$</code>）来移动光标到行末，回退一个单词（<code>b</code>），进入插入模式（<code>i</code>），输入&quot;deep fried &quot; （别忽略&quot;fried &quot;后面的这个空格），之后退出插入模式（<code>&lt;esc&gt;</code>）。</p><p>完整的命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried &lt;esc&gt;A.^[</span><br></pre></td></tr></table></figure><p>这里有一个问题，Vim 不能理解 <code>&lt;esc&gt;</code>。您不能依葫芦画瓢输入&quot;<Esc>&quot;，所以你需要将<code>&lt;Esc&gt;</code>写成内部代码的形式。在插入模式，在按下<code>&lt;esc&gt;</code>后按下 <code>Ctrl-v</code>，Vim 会打印 <code>^[</code>。 <code>Ctrl-v</code> 是一个插入模式的操作符，可以逐字地插入一个非数字字符。你的宏命令应该如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried ^[A.^[</span><br></pre></td></tr></table></figure><p>为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知命名寄存器中添加一个新条目的方式来实现。在一行的行首，执行 <code>&quot;ay$</code>，使用寄存器 &quot;a&quot;来存储复制的文本。</p><p>现在，但你执行 <code>@a</code> 时，你的宏命令会自动改变第一个单词的大小写，在&quot;donut&quot;前面添加&quot;deep fried &quot;，之后在行末添加“.”。</p><p>另一个修改宏命令的方式是通过命令行表达式。执行 <code>:let @a=&quot;</code>，之后执行 <code>Ctrl-r Ctrl-r a</code>，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（<code>&quot;</code>）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 <code>Ctrl-v</code>。</p><h2 id="拷贝宏"><a class="markdownIt-Anchor" href="#拷贝宏"></a> 拷贝宏</h2><p>你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 <code>:let @z = @a</code> 将寄存器&quot;a&quot; 中的命令拷贝到寄存器&quot;z&quot;。 <code>@a</code> 表示寄存器“a”中存储的内容，你现在执行 <code>@z</code>，将会执行和 <code>@a</code> 一样的指令。</p><p>我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。</p><h2 id="串行宏和并行宏"><a class="markdownIt-Anchor" href="#串行宏和并行宏"></a> 串行宏和并行宏</h2><p>Vim 可以连续和同时运行宏命令，假设你有如下的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure><p>假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0f&#123;gui&#123;jq</span><br></pre></td></tr></table></figure><p>分解如下：</p><ul><li><code>qa</code> 开始记录宏命令到 “a” 寄存器。</li><li><code>0</code>移动到第一行。</li><li><code>f&#123;</code> 查找第一个 “{” 字符。</li><li><code>gui&#123;</code> 把括号内的文本（<code>i&#123;</code>）变为小写（<code>gu</code>）。</li><li><code>j</code> 移动到下一行。</li><li><code>q</code> 停止记录宏命令。</li></ul><p>现在，执行 <code>99@a</code> 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import foo from &quot;bar&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure><p>执行 <code>99@a</code>，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时<code>f&#123;</code>命令会遇到错误而停止，当宏串行执行时就会发生这样的情况。当然，你仍然可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？</p><p>你可以并行地执行宏命令。</p><p>如本章前面所说，可以使用 <code>:normal</code> 去执行宏命令，（例如： <code>:3,5 normal @a</code> 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 <code>:1,$ normal @a</code>，会在所有除了包含有 “foo” 的行执行，而且它不会出错。</p><p>尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（<code>1,$</code>）每一行执行 <code>@a</code> 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。</p><h2 id="聪明地学习宏命令"><a class="markdownIt-Anchor" href="#聪明地学习宏命令"></a> 聪明地学习宏命令</h2><p>你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。</p><p>刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。</p><p>使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它(<code>qf</code>)。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的(<code>qn</code>)。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令默认寄存器，因为执行 <code>qq</code> 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 <code>qa</code> 到 <code>qb</code> 再到 <code>qc</code>。</p><p>去寻找最适合你的方法吧。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/49130c49/">Ch 8 - 寄存器</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/49fd3ee8/">Ch 10 - 撤消</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch08-寄存器</title>
      <link href="/posts/49130c49.html"/>
      <url>/posts/49130c49.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。</p><p>你可能已经在复制或删除文本并用<code>p</code>或<code>P</code>粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？如果正确地使用Vim寄存器，将帮助您从重复的输入中解放出来。</p><p>在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。</p><h2 id="寄存器的10种类型"><a class="markdownIt-Anchor" href="#寄存器的10种类型"></a> 寄存器的10种类型</h2><p>下面是Vim所拥有的10种寄存器类型：</p><ol><li>匿名寄存器（<code>&quot;&quot;</code>）.</li><li>编号寄存器(<code>&quot;0-9</code>).</li><li>小删除寄存器 (<code>&quot;-</code>).</li><li>命名寄存器 (<code>&quot;a-z</code>).</li><li>只读寄存器 (<code>&quot;:</code>, <code>&quot;.</code>, and <code>&quot;%</code>).</li><li>Buffer交替文件寄存器 (<code>&quot;#</code>).</li><li>表达式寄存器 (<code>&quot;=</code>).</li><li>选取和拖放寄存器(<code>&quot;*</code> and <code>&quot;+</code>).</li><li>黑洞寄存器 (<code>&quot;_</code>).</li><li>搜索模式寄存器 (<code>&quot;/</code>).</li></ol><h2 id="寄存器命令"><a class="markdownIt-Anchor" href="#寄存器命令"></a> 寄存器命令</h2><p>要使用寄存器，您必须先使用命令将内容存储到寄存器，以下是一些存值到寄存器中的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y    复制</span><br><span class="line">c    删除文本并进入输入模式</span><br><span class="line">d    删除文本</span><br></pre></td></tr></table></figure><p>其实还有更多的寄存器写入操作（比如<code>s</code>或<code>x</code>），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。</p><p>想要从寄存器中取出（粘贴）文本，你可以用以下的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p    在光标位置之后粘贴文本</span><br><span class="line">P    在光标位置之前粘贴文本</span><br></pre></td></tr></table></figure><p><code>p</code>和<code>P</code>都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用<code>10p</code>。想粘贴寄存器&quot;a&quot;中的文本，可以用<code>&quot;ap</code>。想将寄存器“a”中的文本粘贴10次的话，可以使用<code>10&quot;ap</code>。注意，从技术层面讲，命令<code>p</code>实际上表示的是&quot;put&quot;(放置)，而不是&quot;paste&quot;(粘贴)，使用粘贴只是因为它更符合传统习惯。</p><p>从某个特定寄存器中读取文本的通用语法是<code>&quot;x</code>，其中<code>x</code>是这个寄存器的标志。</p><h2 id="在输入模式中使用寄存器"><a class="markdownIt-Anchor" href="#在输入模式中使用寄存器"></a> 在输入模式中使用寄存器</h2><p>在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器&quot;a&quot;中的文本，通常可以使用<code>&quot;ap</code>来进行。不过当你在输入模式下时，你需要运行<code>Ctrl-r a</code>。在输入模式下使用寄存器的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r x</span><br></pre></td></tr></table></figure><p>其中<code>x</code>是寄存器标志。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。</p><h2 id="匿名寄存器"><a class="markdownIt-Anchor" href="#匿名寄存器"></a> 匿名寄存器(<code>&quot;&quot;</code>)</h2><p>想从匿名寄存器中获取文本，可以使用<code>&quot;&quot;p</code>。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。</p><p>默认情况下，<code>p</code>(或者<code>P</code>)是和匿名寄存器相关联的（从现在起我将使用<code>p</code>而不是<code>&quot;&quot;p</code>来指代匿名寄存器）。</p><h2 id="编号寄存器0-9"><a class="markdownIt-Anchor" href="#编号寄存器0-9"></a> 编号寄存器(<code>&quot;0-9</code>)</h2><p>编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(<code>0</code>)和其他编号寄存器(<code>1-9</code>)。让我们先来讨论复制寄存器。</p><h3 id="复制寄存器-0"><a class="markdownIt-Anchor" href="#复制寄存器-0"></a> 复制寄存器 (<code>&quot;0</code>)</h3><p>如果你使用<code>yy</code>来复制一整行文本，事实上Vim会将文本存放两个寄存器中：</p><ol><li>匿名寄存器 (<code>p</code>).</li><li>复制寄存器 (<code>&quot;0p</code>).</li></ol><p>在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器(<code>0</code>)中的内容。其他的任何操作都不会被存放在<code>0</code>号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。</p><p>比如，如果你：</p><ol><li>复制一整行 (<code>yy</code>)</li><li>删除一整行(<code>dd</code>)</li><li>再删除另一行 (<code>dd</code>)</li></ol><p>复制寄存器中的文本仍然是第一步中复制的文本。</p><p>如果你:</p><ol><li>复制一整行 (<code>yy</code>)</li><li>删除一整行 (<code>dd</code>)</li><li>复制另一行 (<code>yy</code>)</li></ol><p>复制寄存器中的内容则是第三步中复制的内容。</p><p>还有一个小技巧，在输入模式下，你可以使用<code>Ctrl-r 0</code>快速地粘贴你刚才复制的内容。</p><h3 id="编号寄存器-1-9"><a class="markdownIt-Anchor" href="#编号寄存器-1-9"></a> 编号寄存器 (<code>&quot;1-9</code>)</h3><p>当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（编号越小时间距离越近）</p><p>比如，你有以下这些文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line three</span><br><span class="line">line two</span><br><span class="line">line one</span><br></pre></td></tr></table></figure><p>当你的光标在文本“line three”上时,使用<code>dd</code>来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是&quot;line one&quot;（时间上最近的文本）， 2号寄存器则包含&quot;line two&quot;(时间上第二近的文本)，3号寄存器中则包含&quot;line three&quot;（最早删除的文本）。普通模式下可以使用<code>&quot;1p</code>来获取1号寄存器中的内容。</p><p>编号寄存器的编号在使用点命令时会自动增加。比如，如果你的1号编号寄存器（<code>&quot;1</code>）中的内容为&quot;line one&quot;， 2号寄存器（<code>&quot;2</code>）为&quot;line two&quot;, 三号寄存器（<code>&quot;3</code>）“line three”,你可以使用以下的技巧来连续地粘贴他们：</p><ul><li>使用<code>&quot;1p</code>来粘贴1号寄存器中的内容。</li><li>使用<code>.</code> (点命令)来粘贴2号寄存器（<code>&quot;2</code>）中的内容。</li><li>使用<code>.</code> (点命令)来粘贴3号寄存器（<code>&quot;3</code>）中的内容。</li></ul><p>在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(<code>&quot;5P</code>), 点命令<code>.</code>会执行<code>&quot;6P</code>,再次使用<code>.</code>则会执行<code>&quot;7P</code>,等等。</p><p>小型的删除比如单词删除（<code>dw</code>)或者单词修改(<code>cw</code>)不会被存储在编号寄存器中，它们被存储在小删除寄存器(<code>&quot;-</code>)中，我将在接下来的一小节讨论小删除寄存器。</p><h2 id="小删除寄存器-"><a class="markdownIt-Anchor" href="#小删除寄存器-"></a> 小删除寄存器(<code>&quot;-</code>)</h2><p>不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (<code>&quot;-</code>)中。</p><p>比如:</p><ol><li>删除一个单词 (<code>diw</code>)</li><li>删除一行文本 (<code>dd</code>)</li><li>删除一行文本 (<code>dd</code>)</li></ol><p><code>&quot;-p</code> 会给你第一步中删除的单词。</p><p>另一个例子:</p><ol><li>删除一个单词(<code>diw</code>)</li><li>删除一行文本 (<code>dd</code>)</li><li>删除一个单词 (<code>diw</code>)</li></ol><p><code>&quot;-p</code> 会给出第三步中删除的单词。类似地, <code>&quot;1p</code> 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。</p><h2 id="命名寄存器-a-z"><a class="markdownIt-Anchor" href="#命名寄存器-a-z"></a> 命名寄存器 (<code>&quot;a-z</code>)</h2><p>命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。</p><p>为了复制一个单词到寄存器&quot;a&quot;中，你可以使用命令<code>&quot;ayiw</code>。</p><ul><li><code>&quot;a</code>告诉Vim下一个动作（删除/修改/复制）会被存储在寄存器&quot;a&quot;中</li><li><code>yiw</code>复制这个单词</li></ul><p>为了从寄存器&quot;a&quot;中获取文本，可以使用命令<code>&quot;ap</code>。你可以使用以26个字母命名的寄存器来存储26个不同的文本。</p><p>有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的&quot;a&quot;寄存器中已经存有文本&quot;Hello&quot;，如果你想继续添加&quot;world&quot;到寄存器&quot;a&quot;中，你可以先找到文本&quot;world&quot;然后使用<code>&quot;Aiw</code>来进行复制,即可完成追加。</p><h2 id="只读寄存器"><a class="markdownIt-Anchor" href="#只读寄存器"></a> 只读寄存器(<code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code>)</h2><p>Vim有三个只读寄存器：<code>.</code>,<code>:</code>和<code>%</code>，它们的用法非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.    存储上一个输入的文本</span><br><span class="line">:    存储上一次执行的命令</span><br><span class="line">%    存储当前文件的文件名</span><br></pre></td></tr></table></figure><p>如果你写入&quot;Hello Vim&quot;,之后再运行<code>&quot;.p</code>就会打印出文本&quot;Hello Vim&quot;。如果你想要获得当前文件的文件名，可以运行命令<code>&quot;%p</code>。如果你运行命令<code>:s/foo/bar/g</code>，再运行<code>&quot;:p</code>的话则会打印出文本&quot;s/foo/bar/g&quot;。</p><h2 id="buffer交替文件寄存器"><a class="markdownIt-Anchor" href="#buffer交替文件寄存器"></a> Buffer交替文件寄存器 (<code>&quot;#</code>)</h2><p>在Vim中，<code>#</code>通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令<code>&quot;#p</code>。</p><h2 id="表达式寄存器"><a class="markdownIt-Anchor" href="#表达式寄存器"></a> 表达式寄存器 (<code>&quot;=</code>)</h2><p>Vim有一个表达式寄存器，<code>&quot;=</code>,用于计算表达式的结果。</p><p>你可以使用以下命令计算数学表达式<code>1+1</code>的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=1+1&lt;Enter&gt;p</span><br></pre></td></tr></table></figure><p>在这里，你在告诉Vim你正在使用表达式寄存器<code>&quot;=</code>，你的表达式是（<code>1+1</code>），你还需要输入<code>p</code>来得到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =1+1</span><br></pre></td></tr></table></figure><p>你可以使用<code>@</code>来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器&quot;a&quot;中获取文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=@a</span><br></pre></td></tr></table></figure><p>之后输入<code>&lt;enter&gt;</code>，再输入<code>p</code>。类似地，想在输入模式中得到寄存器&quot;a&quot;中的值可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =@a</span><br></pre></td></tr></table></figure><p>表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的VimScript章节中进一步讲解更多关于表达式的细节。</p><h2 id="选取和拖放寄存器"><a class="markdownIt-Anchor" href="#选取和拖放寄存器"></a> 选取和拖放寄存器 (<code>&quot;*</code>, <code>&quot;+</code>)</h2><p>你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：<code>quotestar</code> (<code>&quot;*</code>) 和 <code>quoteplus</code> (<code>&quot;+</code>)。你可以用它们来访问从外部程序中复制的文本。</p><p>如果你在运行一个外部程序（比如Chrome浏览器），然后你使用<code>Ctrl-c</code>(或者<code>Cmd-c</code>,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用<code>p</code>来粘贴这部分文本的。但是，Vim的两个寄存器<code>&quot;+</code>和<code>&quot;*</code>都是和你系统的粘贴板相连接的，所以你可以使用<code>&quot;+p</code>和<code>&quot;*p</code>来粘贴这些文本。反过来，如果你使用<code>&quot;+yiw</code>或者<code>&quot;*yiw</code>在Vim中复制了一些文本，你可以使用<code>Ctrl-v</code>（或者<code>Cmd-v</code>）。值得注意的是这个方法只在你的Vim开启了<code>+clipboard</code>选项时才有用，可以在命令行中运行<code>vim --version</code>查看这一选项。如果你看见<code>-clipboard</code>的话，则需要安装一下支持Vim粘贴板的配置。</p><p>你也许会想如果<code>&quot;*</code>和<code>&quot;+</code>能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是<code>quotestar</code> (<code>&quot;*</code>)寄存器作为X11的首选选项，并使用 <code>quoteplus</code> (<code>&quot;+</code>)作为粘贴板选项。这只在你的Vim配置里开启了<code>xterm_clipboard</code> 选项时才有效（<code>vim --version</code>中的<code>+xterm_clipboard</code>）。如果你的的Vim配置中没有 <code>xterm_clipboard</code>也不是什么大问题。这只是意味着<code>quotestar</code> 和<code>quoteplus</code>两个寄存器是可以互相替代的。</p><p>我发觉使用<code>=*p</code>或者<code>=+p</code>的话比较麻烦，为了使Vim仅使用<code>p</code>就能粘贴从外部程序复制的文本，你可以在你的<code>vimrc</code>配置文件中加入下面一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set clipboard=unnamed</span><br></pre></td></tr></table></figure><p>现在当我从外部程序中复制文本时，我可以使用匿名寄存器<code>p</code>来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用<code>Ctrl-v</code>来粘贴。如果你的Vim开启了 <code>+xterm_clipboard</code>设置，你或许会想同时也使用<code>unnamed</code>和<code>unnamedplus</code>的粘贴板选项。</p><h2 id="黑洞寄存器-_"><a class="markdownIt-Anchor" href="#黑洞寄存器-_"></a> 黑洞寄存器 (<code>&quot;_</code>)</h2><p>你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？</p><p>你可以使用黑洞寄存器（<code>&quot;_</code>）。想要删除一行并且不将其存储在任何寄存器中时，可以使用<code>&quot;_dd</code>命令.</p><p>它是和 <code>/dev/null</code> 类似的寄存器。</p><h2 id="搜索模式寄存器"><a class="markdownIt-Anchor" href="#搜索模式寄存器"></a> 搜索模式寄存器 (<code>&quot;/</code>)</h2><p>为了粘贴你的上一个搜索询问（<code>/</code> 或 <code>?</code>），你可以使用搜索模式寄存器(<code>&quot;/</code>)。使用命令 <code>&quot;/p</code>就能粘贴上一个搜索的条目。</p><h2 id="查看所有的寄存器"><a class="markdownIt-Anchor" href="#查看所有的寄存器"></a> 查看所有的寄存器</h2><p>你可以使用<code>:register</code>命令来查看你的所有寄存器。如果你只想查看&quot;a&quot;,“1&quot;和”-&quot;寄存器的内容的话则可以使用命令<code>:register a 1 -</code>。</p><p>有一个Vim的插件叫做 <a href="https://github.com/junegunn/vim-peekaboo">vim-peekaboo</a> ,可以让你查看到寄存器的内容，在普通模式下输入<code>&quot;</code>或<code>@</code> 即可，或者在输入模式中输入<code>Ctrl-r</code>。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！</p><h2 id="执行寄存器"><a class="markdownIt-Anchor" href="#执行寄存器"></a> 执行寄存器</h2><p>命名寄存器不只可以用来存放文本，你还可以借助<code>@</code>来执行宏命令。我会在下一章节中介绍宏命令。</p><p>注意，因为宏命令时存储在Vim寄存器中的，使用宏时可能会覆盖存储的内容。如果你将文本&quot;Hello Vim&quot;存放在寄存器&quot;a&quot;中，并且之后你在同一个寄存器里记录了一个宏命令 (<code>qa&#123;macro-commands&#125;q</code>),那么这个宏命令将会覆盖之前存储的文本&quot;Hello Vim&quot;（你可以使用<code>@a</code>来执行寄存器中存储的宏命令）。</p><h2 id="清除寄存器"><a class="markdownIt-Anchor" href="#清除寄存器"></a> 清除寄存器</h2><p>从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行<code>qaq</code>，Vim就会在寄存器&quot;a&quot;中记录一个空的宏命令。</p><p>还有一种方法就是运行命令<code>:call setreg('a','hello register a')</code>,其中’a’代表的就是寄存器&quot;a&quot;。而&quot;hello register a&quot;就是你想存储的内容。</p><p>还有一种清除寄存器的方法就是使用表达式<code>:let @a = ''</code>来将寄存器&quot;a 的值设为空的字符串。</p><h2 id="获取寄存器中的内容"><a class="markdownIt-Anchor" href="#获取寄存器中的内容"></a> 获取寄存器中的内容</h2><p>你可以使用<code>:put</code>命令来粘贴任何寄存器的内容。比如，如果你运行命令<code>:put a</code>,Vim就会打印出寄存器&quot;a&quot;的内容，这和<code>&quot;ap</code>非常像，唯一的区别在于在普通模式下命令<code>p</code>在当前光标位置之后打印寄存器的内容，而<code>:put</code>新起一行来打印寄存器的内容。</p><p>因为<code>:put</code>是一个命令行命令，您可以传一个地址给它。<code>:10put a</code>将会在当前光标下数10行，然后插入新行，内容为寄存器a中的内容。</p><p>一个很酷的技巧是将黑洞寄存器(<code>&quot;_</code>)传给<code>:put</code>命令。因为黑洞寄存器不保存任何值，<code>:put _</code>命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本&quot;end&quot;结尾的行下插入空行，使用<code>:g/end/put _</code>。在后面您将了解关于全局命令的知识。</p><h2 id="聪明地学习寄存器"><a class="markdownIt-Anchor" href="#聪明地学习寄存器"></a> 聪明地学习寄存器</h2><p>恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。</p><p>我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：</p><ol><li>匿名寄存器(<code>&quot;&quot;</code>).</li><li>命名寄存器 (<code>&quot;a-z</code>).</li><li>编号寄存器 (<code>&quot;0-9</code>).</li></ol><p>既然匿名寄存器是默认和<code>p</code>或<code>P</code>，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。</p><p>普通人的短期记忆都是有极限的，大概每次只能记住5-7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器&quot;a&quot;开始用，之后用寄存器&quot;b&quot;,以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。</p><p>Vim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/83932852/">Ch 7 - 点命令</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/7e0645cb/">Ch 9 - 宏</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch07-点命令</title>
      <link href="/posts/83932852.html"/>
      <url>/posts/83932852.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。</p><h2 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令。</p><p>比如，如果你想将下面文本中的所有”let“替换为&quot;const&quot;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure><ul><li>首先，使用<code>/let</code>来进行匹配。</li><li>接着，使用<code>cwconst&lt;esc&gt;</code>来将&quot;let&quot;替换成&quot;const&quot;。</li><li>第三步，使用<code>n</code>来找到下一个匹配的位置。</li><li>最后，使用点命令(<code>.</code>)来重复之前的操作。</li><li>持续地使用<code>n . n .</code>直到每一个匹配的词都被替换。</li></ul><p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。</p><h2 id="什么才算是修改操作"><a class="markdownIt-Anchor" href="#什么才算是修改操作"></a> 什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？</p><p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作。</p><p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作。现在假设你有以下这么一个句子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure><p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df,</code>来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除。</p><p>让我们再来试试另一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure><p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f,</code>来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用<code>.</code>来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？</p><p>在Vim里，修改操作是不包括移动（motions）的，因为移动(motions)不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df,</code>进行一下对比的话，你会发现<code>df,</code>中的<code>f,</code>告诉删除操作<code>d</code>哪里需要删除，是整个删除命令<code>df,</code>的一部分。</p><p>让我们想想办法完成这个任务。在你运行<code>f,</code>并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; . ; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.</code>。</p><p>再来试试下一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancake</span><br><span class="line">potatoes</span><br><span class="line">fruit-juice</span><br></pre></td></tr></table></figure><p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j . j . </code>来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>。</p><p>从你按下输入命令（A）开始到你退出输入模式（<esc>）之间的所有输入都算作是一整个修改操作。</p><h2 id="重复多行修改操作"><a class="markdownIt-Anchor" href="#重复多行修改操作"></a> 重复多行修改操作</h2><p>假设你有如下的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">const foo = &quot;bar&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br><span class="line">let six = &quot;6&quot;;</span><br><span class="line">let seven = &quot;7&quot;;</span><br><span class="line">let eight = &quot;8&quot;;</span><br><span class="line">let nine = &quot;9&quot;;</span><br></pre></td></tr></table></figure><p>你的目标是删除除了含有&quot;foo&quot;那一行以外的所有行。首先，使用<code>d2j</code>删除前三行。之后跳过&quot;foo&quot;这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是<code>d2jj..</code>。</p><p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动(motion)操作，而是整个删除命令的一部分。</p><p>我们再来看看下一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zlet zzone = &quot;1&quot;;</span><br><span class="line">zlet zztwo = &quot;2&quot;;</span><br><span class="line">zlet zzthree = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br></pre></td></tr></table></figure><p>我们的目标是删除所有的’z’。从第一行第一个字符开始，首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个’z’字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个’z’后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个z字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>。</p><p>你删除一列上的三个’z‘的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。</p><h2 id="在修改中包含移动操作"><a class="markdownIt-Anchor" href="#在修改中包含移动操作"></a> 在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n . n .</code>将下面的文本中的’let’都替换成了’const’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure><p>其实还有更快的方法来完成整个操作。当你使用<code>/let</code>搜索后，执行<code>cgnconst&lt;Esc&gt;</code>，然后<code>. . .</code>。</p><p><code>gn</code>是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且 <strong>自动对匹配的文本进行可视化模式下的选取</strong>。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n . n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。</p><p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作。</p><blockquote><p>（译者在这里研究了一会，并做了不少实验，总结规律是：单独的motion(第4章中所说的名词)不算修改操作，而opeartor(动词)+motion(名词)时(请回顾第4章)，motion被视为一个完整的修改操作中的一部分。再看一个例子，看看<code>/</code>命令是如何被包含在一个修改操作中的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">foo</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">foo</span><br><span class="line">e</span><br><span class="line">f</span><br></pre></td></tr></table></figure><blockquote><p>假设你的光标在第一行的a上，执行命令<code>d/foo&lt;Esc&gt;</code>，Vim会删除a,b。然后<code>.</code>，Vim会删除foo, c, d，再按<code>.</code>，Vim什么也不做，因为后面没有&quot;foo&quot;了。在这个例子中，<code>/foo</code>是一个motion（名词），是Vim语法(动词+名词：operator + motion)的一部分，前面的<code>d</code>则是动词。<code>d/foo&lt;Esc&gt;</code>这条命令的功能是：从当前光标所在位置开始删除，直到遇到&quot;foo&quot;为止。后面的点命令就重复这个功能，第二次按<code>.</code>之所以Vim什么也不做，是因为找不到下一个匹配了，所以这条命令就失效了。</p></blockquote><h2 id="聪明地学习点命令"><a class="markdownIt-Anchor" href="#聪明地学习点命令"></a> 聪明地学习点命令</h2><p>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了。</p><p>在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念。</p><p>点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/f92aab20/">Ch 6 - 插入模式</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/49130c49/">Ch 8 - 寄存器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch06-插入模式</title>
      <link href="/posts/f92aab20.html"/>
      <url>/posts/f92aab20.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。</p><p>尽管如此，这并不代表输入模式没什么好学的。Vim的输入模式包含许多有用功能。在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。</p><h2 id="进入输入模式的方法"><a class="markdownIt-Anchor" href="#进入输入模式的方法"></a> 进入输入模式的方法</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i    从光标之前的位置开始输入文本</span><br><span class="line">I    从当前行第一个非空字符之前的位置之前开始输入文本</span><br><span class="line">a    在光标之后的位置追加文本</span><br><span class="line">A    在当前行的末尾追加文本</span><br><span class="line">o    在光标位置下方新起一行并开始输入文本</span><br><span class="line">O    在光标位置的上方新起一行并开始输入文本</span><br><span class="line">s    删除当前光标位置的字符并开始输入文本</span><br><span class="line">S    删除当前行并开始输入文本</span><br><span class="line">gi   从当前缓冲区上次结束输入模式的地方开始输入文本</span><br><span class="line">gI   在当前行的第一列的位置开始输入文本</span><br></pre></td></tr></table></figure><p>值得注意的是这些命令的小写/大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。</p><h2 id="退出输入模式的方法"><a class="markdownIt-Anchor" href="#退出输入模式的方法"></a> 退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;esc&gt;     退出输入模式进入普通模式</span><br><span class="line">Ctrl-[    退出输入模式进入普通模式</span><br><span class="line">Ctrl-c    与 Ctrl-[ 和 &lt;esc&gt;功能相同, 但是不检查缩写</span><br></pre></td></tr></table></figure><p>我发现<code> esc</code>键在键盘上太远了，很难够到，所以我在我的机器上将<code> caps lock</code> 映射成了<code>esc</code>键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现<code>esc</code>键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在<code>q</code>键的左边，所以我认为将<code>caps lock</code> 映射成<code>esc</code>键是合理的。</p><p>另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap jj &lt;esc&gt;</span><br><span class="line">inoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure><h2 id="重复输入模式"><a class="markdownIt-Anchor" href="#重复输入模式"></a> 重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10i</span><br></pre></td></tr></table></figure><p>如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p><h2 id="在输入模式中删除大块文本"><a class="markdownIt-Anchor" href="#在输入模式中删除大块文本"></a> 在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用<code>d</code>来删除错误。或者，你能用以下命令在输入模式下就删除一个或者多个字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure><p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）</p><h2 id="用寄存器进行输入"><a class="markdownIt-Anchor" href="#用寄存器进行输入"></a> 用寄存器进行输入</h2><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键<code>Ctrl-r</code>加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。</p><p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ayiw</span><br></pre></td></tr></table></figure><ul><li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a</li><li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。</li></ul><p>现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r a</span><br></pre></td></tr></table></figure><p>Vim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。</p><h2 id="页面滚动"><a class="markdownIt-Anchor" href="#页面滚动"></a> 页面滚动</h2><p>你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键<code>Ctrl-x</code>进入<code>Ctrl-x</code>子模式，你可以进行一些额外操作，页面滚动正是其中之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-y    向上滚动页面</span><br><span class="line">Ctrl-x Ctrl-e    向下滚动页面</span><br></pre></td></tr></table></figure><h2 id="自动补全"><a class="markdownIt-Anchor" href="#自动补全"></a> 自动补全</h2><p>Vim在进入<code>Ctrl-x</code>子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。</p><p>下面列出了一些适合入门时学习的自动补全命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-l   补全一整行</span><br><span class="line">Ctrl-x Ctrl-n   从当前文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-i   从引用（include）的文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-f   补全一个文件名</span><br></pre></td></tr></table></figure><p>当你出发自动补全时，Vim会显示一个选项弹窗，可以使用<code>Ctrl-n</code>和<code>Ctrl-p</code>来分别向上和向下浏览选项。</p><p>Vim也提供了两条不需要进入<code>Ctrl-x</code>模式就能使用的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-n             使用下一个匹配的单词进行补全</span><br><span class="line">Ctrl-p             使用上一个匹配的单词进行补全</span><br></pre></td></tr></table></figure><p>通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是&quot;Chocolate donuts are the best&quot;：</p><ul><li>当你输入&quot;Choco&quot;然后使用快捷键<code>Ctrl-x Ctrl-l</code>， Vim会进行匹配并输出这一整行的文本。</li><li>当你输入&quot;Choco&quot;然后使用快捷键<code>Ctrl-p</code>，Vim会进行匹配并输出&quot;Chocolate&quot;这个单词。</li></ul><p>Vim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看。</p><h2 id="执行普通模式下的命令"><a class="markdownIt-Anchor" href="#执行普通模式下的命令"></a> 执行普通模式下的命令</h2><p>你知道Vim可以在输入模式下执行普通模式的命令吗？</p><p>在输入模式下， 如果你按下<code>Ctrl-o</code>，你就会进入到<code>insert-normal</code>（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下<code>Ctrl-o</code>后就会变为<code>-- (insert) --</code>。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：</p><p><strong>设置居中以及跳转</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o zz       居中窗口</span><br><span class="line">Ctrl-o H/M/L    跳转到窗口的顶部/中部/底部</span><br><span class="line">Ctrl-o &#x27;a       跳转到标志&#x27;a处</span><br></pre></td></tr></table></figure><p><strong>重复文本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o 100ihello    输入 &quot;hello&quot; 100 次</span><br></pre></td></tr></table></figure><p><strong>执行终端命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o !! curl https://google.com    运行curl命令</span><br><span class="line">Ctrl-o !! pwd                        运行pwd命令</span><br></pre></td></tr></table></figure><p><strong>快速删除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o dtz    从当前位置开始删除文本，直到遇到字母&quot;z&quot;</span><br><span class="line">Ctrl-o D      从当前位置开始删除文本，直到行末</span><br></pre></td></tr></table></figure><h2 id="聪明地学习输入模式"><a class="markdownIt-Anchor" href="#聪明地学习输入模式"></a> 聪明地学习输入模式</h2><p>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。</p><p>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/25eb02e8/">Ch 5 - 移动文件</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/83932852/">Ch 7 - 点命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch05-移动文件</title>
      <link href="/posts/25eb02e8.html"/>
      <url>/posts/25eb02e8.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。</p><p>这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令(motions)，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>。</p><h2 id="字符导航"><a class="markdownIt-Anchor" href="#字符导航"></a> 字符导航</h2><p>最基本的移动单元是上下左右移动一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h   左</span><br><span class="line">j   下</span><br><span class="line">k   上</span><br><span class="line">l   右</span><br></pre></td></tr></table></figure><p>你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。</p><p>我更喜欢<code>hjkl</code>因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过<code>~/.vimrc</code>关闭了方向键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;Up&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Down&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Left&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Right&gt; &lt;NOP&gt;</span><br></pre></td></tr></table></figure><p>也有一些插件可以帮助改掉这个坏习惯，其中有一个叫<a href="https://github.com/takac/vim-hardtime">vim-hardtime</a>。 让我感到惊讶的是，我只用了几天就习惯了使用<code>hjkl</code>。</p><p>另外，如果你想知道为什么Vim使用<code>hjkl</code>进行移动，<em>这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把<code>hjkl</code>当做方向键</em>。</p><p>如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用<code>h</code>和<code>l</code>。 如果我需要在可见的范围内上下移动几行，我会使用<code>j</code>和<code>k</code>。 如果我想去更远的地方，我倾向于使用其他移动命令。</p><h2 id="相对行号"><a class="markdownIt-Anchor" href="#相对行号"></a> 相对行号</h2><p>我觉得设置<code>number</code>和<code>relativenumber</code>非常有用，你可以在<code>~/.vimrc</code>中设置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set relativenumber number</span><br></pre></td></tr></table></figure><p>这将会展示当前行号和其他行相对当前行的行号。</p><p>为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用<code>12j</code>去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69=12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。</p><p>这是一个100%的个人偏好，你可以尝试<code>relativenumber</code>/<code>norelativenumber</code>，<code>number</code>/<code>nonumber</code> 然后选择自己觉得最有用的。</p><h2 id="对移动计数"><a class="markdownIt-Anchor" href="#对移动计数"></a> 对移动计数</h2><p>在继续之前，让我们讨论一下&quot;计数&quot;参数。 一个移动(motion)可以接受一个数字前缀作为参数，上面我提到的你可以通过<code>12j</code>向下移动12行，其中<code>12j</code>中的<code>12</code>就是计数数字。</p><p>你使用带计数的移动的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[计数] + 移动</span><br></pre></td></tr></table></figure><p>你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用<code>9l</code>来代替按9次<code>l</code>。 当你学到了更多的动作时，你都可以试试给定计数参数。</p><h2 id="单词导航"><a class="markdownIt-Anchor" href="#单词导航"></a> 单词导航</h2><p>我们现在移动一个更长的单元：单词(word)。 你可以通过<code>w</code>移动到下一个单词的开始，通过<code>e</code>移动到下一个单词的结尾，通过<code>b</code>移动到上一个单词的开始，通过<code>ge</code>移动到前一个单词的结尾。</p><p>另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过<code>W</code>移动到下一个词组的开始，通过<code>E</code>移动到下一个词组的结尾，通过<code>B</code>移动到前一个词组的开头，通过<code>gE</code>移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w移动到下一个单词的开头</span><br><span class="line">W移动到下一个词组的开头</span><br><span class="line">e移动到下一个单词的结尾</span><br><span class="line">E移动到下一个词组的结尾</span><br><span class="line">b移动到前一个单词的开头</span><br><span class="line">B移动到前一个词组的开头</span><br><span class="line">ge移动到前一个单词的结尾</span><br><span class="line">gE移动到前一个词组的结尾</span><br></pre></td></tr></table></figure><p>词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-zA-Z0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过<code>:h word</code>和<code>:h WORD</code>了解更多。</p><p>例如，假如你有下面这段内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure><p>当你光标位于这行的开头时，你可以通过<code>l</code>走到行尾，但是你需要按21下，使用<code>w</code>，你需要6下，使用<code>W</code>只需要4下。 单词和词组都是短距离移动的很好的选择。</p><p>然而，之后你可以通过当前行导航只按一次从<code>c</code>移动到<code>;</code>。</p><h2 id="当前行导航"><a class="markdownIt-Anchor" href="#当前行导航"></a> 当前行导航</h2><p>当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过<code>0</code>跳到本行第一个字符，通过<code>$</code>跳到本行最后一个字符。 另外，你可以使用<code>^</code>跳到本行第一个非空字符，通过<code>g_</code>跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用<code>n|</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0跳到本行第一个字符</span><br><span class="line">^跳到本行第一个非空字符</span><br><span class="line">g_      跳到本行最后一个非空字符</span><br><span class="line">$跳到本行最后一个字符</span><br><span class="line">n|      跳到本行第n列</span><br></pre></td></tr></table></figure><p>你也可以在本行通过<code>f</code>和<code>t</code>进行行内搜索，<code>f</code>和<code>t</code>的区别在于<code>f</code>会停在第一个匹配的字母上，<code>t</code>会停在第一个匹配的字母前。 因此如果你想要搜索并停留在&quot;h&quot;上，使用<code>fh</code>。 如果你想搜索第一个&quot;h&quot;并停留在它的前一个字母上，可以使用<code>th</code>。 如果你想去下一个行内匹配的位置，使用<code>;</code>，如果你想去前一个行内匹配的位置，使用<code>,</code>。</p><p><code>F</code>和<code>T</code>是<code>f</code>和<code>t</code>对应的向后搜索版本。如果想向前搜索&quot;h&quot;，可以使用<code>Fh</code>，使用<code>;</code>，保持相同的搜索方向搜索下一个匹配的字母。 注意，<code>;</code>不是总是向后搜索，<code>;</code>表示的是上一次搜索的方向，因此如果你使用的<code>F</code>，那么使用<code>;</code>时将会向前搜索使用<code>,</code>时向后搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f   在同一行向后搜索第一个匹配</span><br><span class="line">F   在同一行向前搜索第一个匹配</span><br><span class="line">t   在同一行向后搜索第一个匹配，并停在匹配前</span><br><span class="line">T   在同一行向前搜索第一个匹配，并停在匹配前</span><br><span class="line">;   在同一行重复最近一次搜索</span><br><span class="line">,   在同一行向相反方向重复最近一次搜索</span><br></pre></td></tr></table></figure><p>回到上一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure><p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符&quot;;“。 如果想去往&quot;world&quot;中的&quot;w”，你可以使用<code>fw</code>。 一个建议是，在行内目标附近通过寻找重复出现最少的字母例如&quot;j&quot;，“x”，&quot;z&quot;来前往行中的该位置更快。</p><h2 id="句子和段落导航"><a class="markdownIt-Anchor" href="#句子和段落导航"></a> 句子和段落导航</h2><p>接下来两个移动的单元是句子和段落。</p><p>首先我们来聊聊句子。 一个句子的定义是以<code>.!?</code>和跟着的一个换行符或空格，tab结尾的。 你可以通过<code>)</code>和<code>(</code>跳到下一个和上一个句子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(   跳到前一个句子</span><br><span class="line">)   跳到下一个句子</span><br></pre></td></tr></table></figure><p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用<code>(</code>和<code>)</code>感受一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :</span><br><span class="line"></span><br><span class="line">There is an empty line above me.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外，如果你的Vim中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于<code>compatible</code>的模式。 运行<code>:set nocompatible</code>可以修复。 在Vi中，一个句子是以<strong>两个</strong>空格结尾的，你应该总是保持的<code>nocompatible</code>的设置。</p><p>接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项(<code>paragraphs</code>)中&quot;字符对&quot;所指定的段落宏的每个集合开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;   跳转到上一个段落</span><br><span class="line">&#125;   跳转到下一个段落</span><br></pre></td></tr></table></figure><p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。</p><p>我们来看这个例子。 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>()</code>这样的句子导航。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello. How are you? I am great, thanks!</span><br><span class="line">Vim is awesome.</span><br><span class="line">It may not easy to learn it at first...- but we are in this together. Good luck!</span><br><span class="line"></span><br><span class="line">Hello again.</span><br><span class="line"></span><br><span class="line">Try to move around with ), (, &#125;, and &#123;. Feel how they work.</span><br><span class="line">You got this.</span><br></pre></td></tr></table></figure><p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多。</p><h2 id="匹配导航"><a class="markdownIt-Anchor" href="#匹配导航"></a> 匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过<code>%</code>跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%    Navigate to another match, usually works for (), [], &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用<code>%</code>移动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define (fib n)</span><br><span class="line">  (cond ((= n 0) 0)</span><br><span class="line">        ((= n 1) 1)</span><br><span class="line">        (else</span><br><span class="line">          (+ (fib (- n 1)) (fib (- n 2)))</span><br><span class="line">        )))</span><br></pre></td></tr></table></figure><p>我个人喜欢使用类似<a href="https://github.com/frazrepo/vim-rainbow">vim-rainbow</a>这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多。</p><h2 id="行号导航"><a class="markdownIt-Anchor" href="#行号导航"></a> 行号导航</h2><p>你可以通过<code>nG</code>调到行号为<code>n</code>的行，例如如果你想跳到第7行，你可以使用<code>7G</code>，跳到第一行使用<code>gg</code>或<code>1G</code>，跳到最后一行使用<code>G</code>。</p><p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用<code>70%</code>跳过去，可以使用<code>50%</code>跳到文件的中间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gg      跳转到第一行</span><br><span class="line">G       跳转到最后一行</span><br><span class="line">nG      跳转到第n行</span><br><span class="line">n%      跳到文件的n%</span><br></pre></td></tr></table></figure><p>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看。</p><h2 id="窗格导航"><a class="markdownIt-Anchor" href="#窗格导航"></a> 窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>。</p><p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀。 如果你输入<code>10H</code>你会跳转到窗格顶部往下数10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H   跳转到屏幕的顶部</span><br><span class="line">M   跳转到屏幕的中间</span><br><span class="line">L   跳转到屏幕的底部</span><br><span class="line">nH  跳转到距离顶部n行的位置</span><br><span class="line">nL  跳转到距离底部n行的位置</span><br></pre></td></tr></table></figure><h2 id="滚动"><a class="markdownIt-Anchor" href="#滚动"></a> 滚动</h2><p>在文件中滚动，你有三种速度可以选择： 滚动一整页(<code>CTRL-F</code>/<code>CTRL-B</code>)，滚动半页(<code>CTRL-D</code>/<code>CTRL-U</code>)，滚动一行<code>CTRL-E</code>/<code>CTRL-Y</code>)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-e    向下滚动一行</span><br><span class="line">Ctrl-d    向下滚动半屏</span><br><span class="line">Ctrl-f    向下滚动一屏</span><br><span class="line">Ctrl-y    向上滚动一行</span><br><span class="line">Ctrl-u    向上滚动半屏</span><br><span class="line">Ctrl-b    向上滚动一屏</span><br></pre></td></tr></table></figure><p>你也可以相对当前行进行滚动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zt    将当前行置于屏幕顶部附近</span><br><span class="line">zz    将当前行置于屏幕中央</span><br><span class="line">zb    将当前行置于屏幕底部</span><br></pre></td></tr></table></figure><h2 id="搜索导航"><a class="markdownIt-Anchor" href="#搜索导航"></a> 搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过<code>/</code>向下搜索，也可以通过<code>?</code>向上搜索一个字段。 你可以通过<code>n</code>重复最近一次搜索，<code>N</code>向反方向重复最近一次搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/   向后搜索一个匹配</span><br><span class="line">?   向前搜素一个匹配</span><br><span class="line">n   重复上一次搜索(和上一次方向相同)</span><br><span class="line">N   重复上一次搜索(和上一次方向相反)</span><br></pre></td></tr></table></figure><p>假设你有一下文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">one = &quot;01&quot;;</span><br><span class="line">one = &quot;one&quot;;</span><br><span class="line">let onetwo = 12;</span><br></pre></td></tr></table></figure><p>你可以通过<code>/let</code>搜索&quot;let&quot;，然后通过<code>n</code>快速的重复搜索下一个&quot;let&quot;，如果需要向相反方向搜索，可以使用<code>N</code>。 如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索&quot;let&quot;)。</p><p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段。 另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>。 因为我经常使用这个功能，所以我会设置一个映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;esc&gt;&lt;esc&gt; :noh&lt;return&gt;&lt;esc&gt;</span><br></pre></td></tr></table></figure><p>你可以通过<code>*</code>快速的向前搜索光标下的文本，通过<code>#</code>快速向后搜索光标下的文本。 如果你的光标位于一个字符串&quot;one&quot;上，按下<code>*</code>相当于<code>/\&lt;one\&gt;</code>。<br /><code>/\&lt;one\&gt;</code>中的<code>\&lt;</code>和<code>\&gt;</code>表示整词匹配，使得一个更长的包含&quot;one&quot;的单词不会被匹配上，也就是说它会匹配&quot;one&quot;，但不会匹配&quot;onetwo&quot;。 如果你的光标在&quot;one&quot;上并且你想向后搜索完全或部分匹配的单词，例如&quot;one&quot;和&quot;onetwo&quot;，你可以用<code>g*</code>替代<code>*</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   向后查找光标所在的完整单词</span><br><span class="line">#   向前查找光标所在的完整单词</span><br><span class="line">g*  向后搜索光标所在的单词</span><br><span class="line">g#  向前搜索光标所在的单词</span><br></pre></td></tr></table></figure><h2 id="位置标记"><a class="markdownIt-Anchor" href="#位置标记"></a> 位置标记</h2><p>你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过<code>mx</code>设置一个标记，其中<code>x</code>可以是<code>a-zA-Z</code>。 有两种办法能回到标记的位置： 用<code> `x</code>精确回到(行和列)，或者用<code>'x</code>回到行级位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ma    用a标签标记一个位置</span><br><span class="line">`a    精确回到a标签的位置(行和列)</span><br><span class="line">&#x27;a    跳转到a标签的行</span><br></pre></td></tr></table></figure><p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。</p><p>我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记&quot;a&quot;(<code>ma</code>)，然后在另一个文件中设置另一个标记&quot;a&quot;(<code>ma</code>)。</p><p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在<code>myFile.txt</code>中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。</p><p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-zA-Z</code>以外还有别的标签，其中有一些例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;   在当前buffer中跳转回到上一次跳转前的最后一行</span><br><span class="line">``  在当前buffer中跳转回到上一次跳转前的最后一个位置</span><br><span class="line">`[  跳转到上一次修改或拷贝的文本的开头</span><br><span class="line">`]  跳转到上一次修改或拷贝的文本的结尾</span><br><span class="line">`&lt;  跳转到最近一次可视模式下选择的部分的开头</span><br><span class="line">`&gt;  跳转到最近一次可视模式下选择的部分的结尾</span><br><span class="line">`0  跳转到退出Vim前编辑的最后一个文件</span><br></pre></td></tr></table></figure><p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看。</p><h2 id="跳转"><a class="markdownIt-Anchor" href="#跳转"></a> 跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用<code>j</code>向下移动一行就不被看做一个跳转，即使你使用<code>10j</code>向下移动10行，也不是一个跳转。 但是你通过<code>10G</code>去往第10行被算作一个跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x27;   跳转到标记的行</span><br><span class="line">`   跳转到标记的位置(行和列)</span><br><span class="line">G   跳转到行</span><br><span class="line">/   向后搜索</span><br><span class="line">?   向前搜索</span><br><span class="line">n   重复上一次搜索，相同方向</span><br><span class="line">N   重复上一次搜索，相反方向</span><br><span class="line">%   查找匹配</span><br><span class="line">(   跳转上一个句子</span><br><span class="line">)   跳转下一个句子</span><br><span class="line">&#123;   跳转上一个段落</span><br><span class="line">&#125;   跳转下一个段落</span><br><span class="line">L   跳转到当前屏幕的最后一行</span><br><span class="line">M   跳转到当前屏幕的中间</span><br><span class="line">H   跳转到当前屏幕的第一行</span><br><span class="line">[[  跳转到上一个小节</span><br><span class="line">]]  跳转到下一个小节</span><br><span class="line">:s  替换</span><br><span class="line">:tag  跳转到tag定义</span><br></pre></td></tr></table></figure><p>我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>。</p><p>为什么跳转有用呢? 因为你可以在跳转列表中通过<code>Ctrl-o</code>和<code>Ctrl-i</code>在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。</p><h2 id="聪明地学习导航"><a class="markdownIt-Anchor" href="#聪明地学习导航"></a> 聪明地学习导航</h2><p>如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。</p><p>我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从<code>h,j,k,l,w,b,G,/,?,n</code>开始，不断地重复这10个移动知道形成肌肉记忆，这花不了多少时间。</p><p>为了让你更擅长导航，我有两个建议：</p><ol><li>注意重复的动作。 如果你发现你自己在重复的使用<code>l</code>，你可以去找一个方法让你前进的更快，然后你会发现你可以用<code>w</code>在单词间移动。 如果你发现你自己的重复的使用<code>w</code>，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用<code>$</code>。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。</li><li>当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。</li></ol><p>最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。</p><p>慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/0584a475/">Ch 4 - Vim 语法</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/f92aab20/">Ch 6 - 插入模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch04-Vim语法</title>
      <link href="/posts/0584a475.html"/>
      <url>/posts/0584a475.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用<code>gUfV</code>或<code>1GdG</code>，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。</p><p>这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim&quot;说话&quot;。注意，在这一章中当我讨论Vim语言时，我讨论并不是<br />Vimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。</p><h2 id="如何学习一门语言"><a class="markdownIt-Anchor" href="#如何学习一门语言"></a> 如何学习一门语言</h2><p>我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：</p><ol><li>学习语法规则</li><li>扩展我的词汇量</li><li>练习，练习，练习</li></ol><p>同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。</p><h2 id="语法规则"><a class="markdownIt-Anchor" href="#语法规则"></a> 语法规则</h2><p>你只需要知道一个Vim语言的语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun # 动词 + 名词</span><br></pre></td></tr></table></figure><p>这就类似与在英语中的祈使句：</p><ul><li>“Eat(verb) a donut(noun)”</li><li>“Kick(verb) a ball(noun)”</li><li>“Learn(verb) the Vim Editor(noun)”</li></ul><p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p><h2 id="名词动作-motion"><a class="markdownIt-Anchor" href="#名词动作-motion"></a> 名词(动作 Motion)</h2><p>我们这里将 <strong>动作 Motion</strong> 作为名词， <strong>动作Motion</strong>用来在Vim中到处移动。下面列出了一些常见的<strong>动作</strong>的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h左</span><br><span class="line">j下</span><br><span class="line">k上</span><br><span class="line">l右</span><br><span class="line">w向前移动到下一个单词的开头</span><br><span class="line">&#125;跳转到下一个段落</span><br><span class="line">$跳转到当前行的末尾</span><br></pre></td></tr></table></figure><p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些<strong>动作</strong>也不必担心。</p><h2 id="动词操作符-operator"><a class="markdownIt-Anchor" href="#动词操作符-operator"></a> 动词(操作符 Operator)</h2><p>根据<code>:h operator</code>，Vim共有16个<strong>操作符</strong>，然而根据我的经验，学习这3个<strong>操作符</strong>在80%的情况下就已经够用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yyank(复制)</span><br><span class="line">ddelete(删除)</span><br><span class="line">cchange 删除文本，将删除的文本存到寄存器中，进入插入模式</span><br></pre></td></tr></table></figure><p>顺带说一句，当你yank一段文本后，您可以使用<code>p</code>将它粘贴到光标后，或使用<code>P</code>粘贴到光标前。</p><h2 id="动词操作符-operator和名词动作-motions的结合"><a class="markdownIt-Anchor" href="#动词操作符-operator和名词动作-motions的结合"></a> 动词（操作符 Operator）和名词（动作 motions）的结合</h2><p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则，动词和名词的结合！假设你有下面这段文本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> learn = <span class="string">&quot;Vim&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>复制当前位置到行尾的所有内容：<code>y$</code></li><li>删除当前位置到下一个单词的开头：<code>dw</code></li><li>修改当前位置到这个段落的结尾：<code>c&#125;</code></li></ul><p><strong>动作 motions</strong>也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用<code>3k</code>代替按3次<code>k</code>，数字可应用在Vim语法中。</p><ul><li>向左拷贝2个字符：<code>y2h</code></li><li>删除后两个单词：<code>d2w</code></li><li>修改后面两行：<code>c2j</code></li></ul><p>目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。唯一途径就是重复、重复再重复。</p><p>作为补充，行级的 <strong>操作符 operations</strong> (作用在整行中的操作符)在文本编辑中和其他的 <strong>操作符</strong> 一样，Vim允许你通过按两次 <strong>操作符</strong>使它执行行级的操作，例如<code>dd</code>，<code>yy</code>，<code>cc</code>来执行删除，复制或修改整个行。您可以使用其他operations试一下（比如<code>gUgU</code>）。</p><p>666!从这可以看出Vim命令的一种执行模式。但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)</p><h2 id="更多名词文本对象-text-objects"><a class="markdownIt-Anchor" href="#更多名词文本对象-text-objects"></a> 更多名词(文本对象 Text Objects)</h2><p>想象一下你现在正在某个被括号包围的文本中例如<code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？</p><p>答案是有的。文本通常是结构化的，特别是代码中，文本经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。</p><p>文本对象可以被 <strong>操作符 operations</strong> 使用，这里有两类文本对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i + object  内部文本对象</span><br><span class="line">a + object  外部文本对象</span><br></pre></td></tr></table></figure><p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多。如果你的光标位于一对括号内部，例如<code>(hello Vim)</code>中：</p><ul><li>删除括号内部的内容但保留括号：<code>di(</code></li><li>删除括号以及内部的内容：<code>da(</code></li></ul><p>让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在&quot;Hello&quot;中的&quot;H&quot;上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello Vim&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除整个&quot;Hello Vim&quot;：<code>di(</code></li><li>删除整个函数(被{}包含)：<code>di&#123;</code></li><li>删除&quot;Hello&quot;这个词：<code>diw</code></li></ul><p>文本对象很强大因为你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到<code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词。</p><p>让我们来看最后一个例子。假设你有这样一些html的标签的文本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你的光标位于&quot;Header1&quot;文本上：</p><ul><li>删除&quot;Header1&quot;：<code>dit</code></li><li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：<code>dat</code></li></ul><p>如果你的光标在&quot;div&quot;文本上：</p><ul><li>删除<code>h1</code>和所有<code>p</code>标签的行：<code>dit</code></li><li>删除所有文本：<code>dat</code></li><li>删除&quot;div&quot;：<code>di&lt;</code></li></ul><p>下面列举的一些通常见到的文本对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w     一个单词</span><br><span class="line">p     一个段落</span><br><span class="line">s     一个句子</span><br><span class="line">(或)  一对()</span><br><span class="line">&#123;或&#125;  一对&#123;&#125;</span><br><span class="line">[或]  一对[]</span><br><span class="line">&lt;或&gt;  一对&lt;&gt;</span><br><span class="line">t     XML标签</span><br><span class="line">&quot;     一对&quot;&quot;</span><br><span class="line">&#x27;     一对&#x27;&#x27;</span><br><span class="line">`     一对``</span><br></pre></td></tr></table></figure><p>你可以通过<code>:h text-objects</code>了解更多</p><h2 id="结合性和语法"><a class="markdownIt-Anchor" href="#结合性和语法"></a> 结合性和语法</h2><p>在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。</p><p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。</p><p>Vim的结合性最强大之处体现在它和外部程序结合时，Vim有一个 <strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id|Name|Cuteness</span><br><span class="line">01|Puppy|Very</span><br><span class="line">02|Kitten|Ok</span><br><span class="line">03|Bunny|Ok</span><br></pre></td></tr></table></figure><p>这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令<code>column</code>很快的完成它，当你的光标位于&quot;Id&quot;上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id  Name    Cuteness</span><br><span class="line">01  Puppy   Very</span><br><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure><p>让我们分解一下上面那条命令，动词是<code>!</code>(<strong>过滤操作符</strong>)，名词是<code>&#125;</code>(到下一个段落)。<strong>过滤操作符</strong><code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本。</p><p>假设你不止想格式化你的文本，还想只展示<code>Ok</code>结尾的行，你知道<code>awk</code>命令可以做这件事情，那么你可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&#125;column -t -s &quot;|&quot; | awk &#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure><p>666！管道竟然在Vim中也能起作用。</p><p>这就是Vim的结合性的强大之处。你知道的动词 <strong>操作符</strong>，名词 <strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长。</p><p>换句话说，假设你只知道四个<strong>动作</strong>：<code>w, $, &#125;, G</code>和删除操作符(<code>d</code>)，你可以做8件事：按四种方式移动(<code>w, $, &#125;, G</code>)和删除4种文本对象(<code>dw, d$, d&#125;, dG</code>)。如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的Vim工具箱中多的不是1种工具，而是4种：<code>gUw, gU$, gU&#125;, gUG</code>。现在你的Vim工具箱中就有12种工具了。如果你知道10个<strong>动作</strong>和5个<strong>操作符</strong>，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(<code>nG</code>)给你了<code>n</code>种<strong>动作</strong>，其中<code>n</code>是你文件中的行数(例如前往第5行，<code>5G</code>)。搜索动作(<code>/</code>)实际上给你带来无限数量的<strong>动作</strong>因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(<code>!</code>)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。</p><p>这种具有结合性的行为也正符合Unix的哲学：<em>一个命令做好一件事</em>。<strong>动作</strong>只需要做一件事：前往X。<strong>操作符</strong>只需要做一件事：完成Y。通过结合一个<strong>操作符</strong>和一个<strong>动作</strong>，你就获得了YX：在X上完成Y。</p><p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造<strong>动作</strong>和<strong>操作符</strong>去丰富你的Vim工具箱，<a href="https://github.com/kana/vim-textobj-user"><code>Vim-textobj-user</code></a>插件允许你创建自己的文本对象，同时包含有<a href="https://github.com/kana/vim-textobj-user/wiki">一系列定义好的文本对象</a>。</p><p>另外，如果你不知道我刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。</p><h2 id="聪明地学习语法"><a class="markdownIt-Anchor" href="#聪明地学习语法"></a> 聪明地学习语法</h2><p>你刚刚学完Vim唯一的语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun</span><br></pre></td></tr></table></figure><p>我学Vim中最大的&quot;AHA moment&quot;之一是当我刚学完大写命令(<code>gU</code>)时，想要把一个单词变成大写，我本能的运行了<code>gUiW</code>，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的&quot;AHA moment&quot;，如果之前没有的话。</p><p>这一章的目标是向你展现Vim中的<code>verb+noun</code>模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。</p><p>学习这种模式并且理解其中的含义，这是聪明的学习方式。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/32c07678/">Ch 3 - 打开和搜索文件</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/25eb02e8/">Ch 5 - 移动文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch03-打开和搜索文件</title>
      <link href="/posts/32c07678.html"/>
      <url>/posts/32c07678.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>本章的目的是向您介绍如何在Vim中快速搜索，能够快速搜索是提高您的Vim工作效率的重要途径。当我解决了如何快速搜索文件这个问题后，我就决定改为完全使用Vim来工作。</p><p>本章划分为两个部分：一是如何不依赖插件搜索；二是使用<a href="https://github.com/junegunn/fzf.vim">fzf插件</a>搜索。让我们开始吧！</p><h2 id="打开和编辑文件"><a class="markdownIt-Anchor" href="#打开和编辑文件"></a> 打开和编辑文件</h2><p>要在Vim中打开一个文件，您可以使用<code>:edit</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit file.txt</span><br></pre></td></tr></table></figure><p>如果<code>file.txt</code>已经存在，就会打开<code>file.txt</code>buffer。如果<code>file.txt</code>不存在，会创建一个新buffer名为<code>file.txt</code>。</p><p><code>:edit</code>命令支持使用<code>&lt;Tab&gt;</code>进行自动补全。比如，如果您的文件位于<a href="https://rubyonrails.org/">Rails</a>应用控制器的用户控制器目录<code>./app/controllers/users_controllers.rb</code>内，您可以使用<code>&lt;Tab&gt;</code>对文件路径名进行快速扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit a&lt;Tab&gt;c&lt;Tab&gt;u&lt;Tab&gt;</span><br></pre></td></tr></table></figure><p><code>:edit</code>可以接收通配符参数。<code>*</code>匹配当前目录下的任意文件。如果您只想查找当前目录下后缀名为<code>.yml</code>的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit *.yml&lt;Tab&gt;</span><br></pre></td></tr></table></figure><p>Vim将列出当前目录下所有<code>.yml</code>文件供您选择。</p><p>您可以使用<code>**</code>进行递归的搜索。如果您想查找当前项目文件夹下所有<code>*.md</code>文件，但您不知道在哪个目录，您可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit **/*.md&lt;Tab&gt;</span><br></pre></td></tr></table></figure><p><code>:edit</code>可以用于运行<code>netrw</code>（Vim的内置文件浏览器）。使用方法是，给<code>:edit</code>一个目录参数而不是文件名就行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:edit .</span><br><span class="line">:edit test/unit/</span><br></pre></td></tr></table></figure><h2 id="使用find命令搜索文件"><a class="markdownIt-Anchor" href="#使用find命令搜索文件"></a> 使用find命令搜索文件</h2><p>您可以使用<code>:find</code>命令搜索文件。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:find package.json</span><br><span class="line">:find app/controllers/users_controller.rb</span><br></pre></td></tr></table></figure><p><code>:find</code>命令同样支持自动补全：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:find p&lt;Tab&gt;                &quot; to find package.json</span><br><span class="line">:find a&lt;Tab&gt;c&lt;Tab&gt;u&lt;Tab&gt;    &quot; to find app/controllers/users_controller.rb</span><br></pre></td></tr></table></figure><p>您可能注意到<code>:find</code>和<code>:edit</code>看起来很像。它们的区别是什么呢？</p><h2 id="find-和-path"><a class="markdownIt-Anchor" href="#find-和-path"></a> Find 和 Path</h2><p>两者的区别在于，<code>:find</code>命令根据<code>path</code>选项配置的路径查找文件，而<code>:edit</code>不会。让我们了解一点关于<code>path</code>选项的知识。一旦您学会如何修改您的路径，<code>:find</code>命令能变成一个功能强大的搜索工具。先查看一下您的<code>path</code>是什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path?</span><br></pre></td></tr></table></figure><p>默认情况下，您的<code>path</code>内容很可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path=.,/usr/include,,</span><br></pre></td></tr></table></figure><ul><li><code>.</code> 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 <strong>当前所打开的文件</strong> 所在的目录)</li><li><code>,</code> means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号<code>,</code>应该是表示路径之间的分割符。连续的两个<code>,,</code>（两个逗号之间为空）才表示当前目录)</li><li><code>/usr/include</code> 表示在C编译器头文件目录下搜索。</li></ul><p>前两个配置非常重要，第3个现在可以被忽略。您这里应该记住的是：您可以修改您自己的路径。让我们假设您的项目结构是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">  assets/</span><br><span class="line">  controllers/</span><br><span class="line">    application_controller.rb</span><br><span class="line">    comments_controller.rb</span><br><span class="line">    users_controller.rb</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果您想从根目录跳到<code>users_controller.rb</code>，您将不得不经过好几层目录（按好几次<code>&lt;Tab&gt;</code>）。一般说来，当您处理一个framework时，90%的时间您都在某个特定的目录下。在这种情况下，您只关心如何用最少的按键跳到<code>controllers/</code>目录。那么<code>path</code>设置可以减少这个途程。</p><p>您只需要将<code>app/controllers/</code>添加到当前<code>path</code>选项。以下是操作步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path+=app/controllers/</span><br></pre></td></tr></table></figure><p>现在您的路径已经更新，当您输入<code>:find u&lt;Tab&gt;</code>时，Vim将会在<code>app/controllers/</code>目录内搜索所有以&quot;u&quot;开头的文件。</p><p>如果您有一个嵌套的目录<code>controllers/</code>，比如<code>app/controllers/account/users_controller.rb</code>，Vim就找不到<code>users_controllers</code>了。您必须改为添加<code>:set path+=app/controllers/**</code>，这样自动补全才会找到<code>users_controller.rb</code>。这太棒了！您现在可以只需要按1次键就可找到users controller。</p><p>您可能会想将整个项目文件夹添加到<code>path</code>中，这样当您按<code>&lt;Tab&gt;</code>，Vim将在所有文件夹内搜索您要找的文件，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path+=$PWD/**</span><br></pre></td></tr></table></figure><p><code>$PWD</code> 表示的是当前工作目录。如果您尝试将整个项目路径加到<code>path</code>中，并希望让所有文件名可以用<code>&lt;Tab&gt;</code>补全，虽然对于小项目没问题，但如果您的项目中包含大量文件时，这会显著降低您的搜索速度。我建议仅仅将您最常访问的文件/目录添加到<code>path</code>。（译者注：不知道是不是因为系统环境不一样的原因，译者使用的是windows下的Vim8.2，$PWD 这个环境变量在译者的vim中不起作用，必须在vimrc文件中添加一句<code>let $PWD=getcwd()</code>才行）。</p><p>您可以将<code>set path+=&#123;您需要添加的目录&#125;</code>添加到您的vimrc文件中。更新<code>path</code>仅花费几秒钟，但可以为您的工作节省很多时间。</p><h2 id="使用grep命令在文件中搜索"><a class="markdownIt-Anchor" href="#使用grep命令在文件中搜索"></a> 使用Grep命令在文件中搜索</h2><p>如果您想在文件内部查找（搜索文件中的词句），您可以使用grep。Vim有两个方法可以完成这个工作：</p><ul><li>内置grep （<code>:vim</code>。没错，就是<code>:vim</code>，它是<code>:vimgrep</code>的简写）。</li><li>外部grep (<code>:grep</code>)。</li></ul><p>让我们首先仔细看看内置grep。<code>:vim</code>有以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vim /pattern/ file</span><br></pre></td></tr></table></figure><ul><li><code>/pattern/</code> 是您要搜索的内容的正则表达式。</li><li><code>file</code> 是文件参数。您可以传入多个参数。Vim将在文件中搜索所有匹配正则表达式的内容。类似于<code>:find</code>，您可以传入*和**通配符。</li></ul><p>比如，要在<code>app/controllers/</code>目录下所有ruby文件(<code>.rb</code>)中，查找所有的&quot;breakfast&quot;字符串:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vim /breakfast/ app/controllers/**/*.rb</span><br></pre></td></tr></table></figure><p>输入上面的命令后，您将会被导航到第一个结果。Vim的<code>vim</code>搜索命令使用<code>quickfix</code>进行处理。要查看所有搜索结果，运行<code>:copen</code>会打开一个<code>quickfix</code>窗口。下面有一些有用的quickfix命令，可以让您提高效率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:copen        打开quickfix窗口</span><br><span class="line">:cclose       关闭quickfix窗口</span><br><span class="line">:cnext        跳到下一个错误</span><br><span class="line">:cprevious    跳到前一个错误</span><br><span class="line">:colder       跳到旧的错误列表</span><br><span class="line">:cnewer       跳到新的错误列表</span><br></pre></td></tr></table></figure><p>要了解更多关于quickfix的信息，使用<code>:h quickfix</code>查看帮助信息。</p><p>您可能注意到运行内置grep(<code>:vim</code>)命令时，如果匹配结果数量较多时系统速度会变慢。这是因为Vim将每一个搜索结果读入内存。Vim加载每一个匹配的文件就像它们被编辑一样。如果Vim查到大量文件，它将消耗很多内存。</p><p>让我们谈谈外置grep。默认情况下，它使用终端命令<code>grep</code>。要想在<code>app/controllers/</code>目录中搜索字符串&quot;lunch&quot;，您可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:grep -R &quot;lunch&quot; app/controllers/</span><br></pre></td></tr></table></figure><p>注意这里不是使用<code>/pattern/</code>，它遵循的是终端grep的语法<code>&quot;pattern&quot;</code>，它同样使用’quickfix’来显示所有的匹配结果。</p><p>Vim使用<code>grepprg</code>变量来决定运行<code>:grep</code>时，应该使用哪个外部程序。所以您并不是非得使用终端的<code>grep</code>命令。稍后我将为您演示如何改变外部grep程序的默认值。</p><h2 id="用netrw浏览文件"><a class="markdownIt-Anchor" href="#用netrw浏览文件"></a> 用Netrw浏览文件</h2><p><code>netrw</code>是Vim的内置文件浏览器，当查看项目的目录结构时很有用。要运行<code>netrw</code>，您需要在您的<code>.vimrc</code>中做以下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nocp</span><br><span class="line">filetype plugin on</span><br></pre></td></tr></table></figure><p>由于<code>netrw</code>是一个很宽泛的话题，我将紧紧介绍它的基本用法，这应该已经足够了。您可以在启动Vim时运行<code>netrw</code>，只需要传给Vim一个目录参数（而不是文件参数）就行了。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim .</span><br><span class="line">vim src/client/</span><br><span class="line">vim app/controllers/</span><br></pre></td></tr></table></figure><p>要想从Vim内部运行<code>netrw</code>，您可以使用<code>:edit</code>命令，传给他一个目录而不是文件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:edit .</span><br><span class="line">:edit src/client/</span><br><span class="line">:edit app/controllers/</span><br></pre></td></tr></table></figure><p>也有其他方法，不需要传递目录参数就运行<code>netrw</code>窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:Explore     从当前文件启动netrw。</span><br><span class="line">:Sexplore    Sex_Plore?不是开玩笑:)，在顶部水平分割的窗口打开netrw。</span><br><span class="line">:Vexplore    在左侧垂直分割的窗口打开netrw。</span><br></pre></td></tr></table></figure><p>您可以使用Vim动作(motions，在后面的章节中将详细讲述)在<code>netrw</code>中导航。如果您要创建、删除、重命名文件或文件夹，下面有一些关于<code>netrw</code>的有用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%    创建新文件</span><br><span class="line">d    创建新目录</span><br><span class="line">R    重命名文件/目录</span><br><span class="line">D    删除文件/目录</span><br></pre></td></tr></table></figure><p><code>:h netrw</code> 的信息非常复杂，如果您有时间可以看看。</p><p>如果您觉得 <code>netrw</code> 过于单调乏味，<a href="https://github.com/tpope/vim-vinegar">vim-vinegar</a>是netrw的一个改进插件。如果您想找一个不同的文件浏览器，<a href="https://github.com/preservim/nerdtree">NERDTree</a> 是一个很好的选择。去看看吧。</p><h2 id="fzf插件"><a class="markdownIt-Anchor" href="#fzf插件"></a> Fzf插件</h2><p>您现在已经学会了如何使用Vim的内置工具去搜索文件，那么让我们学习一下如何用插件实现这些功能吧。</p><p>现代文本编辑器相比Vim，有一个功能设计得很好，那就是文件搜索和模糊搜索的简化。在本章的下半部分，我将向您演示如何使用<a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>插件，在Vim中轻松实现功能强大的搜索功能。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>首先，确保您下载了<a href="https://github.com/junegunn/fzf">fzf</a>和<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>。按照它们在github仓库上的指令一步步做。成功安装后，命令<code>fzf</code>和<code>rg</code>应该就可以用了。</p><p>Ripgrep是一个类似grep（从名字上就看得出）的搜索工具。一般说来，它比grep要快，而且还有很多有用的特性。Fzf是一个多用途的命令行模糊搜索工具，您可以讲它与其他命令联合起来使用，包括ripgrep。联合起来后，它们成为一个功能强大的搜索工具。</p><p>Fzf默认并不使用ripgrep，所以我们需要设置<code>FZF_DEFAULT_COMMAND</code>变量告诉fzf使用ripgrep命令。在我的<code>.zshrc</code>（如果您用bash，应该是<code>.bashrc</code>）文件内，我有以下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if type rg &amp;&gt; /dev/null; then</span><br><span class="line">  export FZF_DEFAULT_COMMAND=&#x27;rg --files&#x27;</span><br><span class="line">  export FZF_DEFAULT_OPTS=&#x27;-m&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>注意<code>FZF_DEFAULT_OPTS</code>变量中的<code>-m</code>。这个设置允许我们按下<code>&lt;Tab</code>或<code>&lt;Shift-Tab&gt;</code>后进行多重选择。如果仅想让fzf在Vim中能够工作，这个设置不是必须的，但我认为这是一个有用的设置。当您想在多个文件中执行搜索和替换，进行少量修改时，它会很方便。fzf命令可以接收很多标志，但我不会再这里讲。要想了解更多信息，可以查看<a href="https://github.com/junegunn/fzf#usage">fzf’s 仓库</a>，或者使用<code>man fzf</code>。要想让fzf使用ripgrep，您至少得有这个设置<code>export FZF_DEFAULT_COMMAND='rg'</code>。</p><p>安装好了fzf和ripgrep后，让我们再安装fzf的插件。在这个例子中，我使用的是<a href="https://github.com/junegunn/vim-plug">vim-plug</a>插件管理器，当然您可以使用其他插件管理器。</p><p>将下列配置添加到您的<code>.vimrc</code>中。因为您需要使用<a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>插件。（同样是由fzf的作者在维护）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;junegunn/fzf.vim&#x27;</span><br><span class="line">Plug &#x27;junegunn/fzf&#x27;, &#123; &#x27;do&#x27;: &#123; -&gt; fzf#install() &#125; &#125;</span><br></pre></td></tr></table></figure><p>添加后，您需要打开vim，运行<code>:PlugInstall</code>。这条命令将会安装所有您在<code>vimrc</code>文件中定义了但尚未安装的插件。 在我的例子中，将会安装<code>fzf.vim</code>和<code>fzf</code>。</p><p>要了解更多关于此插件的信息，您可以查看<a href="https://github.com/junegunn/fzf/blob/master/README-VIM.md">fzf.vim 的仓库</a>。</p><h2 id="fzf的语法"><a class="markdownIt-Anchor" href="#fzf的语法"></a> Fzf的语法</h2><p>要想高效的使用fzf，您首先得了解一些fzf的基础语法。幸运的是，这个列表比较短：</p><ul><li><code>^</code> 表示前缀精确匹配。要搜索一个以&quot;welcome&quot;开头的短语：<code>^welcom</code>。</li><li><code>$</code> 表示后缀精确匹配。要搜索一个以&quot;my friends&quot;结尾的短语：<code>friends$</code>。</li><li><code>'</code> 表示精确匹配。要搜索短语&quot;welcom my friends&quot;：<code>'welcom my friends</code>。</li><li><code>|</code> 表示&quot;或者&quot;匹配。要搜索&quot;friends&quot;或&quot;foes&quot;：<code>friends | foes</code>。</li><li><code>!</code> 表示反向匹配。要搜索一个包含&quot;welcome&quot;但不包含&quot;friends&quot;的短语：<code>welcome !friends</code>。</li></ul><p>您可以混合起来使用。比如，<code>^hello | ^welcome friends$</code>将搜索以&quot;welcome&quot;或&quot;hello&quot;开头，并且以&quot;friends&quot;结束的短语。</p><h2 id="查找文件"><a class="markdownIt-Anchor" href="#查找文件"></a> 查找文件</h2><p>要想在Vim内使用fzf.vim插件搜索文件，您可以使用<code>:Files</code>方法。在Vim中运行<code>:Files</code>，您将看到fzf搜索提示符。</p><p>因为您将频繁地使用这个命令，最好建立一个键盘映射，我把它映射到<code>Ctrl-f</code>。在我的vimrc配置中，有这个设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;silent&gt; &lt;C-f&gt; :Files&lt;CR&gt;</span><br></pre></td></tr></table></figure><h2 id="在文件中查找"><a class="markdownIt-Anchor" href="#在文件中查找"></a> 在文件中查找</h2><p>要想在文件内部搜索，您可以使用<code>:Rg</code>命令。</p><p>同样，因为您可能将频繁的使用这个命令，让我们给它一个键盘映射。我的映射在<code>&lt;Leader&gt;f</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;f :Rg&lt;CR&gt;</span><br></pre></td></tr></table></figure><h2 id="其他搜索"><a class="markdownIt-Anchor" href="#其他搜索"></a> 其他搜索</h2><p>Fzf.vim提供了许多其他命令。这里我不会一个个仔细讲，您可以去<a href="https://github.com/junegunn/fzf.vim#commands">这里</a>查看更多信息。</p><p>这是我的fzf键盘映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;b :Buffers&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;C-f&gt; :Files&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;f :Rg&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;/ :BLines&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;&#x27; :Marks&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;g :Commits&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;H :Helptags&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;hh :History&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;h: :History:&lt;CR&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;h/ :History/&lt;CR&gt;</span><br></pre></td></tr></table></figure><h2 id="将grep替换为rg"><a class="markdownIt-Anchor" href="#将grep替换为rg"></a> 将Grep替换为Rg</h2><p>正如前面提到的，Vim有两种方法在文件内搜索：<code>:vim</code>和<code>:grep</code>。您可以使用<code>grepprg</code>这个关键字重新指定<code>:grep</code>使用的外部搜索工具。我将向您演示如何设置Vim，使得当运行<code>:grep</code>命令时，使用ripgrep代替终端的grep。</p><p>现在，让我们设置<code>grepprg</code>来使<code>:grep</code>使用ripgrep。将下列设置添加到您的vimrc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set grepprg=rg\ --vimgrep\ --smart-case\ --follow</span><br></pre></td></tr></table></figure><p>上面的一些选项可以随意修改！要想了解更多关于这些选项的含义，请使用<code>man rg</code>了解详情。</p><p>当您更新<code>grepprg</code>选项后，现在当您运行<code>:grep</code>，它将实际运行<code>rg --vimgrep --smart-case --follow</code>而不是<code>grep</code>。如果您想使用ripgrep搜索&quot;donut&quot;，您可以运行一条更简洁的命令<code>:grep &quot;donut&quot;</code>，而不是<code>:grep &quot;donut&quot; . -R</code></p><p>就像老的<code>:grep</code>一样，新的<code>:grep</code>同样使用quickfix窗口来显示结果。</p><p>您可能好奇，“很好，但我从没在Vim中使用过<code>:grep</code>，为什么我不能直接使用<code>:Rg</code>命令在文件中搜索呢？究竟什么时候我必须使用<code>:grep</code>？”。</p><p>这个问题问得很好。在Vim中，当您需要在多个文件中执行搜索和替换时，您可能必须使用<code>:grep</code>这个命令。我马上就会讲这个问题。</p><h2 id="在多文件中搜索和替换"><a class="markdownIt-Anchor" href="#在多文件中搜索和替换"></a> 在多文件中搜索和替换</h2><p>现代文本编辑器，比如VSCode中，在多个文件中搜索和替换一个字符串是很简单的事情。在这一节，我将向您演示如何在Vim中轻松实现这个。</p><p>第一个方法是在您的项目中替换 <strong>所有</strong> 的匹配短句。您得使用<code>:grep</code>命令。如果您想将所有&quot;pizza&quot;替换为&quot;donut&quot;，下面是操作方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:grep &quot;pizza&quot;</span><br><span class="line">:cfdo %s/pizza/donut/g | update</span><br></pre></td></tr></table></figure><p>让我们来分析一下这条命令：</p><ol><li><code>:grep pizza</code>使用ripgrep去搜索所有&quot;pizza&quot;（顺带说一句，就算您不给<code>grepprg</code>重新赋值让它使用ripgrep，这条命令依然有效，但您可能不得不使用<code>:grep &quot;pizza&quot; . -R</code>命令，而不是<code>:grep &quot;pizza&quot;</code>）。</li><li><code>:cfdo</code>会在您的quickfix列表中所有文件里，执行您传递给它的命令。在这个例子中，您的命令是一条替换命令<code>%s/pizza/donut/g</code>。管道符号(<code>|</code>)是一个链接操作符。命令<code>update</code>在每个文件被替换后，立刻保存。在后面的章节中，我将深入介绍替换命令。</li></ol><p>第二个方法是在您选择文件中执行搜索和替换。用这个方法，您可以手动选择您想执行搜索和替换的文件。下面是操作方法：</p><ol><li>首先清空您的buffer。让您的buffer列表仅包含您所需要的文件，这一点很有必要。您可以重启Vim，也可以运行<code>:%bd | e#</code>命令（<code>%bd</code>关闭所有buffer，而<code>e#</code>打开您当前所在的文件）。</li><li>运行<code>:Files</code>。</li><li>选择好您想搜索-替换的文件。要选择多个文件，使用<code>&lt;Tab&gt;</code>或<code>&lt;Shift-Tab&gt;</code>。当然，您必须使多文件标志(<code>-m</code>)位于<code>FZF_DEFAULT_OPTS</code>中。</li><li>运行<code>:bufdo %s/pizza/donut/g | update</code>。命令<code>:bufdo %s/pizza/donut/g | update</code>看起来和前面的<code>:cfdo %s/pizza/donut/g | update</code>很像，区别在于，(<code>:cfdo</code>)替换所有quickfix中的实体，而(<code>:bufdo</code>)替换所有buffer中的实体。</li></ol><h2 id="用聪明的方法学习搜索"><a class="markdownIt-Anchor" href="#用聪明的方法学习搜索"></a> 用聪明的方法学习搜索</h2><p>在文本编辑时，搜索是一个很实用的技巧。学会在Vim中如何搜索，将显著提高您的文本编辑工作流程效率。</p><p>Fzf.vim插件就像一个游戏规则改变者。我无法想象使用Vim没有它的情景。当最开始使用Vim时，如果有一个好的搜索工具，我想是非常重要的。我看见很多人过渡到Vim时的艰难历程，就是因为Vim缺少了现代编辑器所拥有的一些关键功能特性，比如简单快捷且功能强大的搜索功能。我希望本章将帮助您更轻松地向Vim过渡。</p><p>您同时也看到了Vim的扩展性，即使用插件或外部程序扩展搜索功能的能力。将来，记住您想在Vim中拓展的功能。很有可能已经有人写好了相关插件，已经有现成的程序了。下一章，您将学习Vim中非常重要的主题：Vim语法。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/e5aa9cfc/">Ch 2 - 缓冲区，窗口和选项卡</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/0584a475/">Ch 4 - Vim 语法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch02-缓冲区，窗口选项卡</title>
      <link href="/posts/e5aa9cfc.html"/>
      <url>/posts/e5aa9cfc.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>(译者注：在Vim中，Buffers缓冲区，Windows窗口，Tabs选项卡是专有名词。为适应不同读者的翻译习惯，确保没有歧义，本文将不对Buffers、Windows、Tabs这三个词进行翻译)。</p><p>如果您使用过现代文本编辑器，您很可能对Windows和tabs这两个概念是非常熟悉的。但Vim使用了三个关于显示方面的抽象概念：buffers, windows, 还有tabs。在本章，我将向您解释什么是buffers, windows和tabs，以及它们在Vim中如何工作。</p><p>在开始之前，确保您的vimrc文件中开启了<code>set hidden</code>选项。若没有配置该选项，当您想切换buffer且当前buffer没有保存时，Vim将提示您保存文件（如果您想快速切换，您不会想要这个提示）。我目前还没有讲vimrc，如果您没有vimrc配置文件，那就创建一个。它通常位于根目录下，名字叫<code>.vimrc</code>。我的vimrc位于<code>~/.vimrc</code>。要查看您自己的vimrc文件应该放置在哪，可以在Vim命令模式中输入<code>:h vimrc</code>。在vimrc文件中，添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set hidden</span><br></pre></td></tr></table></figure><p>保存好vimrc文件，然后激活它(在vimrc文件中运行<code>:source %</code>)。</p><h2 id="buffers"><a class="markdownIt-Anchor" href="#buffers"></a> Buffers</h2><p><em>buffer</em>到底是什么？</p><p>buffer就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers。</p><p>创建两个可使用的空文件，分别名为<code>file1.js</code>和<code>file2.js</code>（如果可能，尽量使用Vim来创建）。在终端中运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file1.js</span><br></pre></td></tr></table></figure><p>这时您看到的是<code>file1.js</code>的 <em>buffer</em> 。每当您打开一个新文件，Vim总是会创建一个新的buffer。</p><p>退出Vim。这一次，打开两个新文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file1.js file2.js</span><br></pre></td></tr></table></figure><p>Vim当前显示的是<code>file1.js</code>的buffer，但它实际上创建了两个buffers：<code>file1.js</code>buffer和<code>file2.js</code>buffer。运行<code>:buffers</code>命令可以查看所有的buffers（另外，您也可以使用<code>:ls</code>和<code>:files</code>命令）。您应该会 <em>同时</em> 看到列出来的<code>file1.js</code>和<code>file2.js</code>。运行<code>vim file1 file2 file3 ... filen</code>创建n个buffers。每一次您打开一个新文件，Vim就为这个文件创建一个新的buffer。</p><p>要遍历所有buffers，有以下几种方法：</p><ul><li><code>:bnext</code> 切换至下一个buffer（<code>:bprevious</code>切换至前一个buffer）。</li><li><code>:buffer</code> + 文件名。（按下<code>&lt;Tab&gt;</code>键Vim会自动补全文件名）。</li><li><code>:buffer</code> + <code>n</code>, n是buffer的编号。比如，输入<code>:buffer 2</code>将使您切换到buffer #2。</li><li>按下<code>Ctrl-O</code>将跳转至跳转列表中旧的位置，对应的，按下<code>Ctrl-I</code>将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转。我将在第5章详细讲述关于跳转的知识。</li><li>按下<code>Ctrl-^</code>跳转至先前编辑过的buffer。</li></ul><p>一旦Vim创建了一个buffer，它将保留在您的buffers列表中。若想删除它，您可以输入<code>:bdelete</code>。这条命令也可以接收一个buffer编号（<code>:bdelete 3</code>将删除buffer #3）或一个文件名（<code>:bdelete</code>然后按<code>&lt;Tab&gt;</code>自动补全文件名）。</p><p>我学习buffer时最困难的事情就是理解buffer如何工作，因为我当时的思维已经习惯了使用主流文本编辑器时关于窗口的概念。要理解buffer，可以打个很好的比方，就是打牌的桌面。如果您有2个buffers，就像您有一叠牌（2张）。您只能看见顶部的牌，虽然您知道在它下面还有其他的牌。如果您看见<code>file1.js</code>buffer，那么<code>file1.js</code>就是顶部的牌。虽然您看不到其他的牌<code>file2.js</code>，但它实际上就在那。如果您切换buffers到<code>file2.js</code>，那么<code>file2.js</code>这张牌就换到了顶部，而<code>file1.js</code>就换到了底部。</p><p>如果您以前没有用过Vim，这是一个新的概念。花上几分钟理解一下。</p><h2 id="退出vim"><a class="markdownIt-Anchor" href="#退出vim"></a> 退出Vim</h2><p>顺带说一句，如果您已经打开了多个buffers，您可以使用quit -all来关闭所有的buffers：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall</span><br></pre></td></tr></table></figure><p>如果您想关闭所有buffers但不保存，仅需要在后面加<code>!</code>（叹号）就行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall!</span><br></pre></td></tr></table></figure><p>若要保存所有buffers然后退出，请运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wqall</span><br></pre></td></tr></table></figure><h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2><p>一个window就是在buffer上的一个视口。如果您使用过主流的编辑器，Windows这个概念应该很熟悉。大部分文本编辑器具有显示多个窗口的能力。在Vim中，您同样可以拥有多个窗口。</p><p>让我们从终端再次打开<code>file1.js</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file1.js</span><br></pre></td></tr></table></figure><p>先前我说过，您看到的是<code>file1.js</code>的buffer。但这个说法并不完整，现在这句话得更正一下，您看到的是<code>file1.js </code>的buffer通过 <strong>一个窗口</strong> 显示出来。窗口就是您查看的buffer所使用的视口。</p><p>先不忙急着退出Vim，在Vim中运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:split file2.js</span><br></pre></td></tr></table></figure><p>现在您看到的是两个buffers通过 <strong>两个窗口</strong> 显示出来。上面的窗口显示的是<code>file2.js</code>的buffer。而下面的窗口显示的是<code>file1.js</code>的buffer。</p><p>如果您想在窗口之间导航，使用这些快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-W H    移动光标到左边的窗口</span><br><span class="line">Ctrl-W J    移动光标到下面的窗口</span><br><span class="line">Ctrl-W K    移动光标到上面的窗口</span><br><span class="line">Ctrl-W L    移动光标到右边的窗口</span><br></pre></td></tr></table></figure><p>现在，在Vim中运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vsplit file3.js</span><br></pre></td></tr></table></figure><p>您现在看到的是三个窗口显示三个buffers。一个窗口显示<code>file3.js</code>的buffer，一个窗口显示<code>file2.js</code>的buffer，还有一个窗口显示<code>file1.js</code>的buffer。</p><p>您可以使多个窗口显示同一个buffer。当光标位于左上方窗口时，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:buffer file2.js</span><br></pre></td></tr></table></figure><p>现在两个窗口显示的都是<code>file2.js</code>的buffer。如果您现在在这两个窗口中的某一个输入内容，您会看到所有显示<code>file2.js</code>buffer的窗口都在实时更新。</p><p>要关闭当前的窗口，您可以按<code>Ctrl-W C</code>或输入<code>:quit</code>。当您关闭一个窗口后，buffers仍然会在列表中。（可以运行<code>:buffers</code>来确认这一点）。</p><p>这里有一些普通模式下关于窗口的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-W V    打开一个新的垂直分割的窗口</span><br><span class="line">Ctrl-W S    打开一个新的水平分割的窗口</span><br><span class="line">Ctrl-W C    关闭一个窗口</span><br><span class="line">Ctrl-W O    除了当前窗口，关闭所有其他的窗口</span><br></pre></td></tr></table></figure><p>另外，下面的列表列出了一些有用的关于windows的命令行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:vsplit filename    垂直分割当前窗口，并在新窗口中打开名为filename的文件。</span><br><span class="line">:split filename     水平分割当前窗口，并在新窗口中打开名为filename的文件。</span><br><span class="line">:new filename       创建一个新窗口并打开名为filename的文件。</span><br></pre></td></tr></table></figure><p>花一点时间理解上面的知识。要了解更多信息，可以查看帮助<code>:h window</code>。</p><h2 id="tabs"><a class="markdownIt-Anchor" href="#tabs"></a> Tabs</h2><p>Tabs就是windows的集合。它就像窗口的布局。在大部分的现代文本编辑器（还有现代互联网浏览器）中，一个tab意味着打开一个文件/页面，当您关闭标签，相应的文件/页面就消失了。但在Vim中，tab并不表示打开了一个文件。当您在Vim中关闭一个tab，您并不是关闭一个文件。您仅仅关闭了窗口布局。文件的数据依然存储在内存中的buffers中。</p><p>让我们运行几个命令看看Vim中tabs的功能。打开<code>file1.js</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file1.js</span><br></pre></td></tr></table></figure><p>若要在新tab中打开<code>file2.js</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tabnew file2.js</span><br></pre></td></tr></table></figure><p>当然您可以按<code>&lt;Tab&gt;</code>让Vim自动补全 <em>新tab</em> 中将要打开的文件名（啰嗦几句，请理解作者的幽默 ）。</p><p>下面的列表列出了一些有用的关于tab导航的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:tabnew file.txt    在tab中打开一个文件</span><br><span class="line">:tabclose           关闭当前tab</span><br><span class="line">:tabnext            切换至下一个tab</span><br><span class="line">:tabprevious        切换至前一个tab</span><br><span class="line">:tablast            切换至最后一个tab</span><br><span class="line">:tabfirst           切换至第一个tab</span><br></pre></td></tr></table></figure><p>您可以输入<code>gt</code>切换到下一个标签页（对应的，可以用<code>gT</code>切换到前一个标签页）。您也可以传递一个数字作为参数给<code>gt</code>，这个数字是tab的编号。若想切换到第3个tab，输入<code>3gt</code>。</p><p>拥有多个tabs的好处是，您可以在不同的tab中使用不同的窗口布局。也许，您想让您的第1个tab包含3个垂直分割的窗口，然后让第2个tab为水平分割和垂直分割混合的窗口布局。tab是完成这件工作的完美工具!</p><p>若想让Vim启动时就包含多个tabs，您可以在终端中运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -p file1.js file2.js file3.js</span><br></pre></td></tr></table></figure><h2 id="三维移动"><a class="markdownIt-Anchor" href="#三维移动"></a> 三维移动</h2><p>在windows之间移动就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动。您可以使用<code>Ctrl-W H/J/K/L</code>移动到上面、右侧、下面、以及左侧的窗口。</p><p>在buffer之间移动就像在笛卡尔坐标系的Z轴上穿梭。想象您的buffer文件在Z轴上呈线性排列，您可以使用<code>:bnext</code>和<code>bprevious</code>在Z轴上一次一个buffer地遍历。您也可以使用<code>:buffer 文件名/buffer编号</code>在Z轴上跳转到任意坐标。</p><p>结合window和buffer的移动，您可以在 <em>三维空间</em> 中移动。您可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）。因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）。</p><h2 id="用聪明的方法使用buffers-windows-以及tabs"><a class="markdownIt-Anchor" href="#用聪明的方法使用buffers-windows-以及tabs"></a> 用聪明的方法使用Buffers、Windows、以及Tabs</h2><p>您已经学习了什么是buffers、windows、以及tabs，也学习了它们如何在Vim中工作。现在您对它们有了更好地理解，您可以把它们用在您自己的工作流程中。</p><p>每个人都有不同的工作流程，以下示例是我的工作流程：</p><ul><li>首先，对于某个特定任务，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。</li><li>当比对文件、读文档、或追踪代码流时，我使用多窗口来一次查看多个buffers。我尽量保持屏幕上的窗口数不超过3个，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。</li><li>我使用<a href="https://github.com/tmux/tmux/wiki">tmux</a>windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。</li></ul><p>由于编辑风格不同，我的工作流程可能和您的工作流程不同，这没关系。您可以在实践中去探索适合您自己工作流程的编码风格。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/d7470566/">Ch 1 - 起步</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/32c07678/">Ch 3 - 打开和搜索文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch01-起步</title>
      <link href="/posts/d7470566.html"/>
      <url>/posts/d7470566.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><p>在本章，您将了解从终端启动Vim的几种不同方法。我写这本教程时使用的Vim版本是8.2。如果您使用Neovim或老版本的Vim，大部分情况下方法是通用的，但注意个别命令可能无效。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>我不会给出在某台特定机器上安装Vim的详细指令。好消息是，大部分Unix-based电脑应该预装了Vim。如果没有，大部分发行版也应该有关于如何安装Vim的指令。</p><p>从Vim的官方网站或官方仓库可以获得下载链接：</p><ul><li><a href="https://www.vim.org/download.php">Vim 官网</a></li><li><a href="https://github.com/vim/vim">Vim 官方仓库</a></li><li><a href="https://hub.fastgit.org/vim/vim">Vim 官方仓库镜像</a></li></ul><h2 id="vim命令"><a class="markdownIt-Anchor" href="#vim命令"></a> Vim命令</h2><p>当您安装好Vim后，在终端运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br></pre></td></tr></table></figure><p>您应该会看到一个介绍界面。这就是您用来处理文本的工作区。不像其它大部分文本编辑器和IDE，Vim是一个模式编辑器。如果您想输入&quot;hello&quot;，您需要使用’i’命令切换到插入模式。按下’ihello<Esc>'可以在工作区插入文本&quot;hello&quot;。</p><h2 id="退出vim"><a class="markdownIt-Anchor" href="#退出vim"></a> 退出Vim</h2><p>有好几种不同的方法都可以退出Vim。（译者注：在stackflow论坛上，有个著名的问题“如何退出Vim”，五年来，有超过100万开发者遇到相同的问题。<sup>_</sup>，这件事已经成为了开发者中的一个梗）。最常用的退出方法是在Vim中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:quit</span><br></pre></td></tr></table></figure><p>您可以使用简写<code>:q</code>。这是一个命令行模式的命令(command-line mode：Vim的另一种模式)。如果您在普通模式输入<code>:</code>，光标将移动到屏幕底部，在这里您可以输入命令。在后面的第15章，您会学到关于命令行模式更多信息。如果您处于插入模式，按下<code>:</code>将会在屏幕上直接显示&quot;:&quot;(冒号)。因此，您需要按下<code>&lt;Esc&gt;</code>键切换回普通模式。顺带说一下，在命令行模式也可以通过按<code>&lt;Esc&gt;</code>键切换回普通模式。您将会注意到，在Vim的好几种模式下都可以通过按<code>&lt;Esc&gt;</code>键切回普通模式。</p><h2 id="保存文件"><a class="markdownIt-Anchor" href="#保存文件"></a> 保存文件</h2><p>若要保存您的修改，在Vim中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:write</span><br></pre></td></tr></table></figure><p>您也可以输入简写’:w’。如果这是一个新建的文件，您必须给出文件名才能保存。下面的命令使文件保存为名为’file.txt’的文件，在Vim命令行运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w file.txt</span><br></pre></td></tr></table></figure><p>如果想保存并退出，可以将’:w’和’:q’命令联起来，在Vim命令行中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>如果想不保存修改而强制退出，可以在’:q’命令后加’!'（叹号）,在Vim命令行中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure><h2 id="帮助"><a class="markdownIt-Anchor" href="#帮助"></a> 帮助</h2><p>在本指南全文中，我将向您提及好几种Vim的帮助页面。您可以通过输入<code>:help &#123;命令&#125;</code>(<code>:h</code>是简写)进入相关命令的帮助文档。可以向<code>:h</code>命令传递主题、命令名作为参数。比如，如果想查询退出Vim的方法，在vim中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:h write-quit</span><br></pre></td></tr></table></figure><p>我是怎么知道应该搜索&quot;write-quit&quot;这个关键词的呢？实际上我也不知道，我仅仅只是输入’:h quit’，然后按<code>&lt;Tab&gt;</code>。Vim会自动显示相关联的关键词供用户选择。如果您需要查询一些信息，只需要输入<code>:h</code>后接关键词，然后按<code>&lt;Tab&gt;</code>。</p><h2 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h2><p>如果想在终端中使用Vim打开名为(‘hello1.txt’)，在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello1.txt</span><br></pre></td></tr></table></figure><p>可以一次打开多个文件，在终端中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello1.txt hello2.txt hello3.txt</span><br></pre></td></tr></table></figure><p>Vim会在不同的buffers中打开’hello1.txt’，‘hello2.txt’，‘hello3.txt’。在下一章您将学到关于buffers的知识。</p><h2 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h2><p>您可以在终端中向<code>vim</code>命令传递参数。</p><p>如果想查看Vim的当前版本，在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure><p>终端中将显示您当前Vim的版本和所有支持的特性，'+‘表示支持的特性，’-'表示不支持的特性。本教程中的一些操作需要您的Vim支持特定的特性。比如，在后面的章节中提到可以使用<code>:history</code>查看Vim的命令行历史记录。您的Vim必须包含<code>+cmdline_history</code>这一特性，这条命令才能正常使用。一般情况下，如果您通过主流的安装源下载Vim的话，您安装的Vim是支持所有特性的，</p><p>您在终端里做的很多事情都可以在Vim内部实现。比如，在Vim程序中也可以查看当前Vim版本，您可以运行下面的命令，在Vim中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:version</span><br></pre></td></tr></table></figure><p>如果您想打开<code>hello.txt</code>文件后迅速执行一条命令，您可以向<code>vim</code>传递一个<code>+&#123;cmd&#125;</code>选项。</p><p>在Vim中，您可以使用<code>:s</code>命令（<code>substitue</code>的缩写）替换文本。如果您想打开<code>hello.txt</code>后立即将所有的&quot;pancake&quot;替换成&quot;bagel&quot;，在终端中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +%s/pancake/bagel/g hello.txt</span><br></pre></td></tr></table></figure><p>该命令可以被叠加，在终端中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt</span><br></pre></td></tr></table></figure><p>Vim会将所有&quot;pancake&quot; 实例替换为&quot;bagel&quot;，然后将所有&quot;bagel&quot;替换为&quot;egg&quot;，然后将所有&quot;egg&quot;替换为&quot;donut&quot;（在后面的章节中您将学到如何替换）。</p><p>您同样可以使用<code>c</code>标志来代替<code>+</code>语法，在终端中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -c %s/pancake/bagel/g hello.txt</span><br><span class="line">vim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt</span><br></pre></td></tr></table></figure><h2 id="打开多个窗口"><a class="markdownIt-Anchor" href="#打开多个窗口"></a> 打开多个窗口</h2><p>您可以使用<code>o</code>和<code>O</code>选项使Vim打开后分别显示为水平或垂直分割的窗口。</p><p>若想将Vim打开为2个水平分割的窗口，在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o2</span><br></pre></td></tr></table></figure><p>若想将Vim打开为5个水平分割的窗口，在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o5</span><br></pre></td></tr></table></figure><p>若想将Vim打开为5个水平分割的窗口，并使前两个窗口显示<code>hello1.txt</code>和<code>hello2.txt</code>的内容，在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o5 hello1.txt hello2.txt</span><br></pre></td></tr></table></figure><p>若想将Vim打开为2个垂直分割的窗口、5个垂直分割的窗口、5个垂直分割窗口并显示2个文件，在终端中分别运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim -O2</span><br><span class="line">vim -O5</span><br><span class="line">vim -O5 hello1.txt hello2.txt</span><br></pre></td></tr></table></figure><h2 id="挂起"><a class="markdownIt-Anchor" href="#挂起"></a> 挂起</h2><p>如果您编辑时想将Vim挂起，您可以按下<code>Ctrl-z</code>。同样，您也可以使用<code>:stop</code>或<code>:suspend</code>命令达到相同的效果。若想从挂起状态返回，在终端中运行<code>fg</code>命令。</p><h2 id="聪明的启动vim"><a class="markdownIt-Anchor" href="#聪明的启动vim"></a> 聪明的启动Vim</h2><p>您可以向<code>vim</code>命令传递不同的选项(option)和标志(flag)，就像其他终端命令一样。其中一个选项是命令行命令（<code>+&#123;cmd&#125;</code>或<code>-c cmd</code>）。当您读完本教程学到更多命令后，看看您是否能将相应命令应用到Vim的启动中。同样，作为一个终端命令，您可以将<code>vim</code>命令和其他终端命令联合起来。比如，您可以将<code>ls</code>命令的输出重定向到Vim中编辑，命令是<code>ls -l | vim -</code>。</p><p>若要了解更多Vim终端命令，查看<code>man vim</code>。若要了解更多关于Vim编辑器的知识，继续阅读本教程，多使用<code>:help</code>命令。</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>上一部分 <a href="https://blog.ilyfikaros.com/posts/d25eff46/">Ch 0 - 请先阅读</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/e5aa9cfc/">Ch 2 - 缓冲区，窗口和选项卡</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ch00-请先阅读</title>
      <link href="/posts/d25eff46.html"/>
      <url>/posts/d25eff46.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><h2 id="为什么写这本教程"><a class="markdownIt-Anchor" href="#为什么写这本教程"></a> 为什么写这本教程</h2><p>有很多途径可以学习Vim:<code>vimtutor</code>就是一个很好的途径，另外还有Vim自带的帮助手册（<code>:help</code>查看）包含了所有需要的参考信息。</p><p>但是在日常使用中，对于绝大部分用户的需求而言，<code>vimtutor</code>讲得太浅不能满足需要，而<code>:help</code>所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。</p><p>绝大部分情况下，您并不会使用到Vim100%的功能。您可能仅仅需要掌握其中20%就可以成为一名娴熟的Vim用户。本指南将为您展示Vim中最有用的功能。</p><p>本指南带有作者强烈的个人观点。它涵盖了作者在使用Vim的过程中经常用到的技巧。章节按照作者认为的，最适合初学者最符合逻辑的顺序排列。</p><p>本指南包含大量示例。当学习一个新技能时，示例是不可缺少的，大量的示例可以更有效的巩固所学概念。</p><p>部分读者可能好奇为什么要学习Vimscript？我刚使用Vim时，仅仅满足于知道如何使用Vim。随着时间推移，我越来越需要使用Vimscript去写一些自定义命令，以满足特殊的编辑需要。在您使用Vim的过程中，您早晚会接触Vimscript。所以为什么不早点学呢？Vimscript是一门小巧的脚本语言，仅需要本指南的四个章节，您就可以学到它的基础知识。</p><p>您当然可以继续使用Vim而不了解任何Vimscript知识，但了解它可以使您更加擅长Vim。</p><p>本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。</p><h2 id="如何从其他编辑器过渡到vim"><a class="markdownIt-Anchor" href="#如何从其他编辑器过渡到vim"></a> 如何从其他编辑器过渡到Vim</h2><p>学习Vim的过程虽然很困难,但很具有成就感。有两种方法去学习Vim：</p><ol><li>强制转换地使用Vim</li><li>循序渐进地使用Vim</li></ol><p>强制转换为Vim意味着从现在开始只使用Vim，停止使用您以前使用的任何编辑器/IDE。本方法的缺点是在前一周或两周，您将面临编辑效率的严重下降。如果您是一名专职程序员，本方法可能不太行得通。这也是为什么对于大部分读者而言，我认为过渡到Vim最好是循序渐进地使用Vim。</p><p>想要循序渐进地使用Vim，应该在最开始的两个星期，每天花1个小时使用Vim作为您的编辑器，而剩下的时间您可以继续使用其他编辑器。许多现代编辑器都带有Vim插件。我刚开始时，每天花1个小时使用VSCode的Vim插件。逐渐地，我增加使用Vim插件的时间，直到最终完全使用Vim插件。记住，这些插件仅仅模拟了Vim中的一小部分功能。要想体验Vim中比如Vimscript、命令行命令（Ex模式）、以及外部集成命令的强大功能，您必须使用Vim自身。</p><p>有两个关键节点驱使我开始100%地使用Vim：一是当我理解到Vim命令的语法结构（看第4章）时。二是学会<a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>插件时（看第3章）。</p><p>第一个，当我了解了Vim命令的语法结构时。这是一个决定性时间节点，我终于理解了Vim用户以前讨论的是什么。我并不需要去学习上百个命令，而仅需要学习一小部分命令，然后就可以凭直觉将它们串起来去做很多事情。</p><p>第二个，fzf插件我经常使用，该插件具有类似IDE的模糊文件查找功能。当我学会在Vim中如何使用该功能时，我的编辑效率极大提升，从此再也回不去了。</p><p>尽管每一个程序都是不同的。但仔细一想，您会发现您所偏爱的编辑器/IDE总有1个或2个功能是您频繁使用的。也许是模糊查找，也许是跳转至定义，或是快速编译，但不管是什么，快速确认这些功能，然后学会如何在Vim中实现它们（一般情况下Vim都能办到）。您的编辑速度将会获得一个巨大的提高。</p><p>当您使用Vim可以达到您原来50%的效率时，就是时候完全使用Vim了。</p><h2 id="如何阅读本指南"><a class="markdownIt-Anchor" href="#如何阅读本指南"></a> 如何阅读本指南</h2><p>本指南注重实效性。为了更好地在Vim中工作，您需要锻炼您的肌肉记忆，而不是大脑理解。</p><p>想学会骑自行车，您并不需要首先阅读一本骑车教程。您需要做的是骑上一辆真正的自行车，然后在实践中探索。</p><p>您需要输入每一条本指南中提到的命令。不仅如此，您还需要不断地重复，然后尝试命令的不同联合方式。想了解您刚学到命令具有什么功能，<code>:help</code>命令和搜索引擎是您最好的帮手。但您的目标并不是去掌握关于一条命令的全部信息，而是能够本能地、自然地使用该命令。</p><p>我本想尽可能地使本指南的知识点呈线性化展示，但有些概念还是不得不违反顺序。比如在第1章，我就提到了替换命令（<code>:s</code>），这个知识点要到第12章才讲。作为补救，不管是什么概念，如果被提前讲到了，我将为它提供一个简短的说明，原谅我吧。</p><h2 id="更多帮助"><a class="markdownIt-Anchor" href="#更多帮助"></a> 更多帮助</h2><p>关于Vim帮助手册有一个额外的小技巧：假设您想了解关于<code>Ctrl-p</code>在插入模式时的功能。如果您仅仅查找<code>:h CTRL-P</code>，您将被导航到普通模式下关于<code>Ctrl-P</code>的介绍页面，这并不是您想要的信息。在这种情况下，改为查找<code>:h i_CTRL-P</code>。添加的<code>i_</code>表示插入模式。注意它属于哪个模式。</p><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><p>大部分命令或涉及的代码片段都使用代码样式（<code>like this</code>）。</p><p>字符串使用双引号包括（“like this”）。</p><p>Vim命令可以使用简写。比如，<code>:join</code>可以简写为<code>:j</code>。本指南全文中，我将混合使用简写和全称。对于本指南不经常使用的命令，我将使用全称。而对于经常使用的命令，我将使用简写。我为这不一致性道歉。总之，不管什么时候当您看到一个新命令，记得使用<code>:help</code>查看它的简写。</p><h2 id="vimrc"><a class="markdownIt-Anchor" href="#vimrc"></a> Vimrc</h2><p>在本指南的很多地方，我将提到vimrc选项。如果您是初学者，可以把vimrc看做一个配置文件。</p><p>Vimrc直到第21章才讲。为了保持清晰，我将在这里简要的介绍如何配置Vimrc。</p><p>假设您需要设置number选项，即显示行号(<code>set number</code>)。如果您还没有vimrc文件，就创建一个。它通常位于根目录，名字为<code>.vimrc</code>。根据您的操作系统，该位置可能不同。在macOS，我将它放在<code>~/.vimrc</code>。要查看您的vimrc文件应该放在哪里，查看<code>:h vimrc</code>。</p><p>在vimrc文件内，添加一行<code>set number</code>。保存(<code>:w</code>)，然后激活这一配置(<code>:source %</code>)。您将会在每一行的的左侧看到行号。</p><p>另外，如果您不想永久配置一个选项，您可以在Vim命令行使用<code>set</code>命令，输入<code>:set number</code>。这种方法的缺点是设置是临时的。当您关闭Vim，该配置选项将消失。</p><p>因为我们学的是Vim而不是Vi，有一个设置您必须启用，这就是<code>nocompatible</code>选项。在您的vimrc文件中添加<code>set nocompatible</code>。如果启用<code>compatible</code>选项，许多Vim特有的功能将会被禁止。</p><p>一般而言，不管什么时候只要有一段内容涉及vimrc选项，只需要将该选项添加到vimrc中就好了，然后保存并激活相关选项。</p><h2 id="未来计划错误问题"><a class="markdownIt-Anchor" href="#未来计划错误问题"></a> 未来计划，错误，问题</h2><p>期待未来有更多的更新。如果您发现任何错误或有什么疑问，请随意提交。</p><p>我计划近期再发布一些更新章节，敬请关注。</p><h2 id="更多关于vim的技巧"><a class="markdownIt-Anchor" href="#更多关于vim的技巧"></a> 更多关于Vim的技巧</h2><p>要了解Vim更多的信息，请关注我的推特（需墙）。<a href="https://twitter.com/learnvim">@learnvim</a>.</p><h2 id="感谢"><a class="markdownIt-Anchor" href="#感谢"></a> 感谢</h2><p>感谢Bram Moleenar编写了Vim，没有Vim就不会有本指南。感谢我的妻子当我编写本指南时表现的耐心和支持。感谢所有的贡献者<a href="https://github.com/iggredible/Learn-Vim/graphs/contributors">contributors</a>，感谢Vim社区，还有很多其他没有提及的人们。</p><p>谢谢，您们使得这件工作更加有趣。😃</p><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><ul><li><a href="https://blog.ilyfikaros.com/posts/284cf1bb/">目录</a></li><li>下一部分 <a href="https://blog.ilyfikaros.com/posts/d7470566/">Ch 1 - 起步</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn-Vim中文目录</title>
      <link href="/posts/284cf1bb.html"/>
      <url>/posts/284cf1bb.html</url>
      
        <content type="html"><![CDATA[<h3 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h3><blockquote><p><font color=red>本文搬运自Github仓库<a href="https://github.com/wsdjeg/Learn-Vim_zh_cn" target="_blank">Learn-Vim_zh_cn</a>，并针对部分错别字做出修正。</font></p></blockquote><h3 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h3><ul><li><a href="https://blog.ilyfikaros.com/posts/d25eff46/">Ch 0 - 请先阅读</a></li></ul><h3 id="第一部分聪明地学习vim"><a class="markdownIt-Anchor" href="#第一部分聪明地学习vim"></a> 第一部分：聪明地学习Vim</h3><ul><li><a href="https://blog.ilyfikaros.com/posts/d7470566/">Ch 1 - 起步</a></li><li><a href="https://blog.ilyfikaros.com/posts/e5aa9cfc/">Ch 2 - 缓冲区，窗口和选项卡</a></li><li><a href="https://blog.ilyfikaros.com/posts/32c07678/">Ch 3 - 打开和搜索文件</a></li><li><a href="https://blog.ilyfikaros.com/posts/0584a475/">Ch 4 - Vim 语法</a></li><li><a href="https://blog.ilyfikaros.com/posts/25eb02e8/">Ch 5 - 移动文件</a></li><li><a href="https://blog.ilyfikaros.com/posts/f92aab20/">Ch 6 - 插入模式</a></li><li><a href="https://blog.ilyfikaros.com/posts/83932852/">Ch 7 - 点命令</a></li><li><a href="https://blog.ilyfikaros.com/posts/49130c49/">Ch 8 - 寄存器</a></li><li><a href="https://blog.ilyfikaros.com/posts/7e0645cb/">Ch 9 - 宏</a></li><li><a href="https://blog.ilyfikaros.com/posts/49fd3ee8/">Ch 10 - 撤消</a></li><li><a href="https://blog.ilyfikaros.com/posts/ba239799/">Ch 11 - 可视模式</a></li><li><a href="https://blog.ilyfikaros.com/posts/36365707/">Ch 12 - 搜索和替换</a></li><li><a href="https://blog.ilyfikaros.com/posts/fbe80173/">Ch 13 - 全局命令</a></li><li><a href="https://blog.ilyfikaros.com/posts/e58db16f/">Ch 14 - 外部命令</a></li><li><a href="https://blog.ilyfikaros.com/posts/d3de6571/">Ch 15 - 命令行模式</a></li><li><a href="https://blog.ilyfikaros.com/posts/514bd033/">Ch 16 - 标签</a></li><li><a href="https://blog.ilyfikaros.com/posts/d7f38bdd/">Ch 17 - 折叠</a></li><li><a href="https://blog.ilyfikaros.com/posts/a575da65/">Ch 18 - Git</a></li><li><a href="https://blog.ilyfikaros.com/posts/520a0cad/">Ch 19 - 编译</a></li><li><a href="https://blog.ilyfikaros.com/posts/26a705fd/">Ch 20 - 视图、会话和 Viminfo</a></li><li><a href="https://blog.ilyfikaros.com/posts/0783c3af/">Ch 21 - 多文件操作</a></li></ul><h3 id="第二部分聪明地定制vim"><a class="markdownIt-Anchor" href="#第二部分聪明地定制vim"></a> 第二部分：聪明地定制Vim</h3><ul><li><a href="https://blog.ilyfikaros.com/posts/29ce7871/">Ch 22 - Vimrc</a></li><li><a href="https://blog.ilyfikaros.com/posts/ad9bd3e0/">Ch 23 - Vim软件包</a></li><li><a href="https://blog.ilyfikaros.com/posts/2d5c14f7/">Ch 24 - Vim Runtime</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> Learn-Vim(the Smart Way) 中文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++输出数据</title>
      <link href="/posts/c8b934ee.html"/>
      <url>/posts/c8b934ee.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo自带markdown渲染器渲染括号问题</title>
      <link href="/posts/ee62c796.html"/>
      <url>/posts/ee62c796.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-问题发现"><a class="markdownIt-Anchor" href="#一-问题发现"></a> 一、问题发现</h2><p>Hexo是一个基于Node.js的静态网页博客框架，使用Markdown文档生成网页文章，对程序员比较友好。笔者前段时间使用Hexo搭建博客，使用一段时间后发现其生成的文章，存在括号内的内容为网址时会变成乱码超链接的现象，影响阅读体验。<br />笔者搭建博客时<strong>Node.js</strong>的版本为<em>12.19.0</em>，<strong>hexo-cli</strong>的版本为<em>4.3.0</em>，经过上网搜索和排除博客安装的插件影响后依旧无法解决问题。在重装博客之后，笔者立即进行测试，发现问题依旧存在。笔者之前曾在CSDN和自己Wodrpress网站上发布过相同的Markdown格式的文章，均未出现此类问题，于是怀疑是Hexo自带的Markdown渲染器的问题，在先后尝试修改文章格式和更换Markdown渲染插件等方法后，解决了该问题。</p><h2 id="二-问题描述"><a class="markdownIt-Anchor" href="#二-问题描述"></a> 二、问题描述</h2><p>Hexo原生自带的渲染器为<strong>hexo-renderer-marked</strong>，笔者在重装博客之后，立即进行了如下测试：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;test&quot;    <span class="variable">%新建测试文档test.md，并填入测试内容%</span></span><br><span class="line"></span><br><span class="line">hexo cl; hexo s         <span class="variable">%启动服务器，观察结果%</span></span><br></pre></td></tr></table></figure><p>test.md的正文内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">中文括号：</span><br><span class="line">括号后跟空格（www.baidu.com） 内容为网址</span><br><span class="line">括号后不跟空格（www.baidu.com）内容为网址</span><br><span class="line">括号后跟空格（你好） 内容为文字</span><br><span class="line">括号后不跟空格（你好）内容为文字</span><br><span class="line"></span><br><span class="line">英文括号：</span><br><span class="line">Parentheses followed by spaces(www.bing.com) The content is the URL</span><br><span class="line">The parentheses are not followed by spaces(www.bing.com)The content is the URL</span><br><span class="line">Parentheses followed by spaces(www.bing.com) The content is text</span><br><span class="line">Parentheses are not followed by spaces(www.bing.com)The content is text</span><br></pre></td></tr></table></figure><p>网页显示结果如下：<br /><img src="https://bimg.ilyfikaros.com/img/1.png" alt="" /></p><p>括号内的内容为英文网址时，如果括号直接跟文字，会出现尾部右括号连同文字一起被渲染成乱码超链接的现象。并且在右括号为中文括号的情况下，无论右括号后是否带空格，右括号都会被编入超链接形成乱码网址。</p><h2 id="三-解决方式"><a class="markdownIt-Anchor" href="#三-解决方式"></a> 三、解决方式</h2><h3 id="1修改文章格式禁止渲染不推荐"><a class="markdownIt-Anchor" href="#1修改文章格式禁止渲染不推荐"></a> 1.修改文章格式禁止渲染（不推荐）</h3><p>笔者在网上搜寻解决Markdown渲染问题的信息时，大致找到两种方案，都不太靠谱。<br />一是可以禁止渲染部分Markdown文档的内容。如下图所示，添加一个禁止渲染的代码将出问题的部分给包起来，或者添加双冒号。由于笔者不了解前端，尝试该方法并不奏效；<br /><img src="https://bimg.ilyfikaros.com/img/2.png" alt="" /></p><p>二是参考Hexo官方<a href="https://hexo.io/zh-cn/api/rendering.html">文档</a>，设置博客根目录下的<code>_config.yml</code>配置文件的<code>skip_render</code>参数，使渲染器不渲染指定文章。</p><h3 id="2更换markdown渲染器推荐"><a class="markdownIt-Anchor" href="#2更换markdown渲染器推荐"></a> 2.更换Markdown渲染器（推荐）</h3><p>除了Hexo自带的Markdown渲染器之外，Hexo常用的Markdown渲染器还有hexo-renderer-kramed，hexo-renderer-pandoc，hexo-renderer-markdown-it以及hexo-renderer-markdown-it-plus。笔者经过一番尝试之后选择了hexo-renderer-markdown-it-plus，避免了原始渲染器的问题。<br />更换渲染器方式如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked -—save  <span class="variable">%卸载Hexo自带渲染插件%</span></span><br><span class="line">npm i hexo-renderer-markdown-it-plus -—save <span class="variable">%安装目标插件%</span></span><br></pre></td></tr></table></figure><p>更换渲染器之后，参照该插件的NPM<a href="https://www.npmjs.com/package/hexo-renderer-markdown-it-plus">文档</a>，在本地博客根目录的<code>_config.yml</code>文件底部添加如下参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown_it_plus:</span></span><br><span class="line">    <span class="attr">highlight:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">langPrefix:</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">“”‘’</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">markdown-it-mark</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>更换渲染器插件后，输入<code>hexo cl</code>以及<code>hexo s</code>重启项目，问题解决<br /><img src="https://bimg.ilyfikaros.com/img/3.png" alt="" /></p><h2 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h2><p>Ling星轨迹原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：Ling星轨迹（<a href="http://www.ilyfikaros.com">www.ilyfikaros.com</a>）<br />作者：凌亦零</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务基础</title>
      <link href="/posts/ac1033c5.html"/>
      <url>/posts/ac1033c5.html</url>
      
        <content type="html"><![CDATA[<h2 id="事务的提出"><a class="markdownIt-Anchor" href="#事务的提出"></a> 事务的提出</h2><p>MySQL事务（transaction）主要用于处理敏感的、复杂度高的数据。处理逻辑为query语句要么一块执行，要么全部回滚。例如网上购物时，只有确认付款之后商品才会到个人账户，在此之前全部过程顾客不持有商品。<br />注意：MySQL事务只有在指定数据库引擎为innodb时可用。</p><h2 id="事务的基本用法"><a class="markdownIt-Anchor" href="#事务的基本用法"></a> 事务的基本用法</h2><p>假设用户A向用户B转账50块钱，则需要将A用户的账户余额减少50块钱，将B用户的账户添加50块钱，操作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;# 开始事务</span><br><span class="line"><span class="keyword">update</span> wallet <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="number">-50</span>;</span><br><span class="line"># query语句错误，未写条件</span><br><span class="line"><span class="keyword">rollback</span>;# 进行回滚，撤回错误<span class="keyword">sql</span>语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">update</span> wallet <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="number">-50</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> wallet <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">50</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;# 提交事务</span><br><span class="line"># 注意：事务开启可以随时<span class="keyword">rollback</span>，一旦<span class="keyword">commit</span>，就不能再<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><p>回滚点rollback to</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;      # 开始事务</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> wallet <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">savepoint</span> four;         # 设置事务回滚点</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> wallet <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">199999</span>);</span><br><span class="line"><span class="keyword">savepoint</span> five;</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> four;</span><br><span class="line"># 回滚到回滚点four之前的事务，回滚点four之后的操作将被丢弃</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h2 id="事务的特性"><a class="markdownIt-Anchor" href="#事务的特性"></a> 事务的特性</h2><p>事务的四大特性，简称ACID</p><ul><li>A：atomicity，原子性，事务的所有操作为一个整体，不可再分，要么全部执行，要么全部不执行。</li><li>C：consistency，一致性，事务开始前或结束后，数据库所有的数据都应该是正确完整。</li><li>I：isolation，隔离性，每个事务都是独立的。</li><li>D：durability，持久性，事务一旦提交，不能再更改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL视图基础</title>
      <link href="/posts/1801a1aa.html"/>
      <url>/posts/1801a1aa.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是视图"><a class="markdownIt-Anchor" href="#什么是视图"></a> 什么是视图</h2><p>视图相当于从副表中创建的一个虚拟的表，它可以筛选数据，隐藏表的结构，防止有关业务人员看到敏感数据。<br />例如：可以针对社会保险基金表创建视图，显示姓名地址，不显示社会保险号和工资。</p><h2 id="view视图创建-使用"><a class="markdownIt-Anchor" href="#view视图创建-使用"></a> view视图创建、使用</h2><ol><li>创建视图<br />格式：</li></ol><blockquote><p>create view vw_视图名 as<br />query语句</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> vw_stu <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> name, phone <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用视图<br />视图作为虚表，其使用和表的query相同。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vw_stu;</span><br></pre></td></tr></table></figure><ol start="3"><li>显示视图</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;                # 显示数据库中的表或视图</span><br><span class="line"><span class="keyword">desc</span> vw_stu;                # 显示视图结构</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> vw_stu;    # 显示视图的创建过程</span><br><span class="line"></span><br><span class="line"># 显示表格详细属性，一般用不到此语句</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">where</span> comment <span class="operator">=</span> <span class="string">&#x27;view&#x27;</span> <span class="operator">|</span> G;</span><br></pre></td></tr></table></figure><ol start="4"><li>更新和删除视图<br />操作与表操作相当。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改并查看修改后的视图</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> vw_stu <span class="keyword">as</span> <span class="keyword">select</span> name <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vw_stu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> vw_stu;       # 删除视图</span><br></pre></td></tr></table></figure><ol start="5"><li>视图算法<br />应用场景：查询视图用了子查询时;<br />分类：temptable（临时表）, merge（合并）, undefined（缺省值，不使用算法）<br />语法：create algorithm = temptable view as + query语句</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL子查询</title>
      <link href="/posts/9da3e761.html"/>
      <url>/posts/9da3e761.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是子查询"><a class="markdownIt-Anchor" href="#什么是子查询"></a> 什么是子查询</h2><p>子查询是一条循环中嵌套着一条查询，类似于递归。</p><h2 id="子查询基本语法"><a class="markdownIt-Anchor" href="#子查询基本语法"></a> 子查询基本语法</h2><p>查询学生表中成绩高于85分的学生信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> (<span class="keyword">select</span> stuid <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="operator">&gt;=</span> <span class="number">85</span>)</span><br><span class="line"># 注意：查询条件表达式处用<span class="operator">=</span>时，只能接受子查询中返回一条记录</span><br></pre></td></tr></table></figure><h2 id="子查询常用关键字"><a class="markdownIt-Anchor" href="#子查询常用关键字"></a> 子查询常用关键字</h2><ol><li>in和not in</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id [<span class="keyword">not</span>] <span class="keyword">in</span>(<span class="keyword">select</span> stuid <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="operator">&gt;=</span> <span class="number">85</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>exists和not exists</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> studnet <span class="keyword">where</span> id [<span class="keyword">not</span>] <span class="keyword">exists</span>(<span class="keyword">select</span> stuid <span class="keyword">from</span> scre <span class="keyword">where</span> score <span class="operator">&gt;=</span> <span class="number">85</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL多表查询</title>
      <link href="/posts/dc3b805.html"/>
      <url>/posts/dc3b805.html</url>
      
        <content type="html"><![CDATA[<p>MySQL多表查询的主要关键字。</p><h2 id="union联合查询"><a class="markdownIt-Anchor" href="#union联合查询"></a> union联合查询</h2><p>作用：在一条查询语句中进行多个查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> age, gender <span class="keyword">from</span> info <span class="keyword">all</span><span class="operator">/</span><span class="keyword">distinct</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;name&#x27;</span>, phone <span class="keyword">from</span> teacher</span><br><span class="line"># <span class="keyword">all</span>默认自带且省略，<span class="keyword">distinct</span>自加，用于去重</span><br></pre></td></tr></table></figure><h2 id="inner-join内连接"><a class="markdownIt-Anchor" href="#inner-join内连接"></a> inner join内连接</h2><p>inner join即内连接，要分清表的主次，主键对应外键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score <span class="keyword">from</span> student innner <span class="keyword">join</span> score <span class="keyword">on</span> student.id <span class="operator">=</span> score.stuid</span><br></pre></td></tr></table></figure><p>inner join注意事项：</p><ol><li>多表查询以相同的公共字段作为基准查询；</li><li>其中一个表没有的则不统计。</li></ol><h2 id="left-join左连接"><a class="markdownIt-Anchor" href="#left-join左连接"></a> left join左连接</h2><p>左连接就是以左表某字段为基准，左边的必须要有，右边的可以为空，类似于军训向……看齐排队。<br />作用：防止空数据不统计。</p><h2 id="right-join右连接"><a class="markdownIt-Anchor" href="#right-join右连接"></a> right join右连接</h2><p>类似于左连接，以右表字段为基准。</p><h2 id="cross-join交叉连接"><a class="markdownIt-Anchor" href="#cross-join交叉连接"></a> cross join交叉连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">cross</span> <span class="keyword">join</span> t3 <span class="keyword">where</span> t1.id  <span class="operator">=</span> t2.id</span><br><span class="line"># 没有<span class="keyword">where</span>及之后内容为笛卡尔积，有相当于内连接</span><br></pre></td></tr></table></figure><h2 id="natural-join自然连接"><a class="markdownIt-Anchor" href="#natural-join自然连接"></a> natural join自然连接</h2><p>select * from t1 natural join t3<br />自然连接会<strong>自动</strong>根据两表的<strong>公共字段</strong>连接（前提：两张表的公共字段（属性）名相同），没有的字段会自动填充。<br />内连接无公共同名字段的自然连接返回笛卡尔积</p><h2 id="using"><a class="markdownIt-Anchor" href="#using"></a> using</h2><p>作用：有多个公共字段时指定以某个字段连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t3 <span class="keyword">using</span>(id)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL单表查询</title>
      <link href="/posts/11952da.html"/>
      <url>/posts/11952da.html</url>
      
        <content type="html"><![CDATA[<p>MySQL单表查询主要关键字。</p><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;内容/实体&#x27;</span> (<span class="keyword">as</span>) 字段名<span class="operator">/</span>属性#<span class="keyword">as</span> 取别名用</span><br></pre></td></tr></table></figure><h2 id="from"><a class="markdownIt-Anchor" href="#from"></a> from</h2><p>from ???来自哪张表<br />多表查询结果是笛卡尔积</p><h2 id="dual伪表"><a class="markdownIt-Anchor" href="#dual伪表"></a> dual(伪表)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">2</span><span class="operator">*</span><span class="number">7</span> (<span class="keyword">as</span>) res <span class="keyword">from</span> dual;</span><br><span class="line"># 等价于</span><br><span class="line"><span class="keyword">select</span> <span class="number">2</span><span class="operator">*</span><span class="number">7</span> (<span class="keyword">as</span>) res</span><br></pre></td></tr></table></figure><h2 id="where筛选"><a class="markdownIt-Anchor" href="#where筛选"></a> where(筛选)</h2><p>符号：&lt; &lt;= &gt;= = ……</p><h2 id="in"><a class="markdownIt-Anchor" href="#in"></a> in</h2><p>in(‘’), not in(‘’)等价于 = 和!=</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t4 <span class="keyword">where</span> address <span class="keyword">in</span>(<span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Shanghai&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="betweenand"><a class="markdownIt-Anchor" href="#betweenand"></a> between…and</h2><p>where age &gt;= 15 and age &lt;= 20等价于where age between 15 and 20</p><h2 id="is-null"><a class="markdownIt-Anchor" href="#is-null"></a> is null</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h2 id="聚合函数自带函数"><a class="markdownIt-Anchor" href="#聚合函数自带函数"></a> 聚合函数（自带函数）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(chinese) <span class="keyword">from</span> score</span><br></pre></td></tr></table></figure><p>函数：</p><blockquote><p>sum()<br />avg()<br />max()<br />min()<br />count()注意谨慎使用count(*)</p></blockquote><h2 id="like模糊查询"><a class="markdownIt-Anchor" href="#like模糊查询"></a> like模糊查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;高_&#x27;</span>;</span><br><span class="line"># <span class="operator">%</span>匹配多个字符，_匹配单个字符</span><br></pre></td></tr></table></figure><h2 id="order-by排序查询"><a class="markdownIt-Anchor" href="#order-by排序查询"></a> order by排序查询</h2><p>ascend 升华 descend 下降</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> chinese <span class="keyword">asc</span>;   # <span class="keyword">asc</span>升序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> chinese <span class="keyword">desc</span>;  # <span class="keyword">desc</span>降序</span><br></pre></td></tr></table></figure><h2 id="group-by分组查询"><a class="markdownIt-Anchor" href="#group-by分组查询"></a> group by分组查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">as</span> <span class="string">&#x27;年龄&#x27;</span>, gender <span class="keyword">as</span> <span class="string">&#x27;性别’ from info group by gender;</span></span><br></pre></td></tr></table></figure><h2 id="group_concat聚合查询信息"><a class="markdownIt-Anchor" href="#group_concat聚合查询信息"></a> group_concat(聚合查询信息)</h2><p>group_concat 将查询结果中同组的name组合在一起</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(name), gender <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br></pre></td></tr></table></figure><h2 id="having"><a class="markdownIt-Anchor" href="#having"></a> having</h2><p>having，在已经筛选的结果中再次筛选</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(age) <span class="keyword">as</span> <span class="string">&#x27;年龄&#x27;</span>, address <span class="keyword">as</span> <span class="string">&#x27;地区&#x27;</span> <span class="keyword">from</span> info <span class="keyword">group</span> <span class="keyword">by</span> address <span class="keyword">having</span> age <span class="operator">&gt;</span> <span class="number">24</span>;</span><br></pre></td></tr></table></figure><h2 id="limit"><a class="markdownIt-Anchor" href="#limit"></a> limit</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> info <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">desc</span> limit <span class="number">3</span></span><br><span class="line"># limit x, y x：开始位置，y：长度</span><br><span class="line"># limit x x：开始位置</span><br></pre></td></tr></table></figure><h2 id="distinct去重"><a class="markdownIt-Anchor" href="#distinct去重"></a> distinct(去重)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="keyword">from</span> info</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL数据库操作</title>
      <link href="/posts/742c6695.html"/>
      <url>/posts/742c6695.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中采用connection和sqlstatement类操作PostgreSQL数据库。</p><p>类的声明文件是freecplus/db/postgresql/_postgresql.h。</p><p>类的定义文件是freecplus/db/postgresql/_postgresql.cpp。</p><p>示例程序位于freecplus/db/postgresql目录中。</p><p>编译规则文件是freecplus/db/postgresql/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍PostgreSQL数据库、SQL语言和C/C<ins>的基础知识，您应该是一个职业的C/C</ins>程序员，在阅读本文之前，您已经掌握了PostgreSQL数据库和SQL语言的基础知识。</p><p>freecplus框架把PostgreSQL提供的库函数封装成了connection和sqlstatement类，采用封装后的类操作PostgreSQL数据库，代码简洁优雅，性能卓越。</p><p>接下来我先列出connection和sqlstatement类的声明，然后通过流程图和示例程序介绍它位的用法。</p><h1 id="三-connection类"><a class="markdownIt-Anchor" href="#三-connection类"></a> 三、connection类</h1><p>PostgreSQL数据库连接connection类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PostgreSQL数据库连接池类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库的连接状态，0-未连接，1-已连接。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 数据库操作的结果或最后一次执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">connection</span>();        <span class="comment">// 构造函数。</span></span><br><span class="line"> ~<span class="built_in">connection</span>();        <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库。</span></span><br><span class="line">  <span class="comment">// connstr：数据库的登录参数，格式：&quot;host= user= password= dbname= port=&quot;,</span></span><br><span class="line">  <span class="comment">// 例如：&quot;host=172.16.0.15 user=qxidc password=qxidcpwd dbname=qxidcdb port=5432&quot;</span></span><br><span class="line">  <span class="comment">// username-登录的用户名，password-登录的密码，dbname-缺省数据库，port-mysql服务的端口。</span></span><br><span class="line">  <span class="comment">// charset：数据库的字符集，如&quot;gbk&quot;，必须与数据库保持一致，否则会出现中文乱码的情况。</span></span><br><span class="line">  <span class="comment">// autocommitopt：是否启用自动提交，0-不启用，1-启用，缺省是不启用。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connecttodb</span><span class="params">(<span class="type">char</span> *connstr,<span class="type">char</span> *charset,<span class="type">unsigned</span> <span class="type">int</span> autocommitopt=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回滚事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与数据库的连接。</span></span><br><span class="line">  <span class="comment">// 注意，断开与数据库的连接时，全部未提交的事务自动回滚。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="comment">// 在connection类中提供了execute方法，是为了方便程序员，在该方法中，也是用sqlstatement类来完成功能。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-sqlstatement类"><a class="markdownIt-Anchor" href="#四-sqlstatement类"></a> 四、sqlstatement类</h1><p>PostgreSQL数据库的SQL语句操作sqlstatement类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作SQL语句类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sqlstatement</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库连接池的绑定状态，0-未绑定，1-已绑定。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sqlstatement</span>();      <span class="comment">// 构造函数。</span></span><br><span class="line">  <span class="built_in">sqlstatement</span>(connection *conn);    <span class="comment">// 构造函数，同时绑定数据库连接池。</span></span><br><span class="line"> ~<span class="built_in">sqlstatement</span>();      <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定数据库连接池。</span></span><br><span class="line">  <span class="comment">// conn：数据库连接池connection对象的地址。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，只要conn参数是有效的，并且数据库的游标资源足够，connect方法不会返回失败。</span></span><br><span class="line">  <span class="comment">// 程序员一般不必关心connect方法的返回值。</span></span><br><span class="line">  <span class="comment">// 注意，每个sqlstatement只需要绑定一次，在绑定新的connection前，必须先调用disconnect方法。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(connection *conn)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消与数据库连接池的绑定。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备SQL语句。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要prepare一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">prepare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输入变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，必须与prepare方法中的SQL的序号一一对应。</span></span><br><span class="line">  <span class="comment">// value：输入变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输入变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindin一次就可以了，2）绑定输入变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输出变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，与SQL的结果集一一对应。</span></span><br><span class="line">  <span class="comment">// value：输出变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输出变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindout一次就可以了，2）绑定输出变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从结果集中获取一条记录。</span></span><br><span class="line">  <span class="comment">// 如果执行的SQL语句是查询语句，调用execute方法后，会产生一个结果集（存放在数据库的缓冲区中）。</span></span><br><span class="line">  <span class="comment">// next方法从结果集中获取一条记录，把字段的值放入已绑定的输出变量中。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，1403-结果集已无记录，其它-失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 返回失败的原因主要有两个：1）与数据库的连接已断开；2）绑定输出变量的内存太小。</span></span><br><span class="line">  <span class="comment">// 每执行一次next方法，m_cda.rpc的值加1。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查next方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-程序流程"><a class="markdownIt-Anchor" href="#五-程序流程"></a> 五、程序流程</h1><p>freecplus框架把对PostgreSQL数据库操作的SQL语句分为两种：有结果集的SQL语句和无结果集的SQL语句。</p><p>如果SQL语句被执行后，有结果集的产生，称为有结果集的SQL，即数据查询语言DQL，以select关键字，各种简单查询，连接查询等都属于DQL。</p><p>如果SQL语句被执行后，没有结果集的产生，称为无结果集的SQL，包括数据定义语言DDL（主要是create、drop和alter）和数据操纵语言DML（insert、update和insert）。</p><p>也可以这么说，查询的SQL语句会产生结果集，其它的SQL语句不会产生结果集。</p><h2 id="1-无结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#1-无结果集sql的程序的流程"></a> 1、无结果集SQL的程序的流程</h2><p>这是一个完程的流程，在实际开发中，如果是执行简单的SQL语句，第6步和第7步可能不需要，如果SQL语句只执行一次，第7步和第8步之间的循环也不需要。</p><h2 id="2-有结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#2-有结果集sql的程序的流程"></a> 2、有结果集SQL的程序的流程</h2><p>这是一个完程的流程，在实际开发中，如果是执行简单的查询语句，第6步、第7步和第8步可能不需要，如果结果集中最多只有一条记录，第10步和第11步之间的循环也不需要。</p><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-创建超女信息表"><a class="markdownIt-Anchor" href="#1-创建超女信息表"></a> 1、创建超女信息表</h2><p><strong>示例（createtable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：createtable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（创建表）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接池。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备创建表的SQL语句。</span></span><br><span class="line">  <span class="comment">// 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    create table girls(id    int,\</span></span><br><span class="line"><span class="string">                       name  varchar(30),\</span></span><br><span class="line"><span class="string">                       weight   numeric(8,2),\</span></span><br><span class="line"><span class="string">                       btime timestamp,\</span></span><br><span class="line"><span class="string">                       memo  text,\</span></span><br><span class="line"><span class="string">                       pic   bytea,\</span></span><br><span class="line"><span class="string">                       primary key (id))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，在postgresql数据库中，创建表也要提交事务，和Oracle、MySQL数据库不同。</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;create table girls ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200313103450414.png" alt="在这里插入图片描述" /></p><h2 id="2-向超女表中插入5条记录"><a class="markdownIt-Anchor" href="#2-向超女表中插入5条记录"></a> 2、向超女表中插入5条记录</h2><p><strong>示例（inserttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：inserttable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（向表中插入5条记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">11</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ssi&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    insert into girls(id,name,weight,btime) \</span></span><br><span class="line"><span class="string">                values(:1,:2,:3,to_date(:4,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>, stgirls.name,<span class="number">10</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟超女数据，向表中插入5条测试信息。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体变量的成员赋值。</span></span><br><span class="line">    stgirls.id=ii;                                 <span class="comment">// 超女编号。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(stgirls.name,<span class="string">&quot;超女%02d&quot;</span>,ii);           <span class="comment">// 超女姓名。</span></span><br><span class="line">    stgirls.weight=ii*<span class="number">2.11</span>;                        <span class="comment">// 超女体重。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stgirls.btime,<span class="string">&quot;2018-03-01 12:25:31&quot;</span>);   <span class="comment">// 报名时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">    <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功插入了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); <span class="comment">// stmt.m_cda.rpc是本次执行SQL影响的记录数。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;insert table girls ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>(); <span class="comment">// 提交数据库事务。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200313103547395.png" alt="在这里插入图片描述" /></p><h2 id="3-更新超女表中的记录"><a class="markdownIt-Anchor" href="#3-更新超女表中的记录"></a> 3、更新超女表中的记录</h2><p><strong>示例（updatetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：updatetable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（修改表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbtime[<span class="number">20</span>];  <span class="comment">// 用于存放超女的报名时间。</span></span><br><span class="line">  <span class="built_in">memset</span>(strbtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strbtime,<span class="string">&quot;2019-12-20 09:45:30&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备更新数据的SQL语句，不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    update girls set btime=to_date(:1,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,strbtime,<span class="number">19</span>);</span><br><span class="line">  <span class="comment">// 如果不采用绑定输入变量的方法，把strbtime的值直接写在SQL语句中也是可以的，如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  stmt.prepare(&quot;\</span></span><br><span class="line"><span class="comment">    update girls set btime=to_date(&#x27;%s&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;,strbtime);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次更新了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103646373.png" alt="在这里插入图片描述" /></p><h2 id="4-查询超女表中的记录"><a class="markdownIt-Anchor" href="#4-查询超女表中的记录"></a> 4、查询超女表中的记录</h2><p><strong>示例（selecttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：selecttable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（查询表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">31</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ss&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iminid,imaxid;  <span class="comment">// 查询条件最小和最大的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    select id,name,weight,to_char(btime,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;iminid);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;imaxid);</span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stgirls.name,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  iminid=<span class="number">2</span>;  <span class="comment">// 指定待查询记录的最小id的值。</span></span><br><span class="line">  imaxid=<span class="number">4</span>;  <span class="comment">// 指定待查询记录的最大id的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 先把结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>() !=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把获取到的记录的值打印出来。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id=%ld,name=%s,weight=%.02f,btime=%s\n&quot;</span>,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103751844.png" alt="在这里插入图片描述" /></p><h2 id="5-查询超女表中的记录数"><a class="markdownIt-Anchor" href="#5-查询超女表中的记录数"></a> 5、查询超女表中的记录数</h2><p><strong>示例（counttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：counttable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（查询表中的记录数）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> icount=<span class="number">0</span>;  <span class="comment">// 用于存放查询结果的记录数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句，把查询条件直接写在SQL语句中，没有采用绑定输入变量的方法。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from girls where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;icount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="comment">// 但是，在本程序中，结果集永远只有一条记录，调用stmt.next()一次就行，不需要循环。</span></span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girls表中符合条件的记录数是%d。\n&quot;</span>,icount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103843434.png" alt="在这里插入图片描述" /></p><h2 id="7-删除超女表中的记录"><a class="markdownIt-Anchor" href="#7-删除超女表中的记录"></a> 7、删除超女表中的记录</h2><p><strong>示例（deletetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：deletetable.cpp，此程序演示freecplus框架操作PostgreSQL数据库（删除表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_postgresql.h&quot;</span>   <span class="comment">// freecplus框架操作PostgreSQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;host=172.16.0.15 user=postgres password=pwdidc dbname=postgres port=5432&quot;</span>,<span class="string">&quot;gbk&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果不需要绑定输入和输出变量，用stmt.execute()方法直接执行SQL语句，不需要stmt.prepare()。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>(<span class="string">&quot;delete from girls where id&gt;=2 and id&lt;=4&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次从girls表中删除了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200313103942977.png" alt="在这里插入图片描述" /></p><h2 id="8-与oracle的兼容性处理"><a class="markdownIt-Anchor" href="#8-与oracle的兼容性处理"></a> 8、与Oracle的兼容性处理</h2><p>在封装sqlstatement类的时候，为了与Oracle兼容，做了以下方面的处理：</p><p>1）在PostgreSQL中，绑定输入和输出变量采用的是&quot;$“，Oracle采用的是”:n&quot;（n表示变量的序号），在sqlstatement的prepare方法中，把&quot;:n&quot;替换成了&quot;$&quot;。</p><p>2）在PostgreSQL中，把字符串输换为日期时间的函数是to_timestamp，Oracle是to_date，在sqlstatement的prepare方法中，把to_date替换成to_timestamp。</p><p>4）PostgreSQL的sqlstatement类绑定输入或输出变量的最大数量缺省是256，在&quot;_mysql.h&quot;头文件中定义了MAXPARAMS宏，您可以根据实际需求修改它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行SQL语句前绑定输入或输出变量个数的最大值，256是很大的了，可以根据实际情况调整。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPARAMS  256</span></span><br></pre></td></tr></table></figure><p>5）sqlstatement类绑定输入或输出变量时，如果是字符串，最大长度缺省是2000，在&quot;_postgresql.h&quot;头文件中定义了MAXFIELDLENGTH宏，您可以根据实际需求修改它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果绑定输入或输出变量是字符串，指定字符串的最大长度，不包括字符串的结束符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFIELDLENGTH 2000</span></span><br></pre></td></tr></table></figure><h2 id="9-text和bytea字段的操作"><a class="markdownIt-Anchor" href="#9-text和bytea字段的操作"></a> 9、text和bytea字段的操作</h2><p>PostgreSQL提供的库函数支持对text和bytea字段的操作，本人的技术水平有限，找不到这方面的资料和示例程序，所以还没有封装对text和bytea字段的操作，希望各位能提供技术帮助，通过C语言技术网与我联系，我们共同完善freecplus框架，非常感谢。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>本文提供的示例程序看上去简单，实则很精妙，希望大家多多思考，慢慢体会。</p><p>为了让大家完全掌握connection和sqlstatement类的用法，我将录制freecplus框架的专题视频，请大家多关注C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）发布的内容。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库操作</title>
      <link href="/posts/f2cccc89.html"/>
      <url>/posts/f2cccc89.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中采用connection和sqlstatement类操作MySQL数据库。</p><p>类的声明文件是freecplus/db/mysql/_mysql.h。</p><p>类的定义文件是freecplus/db/mysql/_mysql.cpp。</p><p>示例程序位于freecplus/db/mysql目录中。</p><p>编译规则文件是freecplus/db/mysql/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍MySQL数据库、SQL语言和C/C<ins>的基础知识，您应该是一个职业的C/C</ins>程序员，在阅读本文之前，您已经掌握了MySQL数据库和SQL语言的基础知识。</p><p>freecplus框架把MySQL提供的库函数封装成了connection和sqlstatement类，采用封装后的类操作MySQL数据库，代码简洁优雅，性能卓越。</p><p>接下来我先列出connection和sqlstatement类的声明，然后通过流程图和示例程序介绍它位的用法。</p><h1 id="三-connection类"><a class="markdownIt-Anchor" href="#三-connection类"></a> 三、connection类</h1><p>MySQL数据库连接connection类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySQL数据库连接池类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库的连接状态，0-未连接，1-已连接。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 数据库操作的结果或最后一次执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">connection</span>();        <span class="comment">// 构造函数。</span></span><br><span class="line"> ~<span class="built_in">connection</span>();        <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库。</span></span><br><span class="line">  <span class="comment">// connstr：数据库的登录参数，格式：&quot;ip,username,password,dbname,port&quot;，</span></span><br><span class="line">  <span class="comment">// 例如：&quot;172.16.0.15,qxidc,qxidcpwd,qxidcdb,3306&quot;。</span></span><br><span class="line">  <span class="comment">// charset：数据库的字符集，如&quot;gbk&quot;，必须与数据库保持一致，否则会出现中文乱码的情况。</span></span><br><span class="line">  <span class="comment">// autocommitopt：是否启用自动提交，0-不启用，1-启用，缺省是不启用。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connecttodb</span><span class="params">(<span class="type">char</span> *connstr,<span class="type">char</span> *charset,<span class="type">unsigned</span> <span class="type">int</span> autocommitopt=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回滚事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与数据库的连接。</span></span><br><span class="line">  <span class="comment">// 注意，断开与数据库的连接时，全部未提交的事务自动回滚。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="comment">// 在connection类中提供了execute方法，是为了方便程序员，在该方法中，也是用sqlstatement类来完成功能。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-sqlstatement类"><a class="markdownIt-Anchor" href="#四-sqlstatement类"></a> 四、sqlstatement类</h1><p>MySQL数据库的SQL语句操作sqlstatement类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作SQL语句类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sqlstatement</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库连接池的绑定状态，0-未绑定，1-已绑定。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sqlstatement</span>();      <span class="comment">// 构造函数。</span></span><br><span class="line">  <span class="built_in">sqlstatement</span>(connection *conn);    <span class="comment">// 构造函数，同时绑定数据库连接池。</span></span><br><span class="line"> ~<span class="built_in">sqlstatement</span>();      <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定数据库连接池。</span></span><br><span class="line">  <span class="comment">// conn：数据库连接池connection对象的地址。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，只要conn参数是有效的，并且数据库的游标资源足够，connect方法不会返回失败。</span></span><br><span class="line">  <span class="comment">// 程序员一般不必关心connect方法的返回值。</span></span><br><span class="line">  <span class="comment">// 注意，每个sqlstatement只需要绑定一次，在绑定新的connection前，必须先调用disconnect方法。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(connection *conn)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消与数据库连接池的绑定。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备SQL语句。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要prepare一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">prepare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输入变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，必须与prepare方法中的SQL的序号一一对应。</span></span><br><span class="line">  <span class="comment">// value：输入变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输入变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindin一次就可以了，2）绑定输入变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输出变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，与SQL的结果集一一对应。</span></span><br><span class="line">  <span class="comment">// value：输出变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输出变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：1）如果SQL语句没有改变，只需要bindout一次就可以了，2）绑定输出变量的总数不能超过256个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从结果集中获取一条记录。</span></span><br><span class="line">  <span class="comment">// 如果执行的SQL语句是查询语句，调用execute方法后，会产生一个结果集（存放在数据库的缓冲区中）。</span></span><br><span class="line">  <span class="comment">// next方法从结果集中获取一条记录，把字段的值放入已绑定的输出变量中。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，1403-结果集已无记录，其它-失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 返回失败的原因主要有两个：1）与数据库的连接已断开；2）绑定输出变量的内存太小。</span></span><br><span class="line">  <span class="comment">// 每执行一次next方法，m_cda.rpc的值加1。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查next方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-程序流程"><a class="markdownIt-Anchor" href="#五-程序流程"></a> 五、程序流程</h1><p>freecplus框架把对MySQL数据库操作的SQL语句分为两种：有结果集的SQL语句和无结果集的SQL语句。</p><p>如果SQL语句被执行后，有结果集的产生，称为有结果集的SQL，即数据查询语言DQL，以select关键字，各种简单查询，连接查询等都属于DQL。</p><p>如果SQL语句被执行后，没有结果集的产生，称为无结果集的SQL，包括数据定义语言DDL（主要是create、drop和alter）和数据操纵语言DML（insert、update和insert）。</p><p>也可以这么说，查询的SQL语句会产生结果集，其它的SQL语句不会产生结果集。</p><h2 id="1-无结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#1-无结果集sql的程序的流程"></a> 1、无结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/20200309082338243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这是一个完程的流程，在实际开发中，如果是执行简单的SQL语句，第6步和第7步可能不需要，如果SQL语句只执行一次，第7步和第8步之间的循环也不需要。</p><h2 id="2-有结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#2-有结果集sql的程序的流程"></a> 2、有结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/2020030908265352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这是一个完程的流程，在实际开发中，如果是执行简单的查询语句，第6步、第7步和第8步可能不需要，如果结果集中最多只有一条记录，第10步和第11步之间的循环也不需要。</p><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-创建超女信息表"><a class="markdownIt-Anchor" href="#1-创建超女信息表"></a> 1、创建超女信息表</h2><p><strong>示例（createtable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：createtable.cpp，此程序演示freecplus框架操作MySQL数据库（创建表）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备创建表的SQL语句。</span></span><br><span class="line">  <span class="comment">// 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    create table girls(id    bigint(10),\</span></span><br><span class="line"><span class="string">                       name  varchar(30),\</span></span><br><span class="line"><span class="string">                       weight   decimal(8,2),\</span></span><br><span class="line"><span class="string">                       btime datetime,\</span></span><br><span class="line"><span class="string">                       memo  longtext,\</span></span><br><span class="line"><span class="string">                       pic   longblob,\</span></span><br><span class="line"><span class="string">                       primary key (id))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;create table girls ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030908291445.png" alt="在这里插入图片描述" /></p><h2 id="2-向超女表中插入5条记录"><a class="markdownIt-Anchor" href="#2-向超女表中插入5条记录"></a> 2、向超女表中插入5条记录</h2><p><strong>示例（inserttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：inserttable.cpp，此程序演示freecplus框架操作MySQL数据库（向表中插入5条记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">11</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ssi&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    insert into girls(id,name,weight,btime) \</span></span><br><span class="line"><span class="string">              values(:1,:2,:3,str_to_date(:4,&#x27;%%Y-%%m-%%d %%h:%%i:%%s&#x27;))&quot;</span>);</span><br><span class="line">  <span class="comment">// 也可以用以下一行代码代替上面这行代码，兼容oracle数据库。</span></span><br><span class="line">  <span class="comment">//            values(:1,:2,:3,to_date(:4,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;);</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>, stgirls.name,<span class="number">10</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟超女数据，向表中插入5条测试信息。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体变量的成员赋值。</span></span><br><span class="line">    stgirls.id=ii;                                 <span class="comment">// 超女编号。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(stgirls.name,<span class="string">&quot;超女%02d&quot;</span>,ii);           <span class="comment">// 超女姓名。</span></span><br><span class="line">    stgirls.weight=ii*<span class="number">2.11</span>;                        <span class="comment">// 超女体重。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stgirls.btime,<span class="string">&quot;2018-03-01 12:25:31&quot;</span>);   <span class="comment">// 报名时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">    <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功插入了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); <span class="comment">// stmt.m_cda.rpc是本次执行SQL影响的记录数。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;insert table girls ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>(); <span class="comment">// 提交数据库事务。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083127849.png" alt="在这里插入图片描述" /></p><h2 id="3-更新超女表中的记录"><a class="markdownIt-Anchor" href="#3-更新超女表中的记录"></a> 3、更新超女表中的记录</h2><p><strong>示例（updatetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：updatetable.cpp，此程序演示freecplus框架操作MySQL数据库（修改表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbtime[<span class="number">20</span>];  <span class="comment">// 用于存放超女的报名时间。</span></span><br><span class="line">  <span class="built_in">memset</span>(strbtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strbtime,<span class="string">&quot;2019-12-20 09:45:30&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备更新数据的SQL语句，不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    update girls set btime=str_to_date(:1,&#x27;%%Y-%%m-%%d %%h:%%i:%%s&#x27;) where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// 也可以用以下一行代码代替上面这行代码，兼容oracle数据库。</span></span><br><span class="line">  <span class="comment">//  update girls set btime=to_date(:1,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;);</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,strbtime,<span class="number">19</span>);</span><br><span class="line">  <span class="comment">// 如果不采用绑定输入变量的方法，把strbtime的值直接写在SQL语句中也是可以的，如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  stmt.prepare(&quot;\</span></span><br><span class="line"><span class="comment">    update girls set btime=to_date(&#x27;%s&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;,strbtime);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次更新了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083318523.png" alt="在这里插入图片描述" /></p><h2 id="4-查询超女表中的记录"><a class="markdownIt-Anchor" href="#4-查询超女表中的记录"></a> 4、查询超女表中的记录</h2><p><strong>示例（selecttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：selecttable.cpp，此程序演示freecplus框架操作MySQL数据库（查询表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">31</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ss&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iminid,imaxid;  <span class="comment">// 查询条件最小和最大的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    select id,name,weight,date_format(btime,&#x27;%%Y-%%m-%%d %%h:%%i:%%s&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;</span>);</span><br><span class="line">  <span class="comment">// 也可以用以下一行代码代替上面这行代码，兼容oracle数据库。</span></span><br><span class="line">  <span class="comment">// select id,name,weight,to_char(btime,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;);</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;iminid);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;imaxid);</span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stgirls.name,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  iminid=<span class="number">2</span>;  <span class="comment">// 指定待查询记录的最小id的值。</span></span><br><span class="line">  imaxid=<span class="number">4</span>;  <span class="comment">// 指定待查询记录的最大id的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 先把结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>() !=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把获取到的记录的值打印出来。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id=%ld,name=%s,weight=%.02f,btime=%s\n&quot;</span>,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083459644.png" alt="在这里插入图片描述" /></p><h2 id="5-查询超女表中的记录数"><a class="markdownIt-Anchor" href="#5-查询超女表中的记录数"></a> 5、查询超女表中的记录数</h2><p><strong>示例（counttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：counttable.cpp，此程序演示freecplus框架操作MySQL数据库（查询表中的记录数）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> icount=<span class="number">0</span>;  <span class="comment">// 用于存放查询结果的记录数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句，把查询条件直接写在SQL语句中，没有采用绑定输入变量的方法。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from girls where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;icount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="comment">// 但是，在本程序中，结果集永远只有一条记录，调用stmt.next()一次就行，不需要循环。</span></span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girls表中符合条件的记录数是%d。\n&quot;</span>,icount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030908364949.png" alt="在这里插入图片描述" /></p><h2 id="7-删除超女表中的记录"><a class="markdownIt-Anchor" href="#7-删除超女表中的记录"></a> 7、删除超女表中的记录</h2><p><strong>示例（deletetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：deletetable.cpp，此程序演示freecplus框架操作MySQL数据库（删除表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_mysql.h&quot;</span>   <span class="comment">// freecplus框架操作MySQL的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接池。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;172.16.0.15,root,123qweASD!@#,mysql,3306&quot;</span>,<span class="string">&quot;gbk&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果不需要绑定输入和输出变量，用stmt.execute()方法直接执行SQL语句，不需要stmt.prepare()。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>(<span class="string">&quot;delete from girls where id&gt;=2 and id&lt;=4&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次从girls表中删除了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200309083918867.png" alt="在这里插入图片描述" /></p><h2 id="8-与oracle的兼容性处理"><a class="markdownIt-Anchor" href="#8-与oracle的兼容性处理"></a> 8、与Oracle的兼容性处理</h2><p>在封装sqlstatement类的时候，为了与Oracle兼容，做了以下方面的处理：</p><p>1）在MySQL中，绑定输入和输出变量采用的是&quot;?“，Oracle采用的是”:n&quot;（n表示变量的序号），在sqlstatement的prepare方法中，把&quot;:n&quot;替换成了&quot;?&quot;。</p><p>2）在MySQL中，字符串与日期的转换函数是str_to_date和date_format，Oracle的转换函数是to_date和to_char，在sqlstatement的prepare方法中，把to_date替换成str_to_date，把to_char替换成date_format。</p><p>3）MySQL有时间格式是&quot;%Y-%m-%d %h:%i:%s&quot;，Oracle数据库是&quot;yyyy-mm-dd hh24:mi:ss&quot;，在sqlstatement的prepare方法中，把&quot;yyyy-mm-dd hh24:mi:ss&quot;替换成&quot;%Y-%m-%d %h:%i:%s&quot;。目前，只对&quot;%Y-%m-%d %h:%i:%s&quot;和&quot;%Y%m%d%h%i%s&quot;两个格式做了替换，如果需要对更多的格式做替换，请修改sqlstatement的prepare方法中的源代码。</p><p>4）MySQL的sqlstatement类绑定输入或输出变量的最大数量缺省是256，在&quot;_mysql.h&quot;头文件中定义了MAXPARAMS宏，您可以根据实际需求修改它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行SQL语句前绑定输入或输出变量个数的最大值，256是很大的了，可以根据实际情况调整。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPARAMS  256</span></span><br></pre></td></tr></table></figure><h2 id="9-longtext和longblob字段的操作"><a class="markdownIt-Anchor" href="#9-longtext和longblob字段的操作"></a> 9、longtext和longblob字段的操作</h2><p>MySQL提供的库函数支持对longtext和longblob字段的操作，本人的技术水平有限，找不到这方面的资料和示例程序，所以还没有封装对longtext和longblob字段的操作，希望各位能提供技术帮助，通过C语言技术网与我联系，我们共同完善freecplus框架，非常感谢。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>本文提供的示例程序看上去简单，实则很精妙，希望大家多多思考，慢慢体会。</p><p>为了让大家完全掌握connection和sqlstatement类的用法，我将录制freecplus框架的专题视频，请大家多关注C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）发布的内容。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库操作</title>
      <link href="/posts/a4264ce.html"/>
      <url>/posts/a4264ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中采用connection和sqlstatement类操作Oracle数据库。</p><p>类的声明文件是freecplus/db/oracle/_ooci.h。</p><p>类的定义文件是freecplus/db/oracle/_ooci.cpp。</p><p>示例程序位于freecplus/db/oracle目录中。</p><p>编译规则文件是freecplus/db/oracle/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍Oracle数据库、SQL语言和C/C<ins>的基础知识，您应该是一个职业的C/C</ins>程序员，在阅读本文之前，您已经掌握了Oracle数据库和SQL语言的基础知识。</p><p>Oracle数据库功能强大，性能卓越，无与伦比，并提供了数据访问接口OCI，OCI非常强大，强大到了普通C/C++程序员难以驾驭。</p><p>freecplus框架把OCI（Oracle Call Interface）封装成了connection和sqlstatement类，采用封装后的类操作Oracle数据库，代码简洁优雅，性能卓越。</p><p>接下来我先列出connection和sqlstatement类的声明，然后通过流程图和示例程序介绍它位的用法。</p><h1 id="三-connection类"><a class="markdownIt-Anchor" href="#三-connection类"></a> 三、connection类</h1><p>Oracle数据库连接池connection类的声明（程序员不必关心的私有成员和数据结构未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Oracle数据库连接池类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;       <span class="comment">// 与数据库的连接状态，0-未连接，1-已连接。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 数据库操作的结果或最后一次执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">connection</span>();    <span class="comment">// 构造函数。</span></span><br><span class="line"> ~<span class="built_in">connection</span>();    <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库。</span></span><br><span class="line">  <span class="comment">// connstr：数据库的登录参数，格式：username/password@tnsname，username-用户名，password-登录密</span></span><br><span class="line">  <span class="comment">// 码，tnsname-数据库的服务名，在$ORACLE_HOME/network/admin/tnsnames.ora文件中配置。</span></span><br><span class="line">  <span class="comment">// charset：数据库的字符集，必须与数据库保持一致，否则会出现中文乱码的情况。</span></span><br><span class="line">  <span class="comment">// autocommitopt：是否启用自动提交，0-不启用，1-启用，缺省是不启用。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connecttodb</span><span class="params">(<span class="type">char</span> *connstr,<span class="type">char</span> *charset,<span class="type">int</span> autocommitopt=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">commit</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回滚事务。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与数据库的连接。</span></span><br><span class="line">  <span class="comment">// 注意，断开与数据库的连接时，全部未提交的事务自动回滚。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="comment">// 在connection类中提供了execute方法，是为了方便程序员，在该方法中，也是用sqlstatement类来完成功能。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-sqlstatement类"><a class="markdownIt-Anchor" href="#四-sqlstatement类"></a> 四、sqlstatement类</h1><p>Oracle数据库的SQL语句操作sqlstatement类的声明（程序员不必关心的私有成员和数据结构未列出，对CLOB和BLOB字段操作的方法也未列出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作SQL语句类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sqlstatement</span></span><br><span class="line">&#123;</span><br><span class="line">  OCI_HANDLE m_handle; <span class="comment">// SQL句柄。</span></span><br><span class="line">  connection *m_conn;  <span class="comment">// 数据库连接池指针。</span></span><br><span class="line">  <span class="type">int</span> m_sqltype;       <span class="comment">// SQL语句的类型，0-查询语句；1-非查询语句。</span></span><br><span class="line">  <span class="type">int</span> m_autocommitopt; <span class="comment">// 自动提交标志，0-关闭；1-开启。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">err_report</span><span class="params">()</span></span>;   <span class="comment">// 错误报告。</span></span><br><span class="line"></span><br><span class="line">  OCILobLocator *m_lob;     <span class="comment">// 指向LOB字段的指针。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">alloclob</span><span class="params">()</span></span>;          <span class="comment">// 初始化lob指针。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">filetolob</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 把文件的内容导入到clob和blob字段中。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">lobtofile</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 从clob和blob字段中导出内容到文件中。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">freelob</span><span class="params">()</span></span>;           <span class="comment">// 释放lob指针。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_state;         <span class="comment">// 与数据库连接池的绑定状态，0-未绑定，1-已绑定。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> m_sql[<span class="number">10241</span>];   <span class="comment">// SQL语句的文本，最长不能超过10240字节。</span></span><br><span class="line"></span><br><span class="line">  CDA_DEF m_cda;       <span class="comment">// 执行SQL语句的结果。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sqlstatement</span>();      <span class="comment">// 构造函数。</span></span><br><span class="line">  <span class="built_in">sqlstatement</span>(connection *conn);    <span class="comment">// 构造函数，同时绑定数据库连接池。</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">sqlstatement</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定数据库连接池。</span></span><br><span class="line">  <span class="comment">// conn：数据库连接池connection对象的地址。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，只要conn参数是有效的，并且数据库的游标资源足够，connect方法不会返回失败。</span></span><br><span class="line">  <span class="comment">// 程序员一般不必关心connect方法的返回值。</span></span><br><span class="line">  <span class="comment">// 注意，每个sqlstatement只需要绑定一次，在绑定新的connection前，必须先调用disconnect方法。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(connection *conn)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消与数据库连接池的绑定。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备SQL语句。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要prepare一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">prepare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输入变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，必须与prepare方法中的SQL的序号一一对应。</span></span><br><span class="line">  <span class="comment">// value：输入变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输入变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要bindin一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindin</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定输出变量的地址。</span></span><br><span class="line">  <span class="comment">// position：字段的顺序，从1开始，与SQL的结果集一一对应。</span></span><br><span class="line">  <span class="comment">// value：输出变量的地址，如果是字符串，内存大小应该是表对应的字段长度加1。</span></span><br><span class="line">  <span class="comment">// len：如果输出变量的数据类型是字符串，用len指定它的最大长度，建议采用表对应的字段长度。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，程序员一般不必关心返回值。</span></span><br><span class="line">  <span class="comment">// 注意：如果SQL语句没有改变，只需要bindout一次就可以了。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">float</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bindout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> position,<span class="type">char</span>   *value,<span class="type">unsigned</span> <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行SQL语句。</span></span><br><span class="line">  <span class="comment">// 如果SQL语句不需要绑定输入和输出变量（无绑定变量、非查询语句），可以直接用此方法执行。</span></span><br><span class="line">  <span class="comment">// 参数说明：这是一个可变参数，用法与printf函数相同。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，其它失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中，</span></span><br><span class="line">  <span class="comment">// 如果成功的执行了非查询语句，在m_cda.rpc中保存了本次执行SQL影响记录的行数。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查execute方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从结果集中获取一条记录。</span></span><br><span class="line">  <span class="comment">// 如果执行的SQL语句是查询语句，调用execute方法后，会产生一个结果集（存放在数据库的缓冲区中）。</span></span><br><span class="line">  <span class="comment">// next方法从结果集中获取一条记录，把字段的值放入已绑定的输出变量中。</span></span><br><span class="line">  <span class="comment">// 返回值：0-成功，1403-结果集已无记录，其它-失败，失败的代码在m_cda.rc中，失败的描述在m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 返回失败的原因主要有两个：1）与数据库的连接已断开；2）绑定输出变量的内存太小。</span></span><br><span class="line">  <span class="comment">// 每执行一次next方法，m_cda.rpc的值加1。</span></span><br><span class="line">  <span class="comment">// 程序员必须检查next方法的返回值。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-程序流程"><a class="markdownIt-Anchor" href="#五-程序流程"></a> 五、程序流程</h1><p>freecplus框架把对Oracle数据库操作的SQL语句分为两种：有结果集的SQL语句和无结果集的SQL语句。</p><p>如果SQL语句被执行后，有结果集的产生，称为有结果集的SQL，即数据查询语言DQL，以select关键字，各种简单查询，连接查询等都属于DQL。</p><p>如果SQL语句被执行后，没有结果集的产生，称为无结果集的SQL，包括数据定义语言DDL（主要是create、drop和alter）和数据操纵语言DML（insert、update和insert）。</p><p>也可以这么说，查询的SQL语句会产生结果集，其它的SQL语句不会产生结果集。</p><h2 id="1-无结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#1-无结果集sql的程序的流程"></a> 1、无结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/20200306173529756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这是一个完程的流程，在实际开发中，如果是执行简单的SQL语句，第6步和第7步可能不需要，如果SQL语句只执行一次，第7步和第8步之间的循环也不需要。</p><h2 id="2-有结果集sql的程序的流程"><a class="markdownIt-Anchor" href="#2-有结果集sql的程序的流程"></a> 2、有结果集SQL的程序的流程</h2><p><img src="https://img-blog.csdnimg.cn/20200306173659630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />这是一个完程的流程，在实际开发中，如果是执行简单的查询语句，第6步、第7步和第8步可能不需要，如果结果集中最多只有一条记录，第10步和第11步之间的循环也不需要。</p><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-创建超女信息表"><a class="markdownIt-Anchor" href="#1-创建超女信息表"></a> 1、创建超女信息表</h2><p><strong>示例（createtable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：createtable.cpp，此程序演示freecplus框架操作Oracle数据库（创建表）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备创建表的SQL语句。</span></span><br><span class="line">  <span class="comment">// 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    create table girls(id    number(10),\</span></span><br><span class="line"><span class="string">                       name  varchar2(30),\</span></span><br><span class="line"><span class="string">                       weight   number(8,2),\</span></span><br><span class="line"><span class="string">                       btime date,\</span></span><br><span class="line"><span class="string">                       memo  clob,\</span></span><br><span class="line"><span class="string">                       pic   blob,\</span></span><br><span class="line"><span class="string">                       primary key (id))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;create table girls ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306173800310.png" alt="在这里插入图片描述" /></p><h2 id="2-向超女表中插入5条记录"><a class="markdownIt-Anchor" href="#2-向超女表中插入5条记录"></a> 2、向超女表中插入5条记录</h2><p><strong>示例（inserttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：inserttable.cpp，此程序演示freecplus框架操作Oracle数据库（向表中插入5条记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">11</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ssi&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    insert into girls(id,name,weight,btime) \</span></span><br><span class="line"><span class="string">                values(:1,:2,:3,to_date(:4,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>, stgirls.name,<span class="number">10</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟超女数据，向表中插入5条测试信息。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体变量的成员赋值。</span></span><br><span class="line">    stgirls.id=ii;                                 <span class="comment">// 超女编号。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(stgirls.name,<span class="string">&quot;超女%02d&quot;</span>,ii);           <span class="comment">// 超女姓名。</span></span><br><span class="line">    stgirls.weight=ii*<span class="number">2.11</span>;                        <span class="comment">// 超女体重。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stgirls.btime,<span class="string">&quot;2018-03-01 12:25:31&quot;</span>);   <span class="comment">// 报名时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">    <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功插入了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); <span class="comment">// stmt.m_cda.rpc是本次执行SQL影响的记录数。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;insert table girls ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>(); <span class="comment">// 提交数据库事务。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306174021361.png" alt="在这里插入图片描述" /></p><h2 id="3-更新超女表中的记录"><a class="markdownIt-Anchor" href="#3-更新超女表中的记录"></a> 3、更新超女表中的记录</h2><p><strong>示例（updatetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：updatetable.cpp，此程序演示freecplus框架操作Oracle数据库（修改表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbtime[<span class="number">20</span>];  <span class="comment">// 用于存放超女的报名时间。</span></span><br><span class="line">  <span class="built_in">memset</span>(strbtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strbtime,<span class="string">&quot;2019-12-20 09:45:30&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备更新数据的SQL语句，不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    update girls set btime=to_date(:1,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,strbtime,<span class="number">19</span>);</span><br><span class="line">  <span class="comment">// 如果不采用绑定输入变量的方法，把strbtime的值直接写在SQL语句中也是可以的，如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  stmt.prepare(&quot;\</span></span><br><span class="line"><span class="comment">    update girls set btime=to_date(&#x27;%s&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) where id&gt;=2 and id&lt;=4&quot;,strbtime);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次更新了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><h2 id="在这里插入图片描述4-查询超女表中的记录"><a class="markdownIt-Anchor" href="#在这里插入图片描述4-查询超女表中的记录"></a> <img src="https://img-blog.csdnimg.cn/20200306184713360.png" alt="在这里插入图片描述" /><br />4、查询超女表中的记录</h2><p><strong>示例（selecttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：selecttable.cpp，此程序演示freecplus框架操作Oracle数据库（查询表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girls</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> id;        <span class="comment">// 超女编号，用long数据类型对应Oracle无小数的number(10)。</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">31</span>];  <span class="comment">// 超女姓名，用char[31]对应Oracle的varchar2(30)。</span></span><br><span class="line">  <span class="type">double</span> weight;  <span class="comment">// 超女体重，用double数据类型对应Oracle有小数的number(8,2)。</span></span><br><span class="line">  <span class="type">char</span> btime[<span class="number">20</span>]; <span class="comment">// 报名时间，用char对应Oracle的date，格式：&#x27;yyyy-mm-dd hh24:mi:ss&#x27;。</span></span><br><span class="line">&#125; stgirls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> iminid,imaxid;  <span class="comment">// 查询条件最小和最大的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    select id,name,weight,to_char(btime,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;iminid);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;imaxid);</span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stgirls.name,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  iminid=<span class="number">2</span>;  <span class="comment">// 指定待查询记录的最小id的值。</span></span><br><span class="line">  imaxid=<span class="number">4</span>;  <span class="comment">// 指定待查询记录的最大id的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirls)); <span class="comment">// 先把结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>() !=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把获取到的记录的值打印出来。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id=%ld,name=%s,weight=%.02f,btime=%s\n&quot;</span>,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306184830196.png" alt="在这里插入图片描述" /></p><h2 id="5-查询超女表中的记录数"><a class="markdownIt-Anchor" href="#5-查询超女表中的记录数"></a> 5、查询超女表中的记录数</h2><p><strong>示例（counttable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：counttable.cpp，此程序演示freecplus框架操作Oracle数据库（查询表中的记录数）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> icount=<span class="number">0</span>;  <span class="comment">// 用于存放查询结果的记录数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句，把查询条件直接写在SQL语句中，没有采用绑定输入变量的方法。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from girls where id&gt;=2 and id&lt;=4&quot;</span>);</span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;icount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="comment">// 但是，在本程序中，结果集永远只有一条记录，调用stmt.next()一次就行，不需要循环。</span></span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girls表中符合条件的记录数是%d。\n&quot;</span>,icount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306184934579.png" alt="在这里插入图片描述" /></p><h2 id="7-删除超女表中的记录"><a class="markdownIt-Anchor" href="#7-删除超女表中的记录"></a> 7、删除超女表中的记录</h2><p><strong>示例（deletetable.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：deletetable.cpp，此程序演示freecplus框架操作Oracle数据库（删除表中的记录）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="comment">// 如果不需要绑定输入和输出变量，用stmt.execute()方法直接执行SQL语句，不需要stmt.prepare()。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>(<span class="string">&quot;delete from girls where id&gt;=2 and id&lt;=4&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次从girls表中删除了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306185024267.png" alt="在这里插入图片描述" /></p><h2 id="8-执行plsql过程"><a class="markdownIt-Anchor" href="#8-执行plsql过程"></a> 8、执行PL/SQL过程</h2><p><strong>示例（execplsql.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：execplsql.cpp，此程序演示freecplus框架操作Oracle数据库（执行PL/SQL过程）。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment"> *  说说我个人的看法，我从不在Oracle数据库中创建PL/SQL过程，也很少使用触发器，原因如下：</span></span><br><span class="line"><span class="comment"> *  1、在Oracle数据库中创建PL/SQL过程，程序的调试很麻烦；</span></span><br><span class="line"><span class="comment"> *  2、维护工作很麻烦，因为维护人员要花时间去了解数据库中的存储过程；</span></span><br><span class="line"><span class="comment"> *  3、采用freecplus框架操作Oracle已经是非常简单，没必要去折腾存储过程；</span></span><br><span class="line"><span class="comment"> *  4、PL/SQL过程可移植性不好，如果换成mysql或其它数据库，比较麻烦。</span></span><br><span class="line"><span class="comment"> *  还有，我在C/C++程序中很少用复杂的PL/SQL过程，因为复杂的PL/SQL调试麻烦。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_ooci.h&quot;</span>   <span class="comment">// freecplus框架操作Oracle的头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection conn; <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录数据库，返回值：0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_198&quot;</span>,<span class="string">&quot;Simplified Chinese_China.ZHS16GBK&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>; <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> id=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的PL/SQL语句，先删除girls表中的全部记录，再插入一条记录。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    BEGIN\</span></span><br><span class="line"><span class="string">      delete from girls;\</span></span><br><span class="line"><span class="string">      insert into girls(id,name,weight,btime)\</span></span><br><span class="line"><span class="string">                 values(:1,&#x27;超女过程&#x27;,55.65,to_date(&#x27;2018-01-02 13:00:55&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;));\</span></span><br><span class="line"><span class="string">    END;&quot;</span>);</span><br><span class="line">  <span class="comment">// 注意，PL/SQL中的每条SQL需要用分号结束，END之后还有一个分号。</span></span><br><span class="line">  <span class="comment">// prepare方法不需要判断返回值。</span></span><br><span class="line">  <span class="comment">// 为PL/SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;id);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exec PL/SQL ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交事务。</span></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306185127654.png" alt="在这里插入图片描述" /></p><h2 id="9-clob和blob字段的操作"><a class="markdownIt-Anchor" href="#9-clob和blob字段的操作"></a> 9、CLOB和BLOB字段的操作</h2><p>sqlstatement类还可以操作CLOB和BLOB字段，在实际开发中，这种需求不多，本文就不演示了，如果您在项目开发中有这方面的需求，可以参考demo程序，示例程序位于freecplus/db/oracle目录中，如下：</p><p>filetoclob.cpp：把文本文件存入数据表的CLOB字段。</p><p>clobtofile.cpp：把数据表CLOB字段中的内容导出到文本文件中。</p><p>filetoblob.cpp：把文本文件存入数据表的BLOB字段。</p><p>blobtofile.cpp：把数据表BLOB字段中的内容导出到文本文件中。</p><h1 id="八-应用经验"><a class="markdownIt-Anchor" href="#八-应用经验"></a> 八、应用经验</h1><p>freecplus框架的connection和sqlstatement类把OCI的强大功能充分的发挥了出来，且性能卓越。本文提供的示例程序看上去简单，实则很精妙，希望大家多多思考，慢慢体会。</p><p>为了让大家完全掌握connection和sqlstatement类的用法，我将录制freecplus框架的专题视频，请大家多关注C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）发布的内容。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ftp客户端</title>
      <link href="/posts/7d4330a2.html"/>
      <url>/posts/7d4330a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的ftp客户端Cftp类。</p><p>Cftp类的声明文件是freecplus/_ftp.h。</p><p>Cftp类的定义文件是freecplus/_ftp.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><p>Cftp类是在ftplib开源库的基础之上做了二次封装，ftplib开源库的头文件是freecplus/ftplib.h，函数定义文件是freecplus/ftplib.c。</p><p>ftplib是C代码，用gcc先编译成lib库文件后，再用g++和_ftp.cpp以及目标文件一起编译。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>本文不会介绍ftp协议的基础知识和ftp命令，在阅读本文之前，您必须熟悉ftp协议和命令才能看懂本文的内容。</p><h1 id="三-cftp类"><a class="markdownIt-Anchor" href="#三-cftp类"></a> 三、Cftp类</h1><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cftp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  netbuf *m_ftpconn;   <span class="comment">// ftp连接句柄。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m_size; <span class="comment">// 文件的大小，单位：字节。</span></span><br><span class="line">  <span class="type">char</span> m_mtime[<span class="number">21</span>];    <span class="comment">// 文件的修改时间，格式：yyyymmddhh24miss。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下三个成员变量用于存放login方法登录失败的原因。</span></span><br><span class="line">  <span class="type">bool</span> m_connectfailed;    <span class="comment">// 连接失败。</span></span><br><span class="line">  <span class="type">bool</span> m_loginfailed;      <span class="comment">// 登录失败，用户名和密码不正确，或没有登录权限。</span></span><br><span class="line">  <span class="type">bool</span> m_optionfailed;     <span class="comment">// 设置传输模式失败。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Cftp</span>();  <span class="comment">// 类的构造函数。</span></span><br><span class="line"> ~<span class="built_in">Cftp</span>();  <span class="comment">// 类的析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initdata</span><span class="params">()</span></span>;   <span class="comment">// 初始化m_size和m_mtime成员变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录ftp服务器。</span></span><br><span class="line">  <span class="comment">// host：ftp服务器ip地址和端口，中间用&quot;:&quot;分隔，如&quot;192.168.1.1:21&quot;。</span></span><br><span class="line">  <span class="comment">// username：登录ftp服务器用户名。</span></span><br><span class="line">  <span class="comment">// password：登录ftp服务器的密码。</span></span><br><span class="line">  <span class="comment">// imode：传输模式，FTPLIB_PASSIVE是被动模式，FTPLIB_PORT是主动模式，缺省是被动模式。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">login</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">const</span> <span class="type">char</span> *username,<span class="type">const</span> <span class="type">char</span> *password,<span class="type">const</span> <span class="type">int</span> imode=FTPLIB_PASSIVE)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注销。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">logout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取ftp服务器上文件的时间。</span></span><br><span class="line">  <span class="comment">// remotefilename：待获取的文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：false-失败；true-成功，获取到的文件时间存放在m_mtime成员变量中。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">mtime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取ftp服务器上文件的大小。</span></span><br><span class="line">  <span class="comment">// remotefilename：待获取的文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：false-失败；true-成功，获取到的文件大小存放在m_size成员变量中。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">size</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改变ftp服务器的当前工作目录。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器上的目录名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在ftp服务器上创建目录。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器上待创建的目录名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除ftp服务器上的目录。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器上待删除的目录名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送NLST命令列出ftp服务器的目录和文件名。</span></span><br><span class="line">  <span class="comment">// remotedir：ftp服务器的目录名。</span></span><br><span class="line">  <span class="comment">// listfilename：用于保存从服务器返回的目录和文件名列表。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="comment">// 注意：如果列出的是ftp服务器当前目录，remotedir用&quot;&quot;,&quot;*&quot;,&quot;.&quot;都可以，但是，不规范的ftp服务器可能有差别。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">nlist</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir,<span class="type">const</span> <span class="type">char</span> *listfilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从ftp服务器上获取文件。</span></span><br><span class="line">  <span class="comment">// remotefilename：待获取ftp服务器上的文件名。</span></span><br><span class="line">  <span class="comment">// localfilename：保存到本地的文件名。</span></span><br><span class="line">  <span class="comment">// bCheckMTime：文件传输完成后，是否核对远程文件传输前后的时间，保证文件的完整性。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="comment">// 注意：文件在传输的过程中，采用临时文件命名的方法，即在localfilename后加&quot;.tmp&quot;，在传输</span></span><br><span class="line">  <span class="comment">// 完成后才正式改为localfilename。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename,<span class="type">const</span> <span class="type">char</span> *localfilename,<span class="type">const</span> <span class="type">bool</span> bCheckMTime=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向ftp服务器发送文件。</span></span><br><span class="line">  <span class="comment">// localfilename：本地待发送的文件名。</span></span><br><span class="line">  <span class="comment">// remotefilename：发送到ftp服务器上的文件名。</span></span><br><span class="line">  <span class="comment">// bCheckSize：文件传输完成后，是否核对本地文件和远程文件的大小，保证文件的完整性。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="comment">// 注意：文件在传输的过程中，采用临时文件命名的方法，即在remotefilename后加&quot;.tmp&quot;，在传输</span></span><br><span class="line">  <span class="comment">// 完成后才正式改为remotefilename。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *localfilename,<span class="type">const</span> <span class="type">char</span> *remotefilename,<span class="type">const</span> <span class="type">bool</span> bCheckSize=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除ftp服务器上的文件。</span></span><br><span class="line">  <span class="comment">// remotefilename：待删除的ftp服务器上的文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ftpdelete</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重命名ftp服务器上的文件。</span></span><br><span class="line">  <span class="comment">// srcremotefilename：ftp服务器上的原文件名。</span></span><br><span class="line">  <span class="comment">// dstremotefilename：ftp服务器上的目标文件名。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ftprename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *srcremotefilename,<span class="type">const</span> <span class="type">char</span> *dstremotefilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以下三个方法如果理解不了就算了，可以不启用。 */</span></span><br><span class="line">  <span class="comment">// 发送LIST命令列出ftp服务器目录中的文件。</span></span><br><span class="line">  <span class="comment">// 参数和返回值与nlist方法相同。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *remotedir,<span class="type">const</span> <span class="type">char</span> *listfilename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向ftp服务器发送site命令。</span></span><br><span class="line">  <span class="comment">// command：命令的内容。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">site</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取服务器返回信息的最后一条(return a pointer to the last response received)。</span></span><br><span class="line">  <span class="function"><span class="type">char</span> *<span class="title">response</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四-准备测试环境"><a class="markdownIt-Anchor" href="#四-准备测试环境"></a> 四、准备测试环境</h1><p>在演示示例程序之前，我认为您已经是一个职业的C/C++程序员，熟悉Linux操作系统、熟悉ftp协议。</p><h2 id="1-创建linux操作系统用户"><a class="markdownIt-Anchor" href="#1-创建linux操作系统用户"></a> 1、创建Linux操作系统用户</h2><p>创建freecplus用户，用户组为bin，用户根目录为/home/freecplus，密码为freecpluspwd</p><h2 id="在这里插入图片描述2-安装配置ftp服务器"><a class="markdownIt-Anchor" href="#在这里插入图片描述2-安装配置ftp服务器"></a> <img src="https://img-blog.csdnimg.cn/20200306170149537.png" alt="在这里插入图片描述" /><br />2、安装配置ftp服务器</h2><p>具体操作请参考C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）的相关文章，或在网上搜索相关的文章。</p><h2 id="3-配置防火墙"><a class="markdownIt-Anchor" href="#3-配置防火墙"></a> 3、配置防火墙</h2><p>具体操作请参考C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）的相关文章，或在网上搜索相关的文章。</p><h2 id="4-准备测试的文件"><a class="markdownIt-Anchor" href="#4-准备测试的文件"></a> 4、准备测试的文件</h2><p>把freecplus框架的源代码复制到/home/freecplus目录，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306170209163.png" alt="在这里插入图片描述" /></p><h1 id="五-示例程序"><a class="markdownIt-Anchor" href="#五-示例程序"></a> 五、示例程序</h1><h2 id="1-获取服务器文件列表-时间和大小"><a class="markdownIt-Anchor" href="#1-获取服务器文件列表-时间和大小"></a> 1、获取服务器文件列表、时间和大小</h2><p><strong>示例（demo50.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo50.cpp，此程序演示采用freecplus框架的Cftp类获取服务器文件列表、时间和大小。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cftp ftp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录远程FTP服务器，请改为您自己服务器的ip地址。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">login</span>(<span class="string">&quot;172.16.0.15:21&quot;</span>,<span class="string">&quot;freecplus&quot;</span>,<span class="string">&quot;freecpluspwd&quot;</span>,FTPLIB_PASSIVE) == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(172.16.0.15:21(freecplus/freecpluspwd)) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取服务器上/home/freecplus/*.h文件列表，保存在本地的/tmp/list/tmp.list文件中。</span></span><br><span class="line">  <span class="comment">// 如果/tmp/list目录不存在，就创建它。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">nlist</span>(<span class="string">&quot;/home/freecplus/*.h&quot;</span>,<span class="string">&quot;/tmp/list/tmp.list&quot;</span>)==<span class="literal">false</span>) </span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.nlist() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;    <span class="comment">// 采用freecplus框架的CFile类来操作list文件。</span></span><br><span class="line">  <span class="type">char</span> strFileName[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  File.<span class="built_in">Open</span>(<span class="string">&quot;/tmp/list/tmp.list&quot;</span>,<span class="string">&quot;r&quot;</span>);  <span class="comment">// 打开list文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)    <span class="comment">// 获取每个文件的时间和大小。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Fgets</span>(strFileName,<span class="number">300</span>,<span class="literal">true</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ftp.<span class="built_in">mtime</span>(strFileName); <span class="comment">// 获取文件时间。</span></span><br><span class="line">    ftp.<span class="built_in">size</span>(strFileName);  <span class="comment">// 获取文件大小。</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;filename=%s,mtime=%s,size=%d\n&quot;</span>,strFileName,ftp.m_mtime,ftp.m_size);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306170253376.png" alt="在这里插入图片描述" /></p><h2 id="2-把文件上传到服务器"><a class="markdownIt-Anchor" href="#2-把文件上传到服务器"></a> 2、把文件上传到服务器</h2><p><strong>示例（demo51.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo51.cpp，此程序演示采用freecplus框架的Cftp类上传文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cftp ftp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录远程FTP服务器，请改为您自己服务器的ip地址。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">login</span>(<span class="string">&quot;172.16.0.15:21&quot;</span>,<span class="string">&quot;freecplus&quot;</span>,<span class="string">&quot;freecpluspwd&quot;</span>,FTPLIB_PASSIVE) == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(172.16.0.15:21(freecplus/freecpluspwd)) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在ftp服务器上创建/home/freecplus/tmp，注意，如果目录已存在，会返回失败。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">mkdir</span>(<span class="string">&quot;/home/freecplus/tmp&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.mkdir() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把ftp服务器上的工作目录切换到/home/freecplus/tmp</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">chdir</span>(<span class="string">&quot;/home/freecplus/tmp&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.chdir() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把本地的demo51.cpp上传到ftp服务器的当前工作目录。</span></span><br><span class="line">  ftp.<span class="built_in">put</span>(<span class="string">&quot;demo51.cpp&quot;</span>,<span class="string">&quot;demo51.cpp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不调用chdir切换工作目录，以下代码也可以直接上传文件。</span></span><br><span class="line">  <span class="comment">// ftp.put(&quot;demo51.cpp&quot;,&quot;/home/freecplus/tmp/demo51.cpp&quot;);</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;put demo51.cpp ok.\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-从服务器下载文件"><a class="markdownIt-Anchor" href="#3-从服务器下载文件"></a> 3、从服务器下载文件</h2><p><strong>示例（demo52.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo52.cpp，此程序演示采用freecplus框架的Cftp类下载文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cftp ftp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录远程FTP服务器，请改为您自己服务器的ip地址。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">login</span>(<span class="string">&quot;172.16.0.15:21&quot;</span>,<span class="string">&quot;freecplus&quot;</span>,<span class="string">&quot;freecpluspwd&quot;</span>,FTPLIB_PASSIVE) == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(172.16.0.15:21(freecplus/freecpluspwd)) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器上的/home/freecplus/tmp/demo51.cpp下载到本地，存为/tmp/test/demo51.cpp。</span></span><br><span class="line">  <span class="comment">// 如果本地的/tmp/test目录不存在，就创建它。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">get</span>(<span class="string">&quot;/home/freecplus/tmp/demo51.cpp&quot;</span>,<span class="string">&quot;/tmp/test/demo51.cpp&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.get() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;get /home/freecplus/tmp/demo51.cpp ok.\n&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除服务上的/home/freecplus/tmp/demo51.cpp文件。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">ftpdelete</span>(<span class="string">&quot;/home/freecplus/tmp/demo51.cpp&quot;</span>)==<span class="literal">false</span>) </span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.ftpdelete() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;delete /home/freecplus/tmp/demo51.cpp ok.\n&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除服务器上的/home/freecplus/tmp目录，如果目录非空，删除将失败。</span></span><br><span class="line">  <span class="keyword">if</span> (ftp.<span class="built_in">rmdir</span>(<span class="string">&quot;/home/freecplus/tmp&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;ftp.rmdir() failed.\n&quot;</span>);<span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp网络通信</title>
      <link href="/posts/5454c89c.html"/>
      <url>/posts/5454c89c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的TCP/IP协议网络通信的函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>freecplus框架对socket通信封装如下：</p><p>CTcpClient类：socket通信的客户端类。</p><p>CTcpServer类：socket通信的服务端类。</p><p>TcpRead函数：接收socket的对端发送过来的数据。</p><p>TcpWrite函数：向socket的对端发送数据。</p><p>Readn函数：从已经准备好的socket中读取数据。</p><p>Writen函数：向已经准备好的socket中写入数据。</p><p>在阅读本文章之前，您必须熟悉TCP/IP协议和socket通信，本文是介绍的是freecplus框架中网络通信的类和函数的用法，不会介绍网络通信的基础知识。</p><h1 id="三-通信的报文格式"><a class="markdownIt-Anchor" href="#三-通信的报文格式"></a> 三、通信的报文格式</h1><p>freecplus框架的socket通信报文格式如下：</p><p><strong>报文长度+报文内容</strong></p><p>报文长度为4字节的整数，表示的是<strong>报文内容</strong>的长度，而不是整个TCP报文的长度，整个TCP报文的长度是<strong>报文内容的长度+4</strong>。</p><p>报文长度是4字节的整数，即int，是以二进制流的方式写入socket，不是ascii码。</p><p>采用CTcpClient类、CTcpServer类、TcpRead函数和TcpWrite函数进行socket通信，可以避免TCP报文<strong>粘包</strong>的问题。</p><h1 id="四-socket通信客户端"><a class="markdownIt-Anchor" href="#四-socket通信客户端"></a> 四、socket通信客户端</h1><p>socket通信的客户端封装在CTcpClient类中。</p><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket通信的客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span>  m_sockfd;    <span class="comment">// 客户端的socket.</span></span><br><span class="line">  <span class="type">char</span> m_ip[<span class="number">21</span>];    <span class="comment">// 服务端的ip地址。</span></span><br><span class="line">  <span class="type">int</span>  m_port;      <span class="comment">// 与服务端通信的端口。</span></span><br><span class="line">  <span class="type">bool</span> m_state;     <span class="comment">// 与服务端的socket连接状态。</span></span><br><span class="line">  <span class="type">bool</span> m_btimeout;  <span class="comment">// 调用Read和Write方法时，失败的原因是否是超时：true-未超时，false-已超时。</span></span><br><span class="line">  <span class="type">int</span>  m_buflen;    <span class="comment">// 调用Read方法后，接收到的报文的大小，单位：字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpClient</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发起连接请求。</span></span><br><span class="line">  <span class="comment">// ip：服务端的ip地址。</span></span><br><span class="line">  <span class="comment">// port：服务端监听的端口。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收服务端发送过来的数据。</span></span><br><span class="line">  <span class="comment">// buffer：接收数据缓冲区的地址，数据的长度存放在m_buflen成员变量中。</span></span><br><span class="line">  <span class="comment">// itimeout：等待数据的超时时间，单位：秒，缺省值是0-无限等待。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时，成员变量m_btimeout的值被设置为true；2）socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> itimeout=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发送数据。</span></span><br><span class="line">  <span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line">  <span class="comment">// ibuflen：待发送数据的大小，单位：字节，缺省值为0，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与服务端的连接</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CTcpClient</span>();  <span class="comment">// 析构函数自动关闭socket，释放资源。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五-socket通信的服务端"><a class="markdownIt-Anchor" href="#五-socket通信的服务端"></a> 五、socket通信的服务端</h1><p>socket通信的服务端封装在CTcpServer类中。</p><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket通信的服务端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_socklen;                    <span class="comment">// 结构体struct sockaddr_in的大小。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> m_clientaddr;  <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> m_servaddr;    <span class="comment">// 服务端的地址信息。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span>  m_listenfd;   <span class="comment">// 服务端用于监听的socket。</span></span><br><span class="line">  <span class="type">int</span>  m_connfd;     <span class="comment">// 客户端连接上来的socket。</span></span><br><span class="line">  <span class="type">bool</span> m_btimeout;   <span class="comment">// 调用Read和Write方法时，失败的原因是否是超时：true-未超时，false-已超时。</span></span><br><span class="line">  <span class="type">int</span>  m_buflen;     <span class="comment">// 调用Read方法后，接收到的报文的大小，单位：字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端初始化。</span></span><br><span class="line">  <span class="comment">// port：指定服务端用于监听的端口。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，一般情况下，只要port设置正确，没有被占用，初始化都会成功。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> port)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞等待客户端的连接请求。</span></span><br><span class="line">  <span class="comment">// 返回值：true-有新的客户端已连接上来，false-失败，Accept被中断，如果Accept失败，可以重新Accept。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取客户端的ip地址。</span></span><br><span class="line">  <span class="comment">// 返回值：客户端的ip地址，如&quot;192.168.1.100&quot;。</span></span><br><span class="line">  <span class="function"><span class="type">char</span> *<span class="title">GetIP</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收客户端发送过来的数据。</span></span><br><span class="line">  <span class="comment">// buffer：接收数据缓冲区的地址，数据的长度存放在m_buflen成员变量中。</span></span><br><span class="line">  <span class="comment">// itimeout：等待数据的超时时间，单位：秒，缺省值是0-无限等待。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时，成员变量m_btimeout的值被设置为true；2）socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> itimeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向客户端发送数据。</span></span><br><span class="line">  <span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line">  <span class="comment">// ibuflen：待发送数据的大小，单位：字节，缺省值为0，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭监听的socket，即m_listenfd，常用于多进程服务程序的子进程代码中。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭客户端的socket，即m_connfd，常用于多进程服务程序的父进程代码中。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CTcpServer</span>();  <span class="comment">// 析构函数自动关闭socket，释放资源。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="六-示例程序"><a class="markdownIt-Anchor" href="#六-示例程序"></a> 六、示例程序</h1><h2 id="1-客户端"><a class="markdownIt-Anchor" href="#1-客户端"></a> 1、客户端</h2><p><strong>示例（demo47.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo47.cpp，此程序演示采用freecplus框架的CTcpClient类实现socket通信的客户端。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpClient TcpClient;   <span class="comment">// 创建客户端的对象。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;172.16.0.15&quot;</span>,<span class="number">5858</span>)==<span class="literal">false</span>) <span class="comment">// 向服务端发起连接请求。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;172.16.0.15\&quot;,5858) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];    <span class="comment">// 存放数据的缓冲区。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)   <span class="comment">// 利用循环，与服务端进行5次交互。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">snprintf</span>(strbuffer,<span class="number">50</span>,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Write</span>(strbuffer)==<span class="literal">false</span>) <span class="keyword">break</span>;    <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Read</span>(strbuffer,<span class="number">20</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;  <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 程序直接退出，析构函数会释放资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-服务端"><a class="markdownIt-Anchor" href="#2-服务端"></a> 2、服务端</h2><p><strong>示例（demo48.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo48.cpp，此程序演示采用freecplus框架的CTcpServer类实现socket通信的服务端。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpServer TcpServer;   <span class="comment">// 创建服务端对象。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5858</span>)==<span class="literal">false</span>) <span class="comment">// 初始化TcpServer的通信端口。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.InitServer(5858) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>()==<span class="literal">false</span>)   <span class="comment">// 等待客户端连接。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.Accept() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端(%s)已连接。\n&quot;</span>,TcpServer.<span class="built_in">GetIP</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];  <span class="comment">// 存放数据的缓冲区。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Read</span>(strbuffer,<span class="number">300</span>)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 接收客户端发过来的请求报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);      <span class="comment">// 在客户端的报文后加上&quot;ok&quot;。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Write</span>(strbuffer)==<span class="literal">false</span>) <span class="keyword">break</span>;     <span class="comment">// 向客户端回应报文。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开。\n&quot;</span>);    <span class="comment">// 程序直接退出，析构函数会释放资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-运行程序前的准备端"><a class="markdownIt-Anchor" href="#3-运行程序前的准备端"></a> 3、运行程序前的准备端</h2><p>我希望您已经学过计算机网络的基础知识，在运行示例程序之前，请确保您的Linux操作系统已开通防火墙。</p><p>在demo47.cpp和demo48.cpp程序中，服务端的ip地址和通信端口是写死在程序中的，请根据您的实际情况修改它们，然后重新编译。</p><h2 id="4-运行程序"><a class="markdownIt-Anchor" href="#4-运行程序"></a> 4、运行程序</h2><p>先启动demo48，然后启动demo47。</p><p><strong>demo47的运行效果如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306164235224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>demo48的运行效果如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306164329299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="七-socket通信的函数"><a class="markdownIt-Anchor" href="#七-socket通信的函数"></a> 七、socket通信的函数</h1><p>采用CTcpClient和CTcpServer类实现socket通信功能非常方便，但是在实际开发中，某些场景中不能只依赖这两个类，例如多程线和异步通信等场景，还必须结合以下将要介绍的几个函数一起使用。</p><h2 id="1-tcpread函数"><a class="markdownIt-Anchor" href="#1-tcpread函数"></a> 1、TcpRead函数</h2><p>接收socket的对端发送过来的数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TcpRead</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">char</span> *buffer,<span class="type">int</span> *ibuflen,<span class="type">const</span> <span class="type">int</span> itimeout=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>sockfd：可用的socket连接。</p><p>buffer：接收数据缓冲区的地址。</p><p>ibuflen：本次成功接收数据的字节数。</p><p>itimeout：接收等待超时的时间，单位：秒，缺省值是0-无限等待。</p><p>返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。</p><p>在CTcpClient和CTcpServer类的Read方法中调用了TcpRead函数。</p><h2 id="2-tcpwrite函数"><a class="markdownIt-Anchor" href="#2-tcpwrite函数"></a> 2、TcpWrite函数</h2><p>向socket的对端发送数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TcpWrite</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>sockfd：可用的socket连接。</p><p>buffer：待发送数据缓冲区的地址。</p><p>ibuflen：待发送数据的字节数，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</p><p>返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</p><p>在CTcpClient和CTcpServer类的Write方法中调用了TcpRead函数。</p><h2 id="3-readn函数"><a class="markdownIt-Anchor" href="#3-readn函数"></a> 3、Readn函数</h2><p>从已经准备好的socket中读取数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Readn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd：已经准备好的socket连接。</p><p>buffer：接收数据缓冲区的地址。</p><p>n：本次接收数据的字节数。</p><p>返回值：成功接收到n字节的数据后返回true，socket连接不可用返回false。</p><p>注意：</p><p>1）sockfd是已经准备好的socket连接，那什么是已经准备好的socket？在这个socket上，已经或马上有n字节的数据一定会到达。</p><p>2）成功接收到n字节的数据后返回true，如果没有n字节的数据怎么办？不会，在1）中已经说明了，一定会有n字节的数据会到达。</p><p>3）如果数据大于n字节怎么办？Readn只读取n个字节的数据，其它的数据属于其它的报文。</p><p>4）socket的对端是采用Writen方法写入的数据。</p><p>在TcpRead函数中，调用了Readn函数。</p><h2 id="4-writen函数"><a class="markdownIt-Anchor" href="#4-writen函数"></a> 4、Writen函数</h2><p>向已经准备好的socket中写入数据。</p><p>函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Writen</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd：已经准备好的socket连接。</p><p>buffer：待发送数据缓冲区的地址。</p><p>n：待发送数据的字节数。</p><p>返回值：成功发送完n字节的数据后返回true，socket连接不可用返回false。</p><p>在TcpWrite函数中，调用了Writen函数。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加载参数文件</title>
      <link href="/posts/898d405.html"/>
      <url>/posts/898d405.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中加载参数文件的方法。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-参数文件的意义"><a class="markdownIt-Anchor" href="#二-参数文件的意义"></a> 二、参数文件的意义</h1><p>在项目开发中，一个完整的系统由多个C/C++服务程序组成，这些服务程序有共同的参数，例如数据库的连接参数、日志文件存放的目录、数据文件存放的目录等。</p><p>传统的方法是把参数放在文本文件中，例如hssms.ini，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logpath=/log/hssms              # 日志文件存放的目录。</span><br><span class="line">connstr=hssms/smspwd@hssmszx  # 数据库连接参数。</span><br><span class="line">datapath=/data/hssms            # 数据文件存放的根目录。</span><br><span class="line">serverip=<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>            # 中心服务器的ip地址。</span><br><span class="line">port=<span class="number">5058</span>                         # 中心服务器的通信端口。</span><br><span class="line">online=<span class="literal">true</span>                       # 是否采用长连接。</span><br></pre></td></tr></table></figure><p>现在有更好的方法是把参数放在xml文件中，例如hssms.xml，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;gbk&quot;</span> ?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;!-- 程序运行的日志文件名。 --&gt;</span><br><span class="line">    &lt;logpath&gt;/log/hssms&lt;/logpath&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据库连接参数。 --&gt;</span><br><span class="line">    &lt;connstr&gt;hssms/smspwd@hssmszx&lt;/connstr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据文件存放的根目录。 --&gt;</span><br><span class="line">    &lt;datapath&gt;/data/hssms&lt;/datapath&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 中心服务器的ip地址。 --&gt;</span><br><span class="line">    &lt;serverip&gt;<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>&lt;/serverip&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 中心服务器的通信端口。 --&gt;</span><br><span class="line">    &lt;port&gt;<span class="number">5058</span>&lt;/port&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 是否采用长连接，<span class="literal">true</span>-是；<span class="literal">false</span>-否。 --&gt;</span><br><span class="line">    &lt;online&gt;<span class="literal">true</span>&lt;/online&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>一般来说，一个项目是由多种语言开发完成，xml文件格式比传统的ini文件格式更方便。</p><h1 id="三-cinifile类"><a class="markdownIt-Anchor" href="#三-cinifile类"></a> 三、CIniFile类</h1><p>CIniFile类用于服务程序从参数文件中加载参数。</p><h2 id="1-类的声明"><a class="markdownIt-Anchor" href="#1-类的声明"></a> 1、类的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数文件操作类。</span></span><br><span class="line"><span class="comment">// CIniFile类操作的是xml格式的参数文件，并不是传统的ini文件。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CIniFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 存放参数文件全部的内容，由LoadFile载入到本变量中。</span></span><br><span class="line">  string m_xmlbuffer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CIniFile</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把参数文件的内容载入到m_xmlbuffer变量中。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">LoadFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数文件字段的内容。</span></span><br><span class="line">  <span class="comment">// fieldname：字段的标签名。</span></span><br><span class="line">  <span class="comment">// value：传入变量的地址，用于存放字段内容，支持bool、int、insigned int、long、unsigned long、double和char[]。</span></span><br><span class="line">  <span class="comment">// 注意，当value参数的数据类型为char []时，必须保证value数组的内存足够，否则可能发生内存溢出的问题，</span></span><br><span class="line">  <span class="comment">// 也可以用ilen参数限定获取字段内容的长度，ilen的缺省值为0，表示不限定获取字段内容的长度。</span></span><br><span class="line">  <span class="comment">// 返回值：true-获取成功；false-获取失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">bool</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">int</span>  *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">int</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">double</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">char</span> *value,<span class="type">const</span> <span class="type">int</span> ilen=<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-示例程序"><a class="markdownIt-Anchor" href="#2-示例程序"></a> 2、示例程序</h2><p><strong>示例（demo45.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo45.cpp，此程序演示采用freecplus框架的CIniFile类加载参数文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放本程序运行参数的数据结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_args</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> logpath[<span class="number">301</span>];</span><br><span class="line">  <span class="type">char</span> connstr[<span class="number">101</span>];</span><br><span class="line">  <span class="type">char</span> datapath[<span class="number">301</span>];</span><br><span class="line">  <span class="type">char</span> serverip[<span class="number">51</span>];</span><br><span class="line">  <span class="type">int</span>  port;</span><br><span class="line">  <span class="type">bool</span> online;</span><br><span class="line">&#125;stargs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果执行程序时输入的参数不正确，给出帮助信息。</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nusing:/freecplus/demo/demo45 inifile\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;samples:/freecplus/demo/demo45 /freecplus/ini/hssms.xml\n\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载参数文件。</span></span><br><span class="line">  CIniFile IniFile;</span><br><span class="line">  <span class="keyword">if</span> (IniFile.<span class="built_in">LoadFile</span>(argv[<span class="number">1</span>])==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IniFile.LoadFile(%s) failed.\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数，存放在stargs结构中。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;stargs,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_args));</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;logpath&quot;</span>,stargs.logpath,<span class="number">300</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;connstr&quot;</span>,stargs.connstr,<span class="number">100</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;datapath&quot;</span>,stargs.datapath,<span class="number">300</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;serverip&quot;</span>,stargs.serverip,<span class="number">50</span>);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;port&quot;</span>,&amp;stargs.port);</span><br><span class="line">  IniFile.<span class="built_in">GetValue</span>(<span class="string">&quot;online&quot;</span>,&amp;stargs.online);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;logpath=%s\n&quot;</span>,stargs.logpath);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;connstr=%s\n&quot;</span>,stargs.connstr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;datapath=%s\n&quot;</span>,stargs.datapath);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;serverip=%s\n&quot;</span>,stargs.serverip);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;port=%d\n&quot;</span>,stargs.port);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;online=%d\n&quot;</span>,stargs.online);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下可以写更多的主程序的代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306161807982.png" alt="在这里插入图片描述" /></p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志文件操作</title>
      <link href="/posts/c683fa0a.html"/>
      <url>/posts/c683fa0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架中日志文件操作的方法。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-日志文件的意义"><a class="markdownIt-Anchor" href="#二-日志文件的意义"></a> 二、日志文件的意义</h1><p>对于C/C++服务程序来说，程序运行在后台，没有操作界面，无人值守，程序运行的状态、数据处理的日志、程序的异常等必须记录在日志文件中，运维人员根据日志文件的内容，查看程序运行和数据处理的情况。</p><h1 id="三-clogfile类"><a class="markdownIt-Anchor" href="#三-clogfile类"></a> 三、CLogFile类</h1><p>CLogFile类用于服务程序记录程序的运行日志。</p><h2 id="1-类的声明"><a class="markdownIt-Anchor" href="#1-类的声明"></a> 1、类的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志文件操作类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLogFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  FILE   *m_tracefp;           <span class="comment">// 日志文件指针。</span></span><br><span class="line">  <span class="type">char</span>    m_filename[<span class="number">301</span>];     <span class="comment">// 日志文件名，建议采用绝对路径。</span></span><br><span class="line">  <span class="type">char</span>    m_openmode[<span class="number">11</span>];      <span class="comment">// 日志文件的打开方式，一般采用&quot;a+&quot;。</span></span><br><span class="line">  <span class="type">bool</span>    m_bEnBuffer;         <span class="comment">// 写入日志时，是否启用操作系统的缓冲机制，缺省不启用。</span></span><br><span class="line">  <span class="type">long</span>    m_MaxLogSize;        <span class="comment">// 最大日志文件的大小，单位M，缺省100M。</span></span><br><span class="line">  <span class="type">bool</span>    m_bBackup;           <span class="comment">// 是否自动切换，日志文件大小超过m_MaxLogSize将自动切换，缺省启用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// MaxLogSize：最大日志文件的大小，单位M，缺省100M，最小为10M。</span></span><br><span class="line">  <span class="built_in">CLogFile</span>(<span class="type">const</span> <span class="type">long</span> MaxLogSize=<span class="number">100</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开日志文件。</span></span><br><span class="line">  <span class="comment">// filename：日志文件名，建议采用绝对路径，如果文件名中的目录不存在，就先创建目录。</span></span><br><span class="line">  <span class="comment">// openmode：日志文件的打开方式，与fopen库函数打开文件的方式相同，缺省值是&quot;a+&quot;。</span></span><br><span class="line">  <span class="comment">// bBackup：是否自动切换，true-切换，false-不切换，在多进程的服务程序中，如果多个进行共用一个日志文件，bBackup必须为false。</span></span><br><span class="line">  <span class="comment">// bEnBuffer：是否启用文件缓冲机制，true-启用，false-不启用，如果启用缓冲区，那么写进日志文件中的内容不会立即写入文件，缺省是不启用。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode=<span class="number">0</span>,<span class="type">bool</span> bBackup=<span class="literal">true</span>,<span class="type">bool</span> bEnBuffer=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果日志文件大于100M，就把当前的日志文件备份成历史日志文件，切换成功后清空当前日志文件的内容。</span></span><br><span class="line">  <span class="comment">// 备份后的文件会在日志文件名后加上日期时间。</span></span><br><span class="line">  <span class="comment">// 注意，在多进程的程序中，日志文件不可切换，多线的程序中，日志文件可以切换。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">BackupLogFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把内容写入日志文件，fmt是可变参数，使用方法与printf库函数相同。</span></span><br><span class="line">  <span class="comment">// Write方法会写入当前的时间，WriteEx方法不写时间。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WriteEx</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭日志文件</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CLogFile</span>();  <span class="comment">// 析构函数会调用Close方法。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-示例程序"><a class="markdownIt-Anchor" href="#2-示例程序"></a> 2、示例程序</h2><p><strong>示例（demo42.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo42.cpp，此程序演示采用freecplus框架的CLogFile类记录程序的运行日志。</span></span><br><span class="line"><span class="comment"> *  本程序修改demo40.cpp把输出的printf语句改为写日志文件。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CLogFile logfile;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开日志文件，如果&quot;/tmp/log&quot;不存在，就创建它，但是要确保当前用户具备创建目录的权限。</span></span><br><span class="line">  <span class="keyword">if</span> (logfile.<span class="built_in">Open</span>(<span class="string">&quot;/tmp/log/demo42.log&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;logfile.Open(/tmp/log/demo42.log) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo42程序开始运行。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描/tmp/data目录下文件名匹配&quot;surfdata_*.xml&quot;的文件。</span></span><br><span class="line">  <span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(<span class="string">&quot;/tmp/data&quot;</span>,<span class="string">&quot;surfdata_*.xml&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;Dir.OpenDir(/tmp/data) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Dir.<span class="built_in">ReadDir</span>()==<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;处理文件%s...&quot;</span>,Dir.m_FullFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Open</span>(Dir.m_FullFileName,<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">    &#123; logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed.File.Open(%s) failed.\n&quot;</span>,Dir.m_FullFileName); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以插入读取数据文件的内容、解析xml字符串并把数据写入数据库的代码。</span></span><br><span class="line">    <span class="comment">// 读取文本数据用Fgets和FFGETS方法，读取二进制数据用Fread方法。</span></span><br><span class="line">    <span class="comment">// 具体的代码我就不写了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完文件中的数据后，关闭文件指针，并删除文件。</span></span><br><span class="line">    File.<span class="built_in">CloseAndRemove</span>();</span><br><span class="line"></span><br><span class="line">    logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo42程序运行结束。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行demo39程序，在/tmp/data目录中生成几个数据文件，然后运行demo42，将生成日志文件/tmp/log/demo42.log，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306155446889.png" alt="在这里插入图片描述" /></p><h2 id="3-日志文件的切换"><a class="markdownIt-Anchor" href="#3-日志文件的切换"></a> 3、日志文件的切换</h2><p>我们通过一个示例程序的演示日志文件的切换功能，往日志文件中写入一千万数据，让它产生切换。</p><p><strong>示例（demo43.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo43.cpp，此程序演示freecplus框架的CLogFile类的日志文件的切换。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CLogFile logfile;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开日志文件，如果&quot;/tmp/log&quot;不存在，就创建它，但是要确保当前用户具备创建目录的权限。</span></span><br><span class="line">  <span class="keyword">if</span> (logfile.<span class="built_in">Open</span>(<span class="string">&quot;/tmp/log/demo43.log&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;logfile.Open(/tmp/log/demo43.log) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo43程序开始运行。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让程序循环10000000，生成足够大的日志。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">10000000</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;本程序演示日志文件的切换，这是第%010%d条记录。\n&quot;</span>,ii);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;demo43程序运行结束。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行demo43，将在/tmp/log目录中产生一批日志文件，用ls -l /tmp/log查看如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306155555194.png" alt="在这里插入图片描述" /></p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件操作.md</title>
      <link href="/posts/b6f23339.html"/>
      <url>/posts/b6f23339.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的文件操作的函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-文件操作函数"><a class="markdownIt-Anchor" href="#二-文件操作函数"></a> 二、文件操作函数</h1><h2 id="1-删除文件"><a class="markdownIt-Anchor" href="#1-删除文件"></a> 1、删除文件</h2><p>删除目录中的文件，类似Linux系统的rm命令。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">REMOVE</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">int</span> times=<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待删除的文件名，建议采用绝对路径的文件名，例如/tmp/root/data.xml。</p><p>times：执行删除文件的次数，缺省是1，建议不要超过3，从实际应用的经验看来，如果删除文件第1次不成功，再尝试2次是可以的，更多次就意义不大了。还有，如果执行删除失败，usleep(100000)后再重试。</p><p>返回值：true-删除成功；false-删除失败，失败的主要原因是权限不足。</p><p>在应用开发中，可以用REMOVE函数代替remove库函数。</p><h2 id="2-文件重命名"><a class="markdownIt-Anchor" href="#2-文件重命名"></a> 2、文件重命名</h2><p>把文件重命名，类似Linux系统的mv命令。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RENAME</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *srcfilename,<span class="type">const</span> <span class="type">char</span> *dstfilename,<span class="type">const</span> <span class="type">int</span> times=<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>srcfilename：原文件名，建议采用绝对路径的文件名。</p><p>destfilename：目标文件名，建议采用绝对路径的文件名。</p><p>times：执行重命名文件的次数，缺省是1，建议不要超过3，从实际应用的经验看来，如果重命名文件第1次不成功，再尝试2次是可以的，更多次就意义不大了。还有，如果执行重命名失败，usleep(100000)后再重试。</p><p>返回值：true-重命名成功；false-重命名失败，失败的主要原因是权限不足或磁盘空间不够，如果原文件和目标文件不在同一个磁盘分区，重命名也可能失败。</p><p>注意，在重命名文件之前，会自动创建destfilename参数中的目录名。</p><p>在应用开发中，可以用RENAME函数代替rename库函数。</p><h2 id="3-复制文件"><a class="markdownIt-Anchor" href="#3-复制文件"></a> 3、复制文件</h2><p>复制文件，类似Linux系统的cp命令。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">COPY</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *srcfilename,<span class="type">const</span> <span class="type">char</span> *dstfilename)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>srcfilename：原文件名，建议采用绝对路径的文件名。</p><p>destfilename：目标文件名，建议采用绝对路径的文件名。</p><p>返回值：true-复制成功；false-复制失败，失败的主要原因是权限不足或磁盘空间不够。</p><p>注意：</p><p>1）在复制名文件之前，会自动创建destfilename参数中的目录名。</p><p>2）复制文件的过程中，采用临时文件命名的方法，复制完成后再改名为destfilename，避免中间状态的文件被读取。</p><p>3）复制后的文件的时间与原文件相同，这一点与Linux系统cp命令不同。</p><h2 id="4-获取文件的大小"><a class="markdownIt-Anchor" href="#4-获取文件的大小"></a> 4、获取文件的大小</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待获取的文件名，建议采用绝对路径的文件名。</p><p>返回值：如果文件不存在或没有访问权限，返回-1，成功返回文件的大小，单位是字节。</p><h2 id="5-获取文件的时间"><a class="markdownIt-Anchor" href="#5-获取文件的时间"></a> 5、获取文件的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FileMTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">char</span> *mtime,<span class="type">const</span> <span class="type">char</span> *fmt=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待获取的文件名，建议采用绝对路径的文件名。</p><p>mtime：用于存放文件的时间，即stat结构体的st_mtime。</p><p>fmt：设置时间的输出格式，与LocalTime函数相同，但缺省是&quot;yyyymmddhh24miss&quot;。</p><p>返回值：如果文件不存在或没有访问权限，返回false，成功返回true。</p><h2 id="6-重置文件的时间"><a class="markdownIt-Anchor" href="#6-重置文件的时间"></a> 6、重置文件的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">UTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *mtime)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>filename：待重置的文件名，建议采用绝对路径的文件名。</p><p>stime：字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少。</p><p>返回值：true-成功；false-失败，失败的原因保存在errno中。</p><h2 id="7-示例程序"><a class="markdownIt-Anchor" href="#7-示例程序"></a> 7、示例程序</h2><p><strong>示例（demo34.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo34.cpp，此程序演示freecplus框架的文件操作函数的用法</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 删除文件。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">REMOVE</span>(<span class="string">&quot;/tmp/root/_freecplus.h&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;REMOVE(/tmp/root/_freecplus.h) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重命名文件。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">RENAME</span>(<span class="string">&quot;/tmp/root/_freecplus.cpp&quot;</span>,<span class="string">&quot;/tmp/root/aaa/bbb/ccc/_freecplus.cpp&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RENAME(/tmp/root/_freecplus.cpp) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 复制文件。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">COPY</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>,<span class="string">&quot;/tmp/root/aaa/bbb/ccc/_freecplus.h&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COPY(/freecplus/_freecplus.h) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size=%d\n&quot;</span>,<span class="built_in">FileSize</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置文件的时间。</span></span><br><span class="line">  <span class="built_in">UTime</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>,<span class="string">&quot;2020-01-05 13:37:29&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件的时间。</span></span><br><span class="line">  <span class="type">char</span> mtime[<span class="number">21</span>]; <span class="built_in">memset</span>(mtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(mtime));</span><br><span class="line">  <span class="built_in">FileMTime</span>(<span class="string">&quot;/freecplus/_freecplus.h&quot;</span>,mtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mtime=%s\n&quot;</span>,mtime);   <span class="comment">// 输出mtime=2020-01-05 13:37:29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-文件读取函数"><a class="markdownIt-Anchor" href="#三-文件读取函数"></a> 三、文件读取函数</h1><h2 id="1-打开文件"><a class="markdownIt-Anchor" href="#1-打开文件"></a> 1、打开文件</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">FOPEN</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>FOPEN函数调用fopen库函数打开文件，如果文件名中包含的目录不存在，就创建目录。</p><p>FOPEN函数的参数和返回值与fopen函数完全相同。</p><p>在应用开发中，用FOPEN函数代替fopen库函数。</p><h2 id="2-读取文件"><a class="markdownIt-Anchor" href="#2-读取文件"></a> 2、读取文件</h2><p>从文本文件中读取一行。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FGETS</span><span class="params">(<span class="type">const</span> FILE *fp,<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> readsize,<span class="type">const</span> <span class="type">char</span> *endbz=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>fp：已打开的文件指针。</p><p>buffer：用于存放读取的内容。</p><p>readsize：本次打算读取的字节数，如果已经读取到了结束标志，函数返回。</p><p>endbz：行内容结束的标志，缺省为空，表示行内容以&quot;\n&quot;为结束标志。</p><p>返回值：true-成功；false-失败，一般情况下，失败可以认为是文件已结束。</p><h2 id="3-示例程序"><a class="markdownIt-Anchor" href="#3-示例程序"></a> 3、示例程序</h2><p><strong>示例（demo36.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo36.cpp，此程序演示freecplus框架中FOPEN函数的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用FOPEN函数代替fopen库函数，如果目录/tmp/aaa/bbb/ccc不存在，会创建它。</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">FOPEN</span>(<span class="string">&quot;/tmp/aaa/bbb/ccc/tmp.xml&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="number">0</span>)   </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FOPEN(/tmp/aaa/bbb/ccc/tmp.xml) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno)); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向文件中写入两行超女数据。</span></span><br><span class="line">  <span class="built_in">fprintf</span>(fp,<span class="string">&quot;&lt;data&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;妲已&lt;/name&gt;&lt;age&gt;28&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;商朝要亡，关我什么事。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;25&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;1、中国排名第一的美女；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;2、男朋友是范蠡；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;3、老公是夫差，被勾践弄死了。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(fp);  <span class="comment">// 关闭文件。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo36.cpp程序生成了数据文件/tmp/aaa/bbb/ccc/tmp.xml，数据内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306152837752.png" alt="在这里插入图片描述" /></p><p>以上数据文件只有两条有效的记录，但是第二条数据是跨多行的，在memo标签里，文字和换行符都是内容的一部分。</p><p><strong>示例（demo37.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo37.cpp，此程序演示freecplus框架中FGETS函数的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">FOPEN</span>(<span class="string">&quot;/tmp/aaa/bbb/ccc/tmp.xml&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FOPEN(/tmp/aaa/bbb/ccc/tmp.xml) %d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno)); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strBuffer[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strBuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strBuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FGETS</span>(fp,strBuffer,<span class="number">300</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;     <span class="comment">// 行内容以&quot;\n&quot;结束。</span></span><br><span class="line">    <span class="comment">//if (FGETS(fp,strBuffer,300,&quot;&lt;endl/&gt;&quot;)==false) break; // 行内容以&quot;&lt;endl/&gt;&quot;结束。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strBuffer=%s&quot;</span>,strBuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306152951257.png" alt="在这里插入图片描述" /></p><p>第二条记录的内容不完整，这并不是程序员想要的结果，如果demo37.cpp启用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">FGETS</span>(fp,strBuffer,<span class="number">300</span>,<span class="string">&quot;&lt;endl/&gt;&quot;</span>)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 行内容以&quot;&lt;endl/&gt;&quot;结束。</span></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306153021238.png" alt="在这里插入图片描述" /></p><p>这才是程序员想要的结果。</p><h1 id="四-cfile类"><a class="markdownIt-Anchor" href="#四-cfile类"></a> 四、CFile类</h1><p>CFile类根据实际开发中的应用场景，对常用的文件操作功能做了封装。</p><p>我们来先介绍类的声明，然后再列出常用应用场景的示例。</p><h2 id="1-类的声明"><a class="markdownIt-Anchor" href="#1-类的声明"></a> 1、类的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件操作类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FILE *m_fp;        <span class="comment">// 文件指针</span></span><br><span class="line">  <span class="type">bool</span>  m_bEnBuffer; <span class="comment">// 是否启用缓冲，true-启用；false-不启用，缺省是启用。</span></span><br><span class="line">  <span class="type">char</span>  m_filename[<span class="number">301</span>]; <span class="comment">// 文件名，建议采用绝对路径的文件名。</span></span><br><span class="line">  <span class="type">char</span>  m_filenametmp[<span class="number">301</span>]; <span class="comment">// 临时文件名，在m_filename后加&quot;.tmp&quot;。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数。</span></span><br><span class="line"> ~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsOpened</span><span class="params">()</span></span>;  <span class="comment">// 判断文件是否已打开，返回值：true-已打开；false-未打开。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开文件。</span></span><br><span class="line">  <span class="comment">// filename：待打开的文件名，建议采用绝对路径的文件名。</span></span><br><span class="line">  <span class="comment">// openmode：打开文件的模式，与fopen库函数的打开模式相同。</span></span><br><span class="line">  <span class="comment">// bEnBuffer：是否启用缓冲，true-启用；false-不启用，缺省是启用。</span></span><br><span class="line">  <span class="comment">// 注意：如果待打开的文件的目录不存在，就会创建目录。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode,<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针，并删除文件。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">CloseAndRemove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 专为重命名而打开文件，参数与Open方法相同。</span></span><br><span class="line">  <span class="comment">// 注意：OpenForRename打开的是filename后加&quot;.tmp&quot;的临时文件，所以openmode只能是&quot;a&quot;、&quot;a+&quot;、&quot;w&quot;、&quot;w+&quot;。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">OpenForRename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode,<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 关闭文件指针，并把OpenForRename方法打开的临时文件名重命名为filename。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">CloseAndRename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fprintf向文件写入数据，参数与fprintf库函数相同，但不需要传入文件指针。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从文件中读取以换行符&quot;\n&quot;结束的一行。</span></span><br><span class="line">  <span class="comment">// buffer：用于存放读取的内容。</span></span><br><span class="line">  <span class="comment">// readsize：本次打算读取的字节数，如果已经读取到了结束标志&quot;\n&quot;，函数返回。</span></span><br><span class="line">  <span class="comment">// bdelcrt：是否删除行结束标志，true-删除；false-不删除，缺省值是false。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，一般情况下，失败可以认为是文件已结束。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Fgets</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> readsize,<span class="type">bool</span> bdelcrt=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从文件文件中读取一行。</span></span><br><span class="line">  <span class="comment">// buffer：用于存放读取的内容。</span></span><br><span class="line">  <span class="comment">// readsize：本次打算读取的字节数，如果已经读取到了结束标志，函数返回。</span></span><br><span class="line">  <span class="comment">// endbz：行内容结束的标志，缺省为空，表示行内容以&quot;\n&quot;为结束标志。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，一般情况下，失败可以认为是文件已结束。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">FFGETS</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">const</span> <span class="type">int</span> readsize,<span class="type">const</span> <span class="type">char</span> *endbz=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从文件中读取数据块。</span></span><br><span class="line">  <span class="comment">// ptr：用于存放读取的内容。</span></span><br><span class="line">  <span class="comment">// size：本次打算读取的字节数。</span></span><br><span class="line">  <span class="comment">// 返回值：本次从文件中成功读取的字节数，如果文件未结束，返回值等于size，如果文件已结束，返回值为实际读取的字节数。</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Fread</span><span class="params">(<span class="type">void</span> *ptr,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向文件中写入数据块。</span></span><br><span class="line">  <span class="comment">// ptr：待写入数据的地址。</span></span><br><span class="line">  <span class="comment">// size：待写入数据的字节数。</span></span><br><span class="line">  <span class="comment">// 返回值：本次成功写入的字节数，如果磁盘空间足够，返回值等于size。</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针，如果存在临时文件，就删除它。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-应用场景示例"><a class="markdownIt-Anchor" href="#2-应用场景示例"></a> 2、应用场景示例</h2><p>在CFile类中，每个成员变量和函数都很容易理解，但不一定能准确的用于应用开发的场景中，我现在列出两个常用的场景。</p><p><strong>场景一：某程序每隔若干时间就会产生一批数据，并把这些数据写入文件中。</strong></p><p>程序的流程如下：</p><p>1）创建数据文件；</p><p>2）往文件中写入数据；</p><p>3）关闭数据文件。</p><p>如果程序这么写，得0分，因为这个流程存在一个严重的问题，那就是在第2）步往文件中写入数据需要时间，从创建文件到写入完成之前，这个文件的内容是不完整的，如果这个不完整的文件被其它程序读取了，怎么办？给文件加锁？用标志位区分？太麻烦。</p><p>假设待写入的数据文件名是/tmp/data/surfdata_20200101123000.txt，修改后的程序流程如下：</p><p>1）创建文件/tmp/data/surfdata_20200101123000.txt.tmp；</p><p>2）往文件中写入数据；</p><p>3）关闭数据文件；</p><p>4）把文件/tmp/data/surfdata_20200101123000.txt.tmp重命名为/tmp/data/surfdata_20200101123000.txt。</p><p><strong>示例（demo39.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo39.cpp，此程序演示freecplus框架中采用CFile类生成数据文件的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strLocalTime[<span class="number">21</span>];   <span class="comment">// 用于存放系统当前的时间，格式yyyymmddhh24miss。</span></span><br><span class="line">  <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line">  <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;yyyymmddhh24miss&quot;</span>);  <span class="comment">// 获取系统当前时间。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 生成绝对路径的文件名，目录/tmp/data，文件名：前缀(surfdata_)+时间+后缀(.xml)。</span></span><br><span class="line">  <span class="type">char</span> strFileName[<span class="number">301</span>];</span><br><span class="line">  <span class="built_in">SNPRINTF</span>(strFileName,<span class="built_in">sizeof</span>(strFileName),<span class="number">300</span>,<span class="string">&quot;/tmp/data/surfdata_%s.xml&quot;</span>,strLocalTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用OpenForRename创建文件，实际创建的文件名例如/tmp/data/surfdata_20200101123000.xml.tmp。</span></span><br><span class="line">  <span class="keyword">if</span> (File.<span class="built_in">OpenForRename</span>(strFileName,<span class="string">&quot;w&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File.OpenForRename(%s) failed.\n&quot;</span>,strFileName); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里可以插入向文件写入数据的代码。</span></span><br><span class="line">  <span class="comment">// 写入文本数据用Fprintf方法，写入二进制数据用Fwrite方法。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向文件中写入两行超女数据。</span></span><br><span class="line">  File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;data&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;妲已&lt;/name&gt;&lt;age&gt;28&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;商要亡，关我什么事。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;25&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&lt;memo&gt;1、中国排名第一的美女；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;2、男朋友是范蠡；\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;3、老公是夫差，被勾践弄死了。&lt;/memo&gt;&lt;endl/&gt;\n&quot;</span>\</span><br><span class="line">     <span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">30</span>);   <span class="comment">// 停止30秒，用ls /tmp/data/*.tmp可以看到生成的临时文件。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针，并把临时文件名改为正式的文件名。</span></span><br><span class="line">  <span class="comment">// 注意，不能用File.Close()，因为Close方法是关闭文件指针，并删除临时文件。</span></span><br><span class="line">  <span class="comment">// CFile类的析构函数调用的是Close方法。</span></span><br><span class="line">  File.<span class="built_in">CloseAndRename</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每运行一次demo39程序，就会在/tmp/data目录下生成一个数据文件，如下：</p><p><img src="https://img-blog.csdnimg.cn/2020030615334735.png" alt="在这里插入图片描述" /></p><p><strong>场景二：从目录中读取场景一生成的数据文件，解析处理后保存到数据库中，然后删除目录中的文件。</strong></p><p>我们利用demo39程序生成的数据来测试。</p><p><strong>示例（demo40.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo40.cpp，此程序演示freecplus框架中采用CDir类和CFile类处理数据文件的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描/tmp/data目录下文件名匹配&quot;surfdata_*.xml&quot;的文件。</span></span><br><span class="line">  <span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(<span class="string">&quot;/tmp/data&quot;</span>,<span class="string">&quot;surfdata_*.xml&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dir.OpenDir(/tmp/data) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Dir.<span class="built_in">ReadDir</span>()==<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理文件%s...&quot;</span>,Dir.m_FullFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Open</span>(Dir.m_FullFileName,<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;failed.File.Open(%s) failed.\n&quot;</span>,Dir.m_FullFileName); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以插入读取数据文件的内容、解析xml字符串并把数据写入数据库的代码。</span></span><br><span class="line">    <span class="comment">// 读取文本数据用Fgets和FFGETS方法，读取二进制数据用Fread方法。</span></span><br><span class="line">    <span class="comment">// 具体的代码我就不写了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完文件中的数据后，关闭文件指针，并删除文件。</span></span><br><span class="line">    File.<span class="built_in">CloseAndRemove</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306153555992.png" alt="在这里插入图片描述" /></p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>目录操作</title>
      <link href="/posts/c56c826c.html"/>
      <url>/posts/c56c826c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的目录操作函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-创建目录"><a class="markdownIt-Anchor" href="#二-创建目录"></a> 二、创建目录</h1><p>在Linux下，如果想创建一个&quot;/tmp/aaa/bbb/ccc/ddd/data.xml&quot;的文件，必须先创建&quot;/tmp/aaa/bbb/ccc/ddd&quot;，步骤如下：</p><p>1）如果&quot;/tmp&quot;目录不存在，创建&quot;/tmp&quot;。</p><p>2）如果&quot;/tmp/aaa&quot;目录不存在，创建&quot;/tmp/aaa&quot;。</p><p>3）如果&quot;/tmp/aaa/bbb&quot;目录不存在，创建&quot;/tmp/aaa/bbb&quot;。</p><p>4）如果&quot;/tmp/aaa/bbb/ccc&quot;目录不存在，创建&quot;/tmp/aaa/bbb/ccc&quot;。</p><p>5）如果&quot;/tmp/aaa/bbb/ccc/ddd&quot;目录不存在，创建&quot;/tmp/aaa/bbb/ccc/ddd&quot;。</p><p>6）创建&quot;/tmp/aaa/bbb/ccc/ddd/data.xml&quot;文件。</p><p>这些操作虽然没有多少技术含量，但也很烦人。</p><p>MKDIR函数根据绝对路径的文件名或目录名逐级的创建目录。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MKDIR</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathorfilename,<span class="type">bool</span> bisfilename=<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>pathorfilename：绝对路径的文件名或目录名。</p><p>bisfilename：说明pathorfilename的类型，true-pathorfilename是文件名，否则是目录名，缺省值为true。</p><p>返回值：true-创建成功，false-创建失败，如果返回失败，原因有大概有三种情况：1）权限不足；2）pathorfilename参数不是合法的文件名或目录名；3）磁盘空间不足。</p><p><strong>示例（demo30.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo30.cpp，此程序演示freecplus框架中采用MKDIR函数根据绝对路径的文件名或目录名逐级的创建目录。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">MKDIR</span>(<span class="string">&quot;/tmp/aaa/bbb/ccc/ddd&quot;</span>,<span class="literal">false</span>);   <span class="comment">// 创建&quot;/tmp/aaa/bbb/ccc/ddd&quot;目录。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">MKDIR</span>(<span class="string">&quot;/tmp/111/222/333/444/data.xml&quot;</span>,<span class="literal">true</span>);   <span class="comment">// 创建&quot;/tmp/111/222/333/444&quot;目录。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-获取目录下的文件信息"><a class="markdownIt-Anchor" href="#三-获取目录下的文件信息"></a> 三、获取目录下的文件信息</h1><p>freecplus框架把获取某目录及其子目录中的文件列表信息的功能封装成CDir类。</p><p>类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某目录及其子目录中的文件列表信息。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_DirName[<span class="number">301</span>];        <span class="comment">// 目录名，例如：/tmp/root。</span></span><br><span class="line">  <span class="type">char</span> m_FileName[<span class="number">301</span>];       <span class="comment">// 文件名，不包括目录名，例如：data.xml。</span></span><br><span class="line">  <span class="type">char</span> m_FullFileName[<span class="number">301</span>];   <span class="comment">// 文件全名，包括目录名，例如：/tmp/root/data.xml。</span></span><br><span class="line">  <span class="type">int</span>  m_FileSize;              <span class="comment">// 文件的大小，单位：字节。</span></span><br><span class="line">  <span class="type">char</span> m_ModifyTime[<span class="number">21</span>];      <span class="comment">// 文件最后一次被修改的时间，即stat结构体的st_mtime成员。</span></span><br><span class="line">  <span class="type">char</span> m_CreateTime[<span class="number">21</span>];      <span class="comment">// 文件生成的时间，即stat结构体的st_ctime成员。</span></span><br><span class="line">  <span class="type">char</span> m_AccessTime[<span class="number">21</span>];      <span class="comment">// 文件最后一次被访问的时间，即stat结构体的st_atime成员。</span></span><br><span class="line">  <span class="type">char</span> m_DateFMT[<span class="number">21</span>];         <span class="comment">// 文件时间显示格式，由SetDateFMT方法设置。</span></span><br><span class="line"></span><br><span class="line">  vector&lt;string&gt; m_vFileName; <span class="comment">// 存放OpenDir方法获取到的文件名（文件全名，包括目录名）列表。</span></span><br><span class="line">  <span class="type">int</span> m_pos;                  <span class="comment">// 已读取m_vFileName容器的位置，每调用一次ReadDir方法m_pos加1。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CDir</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initdata</span><span class="params">()</span></span>; <span class="comment">// 初始化成员变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置文件时间的格式，支持&quot;yyyy-mm-dd hh24:mi:ss&quot;和&quot;yyyymmddhh24miss&quot;两种，缺省是前者。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetDateFMT</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_DateFMT)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开目录，获取目录中的文件列表信息，存放于m_vFileName容器中。</span></span><br><span class="line">  <span class="comment">// in_DirName，待打开的目录名，采用绝对路径，如/tmp/root。</span></span><br><span class="line">  <span class="comment">// in_MatchStr，待获取文件名的匹配规则，不匹配的文件被忽略。</span></span><br><span class="line">  <span class="comment">// in_MaxCount，获取文件的最大数量，缺省值为10000个。</span></span><br><span class="line">  <span class="comment">// bAndChild，是否打开各级子目录，缺省值为false-不打开子目录。</span></span><br><span class="line">  <span class="comment">// bSort，是否对获取到的文件列表（即m_vFileName容器中的内容）进行排序，缺省值为false-不排序。</span></span><br><span class="line">  <span class="comment">// 返回值：如果in_DirName参数指定的目录不存在，OpenDir方法会创建该目录，如果创建失败，返回false，还有，如果当前用户对in_DirName目录下的子目录没有读取权限也会返回false，其它正常情况下都会返回true。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">OpenDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_DirName,<span class="type">const</span> <span class="type">char</span> *in_MatchStr,<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> in_MaxCount=<span class="number">10000</span>,<span class="type">const</span> <span class="type">bool</span> bAndChild=<span class="literal">false</span>,<span class="type">bool</span> bSort=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是一个递归函数，用于OpenDir()的调用，在CDir类的外部不需要调用它。</span></span><br><span class="line">  <span class="type">bool</span> _OpenDir(<span class="type">const</span> <span class="type">char</span> *in_DirName,<span class="type">const</span> <span class="type">char</span> *in_MatchStr,<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> in_MaxCount,<span class="type">const</span> <span class="type">bool</span> bAndChild);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从m_vFileName容器中获取一条记录（文件名），同时得到该文件的大小、修改时间等信息。</span></span><br><span class="line">  <span class="comment">// 调用OpenDir方法时，m_vFileName容器被清空，m_pos归零，每调用一次ReadDir方法m_pos加1。</span></span><br><span class="line">  <span class="comment">// 当m_pos小于m_vFileName.size()，返回true，否则返回false。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ReadDir</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CDir</span>();  <span class="comment">// 析构函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CDir类的成员变量和函数的说明文字在类的声明中已详细描述。</p><p>我们通过一个应用场景来演示CDir类的用法。</p><p>先执行以下脚本生成测试目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/root</span><br><span class="line">mkdir /tmp/root/aaa</span><br><span class="line">mkdir /tmp/root/bbb</span><br><span class="line">cd freecplus</span><br><span class="line">cp freecplus.* /tmp/root/.</span><br><span class="line">cp demo/demo1* /tmp/root/aaa/.</span><br><span class="line">cp demo/demo2* /tmp/root/bbb/.</span><br><span class="line">cp demo/makefile /tmp/root/bbb/.</span><br></pre></td></tr></table></figure><p>执行以上脚本后，在/tmp/root目录中的目录和文件列表如下：</p><p><img src="https://img-blog.csdnimg.cn/20200306145307408.png" alt="在这里插入图片描述" /></p><p><strong>示例（demo32.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo32.cpp，此程序演示freecplus框架中采用CDir类获取某目录及其子目录中的文件列表信息。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(<span class="string">&quot;/tmp/root&quot;</span>,<span class="string">&quot;*.h,*cpp&quot;</span>,<span class="number">100</span>,<span class="literal">true</span>,<span class="literal">true</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dir.OpenDir(/tmp/root) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(Dir.<span class="built_in">ReadDir</span>()==<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;filename=%s,mtime=%s,size=%d\n&quot;</span>,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306145419165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意事项：</p><p>1）每次调用ReadDir方法后，把CDir类其它成员变量的值输出到屏幕，观察运行效果。</p><p>2）OpenDir方法的in_MatchStr参数非常重要，在实际开发中应用广泛。</p><p>3）如果文件名圆点&quot;.&quot;打头，OpenDir方法将不读取这些文件，如果您希望读取这些文件，可以修改_OpenDir方法中的源代码。</p><p>4）OpendDir方法的in_MaxCount参数设置了每次扫描目录中的文件数量，建议不超过10000，如果取值过大，打开目录的时间会比较长，还会消耗比较多的内存。</p><p>5）OpenDir的bSort参数设置是否对m_vFileName容器进行排序，排序会消耗资源和时间，可以不排序就不排序。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日期、时间和计时器</title>
      <link href="/posts/cb3ca34c.html"/>
      <url>/posts/cb3ca34c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的时间操作函数。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-计算机时间的表示方法"><a class="markdownIt-Anchor" href="#二-计算机时间的表示方法"></a> 二、计算机时间的表示方法</h1><p>UNIX操作系统根据计算机产生的年代和应用采用1970年1月1日作为UNIX的纪元时间，1970年1月1日0点作为计算机表示时间的是中间点，将从1970年1月1日开始经过的秒数用一个整数存放，这种高效简洁的时间表示方法被称为“Unix时间纪元”，向左和向右偏移都可以得到更早或者更后的时间。</p><p>在实际开发中，对日期和时间的操作场景非常多，例如程序启动和退出的时间，程序执行任务的时间，数据生成的时间，数据处理的各环节的时间等等。</p><p>在Linux系统中，自定义了time_t类型，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">time_t</span>;    <span class="comment">// 时间值time_t为长整型long的别名。</span></span><br></pre></td></tr></table></figure><h1 id="三-获取操作系统的时间"><a class="markdownIt-Anchor" href="#三-获取操作系统的时间"></a> 三、获取操作系统的时间</h1><p>取操作系统的时间，并把整数表示的时间转换为字符串表示的格式。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LocalTime</span><span class="params">(<span class="type">char</span> *out_stime,<span class="type">const</span> <span class="type">char</span> *in_fmt=<span class="number">0</span>,<span class="type">const</span> <span class="type">int</span> in_interval=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>stime：用于存放获取到的时间字符串。</p><p>timetvl：时间的偏移量，单位：秒，0是缺省值，表示当前时间，30表示当前时间30秒之后的时间点，-30表示当前时间30秒之前的时间点。</p><p>fmt：输出时间的格式，fmt每部分的含义：“yyyy”-年份；“mm”-月份；“dd”-日期；“hh24”-小时；“mi”-分钟；“ss”-秒，缺省是&quot;yyyy-mm-dd hh24:mi:ss&quot;，目前支持以下格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span></span><br><span class="line"><span class="string">&quot;yyyymmddhh24miss&quot;</span></span><br><span class="line"><span class="string">&quot;yyyy-mm-dd&quot;</span></span><br><span class="line"><span class="string">&quot;yyyymmdd&quot;</span></span><br><span class="line"><span class="string">&quot;hh24:mi:ss&quot;</span></span><br><span class="line"><span class="string">&quot;hh24miss&quot;</span></span><br><span class="line"><span class="string">&quot;hh24:mi&quot;</span></span><br><span class="line"><span class="string">&quot;hh24mi&quot;</span></span><br><span class="line"><span class="string">&quot;hh24&quot;</span></span><br><span class="line"><span class="string">&quot;mi&quot;</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>1）小时的表示方法是hh24，不是hh，这么做的目的是为了保持与数据库的时间表示方法一致；</p><p>2）以上列出了常用的时间格式，如果不能满足您应用开发的需求，请修改源代码timetostr函数增加更多的格式支持；</p><p>3）调用函数的时候，如果fmt与上述格式都匹配，stime的内容将为空。</p><p><strong>示例（demo24.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo24.cpp，此程序演示freecplus框架中LocalTime时间函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> strtime[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LocalTime</span>(strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">-30</span>);  <span class="comment">// 获取30秒前的时间。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime1=%s\n&quot;</span>,strtime);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LocalTime</span>(strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>);      <span class="comment">// 获取当前时间。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime2=%s\n&quot;</span>,strtime);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LocalTime</span>(strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">30</span>);   <span class="comment">// 获取30秒后的时间。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime3=%s\n&quot;</span>,strtime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-时间转换函数"><a class="markdownIt-Anchor" href="#四-时间转换函数"></a> 四、时间转换函数</h1><h2 id="1-把整数表示的时间转换为字符串表示的时间"><a class="markdownIt-Anchor" href="#1-把整数表示的时间转换为字符串表示的时间"></a> 1、把整数表示的时间转换为字符串表示的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">timetostr</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> ltime,<span class="type">char</span> *stime,<span class="type">const</span> <span class="type">char</span> *fmt=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>ltime：整数表示的时间。</p><p>stime：字符串表示的时间。</p><p>fmt：输出字符串时间stime的格式，与LocalTime函数的fmt参数相同，如果fmt的格式不正确，stime将为空。</p><h2 id="2-把字符串表示的时间转换为整数表示的时间"><a class="markdownIt-Anchor" href="#2-把字符串表示的时间转换为整数表示的时间"></a> 2、把字符串表示的时间转换为整数表示的时间</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">strtotime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *stime)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>stime：字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少。</p><p>返回值：整数表示的时间，如果stime的格式不正确，返回-1。</p><p><strong>示例（demo26.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo26.cpp，此程序演示freecplus框架中整数表示的时间和字符串表示的时间之间的转换。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">time_t</span> ltime;</span><br><span class="line">  <span class="type">char</span> strtime[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strtime,<span class="string">&quot;2020-01-01 12:35:22&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ltime=<span class="built_in">strtotime</span>(strtime);    <span class="comment">// 转换为整数的时间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ltime=%ld\n&quot;</span>,ltime); <span class="comment">// 输出ltime=1577853322</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line">  <span class="built_in">timetostr</span>(ltime,strtime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>);  <span class="comment">// 转换为字符串的时间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime=%s\n&quot;</span>,strtime);     <span class="comment">// 输出strtime=2020-01-01 12:35:22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-时间的运算"><a class="markdownIt-Anchor" href="#五-时间的运算"></a> 五、时间的运算</h1><p>把字符串表示的时间加上一个偏移的秒数后得到一个新的字符串表示的时间。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AddTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_stime,<span class="type">char</span> *out_stime,<span class="type">const</span> <span class="type">int</span> timetvl,<span class="type">const</span> <span class="type">char</span> *fmt=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>in_stime：输入的字符串格式的时间。</p><p>out_stime：输出的字符串格式的时间。</p><p>timetvl：需要偏移的秒数，正数往后偏移，负数往前偏移。</p><p>fmt：输出字符串时间out_stime的格式，与LocalTime函数的fmt参数相同。</p><p>注意：in_stime和out_stime参数可以是同一个变量的地址，如果调用失败，out_stime的内容会清空。</p><p>返回值：true-成功，false-失败，如果返回失败，可以认为是in_stime的格式不正确。</p><p><strong>示例（demo28.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo28.cpp，此程序演示freecplus框架中采用AddTime进行时间的运算。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">time_t</span> ltime;</span><br><span class="line">  <span class="type">char</span> strtime[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strtime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strtime));</span><br><span class="line">  <span class="built_in">strcpy</span>(strtime,<span class="string">&quot;2020-01-01 12:35:22&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddTime</span>(strtime,strtime,<span class="number">0</span><span class="number">-1</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">// 减一天。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime=%s\n&quot;</span>,strtime);     <span class="comment">// 输出strtime=2019-12-31 12:35:22</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddTime</span>(strtime,strtime,<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">// 加两天。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;strtime=%s\n&quot;</span>,strtime);     <span class="comment">// 输出strtime=2020-01-02 12:35:22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-计时器"><a class="markdownIt-Anchor" href="#六-计时器"></a> 六、计时器</h1><p>CTimer类是一个精确到微秒的计时器。</p><p>类声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个精确到微秒的计时器。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTimer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> m_start;   <span class="comment">// 开始计时的时间。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> m_end;     <span class="comment">// 计时完成的时间。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始计时。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CTimer</span>();  <span class="comment">// 构造函数中会调用Start方法。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算已逝去的时间，单位：秒，小数点后面是微秒。</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">Elapsed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CTimer创建对象后立即开始计时，每次调用Elapsed方法获取已逝去的时间（单位：秒，小数点后面是微秒），并重新开始计时。</p><p><strong>示例（demo29.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo29.cpp，此程序演示freecplus框架中的CTimer类（计时器）的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTimer Timer;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;elapsed=%lf\n&quot;</span>,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306143720422.png" alt="在这里插入图片描述" /></p><p>从demo29运行的效果上看，好像计时有误差，同样是睡1秒，实际耗时却是1.000126或1.000171，这是因为程序本身执行需要时间，虽然时间很短，那也是需要时间。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xml解析</title>
      <link href="/posts/7fe612d8.html"/>
      <url>/posts/7fe612d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是采用freecplus框架的解析xml格式字符串函数。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-xml格式字符串介绍"><a class="markdownIt-Anchor" href="#二-xml格式字符串介绍"></a> 二、xml格式字符串介绍</h1><p>xml格式字符串是应用开发中被广泛采用的一种数据格式，简单易懂，容错性和可扩展性非常好，是数据处理、数据通讯和数据交换等应用场景的首选数据格式。</p><p>完整的xml格式比较复杂，但是，在实际开发中，对我们C/C++程序员来说，绝大部分场景下用到的xml数据格式比较简单，例如表示文件列表信息的xml数据集或文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">&lt;filename&gt;_freecplus.h&lt;/filename&gt;&lt;mtime&gt;<span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">35</span>&lt;/mtime&gt;&lt;size&gt;<span class="number">1834</span>&lt;/size&gt;&lt;endl/&gt;</span><br><span class="line">&lt;filename&gt;_freecplus.cpp&lt;/filename&gt;&lt;mtime&gt;<span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">15</span>&lt;/mtime&gt;&lt;size&gt;<span class="number">5094</span>&lt;/size&gt;&lt;endl/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure><p>数据集说明：</p><p>&lt;data&gt;：数据集的开始。</p><p>&lt;/data&gt;：数据集的结束。</p><p>&lt;endl/&gt;：每行数据的结束。</p><p>filename标签：文件名。</p><p>mtime标签：文件最后一次被修改的时间。</p><p>size标签：文件的大小。</p><h1 id="三-xml格式字符串的解析"><a class="markdownIt-Anchor" href="#三-xml格式字符串的解析"></a> 三、xml格式字符串的解析</h1><p>在freecplus框架中，提供了解析以下xml格式字符串的一系函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">bool</span>   *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">int</span>    *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">int</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">long</span>   *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">double</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *xmlbuffer,<span class="type">const</span> <span class="type">char</span> *fieldname,<span class="type">char</span> *value,<span class="type">const</span> <span class="type">int</span> ilen=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>xmlbuffer：待解析的xml格式字符串的内容。</p><p>fieldname：字段的标签名。</p><p>value：传入变量的地址，用于存放字段内容，支持bool、int、insigned<br />int、long、unsigned long、double和char[]。</p><p>注意，当value参数的数据类型为char []时，必须保证value数组的内存足够，否则可能发生内存溢出的问题，也可以用ilen参数限定获取字段内容的长度，ilen的缺省值为0，表示不限定获取字段内容的长度。</p><p>返回值：true-获取成功；false-获取失败。</p><p><strong>示例（demo22.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo22.cpp，此程序演示调用freecplus框架的GetXMLBuffer函数解析xml字符串。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放足球运动员资料的结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_player</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">char</span> no[<span class="number">6</span>];       <span class="comment">// 球衣号码</span></span><br><span class="line">  <span class="type">bool</span> striker;     <span class="comment">// 场上位置是否是前锋，true-是；false-不是。</span></span><br><span class="line">  <span class="type">int</span>  age;         <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">double</span> weight;    <span class="comment">// 体重，kg。</span></span><br><span class="line">  <span class="type">long</span> sal;         <span class="comment">// 年薪，欧元。</span></span><br><span class="line">  <span class="type">char</span> club[<span class="number">51</span>];    <span class="comment">// 效力的俱乐部</span></span><br><span class="line">&#125;stplayer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;stplayer,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_player));</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">301</span>];  </span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;&lt;name&gt;messi&lt;/name&gt;&lt;no&gt;10&lt;/no&gt;&lt;striker&gt;true&lt;/striker&gt;&lt;age&gt;30&lt;/age&gt;&lt;weight&gt;68.5&lt;/weight&gt;&lt;sal&gt;21000000&lt;/sal&gt;&lt;club&gt;Barcelona&lt;/club&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;name&quot;</span>,stplayer.name,<span class="number">50</span>);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;no&quot;</span>,stplayer.no,<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;striker&quot;</span>,&amp;stplayer.striker);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;age&quot;</span>,&amp;stplayer.age);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;weight&quot;</span>,&amp;stplayer.weight);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;sal&quot;</span>,&amp;stplayer.sal);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;club&quot;</span>,stplayer.club,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,no=%s,striker=%d,age=%d,weight=%.1f,sal=%ld,club=%s\n&quot;</span>,\</span><br><span class="line">         stplayer.name,stplayer.no,stplayer.striker,stplayer.age,\</span><br><span class="line">         stplayer.weight,stplayer.sal,stplayer.club);</span><br><span class="line">  <span class="comment">// 输出结果:name=messi,no=10,striker=1,age=30,weight=68.5,sal=21000000,club=Barcelona</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>对C/C++程序员来说，采用简单的xml字符串表达数据可以提高开发效率，我不建议采用复杂的xml格式，会让程序代码很烦锁。</p><p>如果在实际开发中需要解析更复杂的xml，可以寻找网上的开源库，例如libxml++。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作</title>
      <link href="/posts/81a02d9d.html"/>
      <url>/posts/81a02d9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码说明"><a class="markdownIt-Anchor" href="#一-源代码说明"></a> 一、源代码说明</h1><p>freecplus是一个Linux系统下的C/C++开源框架，源代码请前往C语言技术网(<a href="http://www.freecplus.net">www.freecplus.net</a>)下载。</p><p>本文介绍的是freecplus框架的字符串操作函数和类。</p><p>函数和类的声明文件是freecplus/_freecplus.h。</p><p>函数和类的定义文件是freecplus/_freecplus.cpp。</p><p>示例程序位于freecplus/demo目录中。</p><p>编译规则文件是freecplus/demo/makefile。</p><h1 id="二-字符串复制"><a class="markdownIt-Anchor" href="#二-字符串复制"></a> 二、字符串复制</h1><h2 id="1-strcpy函数"><a class="markdownIt-Anchor" href="#1-strcpy函数"></a> 1、STRCPY函数</h2><p>安全的strcpy函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，不需要初始化，在STRCPY函数中有初始化代码。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：原字符串。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo1.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo1.cpp，此程序演示freecplus框架中STRCPY函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;freecplus&quot;</span>);  <span class="comment">// 待复制的内容没有超过str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=freecplus=</span></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www.freecplus.net&quot;</span>);  <span class="comment">// 待复制的内容超过了str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-strncpy函数"><a class="markdownIt-Anchor" href="#2-strncpy函数"></a> 2、STRNCPY函数</h2><p>安全的strncpy函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，不需要初始化，在STRNCPY函数中有初始化代码。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：原字符串。</p><p>n：待复制的字节数。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo2.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo2.cpp，此程序演示freecplus框架中STRNCPY函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRNCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;freecplus&quot;</span>,<span class="number">5</span>);  <span class="comment">// 待复制的内容没有超过str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=freec=</span></span><br><span class="line">  <span class="built_in">STRNCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www.freecplus.net&quot;</span>,<span class="number">8</span>);  <span class="comment">// 待复制的内容没有超过str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=www.free=</span></span><br><span class="line">  <span class="built_in">STRNCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www.freecplus.net&quot;</span>,<span class="number">17</span>);  <span class="comment">// 待复制的内容超过了str可以存放字符串的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-字符串拼接"><a class="markdownIt-Anchor" href="#三-字符串拼接"></a> 三、字符串拼接</h1><h2 id="1-strcat函数"><a class="markdownIt-Anchor" href="#1-strcat函数"></a> 1、STRCAT函数</h2><p>安全的strcat函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，注意，如果dest从未使过，那么需要至少一次初始化。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：待追加字符串。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo4.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo4.cpp，此程序演示freecplus框架中STRCAT函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.fr&quot;</span>);  <span class="comment">// str原有的内容加上待追加的内容没有超过str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);        <span class="comment">// 出输结果是str=www.fr=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;eecplus.net&quot;</span>);  <span class="comment">// str原有的内容加上待追加的内容超过了str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);                <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-strncat函数"><a class="markdownIt-Anchor" href="#2-strncat函数"></a> 2、STRNCAT函数</h2><p>安全的strncat函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：目标字符串，注意，如果dest从未使过，那么需要至少一次初始化。</p><p>destlen：目标字符串dest占用内存的大小。</p><p>src：待追加字符串。</p><p>n：待追加的字节数。</p><p>返回值：目标字符串dest的地址。</p><p><strong>示例（demo5.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo5.cpp，此程序演示freecplus框架中STRNCAT函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line">  <span class="built_in">STRNCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.free&quot;</span>,<span class="number">10</span>);  <span class="comment">// str原有的内容加上待追加的内容没有超过str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);              <span class="comment">// 出输结果是str=www.free=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line">  <span class="built_in">STRNCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.freecplus.net&quot;</span>,<span class="number">6</span>);  <span class="comment">// str原有的内容加上待追加的内容没有超过str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);                      <span class="comment">// 出输结果是str=www.freec=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;www&quot;</span>);</span><br><span class="line">  <span class="built_in">STRNCAT</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;.freecplus.net&quot;</span>,<span class="number">10</span>); <span class="comment">// str原有的内容加上待追加的内容超过了str可以存放的大小。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);                      <span class="comment">// 出输结果是str=www.freecp=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-格式化输出到字符串"><a class="markdownIt-Anchor" href="#四-格式化输出到字符串"></a> 四、格式化输出到字符串</h1><h2 id="1-sprintf函数"><a class="markdownIt-Anchor" href="#1-sprintf函数"></a> 1、SPRINTF函数</h2><p>安全的sprintf函数，将可变参数(…)按照fmt描述的格式输出到dest字符串中。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SPRINTF</span><span class="params">(<span class="type">char</span> *dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：输出字符串，不需要初始化，在SPRINTF函数中会对它进行初始化。</p><p>destlen：输出字符串dest占用内存的大小，如果格式化后的字符串内容的长度大于destlen-1，后面的内容将丢弃。</p><p>fmt：格式控制描述。</p><p>…：填充到格式控制描述fmt中的参数。</p><p>返回值：格式化后的内容的长度，程序员一般不关心返回值。</p><p><strong>示例（demo7.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo7.cpp，此程序演示freecplus框架中SPRINTF函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">21</span>];   <span class="comment">// 字符串str的大小是21字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:%s,no:%d&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:messi,no:10=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:%s,no:%d,job:%s&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>,<span class="string">&quot;striker&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:messi,no:10,job=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-snprintf函数"><a class="markdownIt-Anchor" href="#2-snprintf函数"></a> 2、SNPRINTF函数</h2><p>安全的snprintf函数，将可变参数(…)按照fmt描述的格式输出到dest字符串中。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SNPRINTF</span><span class="params">(<span class="type">char</span> *dest,<span class="type">const</span> <span class="type">size_t</span> destlen,<span class="type">size_t</span> n,<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>dest：输出字符串，不需要初始化，在SNPRINTF函数中会对它进行初始化。</p><p>destlen：输出字符串dest占用内存的大小，如果格式化后的字符串内容的长度大于destlen-1，后面的内容将丢弃。</p><p>n：把格式化后的字符串截取n-1存放到dest中，如果n&gt;destlen，则取destlen-1。</p><p>fmt：格式控制描述。</p><p>…：填充到格式控制描述fmt中的参数。</p><p>返回值：格式化后的内容的长度，程序员一般不关心返回值。</p><p><strong>示例（demo8.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo8.cpp，此程序演示freecplus框架中SNPRINTF函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">26</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SNPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="number">5</span>,<span class="string">&quot;messi&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=mess=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SNPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="number">9</span>,<span class="string">&quot;name:%s,no:%d,job:%s&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>,<span class="string">&quot;striker&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:mes=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SNPRINTF</span>(str,<span class="built_in">sizeof</span>(str),<span class="number">30</span>,<span class="string">&quot;name:%s,no:%d,job:%s&quot;</span>,<span class="string">&quot;messi&quot;</span>,<span class="number">10</span>,<span class="string">&quot;striker&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=name:messi,no:10,job:stri=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-删除字符串左-右和两边字符"><a class="markdownIt-Anchor" href="#五-删除字符串左-右和两边字符"></a> 五、删除字符串左、右和两边字符</h1><p>删除字符串左边、右边和两边指定的字符。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> chr)</span></span>;  <span class="comment">// 删除字符串左边指定的字符。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> chr)</span></span>;  <span class="comment">// 删除字符串右边指定的字符。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> chr)</span></span>; <span class="comment">// 删除字符串左右两边指定的字符。</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待处理的字符串。</p><p>chr：需要删除的字符。dest：输出字符串，不需要初始化，在SNPRINTF函数中会对它进行初始化。</p><p><strong>示例（demo10.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo10.cpp，此程序演示freecplus框架中删除字符串左、右、两边指定字符的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">11</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;  西施  &quot;</span>);</span><br><span class="line">  <span class="built_in">DeleteLChar</span>(str,<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 删除str左边的空格</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=西施  =</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;  西施  &quot;</span>);</span><br><span class="line">  <span class="built_in">DeleteRChar</span>(str,<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 删除str右边的空格</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=  西施=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;  西施  &quot;</span>);</span><br><span class="line">  <span class="built_in">DeleteLRChar</span>(str,<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 删除str两边的空格</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=西施=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果要删除字符串中间的字符，可以用freecplus框架中的UpdateStr函数，后面的章节中会介绍它。</p><h1 id="六-字符串大小写转换"><a class="markdownIt-Anchor" href="#六-字符串大小写转换"></a> 六、字符串大小写转换</h1><p>把字符串中的小写字母转换成大写，忽略不是字母的字符。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToUpper</span><span class="params">(<span class="type">char</span> *str)</span></span>;   <span class="comment">// 把字符串中的小写字母转换成大写,参数是C语言风格的char []。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToUpper</span><span class="params">(string &amp;str)</span></span>; <span class="comment">// 把字符串中的小写字母转换成大写,参数是C++语言风格的string。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToLower</span><span class="params">(<span class="type">char</span> *str)</span></span>;   <span class="comment">// 把字符串中的大写字母转换成小写,参数是C语言风格的char []。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToLower</span><span class="params">(string &amp;str)</span></span>; <span class="comment">// 把字符串中的大写字母转换成小写,参数是C++语言风格的string。</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待转换的字符串，函数重载了char[]和string两种数据类型。</p><p><strong>示例（demo12.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo12.cpp，此程序演示freecplus框架中字符串大小写转换函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str1[<span class="number">31</span>];   <span class="comment">// C语言风格的字符串。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str1,<span class="built_in">sizeof</span>(str1),<span class="string">&quot;12abz45ABz8西施。&quot;</span>);</span><br><span class="line">  <span class="built_in">ToUpper</span>(str1);      <span class="comment">// 把str1中的小写字母转换为大写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str1=%s=\n&quot;</span>,str1);    <span class="comment">// 出输结果是str1=12ABZ45ABZ8西施。=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str1,<span class="built_in">sizeof</span>(str1),<span class="string">&quot;12abz45ABz8西施。&quot;</span>);</span><br><span class="line">  <span class="built_in">ToLower</span>(str1);      <span class="comment">// 把str1中的大写字母转换为小写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str1=%s=\n&quot;</span>,str1);    <span class="comment">// 出输结果是str1=12abz45abz8西施。=</span></span><br><span class="line"></span><br><span class="line">  string str2;    <span class="comment">// C++语言风格的字符串。</span></span><br><span class="line"></span><br><span class="line">  str2=<span class="string">&quot;12abz45ABz8西施。&quot;</span>;</span><br><span class="line">  <span class="built_in">ToUpper</span>(str2);      <span class="comment">// 把str2中的小写字母转换为大写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str2=%s=\n&quot;</span>,str2.<span class="built_in">c_str</span>());    <span class="comment">// 出输结果是str2=12ABZ45ABZ8西施。=</span></span><br><span class="line"></span><br><span class="line">  str2=<span class="string">&quot;12abz45ABz8西施。&quot;</span>;</span><br><span class="line">  <span class="built_in">ToLower</span>(str2);      <span class="comment">// 把str2中的大写字母转换为小写。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str2=%s=\n&quot;</span>,str2.<span class="built_in">c_str</span>());    <span class="comment">// 出输结果是str1=12abz45abz8西施。=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七-字符串替换"><a class="markdownIt-Anchor" href="#七-字符串替换"></a> 七、字符串替换</h1><p>把字符串中的内容替换成其它的内容，在字符串str中，如果存在字符串str1，就替换为字符串str2。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateStr</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> *str1,<span class="type">const</span> <span class="type">char</span> *str2,<span class="type">const</span> <span class="type">bool</span> bLoop=<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待处理的字符串。</p><p>str1：旧的内容。</p><p>str2：新的内容。</p><p>bloop：是否循环执行替换。</p><p>注意：</p><p>1）如果str2比str1要长，替换后str会变长，所以必须保证str有足够的长度，否则内存会溢出。</p><p>2）如果str2中包函了str1的内容，且bloop为true，存在逻辑错误，将不执行任何替换。</p><p><strong>示例（demo14.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo14.cpp，此程序演示freecplus框架中字符串替换UpdateStr函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:messi,no:10,job:striker.&quot;</span>);</span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;:&quot;</span>,<span class="string">&quot;=&quot;</span>);    <span class="comment">// 把冒号替换成等号。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=name=messi,no=10,job=striker.=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;name:messi,no:10,job:striker.&quot;</span>);</span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;name:&quot;</span>,<span class="string">&quot;&quot;</span>);    <span class="comment">// 把&quot;name:&quot;替换成&quot;&quot;，相当于删除内容&quot;name:&quot;。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi,no:10,job:striker.=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi----10----striker&quot;</span>);  </span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="literal">false</span>);    <span class="comment">// 把两个&quot;--&quot;替换成一个&quot;-&quot;，bLoop参数为false。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi--10--striker=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi----10----striker&quot;</span>);  </span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="literal">true</span>);    <span class="comment">// 把两个&quot;--&quot;替换成一个&quot;-&quot;，bLoop参数为true。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi-10-striker=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi-10-striker&quot;</span>);  </span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="literal">false</span>);    <span class="comment">// 把一个&quot;-&quot;替换成两个&quot;--&quot;，bLoop参数为false。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi--10--striker=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;messi-10-striker&quot;</span>);  </span><br><span class="line">  <span class="comment">// 以下代码把&quot;-&quot;替换成&quot;--&quot;，bloop参数为true，存在逻辑错误，UpdateStr将不执行替换。</span></span><br><span class="line">  <span class="built_in">UpdateStr</span>(str,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="literal">true</span>);    <span class="comment">// 把一个&quot;-&quot;替换成两个&quot;--&quot;，bloop参数为true。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str1=messi-10-striker=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八-从字符串中提取数字"><a class="markdownIt-Anchor" href="#八-从字符串中提取数字"></a> 八、从字符串中提取数字</h1><p>从一个字符串中提取出数字、符号和小数点，存放到另一个字符串中。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PickNumber</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *src,<span class="type">char</span> *dest,<span class="type">const</span> <span class="type">bool</span> bsigned,<span class="type">const</span> <span class="type">bool</span> bdot)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>src：源字符串。</p><p>dest：目标字符串。</p><p>bsigned：是否包括符号（+和-），true-包括；false-不包括。</p><p>bdot：是否包括小数点的圆点符号，true-包括；false-不包括。</p><p><strong>示例（demo16.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo16.cpp，此程序演示freecplus框架中PickNumber函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">26</span>];   <span class="comment">// 字符串str的大小是11字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;iab+12.3xy&quot;</span>);</span><br><span class="line">  <span class="built_in">PickNumber</span>(str,str,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=123=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;iab+12.3xy&quot;</span>);</span><br><span class="line">  <span class="built_in">PickNumber</span>(str,str,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=+123=</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(str,<span class="built_in">sizeof</span>(str),<span class="string">&quot;iab+12.3xy&quot;</span>);</span><br><span class="line">  <span class="built_in">PickNumber</span>(str,str,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);    <span class="comment">// 出输结果是str=-12.3=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九-正则表达式"><a class="markdownIt-Anchor" href="#九-正则表达式"></a> 九、正则表达式</h1><p>正则表达式，判断一个字符串是否匹配另一个字符串。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MatchStr</span><span class="params">(<span class="type">const</span> string str,<span class="type">const</span> string rules)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：需要判断的字符串，精确表示的字符串，如文件名&quot;_freecplus.cpp&quot;。</p><p>rules：匹配规则表达式，用星号&quot;*“表示任意字符串，多个字符串之间用半角的逗号分隔，如”*.h,*.cpp&quot;。</p><p>注意，str参数不支持&quot;?“，rules只支持”*&quot;，函数在判断str是否匹配rules的时候，会忽略字母的大小写。</p><p><strong>示例（demo18.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo18.cpp，此程序演示freecplus框架正则表达示MatchStr函数的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> filename[<span class="number">301</span>];  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(filename,<span class="built_in">sizeof</span>(filename),<span class="string">&quot;_freecplus.h&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 以下代码将输出yes。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">MatchStr</span>(filename,<span class="string">&quot;*.h,*.cpp&quot;</span>)==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码将输出yes。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">MatchStr</span>(filename,<span class="string">&quot;*.H&quot;</span>)==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码将输出no。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">MatchStr</span>(filename,<span class="string">&quot;*.cpp&quot;</span>)==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十-字符串的拆分"><a class="markdownIt-Anchor" href="#十-字符串的拆分"></a> 十、字符串的拆分</h1><p>CCmdStr类用于拆分用分隔符分隔字段内容的字符串。</p><p>字符串的格式为：字段内容1+分隔符+字段内容2+分隔符+字段内容3+分隔符+…+字段内容n。</p><p>例如：“messi,10,striker,30,1.72,68.5,Barcelona”，这是足球运动员梅西的资料，包括姓名、球衣号码、场上位置、年龄、身高、体重和效力的俱乐部，字段之间用半角的逗号分隔开。</p><p>CCmdStr类的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CCmdStr类用于拆分用分隔符分隔字段的字符串。</span></span><br><span class="line"><span class="comment">// 字符串的格式为：字段内容1+分隔符+字段内容2+分隔符+字段内容3+分隔符+...+字段内容n。</span></span><br><span class="line"><span class="comment">// 例如：&quot;messi,10,striker,30,1.72,68.5,Barcelona&quot;，这是足球运动员梅西的资料，包括姓名、</span></span><br><span class="line"><span class="comment">// 球衣号码、场上位置、年龄、身高、体重和效力的俱乐部，字段之间用半角的逗号分隔开。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCmdStr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;string&gt; m_vCmdStr;  <span class="comment">// 存放拆分后的字段内容。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CCmdStr</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把字符串拆分到m_vCmdStr容器中。</span></span><br><span class="line">  <span class="comment">// buffer：待拆分的字符串。</span></span><br><span class="line">  <span class="comment">// sepstr：buffer字符串中字段内容的分隔符，注意，分隔符是字符串，如&quot;,&quot;、&quot; &quot;、&quot;|&quot;、&quot;~!~&quot;。</span></span><br><span class="line">  <span class="comment">// bdelspace：是否删除拆分后的字段内容前后的空格，true-删除；false-不删除，缺省删除。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SplitToCmd</span><span class="params">(<span class="type">const</span> string buffer,<span class="type">const</span> <span class="type">char</span> *sepstr,<span class="type">const</span> <span class="type">bool</span> bdelspace=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取拆分后字段的个数，即m_vCmdStr容器的大小。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">CmdCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从m_vCmdStr容器获取字段内容。</span></span><br><span class="line">  <span class="comment">// inum：字段的顺序号，类似数组，从0开始。</span></span><br><span class="line">  <span class="comment">// value：传入变量的地址，用于存放字段内容。</span></span><br><span class="line">  <span class="comment">// 返回值：true-获取成功；false-获取失败。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">char</span>   *value,<span class="type">const</span> <span class="type">int</span> ilen=<span class="number">0</span>)</span></span>; <span class="comment">// 字符串，ilen缺省值为0。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">int</span>    *value)</span></span>; <span class="comment">// int整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">unsigned</span> <span class="type">int</span> *value)</span></span>; <span class="comment">// unsigned int整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">long</span>   *value)</span></span>; <span class="comment">// long整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">unsigned</span> <span class="type">long</span> *value)</span></span>; <span class="comment">// unsigned long整数。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">double</span> *value)</span></span>; <span class="comment">// 双精度double。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">GetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> inum,<span class="type">bool</span>   *value)</span></span>; <span class="comment">// bool型。</span></span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CCmdStr</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>示例（demo20.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo20.cpp，此程序演示freecplus框架拆分字符串的类CCmdStr的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存放足球运动员资料的结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_player</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">char</span> no[<span class="number">6</span>];       <span class="comment">// 球衣号码</span></span><br><span class="line">  <span class="type">bool</span> striker;     <span class="comment">// 场上位置是否是前锋，true-是；false-不是。</span></span><br><span class="line">  <span class="type">int</span>  age;         <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">double</span> weight;    <span class="comment">// 体重，kg。</span></span><br><span class="line">  <span class="type">long</span> sal;         <span class="comment">// 年薪，欧元。</span></span><br><span class="line">  <span class="type">char</span> club[<span class="number">51</span>];    <span class="comment">// 效力的俱乐部</span></span><br><span class="line">&#125;stplayer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;stplayer,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_player));</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">301</span>];  </span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;messi,10,true,30,68.5,2100000,Barcelona&quot;</span>);</span><br><span class="line"></span><br><span class="line">  CCmdStr CmdStr;</span><br><span class="line">  CmdStr.<span class="built_in">SplitToCmd</span>(buffer,<span class="string">&quot;,&quot;</span>);        <span class="comment">// 拆分buffer</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">0</span>, stplayer.name,<span class="number">50</span>); <span class="comment">// 获取姓名</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">1</span>, stplayer.no,<span class="number">5</span>);    <span class="comment">// 获取球衣号码</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">2</span>,&amp;stplayer.striker); <span class="comment">// 场上位置</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">3</span>,&amp;stplayer.age);     <span class="comment">// 获取年龄</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">4</span>,&amp;stplayer.weight);  <span class="comment">// 获取体重</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">5</span>,&amp;stplayer.sal);     <span class="comment">// 获取年薪，欧元。</span></span><br><span class="line">  CmdStr.<span class="built_in">GetValue</span>(<span class="number">6</span>, stplayer.club,<span class="number">50</span>); <span class="comment">// 获取效力的俱乐部</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,no=%s,striker=%d,age=%d,weight=%.1f,sal=%ld,club=%s\n&quot;</span>,\</span><br><span class="line">         stplayer.name,stplayer.no,stplayer.striker,stplayer.age,\</span><br><span class="line">         stplayer.weight,stplayer.sal,stplayer.club);</span><br><span class="line">  <span class="comment">// 输出结果:name=messi,no=10,striker=1,age=30,weight=68.5,sal=21000000,club=Barcelona</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十一-统计字符串的字数"><a class="markdownIt-Anchor" href="#十一-统计字符串的字数"></a> 十一、统计字符串的字数</h1><p>统计字符串的字数，全角的汉字和全角的标点符号算一个字，半角的汉字和半角的标点符号也算一个字。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Words</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>str：待统计的字符串。</p><p>返回值：字符串str的字数。</p><p>注意事项，本函数只适用用于Linux字符集为GBK的情况，在GB18030和Unicode编码中，汉字不一定是两个字节。</p><p><strong>示例（demo21.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：demo21.cpp，此程序演示freecplus框架的统计字符串字数的函数。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../_freecplus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">301</span>];</span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;messi,10,true,30,68.5,2100000,Barcelona。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;words=%d\n&quot;</span>,<span class="built_in">Words</span>(buffer)); <span class="comment">// 输出结果:words=40</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(buffer,<span class="built_in">sizeof</span>(buffer),<span class="string">&quot;梅西,10,true,30,68.5,2100000,Barcelona。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;words=%d\n&quot;</span>,<span class="built_in">Words</span>(buffer)); <span class="comment">// 输出结果:words=37</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十二-版权声明"><a class="markdownIt-Anchor" href="#十二-版权声明"></a> 十二、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库开机自启动的配置</title>
      <link href="/posts/37b00fb8.html"/>
      <url>/posts/37b00fb8.html</url>
      
        <content type="html"><![CDATA[<p>如果服务器断电重启或计划内重启，在服务器的操作系统启动后，需要手工启动数据库实例和监听，本文介绍如何把Oracle数据库的启动和关闭配置成系统服务，在操作系统启动/关闭时，自动启动/关闭Oracle实例和监听。</p><p>假设ORACLE_HOME环境变量的值是/oracle/home。</p><h2 id="1-启动数据库实例的shell脚本"><a class="markdownIt-Anchor" href="#1-启动数据库实例的shell脚本"></a> 1、启动数据库实例的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbstart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="2-重启数据库实例的shell脚本"><a class="markdownIt-Anchor" href="#2-重启数据库实例的shell脚本"></a> 2、重启数据库实例的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbrestart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="3-关闭数据库实例的shell脚本"><a class="markdownIt-Anchor" href="#3-关闭数据库实例的shell脚本"></a> 3、关闭数据库实例的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbshut，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="4-oracle实例的系统服务配置文件脚本"><a class="markdownIt-Anchor" href="#4-oracle实例的系统服务配置文件脚本"></a> 4、oracle实例的系统服务配置文件脚本</h2><p>如果把系统服务命名为oracle，则创建服务配置文件/usr/lib/systemd/system/oracle.service，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle RDBMS</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbstart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbrestart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbshut \&gt;\&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="5-lsnrctl监听的系统服务配置文件脚本"><a class="markdownIt-Anchor" href="#5-lsnrctl监听的系统服务配置文件脚本"></a> 5、lsnrctl监听的系统服务配置文件脚本</h2><p>如果把系统服务命名为lsnrctl，则创建服务配置文件/usr/lib/systemd/system/lsnrctl.service，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle lsnrctl</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/lsnrctl start &gt;&gt; /tmp/lsnrctl.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/lsnrctl reload &gt;&gt; /tmp/lsnrctl.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/lsnrctl stop &gt;&gt; /tmp/lsnrctl.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="6-重新加载服务配置文件"><a class="markdownIt-Anchor" href="#6-重新加载服务配置文件"></a> 6、重新加载服务配置文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="7-启动停止启重oracle和lsnrctl服务"><a class="markdownIt-Anchor" href="#7-启动停止启重oracle和lsnrctl服务"></a> 7、启动/停止/启重oracle和lsnrctl服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start oracle # 启动oracle服务。</span><br><span class="line">systemctl restart oracle # 重启oracle服务。</span><br><span class="line">systemctl stop oracle # 关闭oracle服务。</span><br><span class="line">systemctl start lsnrctl # 启动lsnrctl服务。</span><br><span class="line">systemctl restart lsnrctl # 重启lsnrctl服务。。</span><br><span class="line">systemctl stop lsnrctl # 关闭lsnrctl服务。</span><br></pre></td></tr></table></figure><h2 id="8-把oracle和lsnrctl服务设置为开机关机自启动停止"><a class="markdownIt-Anchor" href="#8-把oracle和lsnrctl服务设置为开机关机自启动停止"></a> 8、把oracle和lsnrctl服务设置为开机/关机自启动/停止</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable oracle # 把Oracle实例服务设置为开机自启动。</span><br><span class="line">systemctl enable lsnrctl # 把Oracle监听服务设置为开机自启动。</span><br></pre></td></tr></table></figure><h2 id="9-查看oracle实例和监听启动停止的日志"><a class="markdownIt-Anchor" href="#9-查看oracle实例和监听启动停止的日志"></a> 9、查看Oracle实例和监听启动/停止的日志。</h2><p>Oracle实例启动的日志在/tmp/oracle.log文件中。</p><p>监听的启动日成在/tmp/lsnrctl.log文件中。</p><p>注意，只有通过systemctl启动/关闭Oracle实例和监听才会写日志，手工执行脚本不写日志。</p><h2 id="10-版权声明"><a class="markdownIt-Anchor" href="#10-版权声明"></a> 10、版权声明</h2><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据字典</title>
      <link href="/posts/3fa9fcba.html"/>
      <url>/posts/3fa9fcba.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h1><p>Oracle通过数据字典来管理和展现数据库信息，数据字典储存数据库的元数据，是数据库的“数据库”。数据字典由4部分组成：内部RDBMS（X$）表、数据字典表、动态性能视图（V$）和（静态）数据字典视图。</p><p>数据字典系统表，保存在system表空间中。执行以下语句可以查询所有数据字典：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from dictionary;</span><br></pre></td></tr></table></figure><h1 id="二-内部rdbmsx表"><a class="markdownIt-Anchor" href="#二-内部rdbmsx表"></a> 二、内部RDBMS（X$）表</h1><p>X$表示Oracle数据库的核心部分，这些表用于跟踪数据库内部信息，维持数据库的正常运行。X$表是加密命名的，而且Oracle不做文档说明，也不允许sysdba以外的用户直接访问，显示授权不被允许。X$表是Oracle数据库的运行基础，在数据库启动时由Oracle应用程序动态创建。</p><h1 id="三-动态性能视图"><a class="markdownIt-Anchor" href="#三-动态性能视图"></a> 三、动态性能视图</h1><p>动态性能视图记录了数据库运行时信息和统计数据，大部分动态性能视图被实时更新以及反映数据库当前状态。在数据库启动时，Oracle动态创建X$表，在此基础上，Oracle创建了GV$和V$视图，GV$即Global V$，除了一些特例外，每个V$都对应一个GV$。GV$产生是为了OPS/RAC环境的需要，每个V$都是基于GV$的，只是GV$多了INST_ID列来显示实例ID。</p><p>v$database数据库信息</p><p>v$datafile数据文件信息</p><p>v$controlfile控制文件信息</p><p>v$logfile重做日志信息</p><p>v$instance数据库实例信息</p><p>v$log日志组信息</p><p>v$loghist日志历史信息</p><p>v$sga数据库SGA信息</p><p>v$parameter初始化参数信息</p><p>v$process数据库服务器进程信息</p><p>v$bgprocess数据库后台进程信息</p><p>v$controlfile_record_section控制文件记载的各部分信息</p><p>v$thread线程信息</p><p>v$datafile_header数据文件头所记载的信息</p><p>v$archived_log归档日志信息</p><p>v$archive_dest归档日志的设置信息</p><p>v$logmnr_contents归档日志分析的DMLDDL结果信息</p><p>v$logmnr_dictionary日志分析的字典文件信息</p><p>v$logmnr_logs日志分析的日志列表信息</p><p>v$tablespace表空间信息</p><p>v$tempfile临时文件信息</p><p>v$filestat数据文件的I/O统计信息</p><p>v$undostatUndo数据信息</p><p>v$rollname在线回滚段信息</p><p>v$session会话信息</p><p>v$transaction事务信息</p><p>v$rollstat回滚段统计信息</p><p>v$pwfile_users特权用户信息</p><p>v$sqlarea当前查询过的sql语句访问过的资源及相关的信息</p><p>v$sql与v$sqlarea基本相同的相关信息</p><p>v$sysstat数据库系统状态信息</p><h1 id="四-数据字典表"><a class="markdownIt-Anchor" href="#四-数据字典表"></a> 四、数据字典表</h1><p>数据字典表（Data dictionary<br />table）用以存储表、索引、约束以及其它数据库结构的信息，这些对象通常以“$”结尾（例如：TAB$、OBJ$、TS$等），在创建数据库的时候通过运行$ORACLE_HOME/rdbms/admin/sql.bsq脚本来创建。</p><h1 id="五-静态数据字典视图"><a class="markdownIt-Anchor" href="#五-静态数据字典视图"></a> 五、静态数据字典视图</h1><p>由于X$表和数据字典表通常不能直接被用户访问，Oracle创建了静态数据字典视图来提供用户对于数据字典信息的访问，由于这些信息通常相对稳定，不能直接修改，所以又被称为静态数据字典视图。静态数据字典视图在创建数据库时由$ORACLE_HOME/rdbms/admin/catagory.sql脚本创建。</p><p>静态数据字典视图按照前缀的不同通常分成三类，在本质上是为了实现权限控制。在Oracle数据库中，每个用户与方案（Schema）是对应的，Schema是用户所拥有的对象的集合。数据库通过Schema将不同用户的对象隔离开来，用户可以自由的访问自己的对象，但是要访问其他Schema对象就需要相关的授权。</p><h2 id="1-user_用户所拥有的相关对象信息"><a class="markdownIt-Anchor" href="#1-user_用户所拥有的相关对象信息"></a> 1、USER_*（用户所拥有的相关对象信息）</h2><p>user_objects用户对象信息</p><p>user_source数据库用户的所有资源对象信息</p><p>user_segments用户的表段信息</p><p>user_tables用户的表对象信息</p><p>user_tab_columns用户的表列信息</p><p>user_constraints用户的对象约束信息</p><p>user_sys_privs当前用户的系统权限信息</p><p>user_tab_privs当前用户的对象权限信息</p><p>user_col_privs当前用户的表列权限信息</p><p>user_role_privs当前用户的角色权限信息</p><p>user_indexes用户的索引信息</p><p>user_ind_columns用户的索引对应的表列信息</p><p>user_cons_columns用户的约束对应的表列信息</p><p>user_clusters用户的所有簇信息</p><p>user_clu_columns用户的簇所包含的内容信息</p><p>user_cluster_hash_expressions散列簇的信息</p><h2 id="2-all_用于有权限访问的所有对象的信息"><a class="markdownIt-Anchor" href="#2-all_用于有权限访问的所有对象的信息"></a> 2、ALL_*（用于有权限访问的所有对象的信息）</h2><p>all_users数据库所有用户的信息</p><p>all_objects数据库所有的对象的信息</p><p>all_def_audit_opts所有默认的审计设置信息</p><p>all_tables所有的表对象信息</p><p>all_indexes所有的数据库对象索引的信息</p><h2 id="3-dba_数据库所有相关对象的信息"><a class="markdownIt-Anchor" href="#3-dba_数据库所有相关对象的信息"></a> 3、DBA_（数据库所有相关对象的信息）</h2><p>dba_users数据库用户信息</p><p>dba_segments表段信息</p><p>dba_extents数据区信息</p><p>dba_objects数据库对象信息</p><p>dba_tablespaces数据库表空间信息</p><p>dba_data_files数据文件设置信息</p><p>dba_temp_files临时数据文件信息</p><p>dba_rollback_segs回滚段信息</p><p>dba_ts_quotas用户表空间配额信息</p><p>dba_free_space数据库空闲空间信息</p><p>dba_profiles数据库用户资源限制信息</p><p>dba_sys_privs用户的系统权限信息</p><p>dba_tab_privs用户具有的对象权限信息</p><p>dba_col_privs用户具有的列对象权限信息</p><p>dba_role_privs用户具有的角色信息</p><p>dba_audit_trail审计跟踪记录信息</p><p>dba_stmt_audit_opts审计设置信息</p><p>dba_audit_object对象审计结果信息</p><p>dba_audit_session会话审计结果信息</p><p>dba_indexes用户模式的索引信息</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的体系结构</title>
      <link href="/posts/9230b8a1.html"/>
      <url>/posts/9230b8a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h1><p>Oracle的体系结构是数据库的组成、工作过程，以及数据库中数据的组织和管理机制，包含一系列组件（软件）、用户进程（User process）、服务进程（Server process、PGA）、SGA（共享池、数据缓存、日志缓冲区）、后台进程（SMON、DBWn、PMON、CKPT、LGWR、其它进程）、参数文件（Parameter file）、密码文件（Password）、数据文件（Data files）、控制文件（Control files）、在线重做日志文件（Redo log files）、归档日志文件（Archived log files）。</p><p><img src="https://img-blog.csdnimg.cn/20200313101507515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="二-用户进程和服务进程"><a class="markdownIt-Anchor" href="#二-用户进程和服务进程"></a> 二、用户进程和服务进程</h1><h2 id="1-用户进程"><a class="markdownIt-Anchor" href="#1-用户进程"></a> 1、用户进程</h2><p>用户进程（User process），是指用户通过客户端，比如SQL Plus、PL/SQL Developer、SQL Load、应用程序等工具连接上Oracle数据库而产生的进程。用户进程处理用户输入并与服务器进程通信。用户进程还负责表现用户请求的信息，必要时可以将信息处置成更可用的形式。</p><h2 id="2-服务进程"><a class="markdownIt-Anchor" href="#2-服务进程"></a> 2、服务进程</h2><p>服务进程（Server Process），当客户端发起连接时，Oracle创建一个用户进程来处理这个连接。</p><p>用户进程启动后，Oracle还会创建一个服务进程来处理连接到实例的用户进程提交的请求。用户进程连接到数据库并创建一个会话时，Oracle服务器进程会分配专门用于当前用户会话的内存区，即PGA区，该区域是私有的，当进程创建时分配，进程结束后被释放，只能被一个服务进程使用。</p><p>以客户端执行一条SQL为例：</p><p>1）服务进程接收SQL语句；</p><p>2）服务进程去共享池找SQL和执行计划，如果没找到，则解析SQL；</p><p>3）服务进程根据执行计划去数据缓存中找相关的数据，如没有才到数据文件中取出数据放到数据缓存中，再返给客户端；</p><p>4）若需要修改数据，服务进程把数据读取到数据缓存后再修改数据，修改后返给客户端。</p><p>用户进程与服务器进程可以是一对一的关系（配置为专用服务器模式时）。一个服务器也可连接多个用户进程（配置为多线程服务器时），但这样做会减少对系统资源的占用。</p><h1 id="三-系统全局区sga"><a class="markdownIt-Anchor" href="#三-系统全局区sga"></a> 三、系统全局区SGA</h1><p>系统全局区SGA（System Global Area），是Oracle实例的重要组成部分，在实例启动时分配，是一组包含Oracle数据和控制信息的共享内存。一个SGA只属于一个实例，也就是说，当一个服务器上有多个实例运行时，每个实例都有一个自己的SGA，实例之间不能相互访问。SGA包括共享池（Share pool）、数据缓存（Data buffer cache）和重做日志缓冲区（Redo log buffer），其中共享池又包括Library cache（库缓存）和Data dict cache（数据字典缓存）。</p><h1 id="四-后台进程"><a class="markdownIt-Anchor" href="#四-后台进程"></a> 四、后台进程</h1><p>Oracle后台进程是一组运行于Oracle服务器端的后台程序，也是Oracle实例的重要组成部分。这些后台进程分别完成不同的功能。其中SMON、PMON、DBWR、LGWR和CKPT这5个后台进程必须正常启动，否则数据库实例无法工作。此外，还有很多辅助进程，用于实现辅助的功能，如果这些辅助进程发生问题，只会使某些功能受到影响，数据库实例仍是可用的。</p><p>1）数据写入进程（DBWR）</p><p>数据写入进程的主要任务是负责将内存中的“脏”数据块回写到数据文件中。“脏”数据块是指高速数据缓冲区中的被修改过的数据块，这些数据块的内容与数据文件的数据块内容不一致。但DBWR并不是随时将所有的“脏”数据块都写入数据文件，只有满足一定的条件时，DBWR进程才开始成批量的将“脏”数据块写入数据文件Oracle这样做的目的是为了尽量减少I/O操作，提高Oracle服务器性能。</p><p>2）检查点进程（CKPT）</p><p>检查点进程可以看作一个事件，当检查点事件发生时，CKPT会要求DBWR将某些“脏”数据块回写到数据文件。当用户进程发出数据请求时，Oracle系统从数据文件中读取需要的数据并存放到高速数据缓冲区中，用户对数据的操作时在缓冲区中进行的。当用户操作数据时，就会产生大量的日志信息并存储在重做日志缓冲区，当Oracle系统满足一定条件时，日志写入进程（LGWR）会将日志信息写入到重做日志文件组中，当发生日志切换时（写入操作正要从一个日志文件组切换到另一组时），就会启动检查点进程。</p><p>另外，DBA还可以通过修改初始化参数文件SPFILE中的CHECKPOINT_PROCESS参数为TRUE来启动检查点进程。</p><p>3）日志写入进程（LGWR）</p><p>日志写入进程用于将重做日志缓冲区中的数据写入重做日志文件。Oracle系统将用户所做的修改日志信息写入日志文件，然后将修改结果写入数据文件。</p><p>Oracle实例在运行中会产生大量日志信息，这些日志信息首先被记录在SGA的重做日志缓冲区中，当发生提交命令、或者重做日志缓冲区的信息满1/3、或者日志信息存放超过3秒钟时，LGWR进程就将日志信息从重做日志缓冲区中读出并写入日志文件组中序号较小的文件中，一个日志组写满后接着写另外一组。当LGWR进程将所有䣌日志文件都写过一遍后，它将再次转向第一个日志文件组重新覆盖。</p><p>4）归档进程（ARCH）</p><p>归档进程是一个可选择的进程，只有当Oracle数据库处于归档模式时，该进程才可能起到作用。若Oracle数据库处于归档模式，当各个日志文件组都被写满即将被覆盖之前，先由归档进程（ARCH）把即将覆盖的日志文件中的日志信息读出，然后再把这些“读出的日志信息”写入到归档日志文件中。</p><p>当系统比较繁忙而导致LGWR进程处于等待ARCH进程时，可通过修改LOG_ARCHIVE_MAX_PROCESSES参数启动多个归档进程，从而提高归档写磁盘的速度。</p><p>5）系统监控进程（SMON）</p><p>系统监控进程是在数据库启动时执行恢复工作的强制性进程。比如，在并行服务器模式下，SMON可以恢复另一个处于失败的数据库，使系统切换到另外一台正常的服务器上。</p><p>6）进程监控进程（PMON）</p><p>进程监控进程用于监控其他进程的状态，当有进程启动失败时，PMON会清除失败的用户进程，用于数据不一致时进行恢复工作。</p><p>7）锁定进程（LCKN）</p><p>这是一个可选进程，并行服务器模式下可以出现多个锁定进程以利于数据库通信。</p><p>8）恢复进程（RECO）</p><p>这是在分布式数据库模式下使用的一个可选进程，用于数据不一致时进行恢复工作。</p><p>9）调度进程（DNNN）</p><p>这是一个可选进程，在共享服务器模式下使用，可以启动多个调度进程。</p><p>10）快照进程（SNPN）：</p><p>快照进程用于处理数据库快照的自动刷新，并通过DBMS_JOB包运行预定的数据库存储过程。</p><h1 id="五-存储结构"><a class="markdownIt-Anchor" href="#五-存储结构"></a> 五、存储结构</h1><p>Oracle分为逻辑存储结构和物理存储结构，逻辑存储结构用来描述Oracle内部组织和管理数据的方式，是一种层次结构，是面向用户的；物理存储结构是实际的数据存储单元，就是数据库存放在操作系统上的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200313101809756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="1-逻辑存储结构"><a class="markdownIt-Anchor" href="#1-逻辑存储结构"></a> 1、逻辑存储结构</h2><p>Oracle数据库中的数据文件被分组到一个或多个表空间中。在每个表空间中，逻辑数据库结构（如表和索引）都是片段，被进一步细分为“盘区”（extent）和“块”（block）。这种存储的逻辑细分c让Oracle更有效的控制磁盘。</p><p>1）表空间</p><p>表空间是Oracle数据库的最大逻辑划分区域，常用来存放数据表，索引等数据对象，任何实体对象在创建时必须指定表空间。</p><p>表空间与数据文件相对应，一个表空间由一个或多个数据文件组成，一个数据文件只属于一个表空间。</p><p>Oracle数据的存储空间在逻辑上变现为表空间而在物理上表现为数据文件，表空间相当于文件夹，数据文件相当于文件夹中的文件。</p><p>2）段</p><p>数据库中的下一个逻辑分组级别是段。段是一组盘区，这组盘区组成了被Oracle视为一个单位的数据库对象，如表或索引。因此，段一般是数据库终端用户要处理的最小存储单位。Oracle数据库中可看到4种类型的段：数据段（非分区表和分区表的每个分区）、索引段、临时段和回滚段。</p><p>3）盘区</p><p>它由一个或多个数据库块组成。当扩大数据库对象时，为该对象添加的空间将分配为一个盘区。</p><p>4）块</p><p>数据库块是Oracle数据库最小的存储单位。块的大小是数据库内给定表空间中特定数量的存储字节。默认块大小是8KB。</p><h2 id="2-物理存储结构"><a class="markdownIt-Anchor" href="#2-物理存储结构"></a> 2、物理存储结构</h2><p>1）数据文件</p><p>数据文件用于存储数据库中的所有数据，包含系统数据、数据字典数据、临时数据、索引数据、应用数据等。</p><p>安装Oracle数据库时系统会自动为数据库创建几个数据文件，用户对数据库的操作本质是对数据文件的操作。一个表空间可以对应多个数据文件，一个数据文件只能从属于一个表空间。在逻辑上，数据对象都存放在表空间中，实质上是存放在空间对应的数据文件中。</p><p>2）控制文件</p><p>每个Oracle数据库有一组控制文件(control file)，用于记录和描述数据库的物理存储结构信息，包含数据库名、数据库数据文件和日志文件的名字和位置和数据库的时间戳。</p><p>3）参数文件</p><p>参数文件用于设置数据库启动时的参数初始值。</p><p>4）密码文件：</p><p>用于保存具有SYSDBA、SYSOPER权限的用户名和SYS用户密码。</p><p>5）日志文件</p><p>Oracle以SQL脚本的形式实时记录了数据变化的详细日志，这些日志保存在重做日志文件中。根据重做日志文件，可以对数据库进行备份和恢复。</p><p>日志文件有两种：在线日志和归档日志。</p><p>创建Oracle数据库实例的时候，缺省建立三组在线日志，每组一个日志文件。三组日志中只有一组处于活动状态，这组活动的日志也称为当前日志，数据库不断的往当前日志里写入SQL脚本，当前日志写满后，Oracle会切换到下一组日志，继续写入，就这样循环切换。</p><p>日志组在切换时，如果数据库是归档模式，则将当前日志文件的内容转存为操作系统文件，成为归档日志；若当前数据库是非归档模式，则不进行归档操作，当前日志文件中的内容会被下一次覆盖。</p><p>如果数据库运行在归档模式下，当数据库出现介质失败时，使用备份文件、归档日志和在线日志可以完全恢复数据库。</p><p>6）跟踪文件</p><p>用户记录用户进程、数据库后台进程的运行情况。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle字符集的设置</title>
      <link href="/posts/19200837.html"/>
      <url>/posts/19200837.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-字符集的概念"><a class="markdownIt-Anchor" href="#一-字符集的概念"></a> 一、字符集的概念</h1><h2 id="1-字符编码character-encoding"><a class="markdownIt-Anchor" href="#1-字符编码character-encoding"></a> 1、字符编码（character encoding）：</h2><p>字符编码是一种法则，在数字与符号之间建立的对应关系。不同的国家有不同的语言，包含的文字、标点符号、图形符号各有不同。例如在ASCII编码中，用数字97表达字符’a’与字符集相对应，常见的字符编码有ASCII，GBK，GB18030，Unicode等。</p><h2 id="2-字符集character-set"><a class="markdownIt-Anchor" href="#2-字符集character-set"></a> 2、字符集（Character set）</h2><p>字符集是字符的集合，字符是文字和符号的总称，用ASCII编码的字符集称之为ASCII字符集，用GBK编码的字符集称之为GBK字符集。</p><h2 id="3-国际编码unicode"><a class="markdownIt-Anchor" href="#3-国际编码unicode"></a> 3、国际编码（Unicode）</h2><p>为了解决传统的字符编码方案的局限，1994年发布了Unicode（国际编码、统一码、万国码、单一码、通用码），它是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 将全世界所有的字符统一化，统一编码，再也不存在字符集不兼容和字符转换的问题。</p><p>Unicode 有以下三种编码方式：</p><p>1）UTF-8：兼容ASCII编码；拉丁文、希腊文等使用两个字节；包括汉字在内的其它常用字符使用三个字节；剩下的极少使用的字符使用四个字节。</p><p>2）UTF-16：对相对常用的60000余个字符使用两个字节进行编码，其余的使用4字节。</p><p>3）UTF-32：固定使用4个字节来表示一个字符，存在空间利用效率的问题。</p><h2 id="4-汉字的编码"><a class="markdownIt-Anchor" href="#4-汉字的编码"></a> 4、汉字的编码</h2><p>支持汉字（简体中文）的编码有GB2312、GB13000、GBK、GB18030和Unicode（UTF-8、UTF-16、UTF-32）。</p><p>1）GB2312</p><p>仅包含大部分的常用简体汉字，但已经不能适应现在的需要。</p><p>2）GB13000</p><p>由于GB2312的局限性，国家标准化委员会制定了GB13000编码；但由于当时的硬件和软件都已经支持了GB2312，而GB13000与GB2312完全不兼容，所以没有能够得到大范围的推广使用。</p><p>3）GBK</p><p>有了GB13000的教训，中国国家标准化委员会制定了GBK标准，并兼容了GB2312标准，同时在GB2312标准的基础上扩展了GB13000包含的字；由于该标准有微软的支持，得到了广泛的应用。</p><p>4）GB18030</p><p>GB18030编码比GBK又新增了几千个汉字，但由于码位不足使用了2byte与4byte混合编码方式，这给软件开发增加了难度。</p><p>5）Unicode</p><p>包含全世界所有国家需要用到的字符，是国际编码，通用性强。</p><h2 id="5-汉字的编码选择"><a class="markdownIt-Anchor" href="#5-汉字的编码选择"></a> 5、汉字的编码选择</h2><p>在操作系统和数据库中，常用的汉字编码有GBK、GB18030和Unicode，GBK和GB18030的优势是占用空间小，Unicode的优势是全球化的支持。</p><p>在应用开发中，如果不考虑全球化，最好的选择是GBK和GB18030。</p><h2 id="6-编码的转换"><a class="markdownIt-Anchor" href="#6-编码的转换"></a> 6、编码的转换</h2><p>GBK和GB18030与Unicode编码之间需要转换，否则会出现汉字乱码。</p><h1 id="二-oracle的字符集"><a class="markdownIt-Anchor" href="#二-oracle的字符集"></a> 二、Oracle的字符集</h1><h2 id="1-字符集和国家字符集"><a class="markdownIt-Anchor" href="#1-字符集和国家字符集"></a> 1、字符集和国家字符集</h2><p>字符集在创建数据库实例时指定，可以指定字符集（CHARACTER SET）和国家字符集（NATIONAL CHARACTER SET）。</p><p>1）字符集（CHARACTER SET）</p><p>用来存储char、varchar2、clob、long等类型数据，还可以用来标识表名、列名以及PL/SQL变量等。</p><p>2）国家字符集（NATIONAL CHARACTER SET）</p><p>用以存储nchar、nvarchar2、nclob等类型数据。国家字符集实质上是为Oracle选择的附加字符集，主要作用是为了增强字符处理能力，因为nchar数据类型可以提供对亚洲使用定长多字节编码的支持，而数据库字符集则不一定能。国家字符集只能在unicode编码中的AF16UTF16和UTF8中选择，默认值是AF16UTF16。</p><h2 id="2-支持中文的字符集"><a class="markdownIt-Anchor" href="#2-支持中文的字符集"></a> 2、支持中文的字符集</h2><p>Oracle支持汉字（简体中文，繁体不介绍）的字符集有多种，常用的有ZHS16GBK、UTF8、AL32UTF8和AL16UTF16。</p><p>1）ZHS16GBK</p><p>表示简体中文，一个字符需要16位比特，采用GBK编码标准。</p><p>2）UTF8</p><p>Oracle从8i版本开始使用的属于UTF-8编码的字符集，采用的Unicode标准为3.0，在11.2版本中，UTF8已经不是推荐字符集列表中的一员了。</p><p>3）AL32UTF8</p><p>与UTF8相比，它采用的Unicode版本更新，在10g版本中使用的是Unicode 4.01标准，而UTF8因为兼容性的考虑，在10g版本中用的是Unicode 3.0标准。</p><p>4）AL16UTF16</p><p>是ORACLE第一种采用UTF-16编码方式的字符集，从ORACLE9开始使用，是作为缺省的国家字符集使用，它不能被用作数据库的字符集。</p><h2 id="3-nls_lang参数"><a class="markdownIt-Anchor" href="#3-nls_lang参数"></a> 3、NLS_LANG参数</h2><p>Oracle数据库字符集最重要的参数是NLS_LANG参数。</p><p>格式: NLS_LANG=‘language_territory.charset’，不区分大小写，例如’ SIMPLIFIED CHINESE_CHINA.ZHS16GBK’。</p><p>它有三个组成部分：语言（language）、地域（territory）和字符集（charset）。</p><p>其中:</p><p>language：数据库服务器提示信息的语言。</p><p>territory：数据库的日期和数字格式，意义不大。</p><p>charset：数据库的字符集。</p><p>真正影响数据库字符集的其实是第三部分charset，两个数据库之间的字符集只要第三部分相同，交换数据时中文不会出现乱码。language影响的只是提示信息是中文还是英文。</p><h1 id="三-服务端的字符集"><a class="markdownIt-Anchor" href="#三-服务端的字符集"></a> 三、服务端的字符集</h1><h2 id="1-查看服务端字符集"><a class="markdownIt-Anchor" href="#1-查看服务端字符集"></a> 1、查看服务端字符集</h2><p>执行以下SQL可以查看服务端的字符集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from NLS_DATABASE_PARAMETERS where parameter like <span class="string">&#x27;%CHARACTERSET%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202003130959481.png" alt="在这里插入图片描述" /></p><p>执行以下SQL也可以查看服务端的字符集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">userenv</span><span class="params">(<span class="string">&#x27;language&#x27;</span>)</span> from dual</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313100103972.png" alt="在这里插入图片描述" /></p><h2 id="2-修改服务端字符集"><a class="markdownIt-Anchor" href="#2-修改服务端字符集"></a> 2、修改服务端字符集</h2><p>Oracle数据库实例创建后，如果没有开始业务运行，可以修改字符集，如果已经业务化运行，不建议修改字符集，会造成数据中的汉字乱码。</p><p>用DBA权限，执行以下步骤修改Oracle数据库的字符集（例如修改为ZHS16GBK）。</p><p>1）修改服务端操作系统的NLS_LANG环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br></pre></td></tr></table></figure><p>2）关闭Oracle数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown immediate;</span><br></pre></td></tr></table></figure><p>3）把数据库启动到mount状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup mount;</span><br></pre></td></tr></table></figure><p>4）把数据库改为restricted模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter system enable restricted session;</span><br><span class="line">alter system set job_queue_processes=<span class="number">0</span>;</span><br><span class="line">alter system set aq_tm_processes=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>5）打开数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database open;</span><br></pre></td></tr></table></figure><p>6）修改数据库的字符集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database character set internal_use ZHS16GBK;</span><br></pre></td></tr></table></figure><p>7）重启数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown immediate;</span><br><span class="line">startup;</span><br></pre></td></tr></table></figure><h1 id="四-客户端的字符集"><a class="markdownIt-Anchor" href="#四-客户端的字符集"></a> 四、客户端的字符集</h1><p>Oracle客户端的字符集必须与服务端相同，否则中文会出现乱码。</p><h2 id="1-linux环境"><a class="markdownIt-Anchor" href="#1-linux环境"></a> 1、Linux环境</h2><p>客户端的字符集由NLS_LANG环境变量控制。</p><p>1）查看NLS_LANG环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env|grep NLS_LANG</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313100327221.png" alt="在这里插入图片描述" /></p><p>2）设置环境变量</p><p>修改环境变量参数文件（系统或用户的profile文件）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-windows环境"><a class="markdownIt-Anchor" href="#2-windows环境"></a> 2、Windows环境</h2><p>打开注册表（ 执行regedit.exe）</p><p>HKEY_LOCAL_MACHINE -&gt; SOFTWARE -&gt; ORACLE -&gt; KEY_OraClient11g_home1</p><p><img src="https://img-blog.csdnimg.cn/2020031310041361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>1）数据库在业务化之前，就应该确定Oracle的字符集，然后不再改变。数据库在业务化后，修改字符集是一件很麻烦的事情，最好别惹这个麻烦。</p><p>2）如果项目没有全球化的需求，数据库字符集建议采用ZHS16GBK，操作系统语言建议采用gbk。</p><p>3）只要把客户端和服务端设置成相同的字符集，就不会有乱码，没什么技术难点。</p><p>4）虽然GB18030字符集比GBK更丰富，但是GB18030中有部分汉字是4字节，这一点让程序员很郁闷，所以，程序员更倾向GBK字符集。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle归档日志管理</title>
      <link href="/posts/9e072477.html"/>
      <url>/posts/9e072477.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-重做日志"><a class="markdownIt-Anchor" href="#一-重做日志"></a> 一、重做日志</h1><p>Oracle以SQL脚本的形式实时记录了数据变化的详细日志，这些日志保存在重做日志文件中。根据重做日志文件，可以对数据库进行备份和恢复。在下文中，把重做日志简称为日志。</p><p>可以简单的认为，数据库每次在commit之前，会把操作数据的SQL脚本写入日志文件。</p><p>日志文件有两种：在线日志和归档日志。</p><p>创建Oracle数据库实例的时候，缺省建立三组在线日志，每组一个日志文件。三组日志中只有一组处于活动状态，这组活动的日志也称为当前日志，数据库不断的往当前日志里写入SQL脚本，当前日志写满后，Oracle会切换到下一组日志，继续写入，就这样循环切换。</p><p>日志组在切换时，如果数据库是归档模式，则将当前日志文件的内容转存为操作系统文件，成为归档日志；若当前数据库是非归档模式，则不进行归档操作，当前日志文件中的内容会被下一次覆盖。</p><p>如果数据库运行在归档模式下，当数据库出现介质失败时，使用备份文件、归档日志和在线日志可以完全恢复数据库。</p><h1 id="二-日志管理"><a class="markdownIt-Anchor" href="#二-日志管理"></a> 二、日志管理</h1><h2 id="1-查看日志"><a class="markdownIt-Anchor" href="#1-查看日志"></a> 1、查看日志</h2><p>1）查看日志组和日志文件信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group#,type,member from V$LOGFILE order by group#;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093214806.png" alt="在这里插入图片描述" /></p><p>2）查看当前日志组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group#,status,archived from V$LOG order by group#;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093240357.png" alt="在这里插入图片描述" /></p><p>3）查看数据库的日志模式。</p><p>方法一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive log list;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031309331574.png" alt="在这里插入图片描述" /></p><p>方法二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,log_mode from V$DATABASE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093347486.png" alt="在这里插入图片描述" /></p><p>4）查询已归档的日志文件清单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select recid,sequence#,name from V$ARCHIVED_LOG order by sequence#;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093418227.png" alt="在这里插入图片描述" /></p><h2 id="2-日志组和日志文件操作"><a class="markdownIt-Anchor" href="#2-日志组和日志文件操作"></a> 2、日志组和日志文件操作</h2><p>DBA可以增加、删除和移动日志组或日志文件。</p><p>1）增加/删除日志组。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add logfile group 组编号 (<span class="string">&#x27;日志文件名1&#x27;</span>,<span class="string">&#x27;日志文件名2&#x27;</span>,......) size 大小;</span><br><span class="line">alter database drop logfile group 组编号;</span><br></pre></td></tr></table></figure><p>例如，增加日志组编号为4，本组有两个日志文件/oracle/base/oradata/snorcl11g/redo04_1.log和/oracle/base/oradata/snorcl11g/redo04_2.log，两个文件互为备份，大小为256M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add logfile group <span class="number">4</span> (<span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_1.log&#x27;</span>,<span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_2.log&#x27;</span>) size <span class="number">256</span>M;</span><br><span class="line">alter database drop logfile group <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>删除日志组后，要手工的删除磁盘上的日志文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm /oracle/base/oradata/snorcl11g/redo04_1.log</span><br><span class="line">rm /oracle/base/oradata/snorcl11g/redo04_2.log</span><br></pre></td></tr></table></figure><p>2）增加/删除日志文件。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add  logfile member <span class="string">&#x27;日志文件名n&#x27;</span> to group 组编号;</span><br><span class="line">alter database drop logfile member <span class="string">&#x27;日志文件名n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database add  logfile member <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_3.log&#x27;</span> to group <span class="number">4</span>;</span><br><span class="line">alter database drop logfile member <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_3.log&#x27;</span>;</span><br></pre></td></tr></table></figure><p>删除日志组后，要手工的删除磁盘上的日志文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /oracle/base/oradata/snorcl11g/redo04_3.log</span><br></pre></td></tr></table></figure><p>3）移动日志文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database rename file <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_2.log&#x27;</span> to <span class="string">&#x27;/oracle/base/oradata/snorcl11g/redo04_4.log&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行该命令之前必须保证该日志文件物理上已经移动到新目录。</p><h2 id="3-修改日志模式"><a class="markdownIt-Anchor" href="#3-修改日志模式"></a> 3、修改日志模式</h2><p>1）关闭数据库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown immediate;</span><br></pre></td></tr></table></figure><p>2）把数据库启动到mount模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup mount;</span><br></pre></td></tr></table></figure><p>3）查看日志模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive log list;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313093851838.png" alt="在这里插入图片描述" /></p><p>4）设置归档日志文件存放的目录。</p><p>首先，根据您的实际需求，创建用于存放归档日志文件的目录，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /oracle/archive1</span><br></pre></td></tr></table></figure><p>然后，修改数据库参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system set log_archive_dest_1=<span class="string">&#x27;location=/oracle/archive1&#x27;</span> scope=spfile;</span><br></pre></td></tr></table></figure><p>5）修改归档日志文件的格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system set log_archive_format=<span class="string">&#x27;%T_%S_%r.log&#x27;</span> scope=spfile;</span><br></pre></td></tr></table></figure><p>日志文件名缺省是’%t_%s_%r.dbf’，详细的格式含义如下：</p><p>%s 日志序列号。</p><p>%S 日志序列号，但带前导0。</p><p>%t 日志线程号。</p><p>%T 日志线程号，但带前导0。</p><p>%a 活动ID号。</p><p>%d 数据库ID号。</p><p>%r resetlogs的ID值。</p><p>6）启用日志归档模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database archivelog;</span><br></pre></td></tr></table></figure><p>7）修改参数后，需要<strong>重启数据库到正常模式</strong>，确认修改后参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive log list;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313094016359.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter log_archive_format;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313094309689.png" alt="在这里插入图片描述" /></p><p>8）手工切换在线日志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system <span class="keyword">switch</span> logfile;</span><br></pre></td></tr></table></figure><p>用DBA执行以上命令，不管当前日志是否写懣，都立即归档。</p><p><img src="https://img-blog.csdnimg.cn/2020031309433983.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200313094350917.png" alt="在这里插入图片描述" /></p><p>9）禁用日志归档模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database noarchivelog;</span><br></pre></td></tr></table></figure><h2 id="4-归档日志的清理"><a class="markdownIt-Anchor" href="#4-归档日志的清理"></a> 4、归档日志的清理</h2><p>如果Oracle启用了日志归档模式，必须保证有足够的磁盘空间存放归档日志文件，如果空间不足，在线日志不能归档，也不会切换，数据库将暂停运行，错误代码为ORA-00257。</p><p>所以，归档日志文件要定期清理，运维人员经常用shell脚本加crontab任务的方法清理归档日志文件，但是，对我们程序员来，写程序清理是最好的方法。归档日志文件切换频率由数据库事务操作的繁忙程度决定的，只保留最近n个文件，其它的全部清理。</p><h1 id="三-归档非归档模式优缺点"><a class="markdownIt-Anchor" href="#三-归档非归档模式优缺点"></a> 三、归档/非归档模式优缺点</h1><h2 id="1-归档模式的优点"><a class="markdownIt-Anchor" href="#1-归档模式的优点"></a> 1、归档模式的优点</h2><p>1）可以进行完全、不完全恢复</p><p>由于对数据库所做的全部改动都记录在日志文件中，如果发生硬盘故<br />障等导致数据文件丢失的话，则可以利用物理备份和归档日志完全恢复数据库，不会丢失任何数据。</p><p>2）可以进行联机热备</p><p>所谓联机热备，就是在数据库运行状态下，对数据库进行备份。备份时用户对数据库的使用不受任何影响。</p><p>3）可以实施 Data Guard</p><p>可以部署 1 个或多个备用数据库，从而最大限度地提供灾难保护手段。</p><p>4）可以实施 Stream</p><p>利用 Stream 技术，可以实现最简单的单向复制到复杂的双向复制、多向复制，提供更加灵活的数据冗余方案。</p><p>5）表空间可以脱机</p><p>可以备份部分数据库，比如重要的表空间。</p><p>6）能够增量备份</p><p>只需做一次完全备份，以后只备份发生改变的数据，可以提高备份速度。</p><p>7）更多的优化选项</p><p>随着 Oracle 版本升级，在联机热备方面不断有新的优化策略出现。</p><h2 id="2-归档模式的缺点"><a class="markdownIt-Anchor" href="#2-归档模式的缺点"></a> 2、归档模式的缺点</h2><p>1）需要更多的磁盘空间保存归档日志；</p><p>2）DBA会有更多的管理工作，包括维护归档空间、备份归档日志。</p><h2 id="3-非归档模式的优点"><a class="markdownIt-Anchor" href="#3-非归档模式的优点"></a> 3、非归档模式的优点</h2><p>1）DBA 的管理工作减少，因为非归档模式不产生归档日志，因此 DBA 不用考虑对归档的管理；</p><p>2）性能会有微弱的提升。</p><h2 id="4-非归档模式的缺点"><a class="markdownIt-Anchor" href="#4-非归档模式的缺点"></a> 4、非归档模式的缺点</h2><p>1）只能进行脱机备份，也就是所谓的“ 冷备份”，和联机备份的“ 热备份”<br />相对应，数据库必须完全 关闭后备份，在备份过程中数据库不可用；</p><p>2）必须备份整个数据库，不能只备份部分数据库；</p><p>3）不能增量备份，对于 TB 级数据库（VLDB） ，这是一个非常大的缺点；</p><p>4）只能部分恢复，如果数据文件丢失需要恢复，DBA 只能恢复最后一次的完全备份，而之后的所有 数据库改变全部丢失。</p><p>非归档模式不生成归档日志，从数据安全角度来说，这种模式缺点是主要的，而优点可以忽略不计。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据备份和恢复</title>
      <link href="/posts/a6591160.html"/>
      <url>/posts/a6591160.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库的备份和恢复有很多种方法，是一个很大的话题，足可以写一本书，但是，本文只介绍采用exp和imp进行数据备份和恢复，这也是程序员最常用的方法。</p><p>本文涉及的备份与恢复的其它概念都是狭义的，不完整的或不完全准确的，仅供参考。</p><h1 id="一-备份与恢复的概念"><a class="markdownIt-Anchor" href="#一-备份与恢复的概念"></a> 一、备份与恢复的概念</h1><h2 id="1-什么是备份"><a class="markdownIt-Anchor" href="#1-什么是备份"></a> 1、什么是备份</h2><p>备份就是把数据库中的数据复制到存储设备的过程，存储设备包括磁盘、磁带、光盘等，随着存储技术的发展，磁带和光盘已经很少使用。</p><h2 id="2-备份的方法"><a class="markdownIt-Anchor" href="#2-备份的方法"></a> 2、备份的方法</h2><p>1）物理备份</p><p>对数据库操作系统的物理文件（数据文件，控制文件和日志文件）的备份。物理备份又可以分为脱机备份（冷备份）和联机备份（热备份），前者是在关闭数据库的时候进行的，后者是以归档日志的方式对运行的数据库进行备份。可以使用oracle的恢复管理器（rman）或操作系统命令进行数据库的物理备份。</p><p>2）逻辑备份</p><p>对数据库逻辑组件（如表和存储过程等数据库对象）的备份。逻辑备份的手段很多，如传统的exp，数据泵（expdp），数据库闪回技术等第三方工具，都可以进行数据库的逻辑备份。</p><h2 id="3-备份的策略"><a class="markdownIt-Anchor" href="#3-备份的策略"></a> 3、备份的策略</h2><p>1）完全备份</p><p>每次对数据库进行完整备份，当发生数据丢失的灾难时，完全备份无需依赖其他信息即可实现100%的数据恢复，其恢复时间最短且操作最方便。</p><p>2）增量备份</p><p>只有那些在上次完全备份或增量备份后被修改的文件才会被备份。优点是备份数据量小，需要的时间短，缺点是恢复的时候需要依赖以前备份记录，出问题的风险较大。</p><p>3）差异备份</p><p>备份那些自从上次完全备份之后被修改过的文件。从差异备份中恢复数据的时间较短，只需要最后一次完整备份和最后一次差异备份的数据，缺点是每次备份需要的时间较长。</p><h2 id="4-什么是恢复"><a class="markdownIt-Anchor" href="#4-什么是恢复"></a> 4、什么是恢复</h2><p>恢复就是发生故障后，利用已备份的数据文件或控制文件，重新建立一个完整的数据库。</p><h2 id="5-恢复分类"><a class="markdownIt-Anchor" href="#5-恢复分类"></a> 5、恢复分类</h2><p>1）实例恢复</p><p>当oracle实例出现失败后，oracle自动进行的恢复。</p><p>2）介质恢复</p><p>当存放数据库的介质出现故障时所作的恢复，介质恢复又分为完全恢复和不完全恢复。</p><p>完全恢复：将数据库恢复到数据库失败时的状态。这种恢复是通过装载数据库备份并应用全部的重做日志做到的。</p><p>不完全恢复：将数据库恢复到数据库失败前的某一时刻的状态。这种恢复是通过装载数据库备份并应用部分的重做日志做到的。进行不完全恢复后，必须在启动数据库时用resetlogs选项重设联机重做日志。</p><h1 id="二-逻辑备份和恢复"><a class="markdownIt-Anchor" href="#二-逻辑备份和恢复"></a> 二、逻辑备份和恢复</h1><p>Oracle逻辑备份和恢复的工具是exp（导出）和imp（导入），我根据应用场景来介绍这两个命令使用方法。</p><h2 id="1-exp命令"><a class="markdownIt-Anchor" href="#1-exp命令"></a> 1、exp命令</h2><p>在shell下输入<code>exp -help或exp help=y</code>获取exp命令帮助，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">exp -help</span><br><span class="line"></span><br><span class="line">Export: Release <span class="number">11.2</span><span class="number">.0</span><span class="number">.4</span><span class="number">.0</span> - Production on 星期四 <span class="number">2</span>月 <span class="number">6</span> <span class="number">10</span>:<span class="number">04</span>:<span class="number">26</span> <span class="number">2020</span></span><br><span class="line"><span class="built_in">Copyright</span> (c) <span class="number">1982</span>, <span class="number">2011</span>, Oracle <span class="keyword">and</span>/<span class="keyword">or</span> its affiliates.  All rights reserved.</span><br><span class="line"></span><br><span class="line">通过输入 EXP 命令和您的用户名/口令, 导出</span><br><span class="line">操作将提示您输入参数:</span><br><span class="line"></span><br><span class="line"> 例如: EXP SCOTT/TIGER</span><br><span class="line"></span><br><span class="line">或者, 您也可以通过输入跟有各种参数的 EXP 命令来控制导出</span><br><span class="line">的运行方式。要指定参数, 您可以使用关键字:</span><br><span class="line"></span><br><span class="line"> 格式:  EXP KEYWORD=value 或 KEYWORD=(value1,value2,...,valueN)</span><br><span class="line"> 例如: EXP SCOTT/TIGER GRANTS=Y TABLES=(EMP,DEPT,MGR)</span><br><span class="line">           或 TABLES=(T1:P1,T1:P2), 如果 T1 是分区表</span><br><span class="line"></span><br><span class="line">USERID 必须是命令行中的第一个参数。</span><br><span class="line"></span><br><span class="line">关键字   说明 (默认值)         关键字      说明 (默认值)</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">USERID   用户名/口令           FULL        导出整个文件 (N)</span><br><span class="line">BUFFER   数据缓冲区大小        OWNER        所有者用户名列表</span><br><span class="line">FILE     输出文件 (EXPDAT.DMP)  TABLES     表名列表</span><br><span class="line">COMPRESS  导入到一个区 (Y)   RECORDLENGTH   IO 记录的长度</span><br><span class="line">GRANTS    导出权限 (Y)          INCTYPE     增量导出类型</span><br><span class="line">INDEXES   导出索引 (Y)         RECORD       跟踪增量导出 (Y)</span><br><span class="line">DIRECT    直接路径 (N)         TRIGGERS     导出触发器 (Y)</span><br><span class="line">LOG      屏幕输出的日志文件    STATISTICS    分析对象 (ESTIMATE)</span><br><span class="line">ROWS      导出数据行 (Y)        PARFILE      参数文件名</span><br><span class="line">CONSISTENT 交叉表的一致性 (N)   CONSTRAINTS  导出的约束条件 (Y)</span><br><span class="line">OBJECT_CONSISTENT    只在对象导出期间设置为只读的事务处理 (N)</span><br><span class="line">FEEDBACK             每 x 行显示进度 (<span class="number">0</span>)</span><br><span class="line">FILESIZE             每个转储文件的最大大小</span><br><span class="line">FLASHBACK_SCN        用于将会话快照设置回以前状态的 SCN</span><br><span class="line">FLASHBACK_TIME       用于获取最接近指定时间的 SCN 的时间</span><br><span class="line">QUERY                用于导出表的子集的 select 子句</span><br><span class="line">RESUMABLE            遇到与空格相关的错误时挂起 (N)</span><br><span class="line">RESUMABLE_NAME       用于标识可恢复语句的文本字符串</span><br><span class="line">RESUMABLE_TIMEOUT    RESUMABLE 的等待时间</span><br><span class="line">TTS_FULL_CHECK       对 TTS 执行完整或部分相关性检查</span><br><span class="line">VOLSIZE              写入每个磁带卷的字节数</span><br><span class="line">TABLESPACES          要导出的表空间列表</span><br><span class="line">TRANSPORT_TABLESPACE 导出可传输的表空间元数据 (N)</span><br><span class="line">TEMPLATE             调用 iAS 模式导出的模板名</span><br></pre></td></tr></table></figure><h2 id="2-imp命令"><a class="markdownIt-Anchor" href="#2-imp命令"></a> 2、imp命令</h2><p>在shell下输入<code>imp -help 或 imp help=y</code>获取imp命令帮助，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">imp -help</span><br><span class="line"></span><br><span class="line">Import: Release <span class="number">11.2</span><span class="number">.0</span><span class="number">.4</span><span class="number">.0</span> - Production on 星期四 <span class="number">2</span>月 <span class="number">6</span> <span class="number">10</span>:<span class="number">06</span>:<span class="number">42</span> <span class="number">2020</span></span><br><span class="line"><span class="built_in">Copyright</span> (c) <span class="number">1982</span>, <span class="number">2011</span>, Oracle <span class="keyword">and</span>/<span class="keyword">or</span> its affiliates.  All rights reserved.</span><br><span class="line"></span><br><span class="line">通过输入 IMP 命令和您的用户名/口令, 导入</span><br><span class="line">操作将提示您输入参数: </span><br><span class="line"></span><br><span class="line">     例如: IMP SCOTT/TIGER</span><br><span class="line"></span><br><span class="line">或者, 可以通过输入 IMP 命令和各种参数来控制导入</span><br><span class="line">的运行方式。要指定参数, 您可以使用关键字: </span><br><span class="line"></span><br><span class="line"> 格式:  IMP KEYWORD=value 或 KEYWORD=(value1,value2,...,valueN)</span><br><span class="line"> 例如: IMP SCOTT/TIGER IGNORE=Y TABLES=(EMP,DEPT) FULL=N</span><br><span class="line">           或 TABLES=(T1:P1,T1:P2), 如果 T1 是分区表</span><br><span class="line"></span><br><span class="line">USERID 必须是命令行中的第一个参数。</span><br><span class="line"></span><br><span class="line">关键字   说明 (默认值)        关键字      说明 (默认值)</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">USERID   用户名/口令           FULL       导入整个文件 (N)</span><br><span class="line">BUFFER   数据缓冲区大小        FROMUSER    所有者用户名列表</span><br><span class="line">FILE     输入文件 (EXPDAT.DMP)  TOUSER     用户名列表</span><br><span class="line">SHOW     只列出文件内容 (N)     TABLES      表名列表</span><br><span class="line">IGNORE   忽略创建错误 (N)    RECORDLENGTH  IO 记录的长度</span><br><span class="line">GRANTS   导入权限 (Y)          INCTYPE     增量导入类型</span><br><span class="line">INDEXES   导入索引 (Y)         COMMIT       提交数组插入 (N)</span><br><span class="line">ROWS     导入数据行 (Y)        PARFILE      参数文件名</span><br><span class="line">LOG     屏幕输出的日志文件    CONSTRAINTS    导入限制 (Y)</span><br><span class="line">DESTROY                覆盖表空间数据文件 (N)</span><br><span class="line">INDEXFILE              将表/索引信息写入指定的文件</span><br><span class="line">SKIP_UNUSABLE_INDEXES  跳过不可用索引的维护 (N)</span><br><span class="line">FEEDBACK               每 x 行显示进度 (<span class="number">0</span>)</span><br><span class="line">TOID_NOVALIDATE        跳过指定类型 ID 的验证 </span><br><span class="line">FILESIZE               每个转储文件的最大大小</span><br><span class="line">STATISTICS             始终导入预计算的统计信息</span><br><span class="line">RESUMABLE              在遇到有关空间的错误时挂起 (N)</span><br><span class="line">RESUMABLE_NAME         用来标识可恢复语句的文本字符串</span><br><span class="line">RESUMABLE_TIMEOUT      RESUMABLE 的等待时间 </span><br><span class="line">COMPILE                编译过程, 程序包和函数 (Y)</span><br><span class="line">STREAMS_CONFIGURATION  导入流的一般元数据 (Y)</span><br><span class="line">STREAMS_INSTANTIATION  导入流实例化元数据 (N)</span><br><span class="line">DATA_ONLY              仅导入数据 (N)</span><br><span class="line">VOLSIZE                磁带的每个文件卷上的文件的字节数</span><br><span class="line"></span><br><span class="line">下列关键字仅用于可传输的表空间</span><br><span class="line">TRANSPORT_TABLESPACE 导入可传输的表空间元数据 (N)</span><br><span class="line">TABLESPACES 将要传输到数据库的表空间</span><br><span class="line">DATAFILES 将要传输到数据库的数据文件</span><br><span class="line">TTS_OWNERS 拥有可传输表空间集中数据的用户</span><br></pre></td></tr></table></figure><h2 id="3-数据库实例导出和导入"><a class="markdownIt-Anchor" href="#3-数据库实例导出和导入"></a> 3、数据库实例导出和导入</h2><p>导出数据库实例需要DBA权限，包括Oracle系统和全部的用户、索引、存储过程、权限等。应用场景极少，不建议。</p><p>1）导出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp scott/tiger file=/tmp/expdata.dmp full=y</span><br></pre></td></tr></table></figure><p>2）导入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp scott/tiger file=/tmp/expdata.dmp full=y</span><br></pre></td></tr></table></figure><h2 id="4-用户的导出和导入"><a class="markdownIt-Anchor" href="#4-用户的导出和导入"></a> 4、用户的导出和导入</h2><p>导出/导入某用户全部的对象。普通用户只能操作本用户，DBA用户可以操作其他用户。</p><p>1）用scott/tiger登录数据库，导出scott用户，数据保存在/tmp/expscott.dmp文件中，日志保存在/tmp/expscott.log文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp scott/tiger owner=scott file=/tmp/expscott.dmp log=/tmp/expscott.log</span><br></pre></td></tr></table></figure><p>2）用scott/tiger登录数据库，从/tmp/expscott.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到scott用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp scott/tiger file=/tmp/expscott.dmp fromuser=scott touser=scott</span><br></pre></td></tr></table></figure><p>3）用system/systempwd登录数据库（system具有DBA权限），，从/tmp/expscott.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到girl用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/systempwd file=/tmp/expscott.dmp fromuser=scott touser=girl</span><br></pre></td></tr></table></figure><h2 id="5-表的导出和导入"><a class="markdownIt-Anchor" href="#5-表的导出和导入"></a> 5、表的导出和导入</h2><p>导出/导入某用户全部的表。普通用户只能操作本用户的表，DBA用户可以操作其他用户的表。如果要导出多个表，需要把表名写在括号中，括号需要用\转义。</p><p>1）用scott/tiger登录数据库，导出EMP和DEPT表，数据保存在/tmp/empdept.dmp文件中，日志保存在/tmp/empdtpe.log文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp scott/tiger file=/tmp/empdept.dmp log=/tmp/empdept.log tables=\(EMP,DEPT\)</span><br></pre></td></tr></table></figure><p>2）用scott/tiger登录数据库，从/tmp/empdept.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到scott用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp scott/tiger file=/tmp/empdept.dmp fromuser=scott touser=scott</span><br></pre></td></tr></table></figure><p>3）用system/systempwd登录数据库（system具有DBA权限），，从/tmp/expscott.dmp文件中导入数据，指明是从scott用户导出的，现在要导入到girl用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imp system/systempwd file=empdept.dmp fromuser=scott touser=girl</span><br></pre></td></tr></table></figure><h2 id="6-注意事项"><a class="markdownIt-Anchor" href="#6-注意事项"></a> 6、注意事项</h2><p>1）exp和imp的参数比较多，但用到的却很少，您可以多尝试。</p><p>2）exp和imp的时候，如果没有任何警告和错误，会出现<code>成功终止导出/导入,没有出现警告</code>。</p><p>3）log参数很重要，把导出/导入的信息写在日志文件中，您可以用程序来判断导出是否成功。备份工作很重要，必须保证成功。</p><p>4）owner参数支持多个用户名的书写，要用括号，括号前加\转义。</p><p>5）tables参数支持多个表名的书写，要用括号，括号前加\转义。</p><p>6）rows参数很重要，如果rows=n，则只导出/导入表结构，不导出数据。</p><p>7）imp的ignore参数很重要，如果ignore=n，导入数据的时候，如果表已存在，就报错并且不会向表中导入数据，如果ignore=y，导入数据的时候，如果表已存在，会报错但是仍会向表中导入数据。</p><p>8）增量导出功能看上去很棒，但是可操作性很差。</p><p>9）其它的参数看看就行，了解了解。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>重要的业务系统一定会有非常完善的备份方案，由DBA去执行。</p><p>对程序员来说，采用exp/imp的场景主要有：</p><p>1）对一些数据量比较小的系统做备份，例如备份某数据库用户；</p><p>2）只备份数据库对象（不备份数据），缩短故障恢复的时间；</p><p>3）用于表的数据迁移；</p><p>4）程序员还可能自己编写程序来备份数据。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的启动和关闭</title>
      <link href="/posts/95482dc7.html"/>
      <url>/posts/95482dc7.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库的启用和关闭需要DBA权限，本文介绍的全部操作由sysdba来执行。</p><p>在运行数据库实例的操作系统的shell里执行以下命令就可以获得sysdba权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312165652366.png" alt="在这里插入图片描述" /></p><h1 id="一-数据库的启动"><a class="markdownIt-Anchor" href="#一-数据库的启动"></a> 一、数据库的启动</h1><p>Oracle数据库实例的启动要经历三个阶段。</p><p>1）nomount：启动实例（Start an instance）。</p><p>2）mount：装载数据库（Mount the database）。</p><p>3）open：打开数据库（Open the database）。</p><h2 id="1-启动实例"><a class="markdownIt-Anchor" href="#1-启动实例"></a> 1、启动实例</h2><p>执行以下命令启动数据库实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup nomount;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031216573183.png" alt="在这里插入图片描述" /></p><p>nomount状态启动Oracle的可执行程序，初始化数据库实例，包括以三步骤：</p><p>1）读取参数文件pfile或spfile，pfile是文本文件，spfile是二进制文件，它们的内容相同，只是格式不一样，oracle推荐使用spfile。spfile存放在$ORACLE_HOME/dbs目录下，默认名字是spfile$ORACLE_SID.ora，如/oracle/home/dbs/spfilesnorcl11g.ora。</p><p>2）根据参数文件中的参数，分配系统全局区SGA；</p><p>3）启动后台进程，包括数据库写入进程DBWR，日志写入进程LGWR，检查点进程CKPT，系统监控进程SMON，进程监控进程PMON，归档进程ARCH等。</p><p>SGA和后台进程组合起来组成实例（Oracle Instance）。</p><p>执行以下SQL查询实例的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select instance_name,status from V$INSTANCE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170018457.png" alt="在这里插入图片描述" /></p><h2 id="2-装载数据库"><a class="markdownIt-Anchor" href="#2-装载数据库"></a> 2、装载数据库</h2><p>执行以下命令装载数据库：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database mount;</span><br></pre></td></tr></table></figure><p>装载数据库时打开控制文件（Control File）从控制文件中获得数据文件（Data File）和联机日志文件（Redo Log File）信息把实例和数据库关联起来。</p><p>mount状态一般用于DBA对数据库进行维护（如数据恢复），对于普通用户，数据库还是不可访问。</p><p>执行以下SQL查询实例和数据库的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select instance_name,status from V$INSTANCE;</span><br><span class="line">select db_unique_name,open_mode from V$DATABASE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170100139.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200312170110767.png" alt="在这里插入图片描述" /></p><h2 id="3-打开数据库"><a class="markdownIt-Anchor" href="#3-打开数据库"></a> 3、打开数据库</h2><p>执行以下命令打开数据库：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database open;</span><br></pre></td></tr></table></figure><p>Oracle打开数据文件(Data Files)和联机日志文件(Redo Log File)。这时候数据库可以使用，普通用户可以登录数据库，对数据库进行操作。</p><p>执行以下SQL查询实例和数据库的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select instance_name,status from V$INSTANCE;</span><br><span class="line">select db_unique_name,open_mode from V$DATABASE;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170148174.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200312172710257.png" alt="在这里插入图片描述" /></p><h2 id="4-直接启动数据库"><a class="markdownIt-Anchor" href="#4-直接启动数据库"></a> 4、直接启动数据库</h2><p>执行startup open命令直接启动数据库，相当于以上三个步骤，open可以省略不写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup open;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312170218495.png" alt="在这里插入图片描述" /></p><h1 id="二-数据库状态切换"><a class="markdownIt-Anchor" href="#二-数据库状态切换"></a> 二、数据库状态切换</h1><h2 id="1-从open切换到mounted状态"><a class="markdownIt-Anchor" href="#1-从open切换到mounted状态"></a> 1、从open切换到mounted状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database close;</span><br></pre></td></tr></table></figure><h2 id="2-从mounted切换到started状态"><a class="markdownIt-Anchor" href="#2-从mounted切换到started状态"></a> 2、从mounted切换到started状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database dismount;</span><br></pre></td></tr></table></figure><h2 id="3-把数据库启动到限制模式restrict"><a class="markdownIt-Anchor" href="#3-把数据库启动到限制模式restrict"></a> 3、把数据库启动到限制模式（Restrict）</h2><p>在限制模式下，只有create session和restricted session权限的用户可以访问数据库。</p><p>1）如果数据库是关闭的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup restrict;</span><br></pre></td></tr></table></figure><p>2）如果数据库是开启的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system enable restricted session;</span><br></pre></td></tr></table></figure><h2 id="4-以只读模式read-only打开数据库"><a class="markdownIt-Anchor" href="#4-以只读模式read-only打开数据库"></a> 4、以只读模式（Read Only）打开数据库</h2><p>1）如果数据库是关闭的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup open read only;</span><br></pre></td></tr></table></figure><p>2）如果数据库是mount状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database open read only;</span><br></pre></td></tr></table></figure><p>在直读模式下，数据文件和日志文件都禁止写操作，整个数据库是只读的。但是允许数据库恢复（Database Recovery）及其他不会产生事务的操作。</p><h2 id="5-把数据库启动到恢复模式recover"><a class="markdownIt-Anchor" href="#5-把数据库启动到恢复模式recover"></a> 5、把数据库启动到恢复模式（Recover）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup open recover;</span><br></pre></td></tr></table></figure><h1 id="三-关闭数据库"><a class="markdownIt-Anchor" href="#三-关闭数据库"></a> 三、关闭数据库</h1><h2 id="1-数据库关闭的过程"><a class="markdownIt-Anchor" href="#1-数据库关闭的过程"></a> 1、数据库关闭的过程</h2><p>Oracle的关闭也要经历<strong>关闭数据库</strong>、<strong>卸载数据库</strong>和<strong>关闭实例</strong>三个阶段。</p><p>1）关闭数据库（Close the database）</p><p>Oracle首先把SGA中的数据写到数据文件和日志文件中，然后再关闭数据文件和联机日志文件。</p><p>2）卸载数据库（Dismount the database）</p><p>数据库关闭完成之后，Oracle将分离数据库和实例之间的联系，这个阶段叫做“卸载数据库”或者叫“Dismount数据库”。</p><p>3）关闭实例（Shut down the instance）</p><p>这个阶段Oracle将从释放SGA占用的内存，终止全部的后台服务进程。</p><h2 id="2-shutdown-immediate"><a class="markdownIt-Anchor" href="#2-shutdown-immediate"></a> 2、shutdown immediate</h2><p><img src="https://img-blog.csdnimg.cn/20200312170947376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>使用immediate方式关闭数据库时：</p><p>1）新的用户不能登录数据库；</p><p>2）未提交的事务将会被回滚；</p><p>3）Oracle不会等待所有的用户（连接）退出数据库。</p><p>特点：</p><p>1）这种关闭方式可能会造成数据丢失；</p><p>2）数据库重启时不需要实例恢复。</p><p>推荐使用immediate方式关闭数据库。</p><h2 id="3-shutdown-transactional"><a class="markdownIt-Anchor" href="#3-shutdown-transactional"></a> 3、shutdown transactional</h2><p>以transactional方式关闭数据库时：</p><p>1）不允许新的用户登录数据库；</p><p>2）不允许建立新的事务；</p><p>3）所有的事务完成以后才关闭数据库；</p><p>4）一个用户（会话）执行完当前的事务后将被强行断开与数据库的连接。</p><p>特点：</p><p>1）这种关闭方式不会造成数据丢失；</p><p>2）数据库重启时不需要实例恢复；</p><p>3）这是最安全的关闭方式。</p><h2 id="4-shutdown-abort"><a class="markdownIt-Anchor" href="#4-shutdown-abort"></a> 4、shutdown abort</h2><p>以abort方式关闭数据库时：</p><p>1）不允许建立新的连接和新的事务；</p><p>2）客户端的SQL语句立刻终止；</p><p>3）未提交的事务不被回滚；</p><p>4）Oracle立刻终止所有连接（会话）。</p><p>特点：</p><p>1）只有数据库出现问题时候，才使用这种方式关闭数据库；</p><p>2）这是一种最不安全的关闭方式，数据库重启时需要实例恢复。</p><h2 id="5-shutdown-normal"><a class="markdownIt-Anchor" href="#5-shutdown-normal"></a> 5、shutdown normal</h2><p>使用normal方式关闭数据库时：</p><p>（1）允许新的用户注登录数据库；</p><p>（2）要等所有的用户自动退出Oracle以后，Oracle才关闭数据库。如果有未退出的用户，那么Oracle就一直等待，直到这个用户退出才关闭数据库。</p><p>normal是最慢的数据库关闭方式，不推荐。</p><h2 id="6-重启数据库reset"><a class="markdownIt-Anchor" href="#6-重启数据库reset"></a> 6、重启数据库（Reset）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup force;</span><br></pre></td></tr></table></figure><p>相当于shutdown abort和startup。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle表空间和数据文件</title>
      <link href="/posts/1d4455be.html"/>
      <url>/posts/1d4455be.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-表空间的概念"><a class="markdownIt-Anchor" href="#一-表空间的概念"></a> 一、表空间的概念</h1><p>Oracle数据库的数据存放在表空间中，表空间是一个逻辑的概念，它是由数据文件组成，表空间大小由数据文件的数量和大小决定。</p><p>表空间有三种：Permanent Tablespaces（永久表空间）、Temporary Tablespaces（临时表空间）、Undo Tablespaces（回滚表空间），Oracle在创建数据库实例的时候，默认会创建三个永久表空间（SYSTEM、SYSAUX、USERS），一个临时表空间（TEMP），一个回滚表空间（UNDOTBS1）。</p><h2 id="1-system表空间"><a class="markdownIt-Anchor" href="#1-system表空间"></a> 1、SYSTEM表空间</h2><p>SYSTEM表空间主要用于存放Oracle数据库内部的数据字典，它是Oracle数据库最重要的表空间，在创建数据库实例时被最先创建，包含了数据库的元数据，对于数据库来说生死攸关。</p><h2 id="2-sysaux表空间"><a class="markdownIt-Anchor" href="#2-sysaux表空间"></a> 2、SYSAUX表空间</h2><p>SYSAUX表空间是SYSTEM表空间的辅助表空间，主要用于存储数据字典以外的其他数据对象，它在一定程度上降低了SYSTEM表空间的负荷。</p><h2 id="3-undotbs1表空间"><a class="markdownIt-Anchor" href="#3-undotbs1表空间"></a> 3、UNDOTBS1表空间</h2><p>UNDO是回滚表空间，主要有四方面的用途，分别是：事物回滚、数据库恢复、读一致性、闪回查询。</p><p>1）事物回滚：当事物执行失败或用户执行回滚操作（rollback）时，Oracle会利用保存在回退段中的信息将数据恢复到原来的值。</p><p>2）数据库恢复：当数据库实例出现了意外，在重启恢复时，Oracle先利用重做日志文件的信息对数据库进行恢复，再利用回滚段中的信息回滚未提交的事务。</p><p>3）读一致性：当一个用户对数据进行修改时，会预先将其原始值保存到回退段中，这时，如果有其它用户访问该数据，则访问回退段中的信息，使当前用户未提交的修改其他用户无法看到，保证了数据的一致性。</p><p>4）闪回查询：通过保留在回退段中的信息，用户可以查询某个数据在过去某个时刻的状态。</p><h2 id="4-temp表空间"><a class="markdownIt-Anchor" href="#4-temp表空间"></a> 4、TEMP表空间</h2><p>临时表空间用来管理数据库排序以及用于存储临时表和索引、中间结果等临时对象。当Oracle的内存不够时，会把数据放在临时表空间中，当操作完成后，系统会自动清理临时表空间中的临时对象，自动释放空间。这里的释放只是标记为空闲、可以重用，占用的磁盘空间并没有真正释放。这也是临时表空间有时会不断增大却不见减少的原因。</p><h2 id="5-users表空间"><a class="markdownIt-Anchor" href="#5-users表空间"></a> 5、USERS表空间</h2><p>USERS表空间用于存放普通用户的表和索引，一般情况下，它是用户的缺省表空间。</p><h2 id="6-查看表空间"><a class="markdownIt-Anchor" href="#6-查看表空间"></a> 6、查看表空间</h2><p>用DBA登录数据库，执行以下SQL可以查看数据库全部的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from v$tablespace;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312154751355.png" alt="在这里插入图片描述" /></p><h1 id="二-管理表空间"><a class="markdownIt-Anchor" href="#二-管理表空间"></a> 二、管理表空间</h1><p>企业级的Oracle数据系统的存储一般是采用ASM（自动存储管理），ASM是Oracle 10g R2中为了简化Oracle数据库的管理而推出来的一项新功能，这是Oracle自己提供的卷管理器，替代了操作系统所提供的LVM，它不仅支持单实例，同时对RAC的支持也是非常好。</p><p>管理表空间的任务一般是由DBA来执行，涉及的知识比较多，本文介绍用文件系统作为Oracle的存储空间，合适程序员学习。不管是ASM还是文件系统，逻辑上是一样的，作为一个程序员，并不一定要掌握Oralce存储系统的管理和配置，理解它的原理和使用就可以了。</p><h2 id="1-创建表空间"><a class="markdownIt-Anchor" href="#1-创建表空间"></a> 1、创建表空间</h2><p>创建表空间是使用create tablespace命令完成的，建立表空间是特权用户或是DBA来执行的，如果用其它用户来创建表空间，则用户必须要具有create tablespace的系统权限。create tablespace命令的选项比较多，本文只介绍常用的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace 表空间名 datafile <span class="string">&#x27;数据文件名&#x27;</span> size 大小;</span><br></pre></td></tr></table></figure><p><strong>在创建数据库实列后，为了方便管理，最好再创建一个专用于存放数据表空间和一个专用于存放索引表空间。</strong></p><p>示例：</p><p>1）创建数据表空间DATA，同时创建数据文件/oracle/base/oradata/snorcl11g/data01.dbf，数据文件的大小是128M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace DATA datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data01.dbf&#x27;</span> size <span class="number">128</span>M;</span><br></pre></td></tr></table></figure><p>2）创建索引表空间INDEXS，同时创建数据文件/oracle/base/oradata/snorcl11g/indexs01.dbf，数据文件的大小是128M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace INDEXS datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/indexs01.dbf&#x27;</span> size <span class="number">128</span>M;</span><br></pre></td></tr></table></figure><p>创建表空间时，可以指定多个数据文件，但致少要指定一个数据文件，数据文件由Oracle自动创建，不需要事先在磁盘上手工的创建文件。</p><p><img src="https://img-blog.csdnimg.cn/20200312154948579.png" alt="在这里插入图片描述" /></p><h2 id="2-使用表空间"><a class="markdownIt-Anchor" href="#2-使用表空间"></a> 2、使用表空间</h2><p>1）创建数据库用户时，指定用户的对象缺省使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user girl identified by pwdgirl <span class="keyword">default</span> tablespace DATA;</span><br></pre></td></tr></table></figure><p>2）创建表时，指定表使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null    -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> tablespace DATA</span>;</span><br></pre></td></tr></table></figure><p>3）创建主键时，指定主键使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span> <span class="keyword">using</span> index tablespace INDEXS</span>;</span><br></pre></td></tr></table></figure><p>4）创建索引时，指定索引使用的表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create index IDX_GIRL_1 on <span class="title">T_GIRL</span><span class="params">(name)</span> tablespace INDEXS</span>;</span><br></pre></td></tr></table></figure><h2 id="3-删除表空间"><a class="markdownIt-Anchor" href="#3-删除表空间"></a> 3、删除表空间</h2><p>一般情况下，由特权用户或是DBA来操作，如果是其它用户操作，那么要求用户具有drop<br />tablespace系统权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop tablespace 表空间名 including contents <span class="keyword">and</span> datafiles;</span><br></pre></td></tr></table></figure><p>Including contents表示删除表空间，同时删除该表空间全部的数据库对象，而datafiles表示将数据库文件也删除。</p><p>示例：</p><p>删除DATA和INDEXS表空间，和该表空间全部的数据库对象以及数据文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop tablespace DATA including contents <span class="keyword">and</span> datafiles;</span><br><span class="line">drop tablespace INDEXS including contents <span class="keyword">and</span> datafiles;</span><br></pre></td></tr></table></figure><h2 id="4-向表空间中添加数据文件"><a class="markdownIt-Anchor" href="#4-向表空间中添加数据文件"></a> 4、向表空间中添加数据文件</h2><p>表空间的大小是由数据文件的数据和大小决定的，向表空间中添加数据文件，扩展表空间的容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter tablesapce 表空间名 add datafile <span class="string">&#x27;数据文件名&#x27;</span> size 大小</span><br><span class="line">      [reuse]</span><br><span class="line">      [autoextend [on/off] next 大小]</span><br><span class="line">      [maxsize [unlimited|大小]];</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><code>size 大小</code>：数据文件的初始大小，单位：K|M|G|T|P|E。</p><p><code>[reuse]</code>：如果操作系统上已经存在数据文件，加reuse参数表示覆盖它，否则会提示错误，建议一般不要启用reuse选项，容易产生误操作，如果磁盘上已存在同名的数据文件，可以先手工的删除它。</p><p><code>[autoextend [on/off] next 大小]</code>：数据文件是否自动扩展，如果为on，next参数指定每次扩展的大小。</p><p><code>[maxsize [unlimited|大小]]</code>：如果数据文件可以自动扩展，maxsize参数可以限制文件的最大值，unlimited表示无限制。</p><p>示例：</p><p>1）向DATA表空间添加数据文件，大小100M，可重用，可自动扩展，每次扩展10M，最大200M。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA add datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> </span><br><span class="line">      size <span class="number">100</span>M reuse autoextend on next <span class="number">10</span>M maxsize <span class="number">200</span>M;</span><br></pre></td></tr></table></figure><p>2）向DATA表空间添加数据文件，大小100M，可重用，可自动扩展，每次扩展10M，无最大限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA add datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data03.dbf&#x27;</span> </span><br><span class="line">      size <span class="number">100</span>M reuse autoextend on next <span class="number">10</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure><p>3）向DATA表空间添加数据文件，大小200M，不可重用，不能自动扩展。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA add datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data04.dbf&#x27;</span> </span><br><span class="line">      size <span class="number">100</span>M autoextend off;</span><br></pre></td></tr></table></figure><h2 id="6-修改表空间的状态"><a class="markdownIt-Anchor" href="#6-修改表空间的状态"></a> 6、修改表空间的状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace 表空间名 [online] [offline] [read only|write];</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）把DATA表空间的状态改为offline（离线）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA offline;</span><br></pre></td></tr></table></figure><p>2）把DATA表空间的状态改为read onley（只读）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA read only;</span><br></pre></td></tr></table></figure><p>3）把DATA表空间的状态改为read write（可读写）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA read write;</span><br></pre></td></tr></table></figure><p>4）把DATA表空间的状态改为offline（在线）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA online;</span><br></pre></td></tr></table></figure><h2 id="7-修改数据文件状态"><a class="markdownIt-Anchor" href="#7-修改数据文件状态"></a> 7、修改数据文件状态</h2><p>修改数据文件的命令是alter database datafile。</p><p>示例：</p><p>1）先把表空间offline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA offline;</span><br></pre></td></tr></table></figure><p>2）把数据文件的状态改为offline（离线），必须先把表空间offline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> offline;</span><br></pre></td></tr></table></figure><p>3）把数据文件的状态改为online（在线）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> online;</span><br></pre></td></tr></table></figure><p>4）删除数据文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> offline drop;</span><br></pre></td></tr></table></figure><p>5）再把表空间online。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA online;</span><br></pre></td></tr></table></figure><h2 id="8-修改数据文件大小"><a class="markdownIt-Anchor" href="#8-修改数据文件大小"></a> 8、修改数据文件大小</h2><p>修改数据文件的大小可以在线操作，关联的表空间无需offline，对业务运行也没有影响。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;数据文件名&#x27;</span></span><br><span class="line">      [ [resize 大小| [autoextend [on/off] next 大小] [maxsize [unlimited|大小]] ];</span><br></pre></td></tr></table></figure><p>1）把数据文件改为200M，前提是该数据文件已使用空间小于200M，否则提示错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> resize <span class="number">200</span>M;</span><br></pre></td></tr></table></figure><p>2）禁用数据文件自动扩展的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> autoextend off;</span><br></pre></td></tr></table></figure><p>3）启用数据文件自动扩展的属性，无最大限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter database datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> </span><br><span class="line">      autoextend on next <span class="number">10</span>M maxsize unlimited;</span><br></pre></td></tr></table></figure><h2 id="9-移动数据文件"><a class="markdownIt-Anchor" href="#9-移动数据文件"></a> 9、移动数据文件</h2><p>移动数据文件非常重要，例如存放数据文件的磁盘空间不足，增加了新的磁盘空间后，需要把数据文件迁移到新的磁盘。</p><p>移动数据文件有两种方法：alter tablespace和alter database。</p><p>示例：</p><p>1）把表空间offline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA offline;</span><br></pre></td></tr></table></figure><p>2）执行操作系统命令，迁移数据文件，cp和mv都可以，注意，cp和mv是操作系统的命令，不是sqlplus中Oracle的命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv data01.dbf data03.dbf</span><br><span class="line">mv data02.dbf data04.dbf</span><br></pre></td></tr></table></figure><p>3）执行alter tablespace或alter database修改数据库文件名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA rename datafile <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data01.dbf&#x27;</span> to <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data03.dbf&#x27;</span>;</span><br><span class="line">alter database rename file <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data02.dbf&#x27;</span> to <span class="string">&#x27;/oracle/base/oradata/snorcl11g/data04.dbf&#x27;</span>;</span><br></pre></td></tr></table></figure><p>4）把表空间online。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter tablespace DATA online;</span><br></pre></td></tr></table></figure><h1 id="三-查看表空间和数据文件"><a class="markdownIt-Anchor" href="#三-查看表空间和数据文件"></a> 三、查看表空间和数据文件</h1><h2 id="1-查看当前用户的缺省表空间"><a class="markdownIt-Anchor" href="#1-查看当前用户的缺省表空间"></a> 1、查看当前用户的缺省表空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username,default_tablespace from user_users;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312162523541.png" alt="在这里插入图片描述" /></p><h2 id="2-查看数据文件"><a class="markdownIt-Anchor" href="#2-查看数据文件"></a> 2、查看数据文件</h2><p>数据文件存放在数据字典DBA_DATA_FILES中，用DBA权限执行以下SQL查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select file_name,file_id,tablespace_name,bytes,status,autoextensible,</span><br><span class="line">       maxbytes,user_bytes,online_status</span><br><span class="line">  from DBA_DATA_FILES order by tablespace_name,file_name;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312162903267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-查看表空间使用情况"><a class="markdownIt-Anchor" href="#3-查看表空间使用情况"></a> 3、查看表空间使用情况</h2><p>从数据字典DBA_FREE_SPACE和DBA_DATA_FILES中可以查询表空间使用情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select a.tablespace_name <span class="string">&quot;表空间名&quot;</span>,total <span class="string">&quot;表空间大小&quot;</span>,</span><br><span class="line">       (total - free) <span class="string">&quot;已使用大小&quot;</span>,free <span class="string">&quot;表空间剩余大小&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>(total/(<span class="number">1024</span>*<span class="number">1024</span>)) <span class="string">&quot;表空间大小(M)&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>((total-free)/(<span class="number">1024</span>*<span class="number">1024</span>)) <span class="string">&quot;已使用大小(M)&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>(free/(<span class="number">1024</span>*<span class="number">1024</span>)) <span class="string">&quot;表空间剩余大小(M)&quot;</span>,</span><br><span class="line">       <span class="built_in">round</span>((total-free)/total,<span class="number">4</span>)*<span class="number">100</span> <span class="string">&quot;使用率%&quot;</span></span><br><span class="line">  <span class="built_in">from</span></span><br><span class="line">(select tablespace_name,<span class="built_in">sum</span>(bytes) free from DBA_FREE_SPACE group by tablespace_name) a,</span><br><span class="line">(select tablespace_name,<span class="built_in">sum</span>(bytes) total from DBA_DATA_FILES group by tablespace_name) b</span><br><span class="line"> where a.tablespace_name = b.tablespace_name;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312162946650.png" alt="在这里插入图片描述" /></p><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>表空间和数据文件的管理，看上去就是几个命令，但是在实际应用中并不会这么简单。</p><p>如果让您在一片空地上设计规划一座新的城市，想怎么设计就怎么设计，想怎么修改就怎么修改，但是，如果城市一旦建好，想改就没那么容易了，要考虑拆迁问题，补偿问题，还有对交通影响，对人们日常生活的影响等等。</p><p>表空间和数据文件的管理也是一样的道理，如果您新建的表空间和数据文件还没有被使用，您想怎么改就怎么改，一旦投入了业务运行，需要考虑的问题就多了。</p><p>所以，表空间和数据文件最好是一开始就规划和设计好。如果要修改业务运行中的表空间和数据文件（扩展数据文件除外），风险非常大，建议让专业的DBA来操作，或者在操作之前做好业务数据的备份。如果操作不慎造成了数据的丢失或影响业务系统的运行，您会懊悔不已。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle用户和权限管理</title>
      <link href="/posts/6724a9ad.html"/>
      <url>/posts/6724a9ad.html</url>
      
        <content type="html"><![CDATA[<p>当创建一个新数据库实例时，Oracle会创建sys、system和scott数据库用户。sys和system是管理员用户，它们的密码在创建数据库时指定。scott是示范用户（用于学习），里面包括了一些测试数据（DEPT、EMP、BONUS和SALGRADE表），scott用户缺省是锁定状态。</p><h1 id="一-数据库管理员"><a class="markdownIt-Anchor" href="#一-数据库管理员"></a> 一、数据库管理员</h1><p>数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统的相关工作人员的统称，属于运维工程师的一个分支，主要负责数据库的设计、部署、运维和管理，侧重于运维管理。</p><p>DBA的核心目标是保证数据库系统的稳定性、安全性、完整性和高性能，保证数据库服务7*24小时的稳定高效运转。</p><p>数据库实例创建后，<strong>在数据库服务器上</strong>，用 <code>sqlplus / as sysdba</code> 可以以DBA身份登录数据库，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200312151958968.png" alt="在这里插入图片描述" /></p><h1 id="二-用户管理"><a class="markdownIt-Anchor" href="#二-用户管理"></a> 二、用户管理</h1><h2 id="1-创建用户"><a class="markdownIt-Anchor" href="#1-创建用户"></a> 1、创建用户</h2><p>创建用户的命令是 <code>create user</code>，它的选项非常多，在这里我介绍一些常用的选项。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create user 用户名 identified by 密码</span><br><span class="line">       [<span class="keyword">default</span> tablespace 表空间名]</span><br><span class="line">       [temporary tablespace 表空间名]</span><br><span class="line">       [quota 大小 on 表空间名]</span><br><span class="line">       [profile 用户配置文件];</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><code>create user 用户名 identified by 密码</code>：指定登录数据库的用户名和密码。</p><p><code>[default tablespace 表空间名]</code>：指定用户的永久表空间，该用户全部的数据库对象（表、索引）将存放在该表空间中。</p><p><code>[temporary tablespace 表空间名]</code>：指定用户的临时表空间，临时表空间主要用于排序、运算、管理索引、存放临时数据等，当任务完成之后系统会自动清理。</p><p><code>[quota 大小 on 表空间名]</code>：表空间配额，用户使用表空间的大小，单位有[K|M|G|T|P|E]，缺省是unlimited，无限制。</p><p><code>[profile 用户配置文件]</code>：用户的配置文件，它是密码限制，资源限制的命名集合，利用profile<br />可以对数据库用户进行基本的资源管理，密码管理，缺省是default profile，无限制。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create user girl</span><br><span class="line">  identified by girlpwd</span><br><span class="line">  <span class="keyword">default</span> tablespace users</span><br><span class="line">  temporary tablespace temp</span><br><span class="line">  quota <span class="number">20</span>M on users;</span><br></pre></td></tr></table></figure><p>创建一个用户名为girl的新用户，密码是pwdgirl，缺省表空间是users（可使用20M的空间），临时表空间是temp。</p><p>注意，创建用户时，如果不指定default tablespace/ temporary tablespace选项，则使用系统缺省的永久/临时表空间，用以下SQL可以查看系统缺省的永久/临时表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select property_value from DATABASE_PROPERTIES where </span></span><br><span class="line"><span class="function">property_name <span class="title">in</span> <span class="params">(<span class="string">&#x27;DEFAULT_PERMANENT_TABLESPACE&#x27;</span>,<span class="string">&#x27;DEFAULT_TEMP_TABLESPACE&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312152433247.png" alt="在这里插入图片描述" /></p><h2 id="2-修改用户的密码"><a class="markdownIt-Anchor" href="#2-修改用户的密码"></a> 2、修改用户的密码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 identified by 新密码;</span><br></pre></td></tr></table></figure><p>普通用户只能修改自已的密码，DBA可以修改其它用户的密码。</p><h2 id="3-锁定解锁用户"><a class="markdownIt-Anchor" href="#3-锁定解锁用户"></a> 3、锁定/解锁用户</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 account lock;</span><br><span class="line">alter user 用户名 account unlock;</span><br></pre></td></tr></table></figure><p>锁定/解锁用户需要DBA权限。</p><h2 id="4-修改用户表空间配额"><a class="markdownIt-Anchor" href="#4-修改用户表空间配额"></a> 4、修改用户表空间配额</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 quota 大小 on 表空间;</span><br></pre></td></tr></table></figure><p>修改用户表空间配额需要DBA权限。</p><h2 id="5-删除用户"><a class="markdownIt-Anchor" href="#5-删除用户"></a> 5、删除用户</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user 用户名 [cascade];</span><br></pre></td></tr></table></figure><p>drop user 只有在用户下没有任何数据库对象的时候才能删除用户，否则会提示错误。</p><p>采用cascade选项删除用户以及用户下全部的数据库对象，包括表、视图、函数、同义词、过程等。</p><p>删除用户需要DBA权限。</p><h1 id="三-权限管理"><a class="markdownIt-Anchor" href="#三-权限管理"></a> 三、权限管理</h1><p>权限是指用户执行特定命令或操作数据库对象的权利。Oracle的用户权限分系统权限和对象权限。</p><h2 id="1-系统权限"><a class="markdownIt-Anchor" href="#1-系统权限"></a> 1、系统权限</h2><p>系统权限针对的是系统安全性，执行数据库操作，如登录、创建表、创建函数等，通过查询SYSTEM_PRIVILEGE_MAP数据字典可以看到Oracle的两百多种系统权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from SYSTEM_PRIVILEGE_MAP;</span><br></pre></td></tr></table></figure><p>以下是几种常用的系统权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create session       创建会话。</span><br><span class="line">create/drop user     创建/删除用户。</span><br><span class="line">create/drop sequence 创建/删除序列。</span><br><span class="line">create/drop synonym  创建/删除同名对象。</span><br><span class="line">create/drop table    创建/删除表。</span><br><span class="line">create/drop view     创建/删除视图。</span><br></pre></td></tr></table></figure><h2 id="2-对象权限"><a class="markdownIt-Anchor" href="#2-对象权限"></a> 2、对象权限</h2><p>对象权限针对的是数据安全性，对某一特定对象（如表，视图、序列、存储过程等）执行的特定操作，对象的权限分类如下：。</p><p>1）select权限</p><p>对表而言，允许对表执行select语句；对序列而言，允许对序列获取下一个值（nextval）和当前值（currnvl）。</p><p>2）insert权限</p><p>允许向表和视图中插入记录。</p><p>3）update权限</p><p>允许在表或视图中执行update语句，update权限必须随同select权限授予，否则被授权用户不能够选择行。</p><p>4）delete权限</p><p>允许在表或视图中执行delete语句，delete权限必须随同select权限授予，否则被授权用户不能够选择行。</p><p>5）alter权限</p><p>对表而言，允许对表执行alter table语句；对序列而言，允许对序列alter sequence语句。</p><p>6）execute权限</p><p>执行存储过程、函数和包的权限。</p><p>7）index权限</p><p>允许在表上创建索引。</p><p>8）reference权限</p><p>允许在表上创建完整性约束，如外键。</p><p>9）all</p><p>对象的全部权限（上面列出的全部权限）。</p><p>以下是Oracle数据库对象与权限的对照表。</p><table><thead><tr><th>对象权限</th><th>表</th><th>视图</th><th>序列</th><th>过程（函数和包）</th><th>备注</th></tr></thead><tbody><tr><td>select</td><td>是</td><td>是</td><td>是</td><td></td><td>常用。</td></tr><tr><td>insert</td><td>是</td><td>是</td><td></td><td></td><td>常用。</td></tr><tr><td>update</td><td>是</td><td>是</td><td></td><td></td><td>常用。</td></tr><tr><td>delete</td><td>是</td><td>是</td><td></td><td></td><td>常用。</td></tr><tr><td>alter</td><td>是</td><td></td><td>是</td><td></td><td>不常用。</td></tr><tr><td>execute</td><td></td><td></td><td></td><td>是</td><td>不常用。</td></tr><tr><td>index</td><td>是</td><td></td><td></td><td></td><td>不常用。</td></tr><tr><td>references</td><td>是</td><td></td><td></td><td></td><td>不常用。</td></tr></tbody></table><h2 id="3-角色"><a class="markdownIt-Anchor" href="#3-角色"></a> 3、角色</h2><p>由于Oracle提供的权限非常之多，日常操作时我们不可能将所需权限一一赋予用户，此时引进角色概念。角色是一组相关权限的命名集合，使用角色最主要的目的是简化权限管理。将一组权限打包到角色中，将角色赋予用户就是把角色下得全部权限都赋给了用户，简化了赋权操作。</p><p>Oracle提供三种标准的三种角色：</p><p>1）connect角色</p><p>connect是最基本的用户权限，拥有connect权限的用户只可以登录Oracle（仅具有创建SESSION的权限），不可以创建实体，不可以创建数据库结构。</p><p>2）resource角色</p><p>拥有resource权限的用户可以创建数据库对象，和对本用户的数据库对象拥有全部的操作权限。</p><p>3）DBA角色</p><p>DBA角色，拥有全部特权，是系统最高权限。</p><h2 id="4-授于收回权限"><a class="markdownIt-Anchor" href="#4-授于收回权限"></a> 4、授于/收回权限</h2><p>Oracle采用grant命令授于权限，revoke命令收回权限。</p><p>grant命令非常复杂，在实际应用中远远没有那么复杂，所以本文只介绍grant的常用方法。</p><p><strong>1）将对象权限授于用户和角色，revoke收回。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant 对象权限列表 on 对象名 to &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br><span class="line">revoke对象权限列表 on 对象名 from &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的select和insert权限授于girl和scott用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select,insert on scott.T_GIRL to girl,scott;</span><br><span class="line">revoke select,insert on scott.T_GIRL from girl,scott;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的全部权限授于girl和scott用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all on scott.T_GIRL to girl,scott;</span><br><span class="line">revoke all on scott.T_GIRL from girl,scott;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的全部权限授于全部用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on scott.T_GIRL to <span class="keyword">public</span>;</span><br></pre></td></tr></table></figure><p>将scott.T_GIRL表的全部权限授于resource角色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on scott.T_GIRL to resource;</span><br></pre></td></tr></table></figure><p><strong>2）将系统权限和角色权限授于用户，revoke收回。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant &#123; 系统权限 | 角色 &#125;, …… to &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br><span class="line">revoke &#123; 系统权限 | 角色 &#125;, …… from &#123; <span class="keyword">public</span> | 角色名 | 用户名 &#125;,……;</span><br></pre></td></tr></table></figure><p>一般情况下，在新建数据库用户后，都会习惯性的给用户授权connect角色和resource角色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant connect,resource to 用户名;</span><br></pre></td></tr></table></figure><p>将select any table权限授于全部用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select any table to <span class="keyword">public</span>;</span><br><span class="line">revoke select any table from <span class="keyword">public</span>;</span><br></pre></td></tr></table></figure><p>将select any table权限授于connect角色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select any table to connect;</span><br></pre></td></tr></table></figure><p>将select any table和insert any table权限授于girl和scott用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select any table,insert any table to girl,scott;</span><br><span class="line">revoke select any table,insert any table from girl,scott;</span><br></pre></td></tr></table></figure><p>将connect、resource权限授于girl用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant connect,resource to girl;</span><br></pre></td></tr></table></figure><h2 id="5-查询权限"><a class="markdownIt-Anchor" href="#5-查询权限"></a> 5、查询权限</h2><p>从数据字典中可以查询当前用户拥有的权限和角色。</p><p>1）查询当前用户拥有的角色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from USER_ROLE_PRIVS;</span><br></pre></td></tr></table></figure><p>2）查询当前用户拥有的系统权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from USER_SYS_PRIVS;</span><br></pre></td></tr></table></figure><p>3）查询当前用户拥有的对象权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from USER_TAB_PRIVS;</span><br></pre></td></tr></table></figure><h2 id="6-注意事项"><a class="markdownIt-Anchor" href="#6-注意事项"></a> 6、注意事项</h2><p>在Oracle中没有其他数据库系统中的数据库的概念，对象都是创建在用户下。当前用户具有当前用户下全部对象的全部权限无论该对象是否是当前用户所创建。举个简单例子，创建了girl用户并授予connect和resource权限，然后管理员在girl用户下创建一张表，girl用户可以删除管理员在girl用户下创建的表。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle union多表查询</title>
      <link href="/posts/2ca87e18.html"/>
      <url>/posts/2ca87e18.html</url>
      
        <content type="html"><![CDATA[<p>union就是把两个结果集合并起来，被合并的两个结果集的字段数量要相同，数据类型要相似（兼容）。</p><p>union在合并两个结果集的时候，会自动去除重复的数据。</p><p>union all在合并两个结果集的时候，只是简单的将两个结果集中的数据进行连接，不会去除重复的数据。</p><p>我通过一些示例来向大家介绍子查询的常用方法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><h2 id="1-创建超女基本信息历史表t_girl_his"><a class="markdownIt-Anchor" href="#1-创建超女基本信息历史表t_girl_his"></a> 1、创建超女基本信息历史表（T_GIRL_HIS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL_HIS</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key (id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-创建超女基本信息表t_girl"><a class="markdownIt-Anchor" href="#2-创建超女基本信息表t_girl"></a> 2、创建超女基本信息表（T_GIRL）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-测试数据说明"><a class="markdownIt-Anchor" href="#3-测试数据说明"></a> 3、测试数据说明</h2><p><img src="https://img-blog.csdnimg.cn/20200312151059988.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200312151108676.png" alt="在这里插入图片描述" /></p><p>超女基本信息历史表（T_GIRL_HIS）中有4条记录，超女基本信息表（T_GIRL）中有3条记录，两个表中有相交的记录（‘0103’、‘0104’），在图中已用方框圈了出来。</p><h1 id="二-union示例"><a class="markdownIt-Anchor" href="#二-union示例"></a> 二、union示例</h1><h2 id="1-union去重复记录的联合"><a class="markdownIt-Anchor" href="#1-union去重复记录的联合"></a> 1、union（去重复记录的联合）</h2><p>union在合并两个结果集的时候，会自动去除重复的数据。T_GIRL和T_GIRL_HIS用union联合后的结果集有5条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,weight,height,birthday,memo from T_GIRL</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="title class_">select</span> id,name,yz,sc,weight,height,birthday,memo from T_GIRL_HIS;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312151147607.png" alt="在这里插入图片描述" /></p><h2 id="2-union-all不去复记录的重联合"><a class="markdownIt-Anchor" href="#2-union-all不去复记录的重联合"></a> 2、union all（不去复记录的重联合）</h2><p>union all在合并两个结果集的时候，只是简单的将两个结果集中的数据进行连接，不会去除重复的数据。T_GIRL和T_GIRL_HIS用union all联合后的结果集有7条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,weight,height,birthday,memo from T_GIRL</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">all</span> </span><br><span class="line">select id,name,yz,sc,weight,height,birthday,memo from T_GIRL_HIS;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312151232404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-从联合后的结果集中查询"><a class="markdownIt-Anchor" href="#3-从联合后的结果集中查询"></a> 3、从联合后的结果集中查询</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select distinct id,name,yz,sc,weight,height,birthday,<span class="function">memo <span class="title">from</span> </span></span><br><span class="line"><span class="function">  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    select id,name,yz,sc,weight,height,birthday,memo from T_GIRL</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">union</span> all</span></span></span><br><span class="line"><span class="params"><span class="function">    select id,name,yz,sc,weight,height,birthday,memo from T_GIRL_HIS</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span> order by id</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312151311625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>以上SQL的功能相当于union去重复记录的联合查询。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>union在进行结果集联合后会筛选掉重复的记录，所以在表联合后会对所产生的结果集进行排序，删除重复的记录后再返回结果。</p><p>而union all只是简单的将两个结果集合并后就返回，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据。</p><p>从效率上讲，union all要比union快很多，所以，如果可以确定合并的两个结果集中不会包含重复的数据，就应该使用union all。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle join多表查询</title>
      <link href="/posts/98513a74.html"/>
      <url>/posts/98513a74.html</url>
      
        <content type="html"><![CDATA[<p>join（连接）是一个查询，它将来自两个或多个表、视图的数据组合在一起。</p><p>我通过一些示例来向大家介绍join的常用方法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><h2 id="1-创建超女基本信息历史表t_girl_his"><a class="markdownIt-Anchor" href="#1-创建超女基本信息历史表t_girl_his"></a> 1、创建超女基本信息历史表（T_GIRL_HIS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL_HIS</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施_H&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅_H&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已_H&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL_HIS</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐_H&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-创建超女基本信息表t_girl"><a class="markdownIt-Anchor" href="#2-创建超女基本信息表t_girl"></a> 2、创建超女基本信息表（T_GIRL）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-测试数据说明"><a class="markdownIt-Anchor" href="#3-测试数据说明"></a> 3、测试数据说明</h2><p><img src="https://img-blog.csdnimg.cn/20200312145445301.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200312145508158.png" alt="在这里插入图片描述" /></p><p>超女基本信息历史表（T_GIRL_HIS）中有4条记录，为了方便测试，每条记录的姓名后面加了_H的标志，超女基本信息表（T_GIRL）中有3条记录，姓名后没有加_H。</p><p>T_GIRL_HIS和T_GIRL通过id列关联起来，两个表中有相交的记录（‘0103’、‘0104’）。</p><h1 id="二-join示例"><a class="markdownIt-Anchor" href="#二-join示例"></a> 二、join示例</h1><p>连接（join）分为五种，内连接（inner join），左连接（left join），右连接（right join）、全连接（full join）和笛卡儿乘积（cross join），常用的是内连接和左连接，其它的极少使用。</p><h2 id="1-内连接inner-join"><a class="markdownIt-Anchor" href="#1-内连接inner-join"></a> 1、内连接（inner join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312145649634.png" alt="在这里插入图片描述" /></p><p>列出多个表或记录连接字段的匹配记录，即A表和B表的交集。</p><p>内连接有三种写法，这三种写法的效果相同。</p><p>1）标准的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL inner join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>2）省略inner，和第1）种写法相比，只是省略了一个单词而已，没什么特别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>3）还有一种写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS where T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312145817523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-左连接left-join"><a class="markdownIt-Anchor" href="#2-左连接left-join"></a> 2、左连接（left join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312145829487.png" alt="在这里插入图片描述" /><br />列出左边（A）表全部的，及右边（B）表符合条件的，不符合条件的以空值代替，记录总数为A表的记录数。</p><p>左连接有两种写法，这两种写法的效果相同。</p><p>1）标准的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL left join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>2）采用(+)，Oracle特有的写法，其它数据库不支持，注意(+)的位置，在右边字段后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS where T_GIRL.id=T_GIRL_HIS.<span class="built_in">id</span>(+);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312145920895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-右连接right-join"><a class="markdownIt-Anchor" href="#3-右连接right-join"></a> 3、右连接（right join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312145932583.png" alt="在这里插入图片描述" /></p><p>列出右边（B）表全部的，及左边（A）表符合条件的，不符合条件的以空值代替，记录总数为B表的记录数。</p><p>右连接有两种写法，这两种写法的效果相同。</p><p>1）标准的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL right join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p>2）采用(+)，Oracle特有的写法，其它数据库不支持，注意(+)的位置，在左边字段后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS where T_GIRL.<span class="built_in">id</span>(+)=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031215003169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>右连接其实就是把左连接换个顺序书写，和左连接没有任何本质的区别。</p><h2 id="4-全连接full-join"><a class="markdownIt-Anchor" href="#4-全连接full-join"></a> 4、全连接（full join）</h2><p><img src="https://img-blog.csdnimg.cn/20200312150045120.png" alt="在这里插入图片描述" /></p><p>列出右边（B）表全部的，及左边（A）表全部的，不符合条件的以空值代替，记录总数为A表与B表的记录数之和再减相交的记录数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL full join T_GIRL_HIS on T_GIRL.id=T_GIRL_HIS.id;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312150113904.png" alt="在这里插入图片描述" /></p><h2 id="5-笛卡儿乘积cross-join"><a class="markdownIt-Anchor" href="#5-笛卡儿乘积cross-join"></a> 5、笛卡儿乘积（cross join）</h2><p>笛卡儿乘积连接，不加任何条件，记录总数为两个表相乘。</p><p>笛卡儿乘积连接有两种写法，这两种写法的效果相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL cross join T_GIRL_HIS;</span><br><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.sc,T_GIRL.yz,T_GIRL_HIS.id,T_GIRL_HIS.name</span><br><span class="line">  from T_GIRL,T_GIRL_HIS;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312150140541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>在实际开发中，内连接（inner join）和左连接（left join）经常使用，右连接（right join）和左连接本质上是同一回事，全连接（full join）和笛卡儿乘积（cross join）极少使用。</p><h2 id="1-尽可能简单化sql语句"><a class="markdownIt-Anchor" href="#1-尽可能简单化sql语句"></a> 1、尽可能简单化SQL语句</h2><p>SQL语句非常强大，强大到很容易把人搞晕，例如多表操作，有经验的程序员也很难应用自如。我极力反对过于复杂的SQL语句，复杂的SQL语句并不见得能体现程序员的水平，更像给自己和别人挖坑，合理的表结构设计不会让查询的SQL太复杂。</p><h2 id="2-子查询与join"><a class="markdownIt-Anchor" href="#2-子查询与join"></a> 2、子查询与join</h2><p>1）join和子查询都可以操作多个表，join和子查询的区别是：join可以合并多个表的数据，而子查询的数据只能来自一个表，子查询的结果集用于嵌入SQL中。</p><p>2）有的查询语句既可以使用子查询，也可以使用join。如果使用子查询，可以将一个复杂的查询分解为一系列的步骤，条理清晰；但使用join有执行速度快的优点。</p><p>3）用join能实现的功能用子查询都可以实现，但不是所有子查询都能用join替换，子查询比较灵活，方便，形式多样，而join更适合查询多表的数据。</p><p>4）如果表的数据量比较小，建议采用子查询，如果数据量比较大，建议采用join，但是具体情况具体分析，多尝试用PL/SQL Developer软件提供的explain plan分析SQL语句的性能。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle子查询</title>
      <link href="/posts/5261b851.html"/>
      <url>/posts/5261b851.html</url>
      
        <content type="html"><![CDATA[<p>如果SQL语句中包含了另一个select语句的时候，就称为子查询，子查询在select、insert、update或delete命令中都可以包含子查询，子查询还可以包含在另外一个子查询中，以便完成更为复杂的查询。</p><p>我通过一些示例来向大家介绍子查询的常用方法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><h2 id="1-颜值参数表"><a class="markdownIt-Anchor" href="#1-颜值参数表"></a> 1、颜值参数表</h2><table><thead><tr><th>编号（主键）</th><th>颜值描述</th><th>显示顺序</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>倾国倾城</td><td>1</td><td>第一等美女。</td></tr><tr><td>2</td><td>风华绝代</td><td>2</td><td>第二等美女。</td></tr><tr><td>3</td><td>迷倒众生</td><td>3</td><td>第三等美女。</td></tr><tr><td>4</td><td>漂亮</td><td>4</td><td>普通美女。</td></tr><tr><td>5</td><td>一般</td><td>5</td><td></td></tr><tr><td>6</td><td>猪扒</td><td>6</td><td></td></tr></tbody></table><h2 id="2-身材参数表"><a class="markdownIt-Anchor" href="#2-身材参数表"></a> 2、身材参数表</h2><table><thead><tr><th>编号（主键）</th><th>身材描述</th><th>显示顺序</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>火辣</td><td>1</td><td>前凸后翘。</td></tr><tr><td>2</td><td>丰满</td><td>2</td><td>体态丰腴。</td></tr><tr><td>3</td><td>苗条</td><td>3</td><td>风姿绰约。</td></tr><tr><td>4</td><td>一般</td><td>4</td><td></td></tr><tr><td>5</td><td>膘肥体壮</td><td>5</td><td>强悍无比。</td></tr></tbody></table><h2 id="3-超女基本信息表"><a class="markdownIt-Anchor" href="#3-超女基本信息表"></a> 3、超女基本信息表</h2><table><thead><tr><th>编号 （主键）</th><th>姓名</th><th>颜值代码 （外键）</th><th>身材代码 （外键）</th><th>身高</th><th>备注</th></tr></thead><tbody><tr><td>0101</td><td>西施</td><td>2</td><td>4</td><td>170</td><td>这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。</td></tr><tr><td>0102</td><td>貂禅</td><td>1</td><td>2</td><td>168</td><td>王允真不是男人，干不过董卓就把美人往火坑里推，无能。</td></tr><tr><td>0103</td><td>妲已</td><td>1</td><td></td><td>172</td><td>如果商真的因我而亡，您们男人做什么去了？</td></tr><tr><td>0104</td><td>芙蓉姐姐</td><td>6</td><td>5</td><td>166</td><td>如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。</td></tr><tr><td>0105</td><td>神密猫女</td><td></td><td>2</td><td>171</td><td>不知道是什么人，她脸上有一个%符号，很神密。</td></tr></tbody></table><h2 id="4-表之间的关系图"><a class="markdownIt-Anchor" href="#4-表之间的关系图"></a> 4、表之间的关系图</h2><p><img src="https://img-blog.csdnimg.cn/20200312143356608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-生成测试数据"><a class="markdownIt-Anchor" href="#5-生成测试数据"></a> 5、生成测试数据</h2><p>运行以下脚本，生成测试数据；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Table: 颜值参数表   */</span></span><br><span class="line"><span class="function">create table <span class="title">T_YZCODE</span>  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   yzid               number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   yzname             varchar2(<span class="number">10</span>)                    <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   orderby            number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   memo               varchar2(<span class="number">300</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_YZCODE add constraint PK_YZCODE primary <span class="title">key</span><span class="params">(yzid)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;倾国倾城&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;第一等美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">2</span>,<span class="string">&#x27;风华绝代&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;第二等美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">3</span>,<span class="string">&#x27;迷倒众生&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;第三等美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">4</span>,<span class="string">&#x27;漂亮&#x27;</span>,<span class="number">4</span>,<span class="string">&#x27;普通美女。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;一般&#x27;</span>,<span class="number">5</span>,null)</span></span>;</span><br><span class="line"><span class="function">insert into T_YZCODE <span class="title">values</span><span class="params">(<span class="number">6</span>,<span class="string">&#x27;猪扒&#x27;</span>,<span class="number">6</span>,null)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Table: 身材参数表   */</span></span><br><span class="line"><span class="function">create table <span class="title">T_SCCODE</span>  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   scid               number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   scname             varchar2(<span class="number">10</span>)                    <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   orderby            number(<span class="number">2</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   memo               varchar2(<span class="number">300</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_SCCODE add constraint PK_SCCODE primary <span class="title">key</span><span class="params">(scid)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;火辣&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;前凸后翘。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">2</span>,<span class="string">&#x27;丰满&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;体态丰腴。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">3</span>,<span class="string">&#x27;苗条&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;风姿绰约。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">4</span>,<span class="string">&#x27;一般&#x27;</span>,<span class="number">4</span>,null)</span></span>;</span><br><span class="line"><span class="function">insert into T_SCCODE <span class="title">values</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;强悍无比。&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Table: 超女基本信息表   */</span></span><br><span class="line"><span class="function">create table <span class="title">T_GIRL</span>  <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   id                 <span class="type">char</span>(<span class="number">4</span>)                       <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   name               varchar2(<span class="number">10</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   scid               number(<span class="number">2</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   yzid               number(<span class="number">2</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   height             number(<span class="number">3</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   memo               varchar2(<span class="number">300</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint FK_GIRL_SC foreign <span class="title">key</span><span class="params">(scid)</span> references <span class="title">T_SCCODE</span><span class="params">(scid)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint FK_GIRL_YZ foreign <span class="title">key</span><span class="params">(yzid)</span> references <span class="title">T_YZCODE</span><span class="params">(yzid)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，无能。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="number">1</span>,null,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yzid,scid,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,<span class="number">2</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>各表中的数据如下：</p><p><img src="https://img-blog.csdnimg.cn/20200312143552395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200312143602876.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200312143611787.png" alt="在这里插入图片描述" /></p><h1 id="二-表名限定"><a class="markdownIt-Anchor" href="#二-表名限定"></a> 二、表名限定</h1><p>在SQL语句中，列是指表（视图、结果集）的列，可以在列名前加表名限定，也可以用表的别名限定，例如：</p><p>1）不加表名限定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,scid,yzid,height,memo from T_GIRL;</span><br></pre></td></tr></table></figure><p>2）用表名限定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select T_GIRL.id,T_GIRL.name,T_GIRL.scid,T_GIRL.yzid,T_GIRL.height,T_GIRL.memo from T_GIRL;</span><br></pre></td></tr></table></figure><p>3）用表的别名限定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select aa.id,aa.name,aa.scid,aa.yzid,aa.height,aa.memo from T_GIRL aa;</span><br></pre></td></tr></table></figure><p><strong>以上三条SQL语句只操作了一个表，列名可以不用表名限定，但是，在子查询中，如果这多个表中有相同的列名，则必须在列名前面加表名限定，以避免歧义。</strong></p><h1 id="三-子查询示例"><a class="markdownIt-Anchor" href="#三-子查询示例"></a> 三、子查询示例</h1><h2 id="1-在字段列表中使用子查询"><a class="markdownIt-Anchor" href="#1-在字段列表中使用子查询"></a> 1、在字段列表中使用子查询</h2><p>查询T_GIRL表，并从T_SCCODE表中获取身材的中文，从T_YZCODE表中获取颜值的中文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height,memo,</span><br><span class="line">       (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span><br><span class="line">       (select yzname from T_YZCODE where yzid=T_GIRL.yzid) yzname</span><br><span class="line">  from T_GIRL;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312143752685.png" alt="在这里插入图片描述" /></p><p>在上面的SQL语句中，T_GIRL和T_SCCODE表都有相同的列名scid，在子查询</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select scname from T_SCCODE where scid=T_GIRL.scid)</span><br></pre></td></tr></table></figure><p>中，第一个scid不需要加T_SCCODE表名的限定，第二个scid要加T_GIRL表名的限定。</p><h2 id="2-在where子句中使用子查询"><a class="markdownIt-Anchor" href="#2-在where子句中使用子查询"></a> 2、在where子句中使用子查询</h2><p>子查询可以作为where子句条件的值，如果用的是in比较运算符，子查询可以是多行的结果集，其它比较运算符是单行的结果集。</p><p>1）条件的值是单行的结果集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height,memo,</span><br><span class="line">      (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span><br><span class="line">      (select yzname from T_YZCODE where yzid=T_GIRL.yzid) yzname</span><br><span class="line"> from T_GIRL</span><br><span class="line">where yzid=(select yzid from T_YZCODE where yzname=<span class="string">&#x27;风华绝代&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031214394391.png" alt="在这里插入图片描述" /></p><p>2）条件的值是多行的结果集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height,memo,</span><br><span class="line">      (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span><br><span class="line">      (select yzname from T_YZCODE where yzid=T_GIRL.yzid) <span class="function">yzname</span></span><br><span class="line"><span class="function"> from T_GIRL</span></span><br><span class="line"><span class="function">where yzid <span class="title">in</span> <span class="params">(select yzid from T_YZCODE where yzname in (<span class="string">&#x27;风华绝代&#x27;</span>,<span class="string">&#x27;倾国倾城&#x27;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144017137.png" alt="在这里插入图片描述" /></p><h2 id="3-从结果集中查询"><a class="markdownIt-Anchor" href="#3-从结果集中查询"></a> 3、从结果集中查询</h2><p>从结果集中查询也称之为select的嵌套，注意，里层的select的列该用别名的地方要用别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yzname,scname,<span class="function">memo <span class="title">from</span></span></span><br><span class="line"><span class="function">       <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        select id,name,height,memo,</span></span></span><br><span class="line"><span class="params"><span class="function">               (select scname from T_SCCODE where scid=T_GIRL.scid) scname,</span></span></span><br><span class="line"><span class="params"><span class="function">               (select yzname from T_YZCODE where yzid=T_GIRL.yzid) yzname</span></span></span><br><span class="line"><span class="params"><span class="function">          from T_GIRL</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> T_MYGIRL</span></span><br><span class="line"><span class="function"> where  yzname</span>=<span class="string">&#x27;倾国倾城&#x27;</span> <span class="keyword">or</span> scname=<span class="string">&#x27;丰满&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144054292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="4-在insert中使用子查询"><a class="markdownIt-Anchor" href="#4-在insert中使用子查询"></a> 4、在insert中使用子查询</h2><p>1）创建一个临时表TT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">TT</span><span class="params">(id <span class="type">char</span>(<span class="number">4</span>),name varchar2(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>2）在TT中插入多条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into TT select id,name from T_GIRL;</span><br></pre></td></tr></table></figure><p>3）在TT中插入一条记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into TT <span class="title">values</span><span class="params">(<span class="string">&#x27;1088&#x27;</span>,(select name from T_GIRL where id=<span class="string">&#x27;0102&#x27;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144147442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-在delete中使用子查询"><a class="markdownIt-Anchor" href="#5-在delete中使用子查询"></a> 5、在delete中使用子查询</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delete</span> from TT where id <span class="title">in</span> <span class="params">(select id from T_GIRL)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="6-在update中使用子查询"><a class="markdownIt-Anchor" href="#6-在update中使用子查询"></a> 6、在update中使用子查询</h2><p>1）在T_GIRL增加一个列（yzname颜值中文），用于测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add yzname <span class="title">varchar2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2）用T_YZCODE表中的yzname更新T_GIRL表的yzname。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update T_GIRL</span><br><span class="line">   set yzname=(select yzname from T_YZCODE where T_YZCODE.yzid= T_GIRL.yzid);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144317512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="7-在create-table中使用子查询"><a class="markdownIt-Anchor" href="#7-在create-table中使用子查询"></a> 7、在create table中使用子查询</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 新表名 as 子查询</span><br></pre></td></tr></table></figure><p>例如用T_GIRL的结构创建T_MYGIRL表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table T_MYGIRL as select * from T_GIRL where yzid <span class="title">in</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312144404413.png" alt="在这里插入图片描述" /></p><p>如果想创建一张空的表，可以用where 1=2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table T_MYGIRL as select * from T_GIRL where <span class="number">1</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>注意一个问题，用以上方法创建的表只有基本的结构，没有主键、没有索引、没有表约束，没有列约束。</p><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>在SQL语句中，可以把子查询当成表达式或结果集（单行和多行），只要逻辑正确，子查询可用于SQL语句的任何地方。</p><p>SQL非常强大，您能想到的需求它都能支持，本文只介绍了常用子查询的用法，有些我也没有想到。</p><p>所以，大家要放开思路，大胆的想，大胆的尝试。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的主键和外键</title>
      <link href="/posts/8bcdd547.html"/>
      <url>/posts/8bcdd547.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-表的主键"><a class="markdownIt-Anchor" href="#一-表的主键"></a> 一、表的主键</h1><p>在现实世界中，很多数据具有唯一的特性，例如身份证号码，在国家人口基本信息表中，一定不会存在多个人用同一个身份证号码的情况，再例如手机号码、QQ号码、银行帐号等等，还有学生管理系统，学生的年级、班级和学号三个字段组合起来是唯一的标识。</p><p>如果表中一个字段或多个字段组合起来的值是唯一的，就可以作为表的主键，在创建或修改表时用primay key关键字来指定主键。一个表只能有一个主键，而且组成主键的每个字段值都不能为空。</p><p>主键的作用：</p><p>1）体现数据结构设计的合理性。</p><p>2）提升数据操作的速度。</p><p>3）保证数据的完整性，在表中添加或修改记录时，数据库会检查该记录主键的值，不允许与其它记录主键的值重复，这种做法有个专业的名词：主键约束。</p><p>例如超女基本信息表，编号的字段名是id，在超女选秀活动中，每个超女的编号肯定是唯一的，不可能存在两个编号相同的超女，否则会引起混乱，我们可以把id字段设置为T_GIRL表的主键，后面的工作交给数据库，如果试图往表中插入多条id相同的记录，数据库将拒绝。</p><p>指定表的主建有两种方法。</p><p>1）在create table时指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 指定id为表的主键</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>2）修改已经建好的表，增加主键约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 主键名 <span class="function">primary <span class="title">key</span><span class="params">(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n)</span></span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br></pre></td></tr></table></figure><p>在Oracle数据库中，虽然主键不是必需的，但是最好为每个表都设置一个主键，不管是单字段主键还是多字段主键（复合主键），它的存在代表了表结构的完整性，主键还可以用于其他表的外键关联，外键的知识下面再介绍。</p><h1 id="二-表的外键"><a class="markdownIt-Anchor" href="#二-表的外键"></a> 二、表的外键</h1><h2 id="1-外键的概念"><a class="markdownIt-Anchor" href="#1-外键的概念"></a> 1、外键的概念</h2><p>外键（foreign key）是用于表达两个表数据之间的关系，将表中主键字段添加到另一个表中，再创建两个表之间的约束关系，这些字段就成为第二个表的外键。</p><p>超女选秀活动有两个数据表：</p><p>1）赛区参数表</p><p>赛区代码，赛区名称，……。</p><p>2）超女基本信息表</p><p>赛区代码、超女编号、姓名、颜值、身材、身高、体重、……。</p><p>录入超女基本信息的时候要选择赛区，为了保证数据的有效，要求录入赛区代码时，必须保证赛区参数表中有这个赛区代码，否则数据是不一致的，为了保证数据的完整性，必须在程序中判断数据的合法性。针对这种情况，在表结构设计中采用外键来约束这两个表的赛区代码字段。</p><p>对赛区参数表来说，赛区代码是该表的主键。</p><p>对超女基本信息表来说，赛区代码是该表的外键。</p><p>赛区参数表也称为<strong>主表</strong>，超女基本信息表也称为<strong>从表</strong>。</p><h2 id="2-外键的作用"><a class="markdownIt-Anchor" href="#2-外键的作用"></a> 2、外键的作用</h2><p>合理的数据结构设计，表中的数据一定有一致性约束，使用外键，让数据库去约束数据的一致，不给任何人出错的机会。不用外键会怎样？不用也不会怎么样，如果不用外键，在程序中要写代码进行判断，手工操作数据时也必须处处小心。</p><h2 id="3-外键约束"><a class="markdownIt-Anchor" href="#3-外键约束"></a> 3、外键约束</h2><p><strong>1）当对从表进行操作时，数据库会：</strong></p><p>a）向从表插入新记录时，如果外键值在主表中不存在，阻止插入。</p><p>b）修改从表的记录时，如果外键的值在主表中不存在，阻止修改。</p><p><strong>2）当对主表进行修改操作时，数据库会：</strong></p><p>a）主表修改主键值时，旧值在从表里存在便阻止修改。</p><p><strong>3）当对主表进行删除操作时，数据库会（三选一）：</strong></p><p>a）主表删除行时，其主键值在从表里存在便阻止删除。</p><p>b）主表删除行时，连带从表的相关行一起删除。</p><p>c）主表删除行时，把从表相关行的外键字段置为null。</p><h2 id="4-创建外键"><a class="markdownIt-Anchor" href="#4-创建外键"></a> 4、创建外键</h2><p>创建外键的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table 从表名</span><br><span class="line">   add constraint 外键名 <span class="function">foreign <span class="title">key</span> <span class="params">(从表字段列表)</span></span></span><br><span class="line"><span class="function">      references 主表名 <span class="params">(主表字段列表)</span></span></span><br><span class="line"><span class="function">      [on <span class="keyword">delete</span> cascade|set null]</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>外键名，Oracle的标识符，建议采用<strong>FK_从表名_主表名</strong>的方式命名。</p><p>主表执行删除行时，其主键值在从表里存在便阻止删除，如果on delete cascade，连带从表的相关行一起删除；如果on delete set null，把从表相关行的外键字段置为null。</p><h2 id="5-删除外键"><a class="markdownIt-Anchor" href="#5-删除外键"></a> 5、删除外键</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 从表名 drop constraint 外键名;</span><br></pre></td></tr></table></figure><h2 id="6-示例脚本"><a class="markdownIt-Anchor" href="#6-示例脚本"></a> 6、示例脚本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建赛区参数表。 */</span></span><br><span class="line"><span class="function">create table <span class="title">T_AREACODE</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  areaid   number(<span class="number">2</span>)   <span class="keyword">not</span> null,    -- 赛区代码，非空。</span></span></span><br><span class="line"><span class="params"><span class="function">  areaname varchar(<span class="number">20</span>) <span class="keyword">not</span> null,    -- 赛区名称，非空。</span></span></span><br><span class="line"><span class="params"><span class="function">  memo     varchar(<span class="number">300</span>),            -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(areaid)               -- 创建主健。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建超女基本信息表。 */</span></span><br><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)        null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  areaid    number(<span class="number">2</span>)           null,   -- 赛区代码</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 创建主健。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下三种创建外键的方式只能三选一  */</span></span><br><span class="line"><span class="comment">/* 为T_GIRL创建外键，无on delete选项。 */</span></span><br><span class="line"><span class="function">alter table T_GIRL</span></span><br><span class="line"><span class="function">   add constraint FK_GIRL_AREACODE foreign <span class="title">key</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      references <span class="title">T_AREACODE</span><span class="params">(areaid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为T_GIRL创建外键，采用on delete cascade选项。 */</span></span><br><span class="line"><span class="function">alter table T_GIRL</span></span><br><span class="line"><span class="function">   add constraint FK_GIRL_AREACODE foreign <span class="title">key</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      references <span class="title">T_AREACODE</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      on <span class="keyword">delete</span> cascade</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为T_GIRL创建外键，采用on delete set null选项。 */</span></span><br><span class="line"><span class="function">alter table T_GIRL</span></span><br><span class="line"><span class="function">   add constraint FK_GIRL_AREACODE foreign <span class="title">key</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      references <span class="title">T_AREACODE</span><span class="params">(areaid)</span></span></span><br><span class="line"><span class="function">      on <span class="keyword">delete</span> set null</span>;</span><br></pre></td></tr></table></figure><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的distinct关键字</title>
      <link href="/posts/d6978e08.html"/>
      <url>/posts/d6978e08.html</url>
      
        <content type="html"><![CDATA[<p>distinct关键字用于从查询的结果集中筛选出唯一值的记录。</p><p>我们通过示例来介绍distinct关键字的用法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-distinct示例"><a class="markdownIt-Anchor" href="#二-distinct示例"></a> 二、distinct示例</h1><p>从T_GIRL表中查出全部的颜值信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select yz from T_GIRL;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312110201737.png" alt="在这里插入图片描述" /></p><p>如果我想知道颜值有哪些取值，所以希望从结果集中去掉重复的记录，加上distinct关键字，位置在select和字段列表之间。</p><p><img src="https://img-blog.csdnimg.cn/20200312110226878.png" alt="在这里插入图片描述" /></p><p>distinct是从结果集中筛选出唯一值的记录，上面示例的结果集只有一个字段，也可以多个字段，多个字段组合的值唯一。</p><p>未加distinct关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select yz,sc from T_GIRL; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031211031576.png" alt="在这里插入图片描述" /></p><p>加了distinct关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct yz,sc from T_GIRL; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312110350993.png" alt="在这里插入图片描述" /></p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的别名</title>
      <link href="/posts/2f52b857.html"/>
      <url>/posts/2f52b857.html</url>
      
        <content type="html"><![CDATA[<p>在SQL语句中，可以给表和列起别名，这是临时的别名，与同义词不一样，同义词是永久的别名。</p><p>别名是多表查询和嵌套查询语句的基础知识，本文只介绍别名的语法，不涉及别名的应用技巧，大家在学习的时候可能觉得别名没什么意义，其实不然。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-表和列的别名"><a class="markdownIt-Anchor" href="#二-表和列的别名"></a> 二、表和列的别名</h1><p>我们先来看一个SQL语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200312104958171.png" alt="在这里插入图片描述" /></p><p>select语句返回结果集的列标题是列名，如果对列用了函数就是函数的文本。</p><p>试试别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id 编号,name 姓名,yz 颜值,sc 身材,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) 生日</span><br><span class="line">  from T_GIRL 超女基本信息表;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020031210505256.png" alt="在这里插入图片描述" /></p><h2 id="1-列的别名"><a class="markdownIt-Anchor" href="#1-列的别名"></a> 1、列的别名</h2><p>列的别名有两种写法：</p><p>1）直接在列后面加空格写别名，例如：name 姓名。</p><p>2）使用as在列后面再写别名，例如：name as 姓名。</p><p>别名可以直接书写，如果别名中有特殊字符，如数字、单引号和空格，就用双引号将别名括起来。</p><h2 id="2-表的别名"><a class="markdownIt-Anchor" href="#2-表的别名"></a> 2、表的别名</h2><p>表的别名与列的别名不同的地方就是表的别名不能用as。</p><h1 id="三-注意事项"><a class="markdownIt-Anchor" href="#三-注意事项"></a> 三、注意事项</h1><h2 id="1-列的别名-2"><a class="markdownIt-Anchor" href="#1-列的别名-2"></a> 1、列的别名</h2><p>列的别名这种说法不准确，准确的说法是结果集的列的别名，以下用示例来证明。</p><p>1）列的别名不能用在where子句中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id 编号,name 姓名 from T_GIRL where id=<span class="string">&#x27;0101&#x27;</span>;</span><br><span class="line">select id 编号,name 姓名 from T_GIRL where 编号=<span class="string">&#x27;0101&#x27;</span>;</span><br></pre></td></tr></table></figure><p>以上两条SQL语句，第一条是正确的，第二条会报错。</p><p>2）列的别名可以用于order by关键字中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id 编号,name 姓名 from T_GIRL order by id;</span><br><span class="line">select id 编号,name 姓名 from T_GIRL order by 编号;</span><br></pre></td></tr></table></figure><p>以上两条SQL语句都是正确的。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle同义词</title>
      <link href="/posts/aeab5e37.html"/>
      <url>/posts/aeab5e37.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-同义词的概念"><a class="markdownIt-Anchor" href="#一-同义词的概念"></a> 一、同义词的概念</h1><p>同义词（synonym）就是数据库对象的别名，这里的数据库对象包括表、视图、序列、存储过程、包等。</p><p>同义词有两方面的意义：1）简化了数据库对象名称的书写；2）提高了数据库对象的安全性（因为只知道对象的别名，不知道它的真名）。</p><p>Oracle的dual虚表其实就是一个公用的同义词。</p><h1 id="二-创建同义词"><a class="markdownIt-Anchor" href="#二-创建同义词"></a> 二、创建同义词</h1><h2 id="1-创建同义词的权限"><a class="markdownIt-Anchor" href="#1-创建同义词的权限"></a> 1、创建同义词的权限</h2><p>用dba权限登录数据库，授于用户create synonym和create public synonym权限。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant create synonym to 用户名;</span><br><span class="line">grant create <span class="keyword">public</span> synonym to 用户名;</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200312094747768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-创建synonym的命令"><a class="markdownIt-Anchor" href="#2-创建synonym的命令"></a> 2、创建synonym的命令</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">public</span>] synonym 同义词名 <span class="keyword">for</span> [用户名.]数据库对象名;</span><br></pre></td></tr></table></figure><p>说明：</p><p>public：同义词的类型，缺省是当前用户私有的，只有当前用户可以使用该同义词，如果加上public选项，表示公用同义词，所有的数据库用户都可以使用。</p><p>用户名：数据库对象所属的用户，缺省是当前用户。</p><p>数据对象名：常用的是表、视图和序列，其它的不常用。</p><p>注意，如果对其它用户的对象创建同义词，当前用户必须具备对其它用户对象的权限，否则同义词无法使用。</p><p>示例：</p><p>1）为当前用户的dept表创建同义词mydept。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create synonym mydept <span class="keyword">for</span> dept;</span><br></pre></td></tr></table></figure><p>2）为scott用户的emp表创建同义词myemp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create synonym myemp <span class="keyword">for</span> scott.emp;</span><br></pre></td></tr></table></figure><p>3）为远程数据库的scott用户的emp表创建同义词remoteemp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create synonym remoteemp <span class="keyword">for</span> scott.emp@dblink_01;</span><br></pre></td></tr></table></figure><p>4）测试效果。</p><p><img src="https://img-blog.csdnimg.cn/20200312094923950.png" alt="在这里插入图片描述" /></p><h1 id="三-删除同义词"><a class="markdownIt-Anchor" href="#三-删除同义词"></a> 三、删除同义词</h1><p>删除当前用户私有的同义词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop synonym 同义词名;</span><br></pre></td></tr></table></figure><p>删除公用的同义词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop <span class="keyword">public</span> synonym 公用同义词名;</span><br></pre></td></tr></table></figure><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库链路</title>
      <link href="/posts/55aff1ac.html"/>
      <url>/posts/55aff1ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-数据库链路的概念"><a class="markdownIt-Anchor" href="#一-数据库链路的概念"></a> 一、数据库链路的概念</h1><p>数据库链路（database link），简称dblink，它是一个通道，是本地数据库与远程数据库之间的通道，通过dblink，在本地数据库中可以直接访问远程数据库的对象。</p><p>dblink不是应用程序与数据库之间的通道，而是数据库之间的通道。</p><h1 id="二-创建dblink"><a class="markdownIt-Anchor" href="#二-创建dblink"></a> 二、创建dblink</h1><h2 id="1-创建dblink的权限"><a class="markdownIt-Anchor" href="#1-创建dblink的权限"></a> 1、创建dblink的权限</h2><p>用dba权限登录数据库，授于用户create database link和create public database link权限。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant create database link to 用户名;</span><br><span class="line">grant create <span class="keyword">public</span> database link to 用户名;</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200312092903405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-创建dblink的命令"><a class="markdownIt-Anchor" href="#2-创建dblink的命令"></a> 2、创建dblink的命令</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">public</span>] database link 数据库链路名称</span><br><span class="line">connect to 用户名</span><br><span class="line">identified by 密码</span><br><span class="line"><span class="keyword">using</span> <span class="string">&#x27;远程数据库参数&#x27;</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>public：dblink的类型，缺省是当前用户私有的，只有当前用户可以使用该dblink，如果加上public选项，表示公用dblink，所有的数据库用户都可以使用。</p><p>数据库链路名称：给dblink起个名字。</p><p>用户名：远程数据库登录的用户名。</p><p>密码：远程数据库登录的用户的密码。</p><p>远程数据库参数：该参数的配置有两种方法：1）远程数据库的服务名，也就是本地数据库服务器上$ORACLE_HOME/network/admin/tnsnames.ora中配置的数据库服务名；2）不采用tnsnames.ora中的配置，直接指定远程数据库的参数。</p><h2 id="3-用数据库服务名创建dblink"><a class="markdownIt-Anchor" href="#3-用数据库服务名创建dblink"></a> 3、用数据库服务名创建dblink</h2><p>1）配置远程数据库服务名</p><p>远程数据库服务名在$ORACLE_HOME/network/admin/tnsnames.ora文件中配置，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">snorcl11g_198 =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = <span class="number">118.89</span><span class="number">.50</span><span class="number">.198</span>)(PORT = <span class="number">1521</span>))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SID = snorcl11g)</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>2）测试远程数据库登录参数</p><p><img src="https://img-blog.csdnimg.cn/20200312093034967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>3）创建dblink</p><p>用远程数据库服务名创建dblink，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database link dblink_01 connect to shqx identified by pwdidc <span class="keyword">using</span> <span class="string">&#x27;snorcl11g_198&#x27;</span>;</span><br></pre></td></tr></table></figure><p>4）测试dblink</p><p>通过dblink获取远程数据库的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200312093115617.png" alt="在这里插入图片描述" /></p><h2 id="4-不用数据库服务名创建dblink"><a class="markdownIt-Anchor" href="#4-不用数据库服务名创建dblink"></a> 4、不用数据库服务名创建dblink</h2><p>如果不用数据库服务创建dblink，就不需要配置tnsnames.ora文件。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create database link dblink_02 connect to shqx identified by pwdidc <span class="keyword">using</span></span><br><span class="line"><span class="string">&#x27;(DESCRIPTION =</span></span><br><span class="line"><span class="string">   (ADDRESS_LIST =</span></span><br><span class="line"><span class="string">     (ADDRESS = (PROTOCOL = TCP)(HOST = 118.89.50.198)(PORT = 1521))</span></span><br><span class="line"><span class="string">   )</span></span><br><span class="line"><span class="string">   (CONNECT_DATA =</span></span><br><span class="line"><span class="string">     (SID = snorcl11g)</span></span><br><span class="line"><span class="string">     (SERVER = DEDICATED)</span></span><br><span class="line"><span class="string">   )</span></span><br><span class="line"><span class="string"> )&#x27;</span>;</span><br></pre></td></tr></table></figure><p>dblink_01和dblink_02完全一样。</p><h1 id="三-dblink的使用"><a class="markdownIt-Anchor" href="#三-dblink的使用"></a> 三、dblink的使用</h1><p>如果要访问远程数据库的表或视图，在表和视图名之后附加@dblinkname就可以了。</p><p>访问远程数据库的dual表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sysdate from dual@dblink_01;</span><br></pre></td></tr></table></figure><p>访问远程数据库的scott.emp表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from scott.emp@dblink_02;</span><br></pre></td></tr></table></figure><h1 id="四-删除dblink"><a class="markdownIt-Anchor" href="#四-删除dblink"></a> 四、删除dblink</h1><p>删除当前用户私有的dblink：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database link 数据库链路名;</span><br></pre></td></tr></table></figure><p>删除公用的dblink：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop <span class="keyword">public</span> database link 公用数据库链路名;</span><br></pre></td></tr></table></figure><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>dblink的知识很容易掌握，用dblink访问远程数据库的对象很方便，但是，如果在程序中采用dblink对远程数据库的表进行增、删、改、查操作时一定要遵守一个原则：<strong>尽可能不要产生远程事务，因为数据库对远程的事务难以控制</strong>，也就是说，尽可能不要对远程数据库的表进行增、删、改操作，查询是没有问题的。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle视图</title>
      <link href="/posts/7b0aedda.html"/>
      <url>/posts/7b0aedda.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-视图的概念"><a class="markdownIt-Anchor" href="#一-视图的概念"></a> 一、视图的概念</h1><p>视图是基于一个或者多个表上的预定义查询，这些表称为基表，从视图中查询数据的方法与从基表中查询数据的方法相同。视图是一个查看数据的窗口，是查询语句模板，视图本身没有数据，在数据库中只保存了视图的定义。</p><p>视图具有以下优点：</p><p>1）可以向数据访问者只开放访问视图的权限，屏蔽基表信息。</p><p>2）可以将复杂的查询语句保存为视图，简化了SQL语句的编写。</p><p>3）创建视图的时候，可以限制只访问基表中的部分列或者部分行的数据，这样可以实现一定的安全性。</p><p>4）简化用户权限的管理，只授予用户使用视图的权限。</p><p>5）从基表中按一定的业务逻辑抽出用户关心的部分数据创建视图，简化了业务逻辑。</p><h1 id="二-创建视图"><a class="markdownIt-Anchor" href="#二-创建视图"></a> 二、创建视图</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] [&#123;force|noforce&#125;] view 视图名</span><br><span class="line">as</span><br><span class="line">select查询语句</span><br><span class="line">[with read only]</span><br></pre></td></tr></table></figure><p>语法解析：</p><p><strong>or replace</strong>：如果视图已经存在，则替换旧视图。</p><p><strong>force</strong>：即使基表不存在，也可以创建该视图，但是该视图不能正常使用，当基表创建成功后，视图才能正常使用。</p><p><strong>noforce</strong>：如果基表不存在，无法创建视图，该项是默认选项。</p><p><strong>with read only</strong>：默认可以通过视图对基表执行增删改操作，with read only强调这是只读视图，不能通过该视图进行增删改操作。现实开发中，基本上不通过视图对表中的数据进行增删改操作。</p><p>示例一，在超女表中创建一个简单的视图V_GIRL，只提取编号、姓名、身材和颜值字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace noforce view V_GIRL</span><br><span class="line">as</span><br><span class="line">select id,name,sc,yz from T_GIRL</span><br><span class="line">with read only;</span><br></pre></td></tr></table></figure><p>从V_GIRL视图中查询数据：</p><p><img src="https://img-blog.csdnimg.cn/20200312091011810.png" alt="在这里插入图片描述" /></p><p>示例二，连接EMP表和DEPT表创建视图V_EMPDETAIL，隐藏了工资（sal）和备注（comm）字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace view V_EMPDETAIL</span><br><span class="line">as</span><br><span class="line">select empno,ename,job,hiredate,EMP.deptno,dname</span><br><span class="line">  from EMP join DEPT on EMP.deptno=DEPT.deptno</span><br><span class="line">with read only;</span><br></pre></td></tr></table></figure><p>从V_EMPDETAIL视图中查询数据：</p><p><img src="https://img-blog.csdnimg.cn/20200312091101971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-视图的状态"><a class="markdownIt-Anchor" href="#三-视图的状态"></a> 三、视图的状态</h1><p>当创建视图后，Oracle会验证视图的有效性，如修改了基本表，可能会导致视图的不可用，数据字典的USER_OBJECTS的status字段中记录了视图的状态（VALID-有效；INVALID-失效）。</p><p><img src="https://img-blog.csdnimg.cn/20200312091123230.png" alt="在这里插入图片描述" /></p><p>我们来做一个测试。</p><p>1）删除T_GIRL表的name字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL drop column name;</span><br></pre></td></tr></table></figure><p>2）执行一次查询视图，出现了错误。</p><p><img src="https://img-blog.csdnimg.cn/20200312091201901.png" alt="在这里插入图片描述" /></p><p>3）查询视图的状态，成了INVALID。</p><p><img src="https://img-blog.csdnimg.cn/20200312091212810.png" alt="在这里插入图片描述" /></p><p>4）在T_GIRL表中增加name字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add name <span class="title">varchar2</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>5）查询视图的状态，还是INVALID，数据结构已恢复，但视图的状态未恢复。</p><p><img src="https://img-blog.csdnimg.cn/20200312091429875.png" alt="在这里插入图片描述" /></p><p>6）执行一次查询，视图已恢复正常。</p><p><img src="https://img-blog.csdnimg.cn/20200312091445369.png" alt="在这里插入图片描述" /></p><p>7）再查询视图的状态，恢复成了VALID。</p><p><img src="https://img-blog.csdnimg.cn/20200312091502346.png" alt="在这里插入图片描述" /></p><p>在上面的测试中，我们发现基表数据结构的改变导致了视图无效，数据结构恢复后，视图能自动恢复正常（中间有一点曲折）。</p><h1 id="四-删除视图"><a class="markdownIt-Anchor" href="#四-删除视图"></a> 四、删除视图</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view V_GIRL;</span><br></pre></td></tr></table></figure><h1 id="五-视图的其它知识"><a class="markdownIt-Anchor" href="#五-视图的其它知识"></a> 五、视图的其它知识</h1><p>视图还有两个方面的知识，大家可以了解一下：</p><p>1）本文只介绍了只读视图，对视图只会执行select操作，其实视图还可以进行增、删、改操作，但应用场景极少，二十年来，我从未见过。</p><p>2）本文介绍的视图是查询数据的窗口、是虚拟表、是SQL模板，视图本身没有数据，但是，有一种视图叫物化视图，是有数据的，但是，物化视图的应用也非常少。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle索引</title>
      <link href="/posts/f435c111.html"/>
      <url>/posts/f435c111.html</url>
      
        <content type="html"><![CDATA[<p><strong>对于初学者来说，在学习的过程中，创建表的数据量非常有限，感受不到索引的重要性，但是，我希望您把本章节的内容记在心里，等实际工作中遇到问题的时候能立即想到解决问题的方案。</strong></p><p><strong>总的来说，Oracle数据库非常强大，如果您的数据库性能较低或执行SQL语句的效率很低，最主要原因应该是索引设计不合理或使用索引不合理。</strong></p><p><strong>所谓的SQL优化，主要的内容就是如何设计索引和如何利用索引。</strong></p><h1 id="一-索引的概念"><a class="markdownIt-Anchor" href="#一-索引的概念"></a> 一、索引的概念</h1><p>如果一本书只有几页，读者随便翻翻就能很快的找到具体的内容，根本不需要目录，如果一本书有几百页、几千页，没有目录，查找内容的将需要更长的时间，书越厚，耗时越长。</p><p>索引，即表的索引，它对表的重要性就像目录对书一样重要，索引可以大幅提升数据查找的效率。</p><h2 id="1-索引的特点"><a class="markdownIt-Anchor" href="#1-索引的特点"></a> 1、索引的特点</h2><p>1）索引是表的一部分，是可选的，表可以没有索引，就像书可以没有目录一样，数据库不做强制要求。</p><p>2）合理的索引可以提高数据查找的效率，减少磁盘I/O。</p><p>3）唯一索引可以约束表数据的完整性。</p><p>4）索引也是数据，需要存储空间。</p><p>5）数据库自动维护索引的内容，当对表的记录进行了增、删、改的操作时，数据库会自动更新索引。</p><p>6）索引虽然可以提高数据查找的效率，但对表进行增、删、改操作时，数据库除了维护表中的数据，还要维护索引，所以，索引会让增、删、改操作的效率下降。</p><p>7）索引提升了数据查找的效率，降低了数据操作的效率，在设计表和索引的时候，要根据实际情况在两者之间权衡。</p><h2 id="2-索引的分类"><a class="markdownIt-Anchor" href="#2-索引的分类"></a> 2、索引的分类</h2><p>索引可分为普通索引、唯一索引、反向键索引、位图索引和基于函数的索引，常用的是普通索引和唯一索引，其它三种极少使用，我也不建议使用。</p><p>本文只介绍普通索引和唯一索引。</p><h1 id="二-创建索引"><a class="markdownIt-Anchor" href="#二-创建索引"></a> 二、创建索引</h1><p>我们先来创建超女基本信息表T_GIRL。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  keyid     number(<span class="number">8</span>)       <span class="keyword">not</span> null   -- 记录编号,从序列SEQ_GIRL中获取。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="1-普通索引"><a class="markdownIt-Anchor" href="#1-普通索引"></a> 1、普通索引</h2><p>创建普通索引的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......,字段名n);</span><br></pre></td></tr></table></figure><p>索引名是标识符，从语法上来说，索引名只要符合Oracle的规定就行了，但是，在实际开发中，我会以IDX_打头，加表名和索引编号，例如超女基本信息表T_GIRL的索引，命名将会是IDX_GIRL_1、IDX_GIRL_2、IDX_GIRL_3、IDX_GIRL_n。</p><p>例如为超女信息表T_GIRL的姓名字段创建索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create index IDX_GIRL_1 on <span class="title">T_GIRL</span><span class="params">(name)</span></span>;</span><br></pre></td></tr></table></figure><p>例如为超女信息表T_GIRL的颜值和身材两个字段创建索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create index IDX_GIRL_2 on <span class="title">T_GIRL</span><span class="params">(yz,sc)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-唯一索引"><a class="markdownIt-Anchor" href="#2-唯一索引"></a> 2、唯一索引</h2><p>如果表中的列没有重复的值，是唯一的，就可以创建唯一索引，唯一索引的效率比普通索引要高很多。</p><p>创建普通索引的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index 索引名 on 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......,字段名n);</span><br></pre></td></tr></table></figure><p>例如超女基本信息表T_GIRL的keyid字段，其值是从序列SEQ_GIRL中获取的，肯定是个唯一的值，可以创建唯一索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create unique index IDX_GIRL_3 on <span class="title">T_GIRL</span><span class="params">(keyid)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-主建是唯一索引"><a class="markdownIt-Anchor" href="#3-主建是唯一索引"></a> 3、主建是唯一索引</h2><p>不要为表的主建创建索引，因为Oracle自动为表的主建字段创建唯一索引。</p><p><img src="https://img-blog.csdnimg.cn/20200311180842124.png" alt="在这里插入图片描述" /></p><h1 id="三-删除索引"><a class="markdownIt-Anchor" href="#三-删除索引"></a> 三、删除索引</h1><p>当表被删除时，表的索引会被自动删除，也可以采用drop index命令删除索引。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index 索引名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop index IDX_GIRL_1;</span><br><span class="line">drop index IDX_GIRL_2;</span><br><span class="line">drop index IDX_GIRL_3;</span><br></pre></td></tr></table></figure><p>注意，drop index无法删除用于强制唯一/主键的索引，删除主键要用以下语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop constraint 主键名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL drop constraint PK_GIRL;</span><br></pre></td></tr></table></figure><h1 id="四-修改索引"><a class="markdownIt-Anchor" href="#四-修改索引"></a> 四、修改索引</h1><p>修改索引的操作比较多，这些的工作一般由管理员（DBA）来执行。</p><h2 id="1-重建索引"><a class="markdownIt-Anchor" href="#1-重建索引"></a> 1、重建索引</h2><p>重建索引可以减少硬盘碎片和提高数据库系统的性能。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 rebuild;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 rebuild;</span><br></pre></td></tr></table></figure><h2 id="2-整理碎片"><a class="markdownIt-Anchor" href="#2-整理碎片"></a> 2、整理碎片</h2><p>对索引的无用空间进行合并，减少硬盘碎片和提高数据库系统的性能。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 coalesce;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 coalesce;</span><br></pre></td></tr></table></figure><h2 id="3-修改索引名"><a class="markdownIt-Anchor" href="#3-修改索引名"></a> 3、修改索引名</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 rename to 新索引名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 rename to IDX_GIRL_NAME;</span><br></pre></td></tr></table></figure><h2 id="4-禁用索引"><a class="markdownIt-Anchor" href="#4-禁用索引"></a> 4、禁用索引</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index 索引名 unusable;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index IDX_GIRL_1 unusable;</span><br></pre></td></tr></table></figure><p>索引被禁用后，如果要启用，需要用rebuild重建。</p><h1 id="五-索引的存储空间"><a class="markdownIt-Anchor" href="#五-索引的存储空间"></a> 五、索引的存储空间</h1><p>每个数据库用户有一个缺省表空间，创建的表、主键和索引存放在缺省表空间中，也可以指定其它的表空间。</p><p><strong>在实际应用中，会把表和索引的存储空间分开到不同的表空间，减少磁盘的竞争，提升I/O的性能。</strong></p><h2 id="1-查看当前用户的缺省表空间"><a class="markdownIt-Anchor" href="#1-查看当前用户的缺省表空间"></a> 1、查看当前用户的缺省表空间</h2><p>从数据字典USER_USERS中可以查看当前用户的缺省表空间。</p><p><img src="https://img-blog.csdnimg.cn/20200311200323448.png" alt="在这里插入图片描述" /></p><h2 id="2-指定索引的表空间"><a class="markdownIt-Anchor" href="#2-指定索引的表空间"></a> 2、指定索引的表空间</h2><p>指定索引的表空间的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 ...... tablespace 表空间名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create unique index IDX_GIRL_3 on <span class="title">T_GIRL</span><span class="params">(keyid)</span> tablespace INDEXS</span>;</span><br></pre></td></tr></table></figure><p>索引还有其它与存储相关的选项，但应用场景比较少，本文就不介绍了。</p><h1 id="六-索引的优化"><a class="markdownIt-Anchor" href="#六-索引的优化"></a> 六、索引的优化</h1><p>索引的优化体现在SQL语句的where条件中，如果where条件中的字段列表没有创建索引，SQL语句的性能将会很低。</p><p>在设计索引的时候，必须考虑在常用的where条件，在编写SQL语句的时候，也必须清楚表上创建了哪些索引。</p><h2 id="1-索引的查看"><a class="markdownIt-Anchor" href="#1-索引的查看"></a> 1、索引的查看</h2><p>在PL/SQL Developer软件中可以查看表的索引。</p><p><img src="https://img-blog.csdnimg.cn/20200311200554698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-sql语句的执行计划"><a class="markdownIt-Anchor" href="#2-sql语句的执行计划"></a> 2、SQL语句的执行计划</h2><p>利用PL/SQL Developer软件可以查看SQL语句详细的执行计划。</p><p><img src="https://img-blog.csdnimg.cn/2020031120063131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-sql语句的执行步骤"><a class="markdownIt-Anchor" href="#3-sql语句的执行步骤"></a> 3、SQL语句的执行步骤</h2><p><img src="https://img-blog.csdnimg.cn/2020031120064554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>SQL语句的执行顺序是从未级节点往根级节点看的，上图中的SQL语句执行的顺序如下：</p><p><strong>INDEX RANGE SCAN-&gt;TABLE ACCESS BY INDEX ROWID-&gt;SELECT STATEMENT,GOAL=ALL_ROWS</strong></p><h2 id="4-执行计划的含义"><a class="markdownIt-Anchor" href="#4-执行计划的含义"></a> 4、执行计划的含义</h2><p>在执行计划中，我们重点关注访问表（TABLE ACCESS BY ……  ）的方式，常见的有三种：</p><p>1）TABLE ACCESS BY USER ROWID（通过ROWID的表存取）</p><p>rowid的值是行的物理位置，通过rowid可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/2020031120071450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2） TABLE ACCESS FULL（全表扫描）</p><p>Oracle读取表中全部的行，并检查每一行是否满足SQL语句中where的条件。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200311200729708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>数据量太大的表不能使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的5%~10%<br />或以上。</p><p><strong>全表扫描会让数据库的性能大幅下降，程序员一定要避免这种情况的发生，除非您知道自己在做什么。</strong></p><p>3） TABLE ACCESS BY INDEX SCAN（索引扫描）</p><p>在索引中，存储了每个索引的键值和行的rowid，所以索引扫描其实是先扫描索引得到对应的rowid，然后再通过rowid定位到具体的行。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200311200744138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>索引扫描又分五种：</p><p>a）INDEX UNIQUE SCAN，索引唯一扫描，效率最高。</p><p>b）INDEX RANGE SCAN，索引范围扫描，效率较高。</p><p>c）INDEX FULL SCAN，索引全扫描，效率较低。</p><p>d）INDEX FAST FULL SCAN，索引快速扫描，效率一般。</p><p>e）INDEX SKIP SCAN，索引跳跃扫描，效率还行。</p><p><strong>在Object name中显示了SQL语句使用的索引名，是索引优化的重要依据。</strong></p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle伪列</title>
      <link href="/posts/d241424a.html"/>
      <url>/posts/d241424a.html</url>
      
        <content type="html"><![CDATA[<p>Oracle有两个常用的伪列rowid和rownum，对伪列的操作类似于表中的列，你可以对其进行查询操作，但是你却不能对其进行增加、修改或者是删除。</p><h1 id="一-rowid伪列"><a class="markdownIt-Anchor" href="#一-rowid伪列"></a> 一、rowid伪列</h1><h2 id="1-rowid的原理"><a class="markdownIt-Anchor" href="#1-rowid的原理"></a> 1、rowid的原理</h2><p>Oracle数据库表中的每一行在数据库中有一个存放的位置，即rowid（row identification），rowid的长度是10个字节，显示的结果是18字节的字符串，该值表明了行在Oracle数据库中存放的物理具体位置，是唯一的，Oracle内部通常使用它来访问数据。</p><p>我们从超女表中查询每行的rowid。</p><p><img src="https://img-blog.csdnimg.cn/20200311170044763.png" alt="在这里插入图片描述" /></p><p>rowid虽然不是表的字段，但是，在Oracle数据库的内部，保存了每行数据的rowid。</p><p>rowid使用base64编码行的物理地址，编码字符包含A-Z, a-z, 0-9, +, 和/，由四部分组成：OOOOOOOFFFBBBBBBRRR，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200311170207433.png" alt="在这里插入图片描述" /></p><p>1）对象编号：行所属数据库对象的编号，每个数据库对象在创建的时候都被分配一个唯一的编号，六位显示。</p><p>2）文件编号：行所在数据文件的编号，每一个文件标号也是唯一的，三位显示。</p><p>3）块编号：行所在数据文件的数据块的位置，六位显示。</p><p>4）行编号：行目录中的具体位置，三位显示。</p><p>Oracle正是根据rowid可以准确的定位存放行数据的物理位置。</p><h2 id="2-rowid数据类型"><a class="markdownIt-Anchor" href="#2-rowid数据类型"></a> 2、rowid数据类型</h2><p>在Oracle数据库中，用rowid数据类型存放rowid的值，长度是10个字节，为了方便查看和书写，Oracle可以把10字节的rowid类型和18字节的字符串自动转换。</p><p>对程序员来说，把rowid当成18字节的字符串就行了。</p><p><img src="https://img-blog.csdnimg.cn/20200311170744306.png" alt="在这里插入图片描述" /></p><h1 id="二-rowid的应用"><a class="markdownIt-Anchor" href="#二-rowid的应用"></a> 二、rowid的应用</h1><p>我以一个程序员的视角来向大家介绍rowid的应用场景。</p><h2 id="1-记录表数据的变化"><a class="markdownIt-Anchor" href="#1-记录表数据的变化"></a> 1、记录表数据的变化</h2><p>例如我希望把超女基本信息表T_GIRL的操作日志（增加、修改和删除）记录下来。</p><p>1）创建一个SQL日志表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_SQL_LOG</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  tname    varchar2(<span class="number">30</span>),        -- 原表的表名。</span></span></span><br><span class="line"><span class="params"><span class="function">  srcrowid rowid,               -- 原表rowid。</span></span></span><br><span class="line"><span class="params"><span class="function">  sqltype  number(<span class="number">1</span>),           -- SQL语句的类型：<span class="number">1</span>-insert、<span class="number">2</span>-update、<span class="number">3</span>-<span class="keyword">delete</span>。</span></span></span><br><span class="line"><span class="params"><span class="function">  crttime  date <span class="keyword">default</span> sysdate -- 操作时间。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>2）在原表中创建触发器</p><p>在超女基本信息表T_GIRL上创建触发器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace trigger TR_GIRL_LOG</span></span><br><span class="line"><span class="function">       after insert <span class="keyword">or</span> update <span class="keyword">or</span> <span class="keyword">delete</span></span></span><br><span class="line"><span class="function">       on T_GIRL <span class="keyword">for</span> each row</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> inserting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">1</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> updating then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">2</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> deleting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:old.rowid,<span class="number">3</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>3）测试效果</p><p>如果对T_GIRL表插入了四条记录，在T_SQL_LOG中记录的内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200311171945795.png" alt="在这里插入图片描述" /></p><p>4）应用经验</p><p>T_SQL_LOG日志表中可以找到原表数据变化的情况，这种处理技巧在数据审计和数据同步中经常用到。</p><h2 id="2-用于where的条件"><a class="markdownIt-Anchor" href="#2-用于where的条件"></a> 2、用于where的条件</h2><p>rowid是记录了数据存放的物理位置，用rowid作为where的条件的效率永远是最高的，远远超过任何索引，利用这个特点可以提高数据操作的效率。</p><h2 id="3-rowid的缺点"><a class="markdownIt-Anchor" href="#3-rowid的缺点"></a> 3、rowid的缺点</h2><p>rowid的效率虽然很高，在实际开发中经常用到，但也有缺点，主要有两方面：</p><p>1）兼容性不好，rowid是Oracle数据库特有的，其它数据库没有，如果你的应用程序需要迁移到其它数据库，就不能用rowid了。</p><p>2）rowid记录的是数据存放的物理位置，这个值在数据整理、数据迁移和数据备份的时候会变化。</p><h1 id="三-rownum伪列"><a class="markdownIt-Anchor" href="#三-rownum伪列"></a> 三、rownum伪列</h1><p>首先，rowid和rownum都是oracle的伪列，但原理和用法完全不同，没有任何关联和可比性，不要用学习rowid的经验来学习rownum。</p><p>rownum（row number）是Oralce为查询结果集的行分配的顺序号，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200311172035348.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/2020031117205541.png" alt="在这里插入图片描述" /></p><p>再说一次，rownum很简单，就是Oralce为查询结果集的行分配的顺序号。</p><p>rownum在数据库中没有存储空间，从以上的两个查询可以看出，在第一个查询结果中，妲已的rownum是3，在第二个查询结果集中，妲已的rownum是1。</p><p>如果你还不明白，我再解释一次，rownum是Oralce为查询结果集的行分配的顺序号。</p><h1 id="四-rownum的应用"><a class="markdownIt-Anchor" href="#四-rownum的应用"></a> 四、rownum的应用</h1><h2 id="1-限制数据库大事务和长事务"><a class="markdownIt-Anchor" href="#1-限制数据库大事务和长事务"></a> 1、限制数据库大事务和长事务</h2><p>用delete删除表中数据的时候，如果数据记录比较多，会产生大事务和长事务，为了避免对数据库的冲击，可以用rownum限制每次delete数据的记录数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> from 表名 where 待删除数据的条件 <span class="keyword">and</span> rownum&lt;=<span class="number">100000</span> ;</span><br></pre></td></tr></table></figure><p>以上delete语句一次删除100000条记录，这种用法适用于update语句。</p><h2 id="2-用于筛选查询结果集的记录"><a class="markdownIt-Anchor" href="#2-用于筛选查询结果集的记录"></a> 2、用于筛选查询结果集的记录</h2><p>筛选查询结果集的记录的用法对C/C++程序员意义不大，但对java程序员来说非常重要，主要用于查询结果的分页，各位有兴趣可以看一下。</p><p>1）rownum 对于等于某值的查询条件</p><p>如果希望找到超女表中第一条超女的信息，可以使用rownum=1作为条件。但是想找到超女表中第二条超女的信息，使用rownum=2结果查不到数据。因为rownum都是从1开始，但是1以上的自然数在rownum做等于判断是时认为都是false条件，所以无法查到rownum = n（n&gt;1的自然数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,name from T_GIRL where rownum=<span class="number">1</span>; --有记录</span><br><span class="line">select rownum,id,name from T_GIRL where rownum=<span class="number">2</span>; --无记录</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311172446366.png" alt="在这里插入图片描述" /></p><p>2）rownum对于大于某值的查询条件</p><p>如果想找到从第二行记录以后的记录，当使用rownum&gt;2是查不出记录的，可以使用以下的子查询方法来解决。注意子查询中的rownum必须要有别名，否则还是不会查出记录来，这是因为rownum不是某个表的列，如果不起别名的话，无法知道rownum是子查询的列还是主查询的列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select * <span class="title">from</span> <span class="params">(select rownum no,id,name from T_GIRL)</span> where no&gt;2</span>;      -- 有记录</span><br><span class="line"><span class="function">select * <span class="title">from</span> <span class="params">(select rownum   ,id,name from T_GIRL)</span> where rownum&gt;2</span>;  -- 无记录</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311172615297.png" alt="在这里插入图片描述" /><br />3）rownum对于小于某值的查询条件</p><p>如果想找到第三条记录以前的记录，当使用rownum&lt;3是能得到两条记录的。显然rownum对于rownum1的自然数）的条件认为是成立的，所以可以找到记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,name from T_GIRL where rownum&lt;<span class="number">3</span>; -- 有记录</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311172723798.png" alt="在这里插入图片描述" /></p><p>4）rownum排序</p><p>Oracle中的rownum的是在从数据库中取数据的时候产生的序号，所以想对指定排序的数据去指定的rowmun行数据就必须注意了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,name from T_GIRL order by name;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311173230798.png" alt="在这里插入图片描述" /></p><p>可以看出，rownum并不是按照name列来生成的序号。系统是按照记录从数据库取出的顺序给记录排的号，为了解决这个问题，必须使用子查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rownum,id,<span class="function">name <span class="title">from</span> <span class="params">(select * from T_GIRL order by name)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311173306818.png" alt="在这里插入图片描述" /></p><h1 id="五-小结"><a class="markdownIt-Anchor" href="#五-小结"></a> 五、小结</h1><p>rownum和rowid都是伪列，但两者的原理是不同的，rownum是根据SQL查询出来的结果给每行分配一个临时编号，不同的SQL会导致rownum不同。rowid是物理存在的，在每条记录insert到数据库时，就会有一个唯一的物理位置，记录了在数据库中的位置ID，只要记录没被搬动过，rowid是不变的。</p><p>rownum常用于分页查询，rowid常用于提高数据操作的效率，在某些场景中，还会把rowid当成主建来使用。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle触发器</title>
      <link href="/posts/171b244.html"/>
      <url>/posts/171b244.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-触发器的概念"><a class="markdownIt-Anchor" href="#一-触发器的概念"></a> 一、触发器的概念</h1><p>触发器是Oracle数据库的对象，类似存储过程和函数。存储过程和函数需要用户显示调用才执行，而触发器是由一个事件来触发运行，当某个事件发生时会自动地隐式运行，不能被显示的调用。</p><p>触发器的本质是存储过程，发生特定事件时Oracle会执行触发器中的代码，它的组成可以分为三个部分：1）触发器执行的条件，即触发器被触发的事件；2）执行触发器的时间，发生事件之前（before）或发生事件之后（after）；3）触发器要做的事情，就是触发器被触发以后具体想执行的任务（PL/SQL语句块）。</p><p>Oracle的触发器分为DML触发器、DDL触发器、替代触发器和系统触发器。</p><h1 id="二-dml触发器"><a class="markdownIt-Anchor" href="#二-dml触发器"></a> 二、DML触发器</h1><p>基于DML操作的触发器，细分又可以分为行触发器和语句触发器。</p><h2 id="1-语句触发器"><a class="markdownIt-Anchor" href="#1-语句触发器"></a> 1、语句触发器</h2><p>DML操作（insert、delete、update），不管SQL语句影响的记录是多少行，触发器只触发一次。</p><h2 id="2-行级触发器"><a class="markdownIt-Anchor" href="#2-行级触发器"></a> 2、行级触发器</h2><p>DML操作（insert、delete、update），SQL语句影响了多少行记录，触发器就触发多少次。</p><p>行级触发器用for each row关键字。</p><h2 id="3-dml触发器语法"><a class="markdownIt-Anchor" href="#3-dml触发器语法"></a> 3、DML触发器语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] trigger 用户名.触发器名</span><br><span class="line">       &#123;before|after&#125;       </span><br><span class="line">       &#123;<span class="keyword">delete</span>|insert|update|[of列名]&#125;</span><br><span class="line">       on 表名</span><br><span class="line">       [<span class="keyword">for</span> each row [when 条件]]</span><br><span class="line">declare</span><br><span class="line">  定义变量。</span><br><span class="line">begin</span><br><span class="line">  PL/SQL语句块。                          </span><br><span class="line">end;</span><br><span class="line">参数说明：</span><br></pre></td></tr></table></figure><p><code>&#123;before|after&#125;</code>：指定触发器是在对表的操作发生之前触发还是之后触发。</p><p><code>&#123;delete|insert|update|[of列名]&#125;</code>：触发在动作，可以指定多个动作，例如：insert or update。如果是update，update of 指定一个或多个字段，仅在这些字段被更新时才会触发。update of的应用场景极少。</p><p><code>[for each row]</code>：表示是行级触发器。</p><p><code>[when 条件]</code>：只有满足when指定的条件，才会执行触发体中的代码，应用场景极少。</p><h2 id="4-触发器谓词"><a class="markdownIt-Anchor" href="#4-触发器谓词"></a> 4、触发器谓词</h2><p>1）创建超女基本信息表T_GIRL，插入5条测试数据。</p><p>old谓词：执行前的字段的值的名称，比如update一个表时，使用:old.columnname是指执行update操作之前的列的值。</p><p>new谓词：执行后的字段的值的名称，比如update一个表时，使用:new.columnname是指执行update操作之后的列的值。</p><p>可以在触发器体的语句块中使用 inserting、updating、deleting谓词，这些谓词会返回相应的DML操作的布尔值，如果为true，则表示执行了相应的insert、update、delete操作。</p><h2 id="5-示例"><a class="markdownIt-Anchor" href="#5-示例"></a> 5、示例</h2><p>1）准备测试数据，创建超女基本信息表T_GIRL，插入5条测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">drop table T_GIRL;</span><br><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 指定id为表的主键</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2）创建SQL日志表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drop table T_SQL_LOG;</span><br><span class="line"><span class="function">create table <span class="title">T_SQL_LOG</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  tname    varchar2(<span class="number">10</span>),        -- 原表的表名。</span></span></span><br><span class="line"><span class="params"><span class="function">  srcrowid rowid,               -- 原表rowid。</span></span></span><br><span class="line"><span class="params"><span class="function">  sqltype  number(<span class="number">1</span>),           -- SQL语句的类型：<span class="number">1</span>-insert、<span class="number">2</span>-update、<span class="number">3</span>-<span class="keyword">delete</span>。</span></span></span><br><span class="line"><span class="params"><span class="function">  trname  varchar2(<span class="number">10</span>)          -- 触发器名。</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>3）创建语触发器TR_GIRL_1，如果对T_GIRL表做了insert、update和delete操作，把操作记录在T_SQL_LOG表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace trigger TR_GIRL_1</span></span><br><span class="line"><span class="function">  before update <span class="keyword">or</span> <span class="keyword">delete</span> <span class="keyword">or</span> insert</span></span><br><span class="line"><span class="function">  on T_GIRL</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> inserting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,null,<span class="number">1</span>,<span class="string">&#x27;TR_GIRL_1&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> updating then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,null,<span class="number">2</span>,<span class="string">&#x27;TR_GIRL_1&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> deleting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,null,<span class="number">3</span>,<span class="string">&#x27;TR_GIRL_1&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>4）创建行级语触发器TR_GIRL_2，如果对T_GIRL表做了insert、update和delete操作，把每一行的操作记录在T_SQL_LOG表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace trigger TR_GIRL_2</span></span><br><span class="line"><span class="function">  before update <span class="keyword">or</span> <span class="keyword">delete</span> <span class="keyword">or</span> insert</span></span><br><span class="line"><span class="function">  on T_GIRL <span class="keyword">for</span> each row</span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> inserting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">1</span>,<span class="string">&#x27;TR_GIRL_2&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> updating then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:<span class="keyword">new</span>.rowid,<span class="number">2</span>,<span class="string">&#x27;TR_GIRL_2&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> deleting then</span></span><br><span class="line"><span class="function">    insert into <span class="title">T_SQL_LOG</span><span class="params">(tname,srcrowid,sqltype,trname)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;T_GIRL&#x27;</span>,:old.rowid,<span class="number">3</span>,<span class="string">&#x27;TR_GIRL_2&#x27;</span>)</span></span>;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>5）执行一条delete语句，从T_GIRL表中删除两行记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delete</span> from T_GIRL where id <span class="title">in</span> <span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;0102&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>6）查看T_SQL_LOG表中的结果。</p><p><img src="https://img-blog.csdnimg.cn/20200311161439586.png" alt="在这里插入图片描述" /></p><h1 id="三-ddl触发器"><a class="markdownIt-Anchor" href="#三-ddl触发器"></a> 三、DDL触发器</h1><p>当执行DDL语句时会被触发。按照作用范围，分为schema trigger,database trigger。schema trigger作用在一个用户上，database trigger作用在整个数据库所有用户上。</p><p>常用的DDL操作有：grant（授权），revoke（撤销授权），create（创建），drop（删除），alter（修改），comment（注释），audit（审核），rename（重命名）等。</p><h2 id="1-ddl触发器语法"><a class="markdownIt-Anchor" href="#1-ddl触发器语法"></a> 1、DDL触发器语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] trigger 用户名.触发器名</span><br><span class="line">       &#123;before|after&#125; &#123;DDL事件&#125; on &#123;database|schema&#125;</span><br><span class="line">       [when 条件]</span><br><span class="line">declare</span><br><span class="line">  定义变量。</span><br><span class="line">begin</span><br><span class="line">  PL/SQL语句块。</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><code>&#123;before|after&#125;</code>：触发器是在DDL事件之前、之后触发。</p><p><code>&#123;database|schema&#125;</code>：作用在一个用户上，还是全部的用户。</p><p><code>[when 条件]</code>：只有满足when指定的条件，才会执行触发体中的代码，应用场景极少。</p><h2 id="2-ddl事件"><a class="markdownIt-Anchor" href="#2-ddl事件"></a> 2、DDL事件</h2><table><thead><tr><th>DDL事件</th><th>触发时机</th></tr></thead><tbody><tr><td>DDL</td><td>列表中所用的事件都会触发。</td></tr><tr><td>ALTER</td><td>对数据库中的任何一个对象使用SQL的ALTER命令时触发。</td></tr><tr><td>ANALYZE</td><td>对数据库中的任何一个对象使用SQL的ANALYZE命令时触发。</td></tr><tr><td>ASSOCIATE STATISTICS</td><td>统计数据关联到数据库对象时触发。</td></tr><tr><td>AUDIT</td><td>通过SQL的AUDIT命令打开审计时触发。</td></tr><tr><td>COMMENT</td><td>对数据库对象做注释时触发。</td></tr><tr><td>CREATE</td><td>通过SQL的CREATE命令创建数据库对象时触发。</td></tr><tr><td>DISASSOCIATE STATISTICS</td><td>去掉统计数据和数据库对象的关联时触发。</td></tr><tr><td>DROP</td><td>通过SQL的DROP命令删除数据库对象时触发。</td></tr><tr><td>GRANT</td><td>通过SQL的GRANT命令赋权时触发。</td></tr><tr><td>NOAUDIT</td><td>通过SQL的NOAUDIT关闭审计时触发。</td></tr><tr><td>RENAME</td><td>通过SQL的RENAME命令对对象重命名时触发。</td></tr><tr><td>REVOKE</td><td>通过SQL的REVOKE语句撤销授权时触发。</td></tr><tr><td>TRUNCATE</td><td>通过SQL的TRUNCATE语句截断表时触发。</td></tr></tbody></table><h2 id="3-可用属性"><a class="markdownIt-Anchor" href="#3-可用属性"></a> 3、可用属性</h2><table><thead><tr><th>函数名</th><th>返回值</th></tr></thead><tbody><tr><td>ORA_CLIENT_IP_ADDRESS</td><td>客户端IP地址。</td></tr><tr><td>ORA_DATABASE_NAME</td><td>数据库名称。</td></tr><tr><td>ORA_DES_ENCRYPTED_PASSWORD</td><td>当前用户的DES算法加密后的密码。</td></tr><tr><td>ORA_DICT_OBJ_NAME</td><td>触发DDL的数据库对象名称。</td></tr><tr><td>ORA_DICT_OBJ_NAME_LIST</td><td>受影响的对象数量和名称列表。</td></tr><tr><td>ORA_DICT_OBJ_OWNER</td><td>触发DDL的数据库对象属主。</td></tr><tr><td>ORA_DICT_OBJ_OWNER_LIST</td><td>受影响的对象数量和名称列表。</td></tr><tr><td>ORA_DICT_OBJ_TYPE</td><td>触发DDL的数据库对象类型。</td></tr><tr><td>ORA_GRANTEE</td><td>被授权人数量。</td></tr><tr><td>ORA_INSTANCE_NUM</td><td>数据库实例数量。</td></tr><tr><td>ORA_IS_ALTER_COLUMN</td><td>如果操作的参数column_name指定的列，返回true,否则false。</td></tr><tr><td>ORA_IS_CREATING_NESTED_TABLE</td><td>如果正在创建一个嵌套表则返回true,否则false。</td></tr><tr><td>ORA_IS_DROP_COLUMN</td><td>如果删除的参数column_name指定的列，返回true,否则false。</td></tr><tr><td>ORA_LOGIN_USER</td><td>触发器所在的用户名。</td></tr><tr><td>ORA_PARTITION_POS</td><td>SQL命令中可以正确添加分区子句位置。</td></tr><tr><td>ORA_PRIVILEGE_LIST</td><td>授予或者回收的权限的数量。</td></tr><tr><td>ORA_REVOKEE</td><td>被回收者的数量。</td></tr><tr><td>ORA_SQL_TXT</td><td>触发了触发器的SQL语句的行数。</td></tr><tr><td>ORA_SYSEVENT</td><td>导致DDL触发器被触发的时间。</td></tr><tr><td>ORA_WITH_GRANT_OPTION</td><td>如果授权带有grant选项，返回true。否则false。</td></tr></tbody></table><h2 id="4-示例"><a class="markdownIt-Anchor" href="#4-示例"></a> 4、示例</h2><p>限制scott用户的DLL操作，创建数据库对象时发出警告，删除数据库对象时阻止。</p><p>1）创建触发器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace trigger scott.no_drop</span><br><span class="line">  before ddl on schema</span><br><span class="line">begin</span><br><span class="line">  <span class="keyword">if</span> ora_sysevent=<span class="string">&#x27;CREATE&#x27;</span> then</span><br><span class="line">    dbms_output.<span class="built_in">put_line</span>(<span class="string">&#x27;Warning !!! You have created a &#x27;</span>||</span><br><span class="line">                         ORA_DICT_OBJ_TYPE||<span class="string">&#x27; called &#x27;</span>||</span><br><span class="line">                         ORA_DICT_OBJ_NAME|| <span class="string">&#x27;; UserName:&#x27;</span>||</span><br><span class="line">                         ORA_DICT_OBJ_OWNER||<span class="string">&#x27;; IP:&#x27;</span>||</span><br><span class="line">                         ORA_CLIENT_IP_ADDRESS||<span class="string">&#x27;; event:&#x27;</span>||</span><br><span class="line">                         ORA_SYSEVENT);</span><br><span class="line">  elsif ora_sysevent=<span class="string">&#x27;DROP&#x27;</span> then</span><br><span class="line">    <span class="built_in">RAISE_APPLICATION_ERROR</span>(<span class="number">-20000</span>,<span class="string">&#x27;Cannot drop the &#x27;</span>||</span><br><span class="line">                            ORA_DICT_OBJ_TYPE||<span class="string">&#x27; named &#x27;</span>||</span><br><span class="line">                            ORA_DICT_OBJ_NAME ||<span class="string">&#x27; as requested by &#x27;</span>||</span><br><span class="line">                            ORA_DICT_OBJ_OWNER);</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>2）测试触器（创建表），用scott用户登录。</p><p>在上面创建的触发器中用到了dbms_output，在sqlplus中要先执行set serveroutput on;才能输出内容。</p><p><img src="https://img-blog.csdnimg.cn/2020031116163427.png" alt="在这里插入图片描述" /></p><p>3）测试删除表，用scott用户登录。</p><p><img src="https://img-blog.csdnimg.cn/20200311161713243.png" alt="在这里插入图片描述" /></p><p>4）测试删除表，用DBA用户登录，no_drop触发器只限scott用户，不限制其它用户。</p><p><img src="https://img-blog.csdnimg.cn/20200311161723233.png" alt="在这里插入图片描述" /></p><h1 id="四-替代触发器"><a class="markdownIt-Anchor" href="#四-替代触发器"></a> 四、替代触发器</h1><p>DML触发器只能应用在表上。而替代触发器只能定义在视图上。当对一个不能修改的视图进行数据的修改时，或者要修改视图中的某个嵌套表时，可以使用替代触发器。</p><p>替代触发器，又称为instead of触发器，它会替代原来的数据操作语句的执行，更改为使用在触发器中定义的语句来执行数据操作。一些简单的单表视图，可以直接insert、update，但如果要对复杂的视图进行insert、update，可以通过替代触发器，将这些DML语句对视图的更改替换为对基表的DML操作。</p><p>替代触发器的应用场景极少，我个人认为完全没有必要这么麻烦，所以就只介绍一下它的概念。</p><h1 id="五-系统触发器"><a class="markdownIt-Anchor" href="#五-系统触发器"></a> 五、系统触发器</h1><p>系统触发器是由Oracle数据库系统事件所触发的触发器，共有六个数据库事件触发器：startup、shutdown、logon、logoff、servererror 和 db_role_change。</p><p>如果我们需要记录用户登陆系统的信息，或在系统启动或用户登陆后对数据库进行一些设置，可以用系统触发器来实现。</p><p>创建系统触发器的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create [<span class="keyword">or</span> replace] trigger 用户名.触发器名</span><br><span class="line">       &#123;before|after&#125; &#123;数据事件&#125;</span><br><span class="line">       on &#123;database|schema&#125;</span><br><span class="line">declare</span><br><span class="line">  定义变量。</span><br><span class="line">begin</span><br><span class="line">  PL/SQL语句块。</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h2 id="1-数据库启动startup"><a class="markdownIt-Anchor" href="#1-数据库启动startup"></a> 1、数据库启动（startup）</h2><p>数据库打开时（alter database open）触发，没有before startup触发器。</p><h2 id="2-数据库关闭shutdown"><a class="markdownIt-Anchor" href="#2-数据库关闭shutdown"></a> 2、数据库关闭（shutdown）</h2><p>数据库正常关闭时触发，没有after shutdown 触发器。</p><p>只有在正常关闭情况下，shutdown nomal或者shutdown immediate时触发，非正常关闭shutdown abort不能触发。</p><h2 id="3-新建会话logon"><a class="markdownIt-Anchor" href="#3-新建会话logon"></a> 3、新建会话（logon）</h2><p>当开始一个数据库会话时触发，没有before logon触发器。</p><h2 id="4-注销会话logoff"><a class="markdownIt-Anchor" href="#4-注销会话logoff"></a> 4、注销会话（logoff）</h2><p>当一个数据库会话正常终止时触发，没有after logoff触发器。</p><h2 id="5-servererror"><a class="markdownIt-Anchor" href="#5-servererror"></a> 5、servererror</h2><p>当数据库发生错误时触发，没有before servererror触发器。</p><h2 id="6-db_role_change"><a class="markdownIt-Anchor" href="#6-db_role_change"></a> 6、db_role_change</h2><p>当主数据库和备用数据库切换时触发，用于dataguard。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle存储过程</title>
      <link href="/posts/6fb0b350.html"/>
      <url>/posts/6fb0b350.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-存储过程的概念"><a class="markdownIt-Anchor" href="#一-存储过程的概念"></a> 一、存储过程的概念</h1><p>存储过程（stored procedure）是Oracle数据库中为了完成某功能的PL/SQL代码集，就像没有返回值的自定义函数。</p><h1 id="二-存储过程的创建-调用和权限"><a class="markdownIt-Anchor" href="#二-存储过程的创建-调用和权限"></a> 二、存储过程的创建、调用和权限</h1><h2 id="1-创建存储过程"><a class="markdownIt-Anchor" href="#1-创建存储过程"></a> 1、创建存储过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace procedure 存储过程名(参数<span class="number">1</span> 模式 数据类型,......)</span><br><span class="line">as/is</span><br><span class="line">  -- 定义局部变量</span><br><span class="line">  变量<span class="number">1</span> 数据类型;</span><br><span class="line">  ......</span><br><span class="line">begin</span><br><span class="line">  -- 实现存储过程功能的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">  exception</span><br><span class="line">  -- 异常处理的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>1）参数的模式有三种：</p><p><strong>in</strong>：只读模式，在函数中，参数只能被引用/读取，不能改变它的值。</p><p><strong>out</strong>：只写模式，参数只能被赋值，不能被引用/读取。</p><p><strong>in out</strong>：可读可写。</p><p>参数的模式可以不写，缺省为in，out和in out两种模式极少使用。</p><p>2）as/is二选一，在这里没有区别。</p><p>3）可以不定义局部变量。</p><p>4）可以没有异常（exception）处理代码段。</p><p>示例：</p><p>1）生成测试数据，脚本如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2）创建存储过程girlinfo，传入超女id参数，显示超女的基本信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace procedure <span class="title">girlinfo</span><span class="params">(in_id varchar2)</span></span></span><br><span class="line"><span class="function">is</span></span><br><span class="line"><span class="function">  s_name      <span class="title">varchar2</span><span class="params">(<span class="number">30</span>)</span></span>;   -- 姓名</span><br><span class="line">  <span class="function">s_yz        <span class="title">varchar2</span><span class="params">(<span class="number">20</span>)</span></span>;   -- 颜值</span><br><span class="line">  <span class="function">s_height    <span class="title">number</span><span class="params">(<span class="number">3</span>)</span></span>;      -- 身高</span><br><span class="line">begin</span><br><span class="line">  select name,yz,height into s_name,s_yz,s_height from T_GIRL where id=in_id;</span><br><span class="line">  dbms_output.<span class="built_in">put_line</span>(<span class="string">&#x27;姓名：&#x27;</span>||s_name||<span class="string">&#x27;颜值：&#x27;</span>||s_yz||<span class="string">&#x27;身高：&#x27;</span>||s_height);</span><br><span class="line">  exception                           </span><br><span class="line">  when others then</span><br><span class="line">  dbms_output.<span class="built_in">put_line</span>(<span class="string">&#x27;输入的id（&#x27;</span>||in_id||<span class="string">&#x27;）不正确，查询无结果。&#x27;</span>);</span><br><span class="line">end;                           </span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311154427466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-存储过程的调用"><a class="markdownIt-Anchor" href="#2-存储过程的调用"></a> 2、存储过程的调用</h2><p>1）直接执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec 存储过程名(参数,……);</span><br><span class="line">execute 存储过程名(参数,……);</span><br></pre></td></tr></table></figure><p>例如：</p><p>在上面创建的存储过程中用到了dbms_output，在sqlplus中要先执行set serveroutput on;才能输出内容。</p><p><img src="https://img-blog.csdnimg.cn/20200311154457646.png" alt="在这里插入图片描述" /></p><p>2）在PL/SQL过程中调用</p><p><img src="https://img-blog.csdnimg.cn/20200311154508430.png" alt="在这里插入图片描述" /></p><h2 id="3-存储过程的权限"><a class="markdownIt-Anchor" href="#3-存储过程的权限"></a> 3、存储过程的权限</h2><p>存储过程是数据库对象，Oracle对它权限管理方式与其它数据库对象相同。</p><p>如果getinfo函数是用scott用户创建的，其它用户调用时需要加scott用户名前缀，并且具备相应的权限，否则会出现“<code>PLS-00201:必须声明标识符 'GIRLINFO'</code>”的错误。</p><h1 id="三-删除存储过程"><a class="markdownIt-Anchor" href="#三-删除存储过程"></a> 三、删除存储过程</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure 存储过程名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure girlinfo;</span><br></pre></td></tr></table></figure><h1 id="四-plsql语言"><a class="markdownIt-Anchor" href="#四-plsql语言"></a> 四、PL/SQL语言</h1><p>PL/SQL是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）包括一整套的数据类型、条件结构、循环结构和异常处理结构，PL/SQL可以执行SQL语句，SQL语句中也可以使用PL/SQL函数。</p><p>PL/SQL是Oracle数据库对SQL语句的扩展，在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。</p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>关于存储过程的优缺点，本人查找了一些资料，以下文字来源于百度百科。</p><h2 id="1-存储过程的优点"><a class="markdownIt-Anchor" href="#1-存储过程的优点"></a> 1、存储过程的优点</h2><p>1）重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</p><p>2）存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</p><p>3）参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程，提高了安全性。</p><p>4）存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</p><h2 id="2-存储过程的缺点"><a class="markdownIt-Anchor" href="#2-存储过程的缺点"></a> 2、存储过程的缺点</h2><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="3-我的看法"><a class="markdownIt-Anchor" href="#3-我的看法"></a> 3、我的看法</h2><p>1）存储过程不会有任何性能的优势。</p><p>2）调用远程存储过程减少网络流量的说活太牵强，并且，调用远程存储过程的风险很大。</p><p>3）存储过程不能减少开发的工作量，PL/SQL也是一种开发语言，对开发者来说，要付出学习成本。</p><p>4）存储过程的调试、重新编译、兼容、维护等问题，任何一项都是很麻烦。</p><p>存储过程没有任何优点，作为一个程序员，我从来不用存储过程，大家对于这方面的知识了解即可，不必深入学习。</p><h1 id="六-oracle的包"><a class="markdownIt-Anchor" href="#六-oracle的包"></a> 六、Oracle的包</h1><p>PL/SQL为了满足程序模块化的需要，引入了包的构造，把存储过程、函数组合起来就成了包，通过使用包就可以分类管理存储过程和函数。有点类似C++中的命名空间。存储过程的应用场景已经很少，包就更少了。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle自定义函数</title>
      <link href="/posts/32c920a8.html"/>
      <url>/posts/32c920a8.html</url>
      
        <content type="html"><![CDATA[<p>在Oracle数据库中，为了实现特定的功能，可以自定义函数，就像C/C++语言，除了系统的库函数，程序员还会编写很多自定义的函数。</p><h1 id="一-函数的创建-调用和权限"><a class="markdownIt-Anchor" href="#一-函数的创建-调用和权限"></a> 一、函数的创建、调用和权限</h1><h2 id="1-创建函数"><a class="markdownIt-Anchor" href="#1-创建函数"></a> 1、创建函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace function 函数名(参数<span class="number">1</span> 模式 数据类型,......) <span class="keyword">return</span> 数据类型</span><br><span class="line">as</span><br><span class="line">  -- 定义局部变量。</span><br><span class="line">  变量<span class="number">1</span> 数据类型;</span><br><span class="line">  ......</span><br><span class="line">begin</span><br><span class="line">  -- 实现函数功能的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">  exception</span><br><span class="line">  -- 异常处理的PL/SQL代码。</span><br><span class="line">  ......</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>1）参数的模式有三种：</p><p><strong>in</strong>：只读模式，在函数中，参数只能被引用/读取，不能改变它的值。</p><p><strong>out</strong>：只写模式，参数只能被赋值，不能被引用/读取。</p><p><strong>in out</strong>：可读可写。</p><p>参数的模式可以不写，缺省为in，out和in out两种模式极少使用。</p><p>2）as/is二选一，在这里没有区别。</p><p>3）可以不定义局部变量。</p><p>4）可以没有异常（exception）处理代码段。</p><p>示例，创建自定义函数maxvalue，用于比较两个数字的大小，返回较大值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create <span class="keyword">or</span> replace function <span class="title">maxvalue</span><span class="params">(val1 number,val2 number)</span> <span class="keyword">return</span> number</span></span><br><span class="line"><span class="function">as</span></span><br><span class="line"><span class="function">  val number</span>;   -- 定义局部变量，存放返回值。</span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(val1&gt;val2)</span> then    -- 判断传入参数的大小。</span></span><br><span class="line"><span class="function">      val:=</span>val1;         -- 赋值是<span class="string">&quot;:=&quot;</span>，不是<span class="string">&quot;=&quot;</span>。</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      val:=val2;</span><br><span class="line">  end <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> val;  -- 返回</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311151802685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-函数的调用"><a class="markdownIt-Anchor" href="#2-函数的调用"></a> 2、函数的调用</h2><p>自定义函数的调用与Oracle数据库自带的函数调用的方法相同。</p><p><img src="https://img-blog.csdnimg.cn/20200311151816763.png" alt="在这里插入图片描述" /></p><h2 id="3-函数的权限"><a class="markdownIt-Anchor" href="#3-函数的权限"></a> 3、函数的权限</h2><p>自定义函数是数据库对象，Oracle对它权限管理方式与其它数据库对象相同。</p><p>如果maxvalue函数是用scott用户创建的，其它用户调用时需要加scott用户名前缀，并且具备相应的权限，否则会出现“<code>ORA-00904:&quot;MAXVALUE&quot;: 标识符无效</code>”的错误。</p><h1 id="二-删除自定义函数"><a class="markdownIt-Anchor" href="#二-删除自定义函数"></a> 二、删除自定义函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop function maxvalue;</span><br></pre></td></tr></table></figure><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>数据库的自定义函数不会像编程语言的函数那样广泛的应用，和编程语言相比，数据库的自定义函数实在太麻烦，很啰嗦，难以调试，数据库自定义函数能做到的功能编程语言都能做到。</p><p>我使用自定义函数的目的只有一个，就是解决不同数据库的兼容性问题，例如序列生成器，Oracle、MySQL和PostgreSQL的调用方法各不同，那么我们可以编写自定义函数，在不同的数据库中，函数名和参数完全相同，函数体代码不同，这样就可以解决软件的兼容性问题。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle常用函数</title>
      <link href="/posts/316fbd2.html"/>
      <url>/posts/316fbd2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-oracle的函数"><a class="markdownIt-Anchor" href="#一-oracle的函数"></a> 一、Oracle的函数</h1><p>Oracle提供了很多函数用于数据的处理、统计和转换，这些函数增强了SQL语言的功能。</p><p>Oracle的函数分为单行函数、聚合函数和分析函数三大类。</p><h2 id="1-单行函数"><a class="markdownIt-Anchor" href="#1-单行函数"></a> 1、单行函数</h2><p>单行函数应用于SQL语句中时，只能输入一个数据，返回一个结果，常用的单行函数包括字符串函数、数字函数、日期函数、转换函数。</p><h2 id="2-聚合函数"><a class="markdownIt-Anchor" href="#2-聚合函数"></a> 2、聚合函数</h2><p>聚合函数应用于SQL语句中时，同时对多行数据进行操作，返回一个结果，例如求结果集的记录数、最小值、最大值、平均值、统计值等。</p><h2 id="3-分析函数"><a class="markdownIt-Anchor" href="#3-分析函数"></a> 3、分析函数</h2><p>分析函数用于计算基于分组的某种聚合值，它和聚合函数的不同之处是对于每个组返回多行，而聚合函数对于每个组只返回一行。</p><p>分析函数的应用场景比较少，概念难以理解，本文就不介绍了。</p><h1 id="二-字符串函数"><a class="markdownIt-Anchor" href="#二-字符串函数"></a> 二、字符串函数</h1><p>字符串函数接受字符串参数，参数可以是表中的列名，也可以是字符串表达式或字符串常量。</p><h2 id="1-ascii码转换ascii和chr"><a class="markdownIt-Anchor" href="#1-ascii码转换ascii和chr"></a> 1、ASCII码转换ascii和chr</h2><p><strong>ascii(str)</strong>：返回字符串str第一个字符的ASCII码值。</p><p><strong>chr(ii)</strong>：返回ASCII码为数字ii的字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311141701184.png" alt="在这里插入图片描述" /></p><h2 id="2-字符串拼接concat"><a class="markdownIt-Anchor" href="#2-字符串拼接concat"></a> 2、字符串拼接concat</h2><p><strong>concat(str1,str2)</strong>：把字符串str1和str2拼接成一个字符串，在实际应用中，我们更愿意用||拼接字符串，因为||可以拼接多个字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200311141721326.png" alt="在这里插入图片描述" /></p><h2 id="3-字符串查找instr"><a class="markdownIt-Anchor" href="#3-字符串查找instr"></a> 3、字符串查找instr</h2><p><strong>instr(str1,str2,start,n)</strong>：在字符串str1中查找str2。</p><p>start：从str1的哪个位置开始查找，可选参数，缺省为1。如果start为正数，从左到右查找，如果start为负数，从右到左查找。</p><p>n表示要查找第几次出现的str2，可选参数，缺省为1，如果为负数系统会报错。</p><p><img src="https://img-blog.csdnimg.cn/20200311141809581.png" alt="在这里插入图片描述" /></p><h2 id="4-字符串的长度length"><a class="markdownIt-Anchor" href="#4-字符串的长度length"></a> 4、字符串的长度length</h2><p><strong>length (str)</strong>：返回字符串str的长度。</p><p><img src="https://img-blog.csdnimg.cn/20200311141901793.png" alt="在这里插入图片描述" /></p><h2 id="5-字符串大小写转换lower和upper"><a class="markdownIt-Anchor" href="#5-字符串大小写转换lower和upper"></a> 5、字符串大小写转换lower和upper</h2><p><strong>lower (str)</strong>：把字符串str转换为小写，忽略不是字母的字符。</p><p><strong>upper (str)</strong>：把字符串str转换为大写，忽略不是字母的字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311141917260.png" alt="在这里插入图片描述" /></p><h2 id="6-截去字符串ltrim-rtrim和trim"><a class="markdownIt-Anchor" href="#6-截去字符串ltrim-rtrim和trim"></a> 6、截去字符串ltrim、rtrim和trim</h2><p><strong>ltrim(str1,str2)</strong>：从字符串str1的左边截去字符串str2，str2是可选参数，缺省为空格。</p><p><strong>rtrim(str1,str2)</strong>：从字符串str1的右边截去字符串str2，str2是可选参数，缺省为空格。</p><p><strong>trim(leading|trailing|both chr from str)</strong>：从str中截去 <strong>左侧|右侧|两侧</strong>的chr字符，缺省是both（两侧），注意，chr是单个字符，不是字符串，缺省是空格。</p><p><img src="https://img-blog.csdnimg.cn/20200311141932899.png" alt="在这里插入图片描述" /></p><h2 id="7-字符串替换replace"><a class="markdownIt-Anchor" href="#7-字符串替换replace"></a> 7、字符串替换replace</h2><p><strong>replace(str,old,new)</strong>：把字符串str中的old字符串替换成new字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200311141947490.png" alt="在这里插入图片描述" /></p><h2 id="8-字符串截取substr"><a class="markdownIt-Anchor" href="#8-字符串截取substr"></a> 8、字符串截取substr</h2><p><strong>substr(str,start,len)</strong>：从字符串str的start位置开始，截取len个字符，如果len不填就截取start之后全部的字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311142137950.png" alt="在这里插入图片描述" /></p><h2 id="9-字符串补齐lpad的rpad"><a class="markdownIt-Anchor" href="#9-字符串补齐lpad的rpad"></a> 9、字符串补齐lpad的rpad</h2><p>lpad(str,len,[chr])，从左边补齐。</p><p>rpad(str,len,[chr])，从右边补齐。</p><p>str：待补齐的原字符串。</p><p>len：最终返回的字符串的长度，如果最终返回的字符串的长度比源字符串的小，那么此函数将对源串进行截断处理。</p><p>chr：用于填充的字符，缺省为空字符。</p><p><img src="https://img-blog.csdnimg.cn/20200311142155572.png" alt="在这里插入图片描述" /></p><h1 id="三-数字函数"><a class="markdownIt-Anchor" href="#三-数字函数"></a> 三、数字函数</h1><p>数字函数接受数字参数，参数可以是表中的列名，也可以是数字表达式或数字常量。</p><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>abs(x)</td><td>x绝对值。</td><td>abs(-10)=10</td></tr><tr><td>cos(x)</td><td>余弦。</td><td>cos(1)= 0.540302306</td></tr><tr><td>acos(x)</td><td>x的反余弦。</td><td>acos(1)=0</td></tr><tr><td>ceil(x)</td><td>大于或等于x的最小整数。</td><td>ceil(3.14)=4</td></tr><tr><td>floor(x)</td><td>小于或等于x的最大整数。</td><td>floor(3.14)=3</td></tr><tr><td>log(x,y)</td><td>x为底y的对数。</td><td>log(2,4)=2</td></tr><tr><td>mod(x,y)</td><td>x除以y的余数。</td><td>mod(7,3)=1</td></tr><tr><td>power(x,y)</td><td>x的y次幂。</td><td>power(2,4)=16</td></tr><tr><td>round(x,y)</td><td>x在第y小数位四舍五入。</td><td>round(3.1415,3)=3.142</td></tr><tr><td>sign(x)</td><td>判断x的值，大于0返回1，等于0返回0，小于0返回-1。</td><td>sign(100)=1、sign(0)=0、sign(-100)=-1</td></tr><tr><td>sqrt(x)</td><td>x的平方根。</td><td>sqrt(9)=3</td></tr><tr><td>trunc(x,y)</td><td>x在第y位截断。</td><td>trunc(3.14159,3)=3.141</td></tr></tbody></table><p>补充说明：</p><p>1）round函数</p><p>round(x[,y])，四舍五入函数。</p><p>y的缺省值0，例如：round(3.14)=3、round(3.56)=4。</p><p>y是正整数，四舍五入到小数点后y位，例如：round(3.14159,3)=3.142。</p><p>y是负整数，四舍五入到小数点左边y位，round(314.159,-2)=300。</p><p>2）trunc函数</p><p>trunc(x[,y])，直接截断，不四舍五入。</p><p>y的缺省值0，例如：trunc(3.14)=3。</p><p>y是正整数，小数点y位后截断，trunc(3.141592,3)=3.141。</p><p>y是负整数，小数点y位前截断。trunc(314.159,-2)=300。</p><h1 id="四-日期函数"><a class="markdownIt-Anchor" href="#四-日期函数"></a> 四、日期函数</h1><p>Oracle的日期函数极其重要，在《Oracle日期函数》文章中有详细的说明。</p><h1 id="五-转换函数"><a class="markdownIt-Anchor" href="#五-转换函数"></a> 五、转换函数</h1><p>Oracle的数据类型转换主要有三种：1）日期与字符串；2）rowid与字符串；3）数字与字符串。</p><h2 id="1-日期和字符串之间的转换"><a class="markdownIt-Anchor" href="#1-日期和字符串之间的转换"></a> 1、日期和字符串之间的转换</h2><p>日期与字符串的转换用to_date和to_char函数完成，在《Oracle日期函数》文章中有详细的说明。</p><h2 id="2-rowid和字符串之间的转换"><a class="markdownIt-Anchor" href="#2-rowid和字符串之间的转换"></a> 2、rowid和字符串之间的转换</h2><p>Oracle数据库能隐式的在rowid和字符串之间的转换。</p><h2 id="3-数字和字符串之间的转换"><a class="markdownIt-Anchor" href="#3-数字和字符串之间的转换"></a> 3、数字和字符串之间的转换</h2><p>Oracle数据库能隐式的在数字和字符串之间的转换，但是要注意几个问题：</p><p>1）任意数字都可以转换成字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200311142342179.png" alt="在这里插入图片描述" /></p><p>2）只有包含了合法数字的字符串才能转换为数字，否则提示错误。</p><p><img src="https://img-blog.csdnimg.cn/20200311142403500.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200311142413441.png" alt="在这里插入图片描述" /></p><p>3）空字符串转换为数字后是null，不是0，这个特点太棒了。</p><p><img src="https://img-blog.csdnimg.cn/20200311142451680.png" alt="在这里插入图片描述" /></p><p>还有，Oracle提供了to_number函数把字符串转换为数字，to_number支持多种格式，用法比较复杂，不建议使用。</p><h1 id="六-其它的单行函数"><a class="markdownIt-Anchor" href="#六-其它的单行函数"></a> 六、其它的单行函数</h1><h2 id="1-nvl函数"><a class="markdownIt-Anchor" href="#1-nvl函数"></a> 1、nvl函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NVL2</span>(x,value)</span><br></pre></td></tr></table></figure><p>如果x为空，返回value，否则返回x。</p><p>示例，运行以下脚本生成测试数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span><span class="params">(name varchar2(<span class="number">20</span>),age number(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;杨玉环&#x27;</span>,null)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(null,<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">select <span class="title">nvl</span><span class="params">(name,<span class="string">&#x27;匿名美女&#x27;</span>)</span>,<span class="title">nvl</span><span class="params">(age,<span class="number">0</span>)</span> from tt</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311142608633.png" alt="在这里插入图片描述" /></p><h2 id="2-decode函数"><a class="markdownIt-Anchor" href="#2-decode函数"></a> 2、decode函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decode</span>(条件,值<span class="number">1</span>,返回值<span class="number">1</span>,值<span class="number">2</span>,返回值<span class="number">2</span>,......,值n,返回值n,缺省值)</span><br></pre></td></tr></table></figure><p>该函数的含义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件==值<span class="number">1</span>) <span class="keyword">return</span> 返回值<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件==值<span class="number">2</span>) <span class="keyword">return</span> 返回值<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件==值<span class="number">3</span>) <span class="keyword">return</span> 返回值<span class="number">3</span>;</span><br><span class="line">  ......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> 缺省值;</span><br></pre></td></tr></table></figure><p>示例，运行以下脚本生成测试数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span><span class="params">(name varchar2(<span class="number">20</span>),yz number(<span class="number">1</span>),sc number(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;杨玉环&#x27;</span>,<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;夏姬&#x27;</span>,<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">select name,<span class="built_in">decode</span>(yz,<span class="number">1</span>,<span class="string">&#x27;漂亮&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;可爱&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;狐媚&#x27;</span>,<span class="string">&#x27;不合格&#x27;</span>),<span class="built_in">decode</span>(sc,<span class="number">1</span>,<span class="string">&#x27;丰满&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;火辣&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;苗条&#x27;</span>,<span class="string">&#x27;不及格&#x27;</span>) from tt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311142730243.png" alt="在这里插入图片描述" /></p><h2 id="3-userenv函数"><a class="markdownIt-Anchor" href="#3-userenv函数"></a> 3、userenv函数</h2><p>userenv(string)，获取当前用户会话的信息。</p><p>string的取值如下：</p><p>isdba，如果用户已经被认证为DBA或者是通过操作系统或口令文件具有DBA特权的，返回TRUE，否则返回FALSE。</p><p>language，返回数据库当前会话的语言、地域和字符集。</p><p>lang，返回ISO缩写语言名称，一个比现有的“语言”参数较短的形式。</p><p>sid ，返回数据库会话ID。</p><p>terminal，返回当前会话的终端操作系统的标识符。在分布式SQL语句，此参数返回了标识符为本地会话。在分布式环境中，此参数只支持远程SELECT语句，不用于远程INSERT，UPDATE或DELETE操作。</p><p>sessionid，返回审计会话标识符，在分布式SQL语句不能指定此参数。</p><p>client_info，返回最高可达64个字节存储的用户会话信息，可由应用程序使用DBMS_APPLICATION_INFO包。</p><p>entryid，返回当前审计条目编号，审计的EntryID序列细粒度的审计记录和定期审计记录之间共享，在分布式SQL语句不能使用这个属性。</p><p>测试一下比较常用的几个参数：</p><p><img src="https://img-blog.csdnimg.cn/20200311142754952.png" alt="在这里插入图片描述" /></p><h2 id="4-user函数"><a class="markdownIt-Anchor" href="#4-user函数"></a> 4、user函数</h2><p>查看当前会话的用户名。<br /><img src="https://img-blog.csdnimg.cn/20200311142819234.png" alt="在这里插入图片描述" /></p><h1 id="七-聚合函数"><a class="markdownIt-Anchor" href="#七-聚合函数"></a> 七、聚合函数</h1><p>聚合函数也叫分组函数或集合函数，它对多行记录中的某个列执行计算并返回一个值。</p><p>聚合函数经常与 select 语句的 group<br />by 子句一同使用，所以有的时候也把它称之为分组函数。</p><h2 id="1-分组函数"><a class="markdownIt-Anchor" href="#1-分组函数"></a> 1、分组函数</h2><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>min(x)</td><td>求最小值。</td><td>select min(sal) from EMP;</td></tr><tr><td>max(x)</td><td>求最大值。</td><td>select max(sal) from EMP;</td></tr><tr><td>avg(x)</td><td>求平均值。</td><td>select avg(sal) from EMP;</td></tr><tr><td>sum(x)</td><td>求合计值。</td><td>select sum(sal) from EMP;</td></tr><tr><td>count(*)</td><td>求记录数。</td><td>select count(*) from EMP;</td></tr><tr><td>stddev(x)</td><td>求标准差。</td><td>select stddev(sal) from EMP;</td></tr><tr><td>variance(x)</td><td>求协方差。</td><td>select variance(sal) from EMP;</td></tr><tr><td>median(x)</td><td>求中位数。</td><td>select median(sal) from EMP;</td></tr></tbody></table><p>stddev(x)、variance(x)、median(x)这三个函数极少使用。</p><h2 id="2-空值处理"><a class="markdownIt-Anchor" href="#2-空值处理"></a> 2、空值处理</h2><p>有一点需要注意的是，除了count函数，其它的分组函数均会忽略值为null的列，这个特点极其重要，一定要记住它。</p><p>我们来测试一下，先生成测试数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span><span class="params">(cc number(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">values</span><span class="params">(null)</span></span>;</span><br><span class="line"><span class="function">select <span class="title">min</span><span class="params">(cc)</span>,<span class="title">max</span><span class="params">(cc)</span>,<span class="title">avg</span><span class="params">(cc)</span>,<span class="title">sum</span><span class="params">(cc)</span>,<span class="title">count</span><span class="params">(*)</span> from tt</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143059478.png" alt="在这里插入图片描述" /></p><p>注意，表中一共有三条数据，两条非空记录，一条空记录，avg函数得到的结果是(10+20)/2=15，忽略了空值记录，min、max、sum函数表面看不出来，但我们知道它们会忽略空值。</p><p>count函数不会忽略空值记录，除非指定列名，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200311143207208.png" alt="在这里插入图片描述" /></p><h2 id="3-group-by子句"><a class="markdownIt-Anchor" href="#3-group-by子句"></a> 3、group by子句</h2><p>group by子句的意思就是按一定的规则进行分组，把数据集划分成若干个子集，然后针对若干个子集进行数据统计，group by子句要与分组函数结合使用，否则没有意义。</p><p>1）对全部的员工进行统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">min</span><span class="params">(sal)</span>,<span class="title">max</span><span class="params">(sal)</span>,<span class="title">avg</span><span class="params">(sal)</span>,<span class="title">sum</span><span class="params">(sal)</span>,<span class="title">count</span><span class="params">(*)</span> from EMP</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143239452.png" alt="在这里插入图片描述" /></p><p>2）按部门分类（组）统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">min</span>(sal),<span class="built_in">max</span>(sal),<span class="built_in">avg</span>(sal),<span class="built_in">sum</span>(sal),<span class="built_in">count</span>(*) from EMP group by deptno;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143309281.png" alt="在这里插入图片描述" /></p><p>在上面的示例中，select的字段列表中有deptno，那么在group by后面一定也要有deptno，否则会出现语法错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">min</span>(sal),<span class="built_in">max</span>(sal),<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) from EMP;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143411802.png" alt="在这里插入图片描述" /></p><p>但是，在group by中有deptno，select的字段列表中可以没有deptno，不会出现语法错误，但这种用法很少。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">min</span><span class="params">(sal)</span>,<span class="title">max</span><span class="params">(sal)</span>,<span class="title">avg</span><span class="params">(sal)</span>,<span class="title">sum</span><span class="params">(sal)</span>,<span class="title">count</span><span class="params">(*)</span> from EMP group by deptno</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143505550.png" alt="在这里插入图片描述" /></p><p>3）按部门和职位分类（组）统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,job,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) from EMP group by deptno,job;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143759516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>4）where子句一定要在group by子句之前，where子句中不能使用分组函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP where deptno <span class="title">in</span> <span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span> group by deptno</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311143927800.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP group by deptno where deptno <span class="title">in</span> <span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144002914.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP where <span class="title">avg</span><span class="params">(sal)</span>&gt;1000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144033763.png" alt="在这里插入图片描述" /></p><h2 id="4-having子句"><a class="markdownIt-Anchor" href="#4-having子句"></a> 4、having子句</h2><p>having 子句对 group by统计出来的结果进行筛选，语法与 where 类似，但 having可以包含分组函数。</p><p>1）先按部门分组统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) from EMP group by deptno;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144114208.png" alt="在这里插入图片描述" /></p><p>2）从统计结果中筛选人数&gt;=5的记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP group by deptno having <span class="title">count</span><span class="params">(*)</span>&gt;</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144232805.png" alt="在这里插入图片描述" /></p><p>3）从统计结果中筛选平均公司超过两千并且部门代码等于20的记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select deptno,<span class="built_in">avg</span>(sal),<span class="built_in">count</span>(*) <span class="function">from EMP group by deptno having <span class="title">avg</span><span class="params">(sal)</span>&gt;2000 <span class="keyword">and</span> deptno</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311144257633.png" alt="在这里插入图片描述" /></p><h1 id="八-应用经验"><a class="markdownIt-Anchor" href="#八-应用经验"></a> 八、应用经验</h1><p>本文介绍了Oracle常用的函数和用法，还有少部分的函数没有介绍，并不是我偷懒，而是没有必要。</p><p>数据库提供函数的目的是为了增强SQL语言的功能，但是我的看法有些不同，从一个程序员的视角，说说我的看法：</p><p>1）手工处理数据的时候，在SQL中使用函数确实可以扩展SQL的功能，我也经常这么做；</p><p>2）不同数据库提供的函数名、参数和功能有差异，从软件项目的兼容性方面考虑，应用程序中能不用函数就不用函数。</p><p>3）在实际开发中，日期转换函数（to_date和to_char）不得不用，但是，我在freecplus框架中已做了兼容性处理。</p><p>4）分组函数也得不用，包括min、max、avg、sum、count，幸运的是不同的数据库基本上兼容，只是细节上也有点差别，不兼容功能的不建议使用。</p><p>所以，大家在学习函数的时候，了解一些常用的、不同数据库能通用的函数即可，不要花太多的时间和精力去研究那些生辟和不通用的函数。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle日期函数</title>
      <link href="/posts/1ae6cc41.html"/>
      <url>/posts/1ae6cc41.html</url>
      
        <content type="html"><![CDATA[<p>Oracle采用date类型表示日期时间，这是一个7字节的固定宽度的数据类型，有7个属性，包括：世纪、世纪中哪一年、月份、月中的哪一天、小时、分钟和秒。本文中把date类型称为日期时间类型，简称日期。</p><p>对编程语言来说，日期是用字符串来显示和书写的，如果设置了NLS_DATE_FORMAT环境变量，Oracle可以自动的对日期和字符串进行转换，但是，程序员更多的是采用to_char和to_date两个函数对日期和字符串进行转换。</p><h1 id="一-把日期转换为字符串"><a class="markdownIt-Anchor" href="#一-把日期转换为字符串"></a> 一、把日期转换为字符串</h1><p>to_char函数把日期转换成字符串，一般用于 select 和 from 之间的字段列表中的日期输出，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">to_char</span>(日期,格式)</span><br></pre></td></tr></table></figure><p>日期格式用字符串来表达，格式控制标识如下，加粗显示的是常用的格式：</p><p>d：一周中的星期几。</p><p>day：天的名字，使用空格填充到9个字符。</p><p><strong>dd：月中的第几天。</strong></p><p>ddd：年中的第几天。</p><p>dy：天的简写名。</p><p>iw：ISO标准的年中的第几周。</p><p>iyyy：ISO标准的四位年份。</p><p><strong>yyyy：四位年份。</strong></p><p>yyy,yy,y：年份的最后三位，两位，一位。</p><p>hh：小时，按12小时计。</p><p><strong>hh24：小时，按24小时计。</strong></p><p><strong>mi：分。</strong></p><p><strong>ss：秒。</strong></p><p><strong>mm：月。</strong></p><p>mon：月份的简写。</p><p>month：月份的全名。</p><p>w：该月的第几个星期。</p><p>ww：年中的第几个星期。</p><p>举例：</p><p><img src="https://img-blog.csdnimg.cn/20200311093723237.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200311093734968.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311093748155.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311093758239.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311093807249.png" alt="在这里插入图片描述" /></p><h1 id="二-把字符串转换日期"><a class="markdownIt-Anchor" href="#二-把字符串转换日期"></a> 二、把字符串转换日期</h1><p>to_date函数把字符串转换成日期，一般用于insert、update和where之后的条件中的日期输入，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">to_date</span>(字符串表示的日期,格式)</span><br></pre></td></tr></table></figure><p>日期格式用字符串来表达，与to_char函数相同。</p><p>先创建一个用于测试的表tt。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span> <span class="params">( c1 date)</span></span>;</span><br></pre></td></tr></table></figure><p>举列：</p><p><img src="https://img-blog.csdnimg.cn/202003110938454.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/2020031109390665.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/2020031109391937.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200311093952496.png" alt="在这里插入图片描述" /></p><p>在update语句中把字符串转换为日期。</p><p><img src="https://img-blog.csdnimg.cn/20200311100719158.png" alt="在这里插入图片描述" /></p><p>在where条件中把字符串转换为日期。</p><p><img src="https://img-blog.csdnimg.cn/20200311100730350.png" alt="在这里插入图片描述" /></p><h1 id="三-日期运算"><a class="markdownIt-Anchor" href="#三-日期运算"></a> 三、日期运算</h1><p>Oracle数据库提供了多种对日期加减的计算方法。</p><p>为了方便日期的显示，先设置好NLS_DATE_FORMAT环境变量，这个环境变量的用法在本文的“四、日期环境变量”章节中介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_DATE_FORMAT=<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span></span><br></pre></td></tr></table></figure><h2 id="1-直接加减"><a class="markdownIt-Anchor" href="#1-直接加减"></a> 1、直接加减</h2><p>可以在日期上进行加减一个小数（单位是天）得到一个新的时间。</p><p>1）取当前时间和一天后的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311100927909.png" alt="在这里插入图片描述" /></p><p>2）取当前时间和一小时后的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311101234725.png" alt="在这里插入图片描述" /></p><p>3）获取当前时间和一秒后的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311101242961.png" alt="在这里插入图片描述" /></p><h2 id="2-add_months函数"><a class="markdownIt-Anchor" href="#2-add_months函数"></a> 2、add_months函数</h2><p>对日期直接加减的方式不用于月的加减，因为每月的天数不一样，例如2020-01-01，加上30天之后是2020-01-31，不是2020-02-01。如果希望把日期加上一个完整的月（不论月的大小），可以用add_months函数。</p><p><img src="https://img-blog.csdnimg.cn/20200311101327721.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101336789.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101343985.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101356353.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200311101405524.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-df8b7N0G-1583890413413)(media/d5b79b4d06097b5768b3a66c6c0ce668.png)" /></p><p>从上面的例子可以看出，月有大有小：1）如果下月的天小于本月的天，add_months后取下月的最后一天；2）本月的最后一天加上一个月，就是下个月的最后一天。</p><h2 id="3-last_day函数"><a class="markdownIt-Anchor" href="#3-last_day函数"></a> 3、last_day函数</h2><p>last_day函数得到日期所属月份最后一天的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200311101430425.png" alt="在这里插入图片描述" /></p><h2 id="4-其它的日期函数"><a class="markdownIt-Anchor" href="#4-其它的日期函数"></a> 4、其它的日期函数</h2><p>Oracle还提供了其它的日期计算的函数，如months_between、next_day、<a href="https://www.cnblogs.com/xyz0601/p/4417165.html">numtodsinterval和numtoyminterval</a>等，在我看来，这些函数很烦人，实在没有意义，就不介绍了。</p><h1 id="四-日期环境变量"><a class="markdownIt-Anchor" href="#四-日期环境变量"></a> 四、日期环境变量</h1><p>NLS_DATE_FORMAT环境变量指定日期的输入和输入格式，如果字符串的格式与NLS_DATE_FORMAT指定的格式相同，Oracle可以自动转换，不需要to_char和to_date函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_DATE_FORMAT=<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311102139300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NLS_DATE_FORMAT=<span class="string">&quot;yyyymmddhh24miss&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311102226516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>从上图的运行结果看出，修改NLS_DATE_FORMAT环境变量后，如果输入的日期格式不符，Oracle无法识别。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle序列生成器</title>
      <link href="/posts/539e49a0.html"/>
      <url>/posts/539e49a0.html</url>
      
        <content type="html"><![CDATA[<p>在实际开发中，设计数据表的时候会把某些字段定义成一个自动增长的、唯一的流水号，例如记录编号、日志编号等，MySQL和SQL Server采用的是自增字段，Oracle和PostgreSQL采用了更灵活的序列生成器。在本文中，把序列生成器简称为序列。</p><h1 id="一-创建序列"><a class="markdownIt-Anchor" href="#一-创建序列"></a> 一、创建序列</h1><p>创建序列的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create sequence 序列名</span><br><span class="line">       [minvalue n]</span><br><span class="line">       [maxvalue n]</span><br><span class="line">       [increment by n]</span><br><span class="line">       [start with n]</span><br><span class="line">       [cache n|nocache]</span><br><span class="line">       [order|noorder]</span><br><span class="line">       [cycle|nocycle];</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>Oracle的序列分为递增序列和递减序列，递减序列极少使用（二十年我从未用过），为了方便介绍，本文假设序列是递增序列。</p><p><code>序列名</code>：序列名是标志符，建议以SEQ_打头，例如为T_OPERLOG表的logid字段创建一个序列，可以把它命名为SEQ_OPERLOG（或SEQ_OPERLOG_LOGID），增加数据结构的可读性，这是我的个人经验，并不是Oracle数据库的要求。</p><p><code>[minvalue n]</code>：序列的最小值，缺省值是1。</p><p><code>[maxvalue n]</code>：序列的最大值，缺省值是9999999999999999999999999999。</p><p><code>[increment by n]</code>：序列递增的步长，缺省值是1。</p><p><code>[start with n]</code>：序列的起始值，缺省值是minvalue，如果n小于minvalue，创建序列会报语法错误。</p><p><code>[cache n|nocache]</code>：是否采用缓存机制，nocache不采用缓存，缺省cache 20，数据库每次会生成20个值放在缓存中，如果缓存中有数据，就不需要再查数据库了，采用缓存机制可以提升效率。</p><p><code>[order|noorder</code>]：获取序列的时候是否按顺序给值，如果多用户一起获取序列的值，使用order可以保证序列值的顺序按访问序列的事件排序，缺省是noorder。</p><p><code>[cycle|nocycle]</code>：是否循环，缺省不循环，如果不循环，序列值到了maxvalue后将不可用。</p><h1 id="二-序列的使用"><a class="markdownIt-Anchor" href="#二-序列的使用"></a> 二、序列的使用</h1><h2 id="1-创建最简单的序列"><a class="markdownIt-Anchor" href="#1-创建最简单的序列"></a> 1、创建最简单的序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create sequence SEQ_GIRL;</span><br></pre></td></tr></table></figure><p>执行以上SQL语句会在数据库中生成一个名字为SEQ_GIRL的序列，除了序列名，其它的参数都采用缺省值，相当于以下SQL：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create sequence SEQ_GIRL </span><br><span class="line">       minvalue <span class="number">1</span> </span><br><span class="line">       maxvalue <span class="number">9999999999999999999999999999</span> </span><br><span class="line">       increment by <span class="number">1</span> </span><br><span class="line">       start with <span class="number">1</span> </span><br><span class="line">       cache <span class="number">20</span> </span><br><span class="line">       noorder  </span><br><span class="line">       nocycle ;</span><br></pre></td></tr></table></figure><h2 id="2-在dual虚表使用序列"><a class="markdownIt-Anchor" href="#2-在dual虚表使用序列"></a> 2、在dual虚表使用序列</h2><p>序列创建后，用<code>序列名.nextval</code>获取序列的下一个值，用<code>序列名.currval</code>来查看当前值。</p><p>在新的会话中，必须先使用nextval来产生一个值后才可以使用currval进行查看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select SEQ_GIRL.nextval from dual;     -- 获取序列SEQ_GIRL的下一个值。</span><br><span class="line">select SEQ_GIRL.currval from dual;     -- 获取序列SEQ_GIRL的当前值</span><br></pre></td></tr></table></figure><h2 id="3-在sql语句中使用序列"><a class="markdownIt-Anchor" href="#3-在sql语句中使用序列"></a> 3、在SQL语句中使用序列</h2><p>我们先创建一个简单的表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  name    varchar2(<span class="number">10</span>),     -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  keyid   number(<span class="number">10</span>)        -- 记录编号</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>1）在insert语句中使用序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>  ,SEQ_GIRL.nextval)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;妲已&#x27;</span>  ,SEQ_GIRL.nextval)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;杨玉环&#x27;</span>,SEQ_GIRL.nextval)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,keyid)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;李师师&#x27;</span>,SEQ_GIRL.nextval)</span></span>;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200311090638957.png" alt="在这里插入图片描述" /></p><p>2）在update语句中使用序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T_GIRL set keyid=SEQ_GIRL.nextval+<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200311090850471.png" alt="在这里插入图片描述" /></p><h1 id="三-序列裂缝"><a class="markdownIt-Anchor" href="#三-序列裂缝"></a> 三、序列裂缝</h1><h2 id="1-序列不产生事务"><a class="markdownIt-Anchor" href="#1-序列不产生事务"></a> 1、序列不产生事务</h2><p>序列的nextval方法不会产生事务，事务回滚命令rollback不会恢复序列的值，我们来做一个测试。</p><p>1）先获取序列的当前值。</p><p><img src="https://img-blog.csdnimg.cn/20200311091004304.png" alt="在这里插入图片描述" /></p><p>2）执行一条不会成功的SQL语句。</p><p><img src="https://img-blog.csdnimg.cn/20200311091014476.png" alt="在这里插入图片描述" /></p><p>3）再获取序列的当前值。</p><p><img src="https://img-blog.csdnimg.cn/20200311091109676.png" alt="在这里插入图片描述" /></p><h2 id="2-序列裂缝"><a class="markdownIt-Anchor" href="#2-序列裂缝"></a> 2、序列裂缝</h2><p>如果用序列的值作为表中某个字段的值，这个字段的值可能会出现不连续的情况。因为序列的值不连续，有裂缝。</p><p>序列在下列情况下出现裂缝：</p><p>1）执行SQL语句失败；</p><p>2）事务回滚；</p><p>3）序列缓存；</p><p>4）多个表同时使用同一序列；</p><p>5）其它异常。</p><h1 id="四-修改序列"><a class="markdownIt-Anchor" href="#四-修改序列"></a> 四、修改序列</h1><p>修改序列的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alter sequence 序列名</span><br><span class="line">     [minvalue n]</span><br><span class="line">     [maxvalue n]</span><br><span class="line">     [increment by n]</span><br><span class="line">     [start with n]</span><br><span class="line">     [cache n|nocache]</span><br><span class="line">     [order|noorder]</span><br><span class="line">     [cycle|nocycle];</span><br></pre></td></tr></table></figure><p>修改序列的参数与创建序列的参数相同，不同的是，修改序列时没有缺省值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter sequence SEQ_GIRL increment by <span class="number">10</span> cycle</span><br></pre></td></tr></table></figure><h1 id="五-删除序列"><a class="markdownIt-Anchor" href="#五-删除序列"></a> 五、删除序列</h1><p>删除序列的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop sequence 序列名;</span><br></pre></td></tr></table></figure><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle虚表</title>
      <link href="/posts/a671fb61.html"/>
      <url>/posts/a671fb61.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库中存在一个特别的表dual，它是一个虚拟表，用来构成select的语法规则。Oracle对dual虚表的操作做了一些特别的处理，保证dual表里面永远只有一条记录。dual虚表存在给程序员带来了一些方便。</p><h1 id="一-测试dual虚表"><a class="markdownIt-Anchor" href="#一-测试dual虚表"></a> 一、测试dual虚表</h1><p>dual虚表只有一个字段，有一条记录。</p><h2 id="1-dual虚表的结构"><a class="markdownIt-Anchor" href="#1-dual虚表的结构"></a> 1、dual虚表的结构</h2><p><img src="https://img-blog.csdnimg.cn/2020031108521581.png" alt="在这里插入图片描述" /></p><h2 id="2-查询dual虚表中的记录"><a class="markdownIt-Anchor" href="#2-查询dual虚表中的记录"></a> 2、查询dual虚表中的记录</h2><p><img src="https://img-blog.csdnimg.cn/20200311085226794.png" alt="在这里插入图片描述" /></p><h2 id="3-对dual虚表做增-删-改操作"><a class="markdownIt-Anchor" href="#3-对dual虚表做增-删-改操作"></a> 3、对dual虚表做增、删、改操作</h2><p>普通用户对dual虚表只有查询权限，没有增、删、改的权限。DBA对dual虚表有全部的权限，但是，我不建议采用DBA对dual虚表进行操作，没什么意义，大家可以玩玩，但是，<strong>某些操作（删除表）可能造成数据库无法启动，请慎重，一定不能在生产环境中折腾。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200311085243304.png" alt="在这里插入图片描述" /></p><h1 id="二-dual虚表的用途"><a class="markdownIt-Anchor" href="#二-dual虚表的用途"></a> 二、dual虚表的用途</h1><p>利用dual虚表可以调用Oracle的函数和获取序列生成器的值，虽然还可以用来做一些其它的事情，比如说计算，但是对程序员来说利用dual虚表做计算毫无意义。</p><h2 id="1-执行oracle的函数"><a class="markdownIt-Anchor" href="#1-执行oracle的函数"></a> 1、执行Oracle的函数</h2><p>1）查看当前登录用户。</p><p><img src="https://img-blog.csdnimg.cn/2020031108530394.png" alt="在这里插入图片描述" /></p><p>2、获取数据库的日期时间</p><p><img src="https://img-blog.csdnimg.cn/20200311085314122.png" alt="在这里插入图片描述" /></p><h2 id="2-获取序列生成器的值"><a class="markdownIt-Anchor" href="#2-获取序列生成器的值"></a> 2、获取序列生成器的值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create sequence SEQ_FREECPLUS;         -- 创建序列生成器SEQ_FREECPLUS。</span><br><span class="line">select SEQ_FREECPLUS.nextval from dual;  -- 从序列SEQ_FREECPLUS获取下一个值。</span><br><span class="line">select SEQ_FREECPLUS.currval from dual;  -- 从序列SEQ_FREECPLUS获取当前值。</span><br></pre></td></tr></table></figure><p>细心的读者可能会思考一个问题，在insert和update语句中，可以把序列生成器直接填写到SQL语句中，不需要dual虚表。不一定，在实际开发中，可能要把序列生成器的值取出来，比如说参与运算。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的order by关键字</title>
      <link href="/posts/45d3eb99.html"/>
      <url>/posts/45d3eb99.html</url>
      
        <content type="html"><![CDATA[<p>order by关键字用于对查询的结果集进行排序。</p><p>我们通过示例来介绍order by关键字的用法。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-order-by的语法"><a class="markdownIt-Anchor" href="#二-order-by的语法"></a> 二、order by的语法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n from 表名 order by 字段名<span class="number">1</span> asc,字段名<span class="number">2</span> desc,......;</span><br></pre></td></tr></table></figure><p>order by关键字用于对结果集按一个或者多个字段进行排序，默认是升序asc（从小到大），如果需要按降序对记录进行排序，可以用desc。</p><p>如果排序字段有多个，可以对每个字段指定asc或desc。</p><p>1）从T_GIRL表中查出全部的记录，按身高降序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL order by height desc;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310205125368.png" alt="在这里插入图片描述" /></p><p>2）从T_GIRL表中查出全部的记录，按身材（降）和身高（升）排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL order by sc desc,height;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310205157451.png" alt="在这里插入图片描述" /></p><p>3）注意，order by排序的字段可以不在select的字段列表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL order by id desc;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310205249310.png" alt="在这里插入图片描述" /></p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的where子句</title>
      <link href="/posts/58b283b4.html"/>
      <url>/posts/58b283b4.html</url>
      
        <content type="html"><![CDATA[<p>where子句用于从表中或临时数据集中查找满足指定条件的记录，可用于select、update和delete语句中的条件。</p><h1 id="一-生成测试数据"><a class="markdownIt-Anchor" href="#一-生成测试数据"></a> 一、生成测试数据</h1><p>用以下SQL创建超女基本信息表（T_GIRL），插入一些测试数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">10</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">10</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">10</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，你们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="二-where子句的语法"><a class="markdownIt-Anchor" href="#二-where子句的语法"></a> 二、where子句的语法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n from 表名 where 字段名 比较运算符 值;</span><br><span class="line">select * from 表名 where 字段名 比较运算符 值;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL where id=<span class="string">&#x27;0101&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175112748.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,yz,sc,height from T_GIRL where height=<span class="number">172</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175137839.png" alt="在这里插入图片描述" /></p><p>以上的示例展示了where子句最简单的用法，接下来我再介绍Oracle的逻辑运算符和比较运算符，以增强where子句的功能。</p><h1 id="三-逻辑运算符"><a class="markdownIt-Anchor" href="#三-逻辑运算符"></a> 三、逻辑运算符</h1><table><thead><tr><th>运算符</th><th>备注</th></tr></thead><tbody><tr><td>and</td><td>双值运算符，如果左右两个条件都为真，则得到的值就为真。</td></tr><tr><td>or</td><td>双值运算符，只要左右两个条件有一个为真，则得到的值就为真。</td></tr><tr><td>not</td><td>单指运算符，如果原条件为真，则得到真，如果元条件为假，反之如果原条件为假，则结果为真。not一般比较运算符中的in、like、null一起使用。</td></tr></tbody></table><p>逻辑运算符有优先级，但我不想介绍它，在实际应用中，用括号解决全部的优先级问题。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="keyword">and</span> sc=<span class="string">&#x27;火辣&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175217121.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="built_in">and</span> (sc=<span class="string">&#x27;火辣&#x27;</span> <span class="keyword">or</span> sc=<span class="string">&#x27;苗条&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310175247973.png" alt="在这里插入图片描述" /></p><p>看看not的效果，但是很少这么用。</p><p><img src="https://img-blog.csdnimg.cn/20200310175257745.png" alt="在这里插入图片描述" /></p><h1 id="四-比较运算符"><a class="markdownIt-Anchor" href="#四-比较运算符"></a> 四、比较运算符</h1><p><img src="https://img-blog.csdnimg.cn/20200310175953389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意几个问题：</p><p>1）比较运算符都可以和not一起使用，但是在实际应用中，in、like和is null与not结合很常用，其它的比较运算符很少与not结合使用，感觉别扭。</p><p>2）使用like的时候，用百分号%匹配多个字符，下划线_匹配一个字符，但是如果我们希望把%和_当成普通字符，可以采用转义字符的方法，转义字符的用法如下：</p><p>在C语言中，采用反斜线\转义，在Oracle中，用escape关键字定义转义符。</p><p>escape 'chr’定义转义字符，当转义符置于通配符之前时，该通配符就解释为普通字符，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_GIRL where memo like <span class="string">&#x27;%人%/%%&#x27;</span> escape <span class="string">&#x27;/&#x27;</span>;</span><br></pre></td></tr></table></figure><p>第一、第二和第四个%作为通配符，第三个%是普通字符。</p><p><img src="https://img-blog.csdnimg.cn/20200310180121518.png" alt="在这里插入图片描述" /></p><h1 id="五-where子句的高级用法"><a class="markdownIt-Anchor" href="#五-where子句的高级用法"></a> 五、where子句的高级用法</h1><p>where子句条件的值可以是常量（固定的值）或表达式，也可以是函数的返回值或select语句的结果集。</p><p>如果是in比较运算符，条件的值可以是多行的结果集，其它的比较运算符必须是单行记录的结果集。</p><p>1）条件的值是表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where height&gt;<span class="number">100</span>+<span class="number">68</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180202411.png" alt="在这里插入图片描述" /></p><p>2）条件的值是函数和表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,yz,sc,height from T_GIRL where birthday&gt;sysdate-(<span class="number">30</span>*<span class="number">365</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180236527.png" alt="在这里插入图片描述" /></p><p>3）条件的值是单行的结果集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select empno,ename,job,sal from EMP</span><br><span class="line"> where deptno=(select deptno from DEPT where dname=<span class="string">&#x27;ACCOUNTING&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180314482.png" alt="在这里插入图片描述" /></p><p>如果条件的值是多行，在逻辑上存在问题，将提示错误。</p><p><img src="https://img-blog.csdnimg.cn/20200310180332484.png" alt="在这里插入图片描述" /></p><p>4）比较运算符in后面条件的值支持多行的结果集。</p><p><img src="https://img-blog.csdnimg.cn/20200310180341226.png" alt="在这里插入图片描述" /></p><h1 id="六-对where子句的列使用运算和函数"><a class="markdownIt-Anchor" href="#六-对where子句的列使用运算和函数"></a> 六、对where子句的列使用运算和函数</h1><p>在where子句中，对列可以进行运算和使用函数。</p><h2 id="1-对列进行运算"><a class="markdownIt-Anchor" href="#1-对列进行运算"></a> 1、对列进行运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height from T_GIRL where height<span class="number">-170</span>&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180424113.png" alt="在这里插入图片描述" /></p><h2 id="2-对列使用函数"><a class="markdownIt-Anchor" href="#2-对列使用函数"></a> 2、对列使用函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) <span class="function">from T_GIRL</span></span><br><span class="line"><span class="function"> where <span class="title">to_char</span><span class="params">(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>)</span></span>=<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310180507253.png" alt="在这里插入图片描述" /></p><h2 id="3-存在的问题"><a class="markdownIt-Anchor" href="#3-存在的问题"></a> 3、存在的问题</h2><p>以上第一个SQL对height列进行了运算，第二个SQL是对birthday列使用了to_char函数，这两种写法得零分。<strong>因为在where子句中，如果对列使用函数或运算，SQL语句的无法利用索引（函数索引除外），性能很低（采用了table scan），程序员一定不能犯这种低级错误。</strong></p><p>正确的写法是对条件的值进行运算或使用函数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,name,height from T_GIRL where height&gt;<span class="number">170</span>;</span><br><span class="line">select id,name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL</span><br><span class="line"> where birthday=<span class="built_in">to_date</span>(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>);</span><br></pre></td></tr></table></figure><p>补充说明一下，对select关键字后的列名进行运算和使用函数对SQL语句的性能没有任何影响。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle事务</title>
      <link href="/posts/b80388aa.html"/>
      <url>/posts/b80388aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-事务的基本概念"><a class="markdownIt-Anchor" href="#一-事务的基本概念"></a> 一、事务的基本概念</h1><p>在数据库中事务是工作的逻辑任务，一个事务是由一个或一组SQL语句组成，通过事务机制确保这一组SQL语句的操作要么全部成功执行成功，完成整个工作任务，如果任何一条SQL执行失败，对数据表所做的操作全部撤销。</p><p>事务的目的就是为了保证数据的完整性，以银行转换业务为例：</p><p>A用户向B转账1000元，步骤如下：</p><p>1）A用户账户余额减少1000元；</p><p>2）B用户账户余额增加1000元；</p><p>3）记录A用户的交易日志。</p><p>4）记录B用户的交易日志。</p><p>一笔转帐交易将产生四次数据库操作，要么全部都成功，如果有一个失败，其它操作也应该全部被撤销。</p><p>转账交易有四次数据库操作，即四条SQL语句，第一条SQL执行的时候是事务的开始，如果全部的SQL语句执行成功，提交事务，如果有任何一条SQL语句执行失败，回滚事务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit;     -- 提交事务。</span><br><span class="line">rollback;     -- 回滚事务。</span><br></pre></td></tr></table></figure><h1 id="二-事务的特征"><a class="markdownIt-Anchor" href="#二-事务的特征"></a> 二、事务的特征</h1><p>对一组SQL语句操作构成的事务，数据库系统必须保证这些操作的原子性、一致性、隔离性和持久性，即ACID原则。</p><h2 id="1-原子性atomicity"><a class="markdownIt-Anchor" href="#1-原子性atomicity"></a> 1、原子性（Atomicity）</h2><p>事务的原子性是指事务中包含的所有操作要么全做，要么不做，也就是说所有的操作在数据库中要么全部生效，要么全部不生效。</p><h2 id="2-一致性consistency"><a class="markdownIt-Anchor" href="#2-一致性consistency"></a> 2、一致性（Consistency）</h2><p>事务的一致性是指数据库在事务操作前和事务处理后，数据都是一致的。</p><h2 id="3-隔离性isolation"><a class="markdownIt-Anchor" href="#3-隔离性isolation"></a> 3、隔离性（Isolation）</h2><p>隔离性是指数据库允许多个并发的事务同时对数据进行读写或修改，即使出现了SQL语句叉操作数据的情况，也不会导致数据不一致。</p><h2 id="4-持久性durability"><a class="markdownIt-Anchor" href="#4-持久性durability"></a> 4、持久性（Durability）</h2><p>事务的持久性是指在事务处理结束后，它对数据的修改应该是永久的。通俗的理解就是事务结束后立即把数据写入硬盘中。</p><h1 id="三-事务控制"><a class="markdownIt-Anchor" href="#三-事务控制"></a> 三、事务控制</h1><p><strong>事务控制语句中最重要的两个指令，提交（commit）和回滚（rollback），可以满足99%的应用需求。</strong></p><p>本文接下来介绍事务控制的更多知识，大家了解一下就可以了，不必深入研究。</p><h2 id="1-设置事物属性"><a class="markdownIt-Anchor" href="#1-设置事物属性"></a> 1、设置事物属性</h2><p>set transaction可以用来设置事务的各种状态，比如只读、读/写、隔离级别，为事务分配名称或将事务分配回滚段等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set transaction [read only|read write]</span><br><span class="line">                [isolation level [serialize|read commited]]</span><br><span class="line">                [use rollback segment <span class="string">&#x27;segment_name&#x27;</span>]</span><br><span class="line">                [name <span class="string">&#x27;transaction_name&#x27;</span>];</span><br></pre></td></tr></table></figure><p><code>read only</code>：将事务设置为只读事务。</p><p><code>read write</code>：将事务设置为读/写事务。</p><p><code>isolation level</code>：如果指定，它有两个选项：（1）<code>serialize</code>：如果事务尝试更新由另一个事务更新并未提交的资源，则事务将失败。（2）<code>read commited</code>：如果事务需要另一个事务持有的行锁，则事务将等待，直到行锁被释放。</p><p><code>use rollback segment</code>：如果指定，它将事务分配给由’segment_name’标识的回退段，该段是用单引号括起来的段名称。</p><p><code>name</code>：为事务分配一个名称’transaction_name’，该名称是用单引号括起来。</p><p>注意：</p><p>1）set transaction是事务处理的第一条语句，也就是说，必须在任何insert、update、delete语句以及其他的事务处理之前。</p><p>2）在使用set transaction语句设置事务的属性时，很少指定回滚段，对于命名事务也非常简单，只有在分布式事务处理中才会体现出事务命名的用途。</p><h2 id="2-数据异常"><a class="markdownIt-Anchor" href="#2-数据异常"></a> 2、数据异常</h2><p>事务的隔离性定义了一个事务与其它事务的隔离程度，为了更好的理解隔离层，首先讨论一下并发事务对同一个数据库进行访问可能发生的情况，在并发事务中总体来说会发生如下3种情况：</p><p><strong>错读|脏读</strong></p><p><strong>非重复读取|不可重复读</strong></p><p><strong>假读|幻读</strong></p><p><strong>错读|脏读</strong>：当一个事务修改数据时，另一事务读取了该数据，但是第一事务由于某种原因取消对数据修改，使数据返回了原状态，这是第二个事务读取的数据与数据库中数据不一致，这就叫错读。</p><p><strong>非重复读取</strong>：是指一个事务读取数据库中的数据后，另一个事务则更新了数据，当第一个事务再次读取其中的数据时，就会发现数据已经发生了改变,这就是非重复读取。非重复读取所导致的结果就是一个事务前后两次读取的数据不相同。</p><p><strong>假读</strong>：如果一个事务基于某个条件读取数据后，另一个事务则更新了同一个表中的数据，这时第一个事务再次读取数据时，根据搜索的条件返回了不同的行，这就是假读。</p><p>事务中遇到的这些异常与事务的隔离性设置有关，事务的隔离性设置越多，异常就出现的越少，但并发效果就越低，事务的隔离性设置越少，异常出现的越多，并发效果越高。</p><h2 id="3-选择隔离层"><a class="markdownIt-Anchor" href="#3-选择隔离层"></a> 3、选择隔离层</h2><p>针对上文中读取的数据时产生的不一致现象，在ANSI SQL标准92中定义了4个事务的隔离级别，如下图所示：</p><table><thead><tr><th>隔离层</th><th>错读|脏读</th><th>非重复读取|不可重复读</th><th>假读|幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（非提交读）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ COMMITTED（提交读）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Repeatable READ（可重复读）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>Serializable（串行读）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>Oracle支持上述四种隔离层中的两种：read committed 和serializable，除此之外oralce中还定义read only 和 read write隔离层。<br />read committed：这是oracle默认的隔离层。<br />serializable：事务与事务之间完全隔开，事务以串行的方式执行，这并不是说一个事务必须结束才能启动另外一个事务，而是说这些事务的执行的结果于一次执行的事务的结果一致。<br />read only和 read write 当使用read only时，事务中不能有任何修改数据库中数据的操作语句，这包括 insert、update、delete、create语句。read only是serializable的一个子集，区别是read only 只读，而serialzable可以执行DML操作。read write它是默认设置，该选项表示在事务中可以有访问语句和修改语句，但很少使用。</p><h2 id="4-保存点"><a class="markdownIt-Anchor" href="#4-保存点"></a> 4、保存点</h2><p>保存点（savepoint）是在数据库事务处理中实现“子事务”（subtransaction），也称为嵌套事务的方法，事务可以回滚到<br />savepoint 而不影响 savepoint 创建前的变化，不需要放弃整个事务。</p><p>rollback回滚的用法可以设置保留点<br />savepoint，执行多条SQL操作时，回滚到想要的那条SQL之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">savepoint savepoint_name;    -- 声明一个savepoint。</span><br><span class="line">rollback to savepoint_name;   -- 回滚到savepoint。</span><br></pre></td></tr></table></figure><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的表</title>
      <link href="/posts/a04113c8.html"/>
      <url>/posts/a04113c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-表的概念"><a class="markdownIt-Anchor" href="#一-表的概念"></a> 一、表的概念</h1><p>表是数据库最基本的逻辑结构，一切数据都存放在表中，其它数据库对象（索引、视图、同义词等）都是为了更方便的操作表中的数据。Oracle数据库是由若干个表组成，每个表由列和行组成，如下表所示。</p><table><thead><tr><th>编号</th><th>姓名</th><th>颜值</th><th>身材</th><th>体重</th><th>身高</th><th>出生时间</th><th>备注</th></tr></thead><tbody><tr><td>0101</td><td>西施</td><td>漂亮</td><td>火辣</td><td>48.5</td><td>170</td><td>2000-01-01 01:12:35</td><td>这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。</td></tr><tr><td>0102</td><td>貂禅</td><td>漂亮</td><td>火辣</td><td>45.2</td><td>168</td><td>1997-08-02 12:20:38</td><td>王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。</td></tr><tr><td>0103</td><td>妲已</td><td>漂亮</td><td>丰满</td><td>53.6</td><td>172</td><td>1998-03-03 10:50:33</td><td>如果商真的因我而亡，您们男人做什么去了？</td></tr><tr><td>0104</td><td>芙蓉 姐姐</td><td>猪扒</td><td>膘肥 体壮</td><td>85.8</td><td>171</td><td>1980-05-05 10:11:55</td><td>如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。</td></tr><tr><td>0105</td><td>神密 猫女</td><td></td><td></td><td>48.5</td><td>171</td><td>1989-12-08 12:10:35</td><td>不知道是什么人，她脸上有一个%符号，很神密。</td></tr></tbody></table><h2 id="1-表的列"><a class="markdownIt-Anchor" href="#1-表的列"></a> 1、表的列</h2><p>表的结构是由列组成，习惯上把列也称之为字段，字段的基本属性如下：</p><p>1）字段名：字段的名称。</p><p>2）数据类型：该字段存放数据的类型和长度。</p><p>3）是否允许空值：该字段是否为必填，如果不是必填，表示可以为空。</p><h2 id="2-列的数据类型"><a class="markdownIt-Anchor" href="#2-列的数据类型"></a> 2、列的数据类型</h2><p>表的每个列一定会有它的数据类型，表示该列存放的是什么数据，常用的数据类型如下：</p><p>1）字符串类型：char和varchar2，可表达任何字符串。</p><p>2）数字类型：number(m,n)，可表达任何数字，m是数字的总长度，n是小数点后的位数，如果n为0则表示是存放整数。</p><p>3）日期类型：date，存放日期和时间，包括年（yyyy）、月（mm）、日（dd）、小时（hh24）、分（mi）、秒（ss）。</p><p>4）clob类型，存放单字节字符串或多字节字符数据，如文本文件、xml文件。</p><p>5）blob类型，存放非结构化的二进制数据，如图片、音频、视频、office文档等。</p><p>6）rowid类型，存放表中记录在数据库中的物理地址。</p><p>更详细的介绍请阅读《Oracle数据类型》文章。</p><h2 id="3-表的行"><a class="markdownIt-Anchor" href="#3-表的行"></a> 3、表的行</h2><p>表中的数据是由行组成的，每一行就是一条数据，也称之为记录，数据越多，记录就越多。</p><h1 id="二-创建表"><a class="markdownIt-Anchor" href="#二-创建表"></a> 二、创建表</h1><h2 id="1-创建表"><a class="markdownIt-Anchor" href="#1-创建表"></a> 1、创建表</h2><p>Oracle数据库创建表是用create table命令来完成的，我们通过创建T_GIRL表（超女基本信息表）来讲解create table 命令的使用。</p><p>建表命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名</span><br><span class="line">(</span><br><span class="line">  字段名<span class="number">1</span> 数据类型 null,</span><br><span class="line">  字段名<span class="number">2</span> 数据类型 <span class="keyword">not</span> null,</span><br><span class="line">  ......,</span><br><span class="line">  字段名n 数据类型 null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表名是标识符，从语法上来说，表名只要符合Oracle的规定就行了，但是，在实际开发中，我会遵守两个原则：1）表名以T_打头，可读性比较好；2）表名尽可能有意义，用完整的英文单词或简写、或中文拼音都可以，方便理解和记忆就好。</p><p>创建超女基本信息表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：1）在Oracle数据库的SQL命令中，关键字、表名和字段名都不区分大小写，CREATE和create没有区别，表名T_GIRL和t_girl也没有区别，字段名ID和id也没有区别；2）两根短线“--”是说明文字，就像C/C++语言中的“//”。</p><h2 id="2-创建表的主键"><a class="markdownIt-Anchor" href="#2-创建表的主键"></a> 2、创建表的主键</h2><p>在现实世界中，很多数据具有唯一的特性，例如身份证号码，在国家人口基本信息表中，一定不会存在多个人用同一个身份证号码的情况，再例如手机号码、QQ号码、银行帐号等等，还有学生管理系统，学生的年级、班级和学号三个字段组合起来是唯一的标识。</p><p>如果表中一个字段或多个字段组合起来的值是唯一的，就可以作为表的主键，在创建或修改表时用primay key关键字来指定主键。一个表只能有一个主键，而且组成主键的每个字段值都不能为空。</p><p>主键的作用：</p><p>1）体现数据结构设计的合理性。</p><p>2）提升数据操作的速度。</p><p>3）保证数据的完整性，在表中添加或修改记录时，数据库会检查该记录主键的值，不允许与其它记录主键的值重复，这种做法有个专业的名词：主键约束。</p><p>例如超女基本信息表，编号的字段名是id，在超女选秀活动中，每个超女的编号肯定是唯一的，不可能存在两个编号相同的超女，否则会引起混乱，我们可以把id字段设置为T_GIRL表的主键，后面的工作交给数据库，如果试图往表中插入多条id相同的记录，数据库将拒绝。</p><p>指定表的主建有两种方法。</p><p>1）在create table时指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null,   -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(id)                       -- 指定id为表的主键</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>2）修改已经建好的表，增加主键约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 主键名 <span class="function">primary <span class="title">key</span><span class="params">(字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n)</span></span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add constraint PK_GIRL primary <span class="title">key</span><span class="params">(id)</span></span>;</span><br></pre></td></tr></table></figure><p>在Oracle数据库中，虽然主键不是必需的，但是最好为每个表都设置一个主键，不管是单字段主键还是多字段主键（复合主键），它的存在代表了表结构的完整性，主键还可以用于其他表的外键关联，外键的知识以后再介绍。</p><h1 id="三-表记录的插入-修改和删除"><a class="markdownIt-Anchor" href="#三-表记录的插入-修改和删除"></a> 三、表记录的插入、修改和删除</h1><h2 id="1-向表中插入记录"><a class="markdownIt-Anchor" href="#1-向表中插入记录"></a> 1、向表中插入记录</h2><p>insert into命令用于向表中插入记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>,...... 字段名n) <span class="built_in">values</span> (字段<span class="number">1</span>的值, 字段<span class="number">2</span>的值,..... 字段n的值);</span><br></pre></td></tr></table></figure><p>注意，表名后的字段名列表与values后面字段值列表必须一一对应。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0101&#x27;</span>,<span class="string">&#x27;西施&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">48.5</span>,<span class="number">170</span>,<span class="string">&#x27;这是一个非常漂亮姑娘，老公是夫差，男朋友是范蠡。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0102&#x27;</span>,<span class="string">&#x27;貂禅&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1997-08-02 12:20:38&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;苗条&#x27;</span>,<span class="number">45.2</span>,<span class="number">168</span>,<span class="string">&#x27;王允真不是男人，干不过董卓就把美人往火坑里推，千古罪人啊。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0103&#x27;</span>,<span class="string">&#x27;妲已&#x27;</span>,<span class="string">&#x27;漂亮&#x27;</span>,to_date(<span class="string">&#x27;1998-03-03 10:50:33&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;火辣&#x27;</span>,<span class="number">53.6</span>,<span class="number">172</span>,<span class="string">&#x27;如果商真的因我而亡，您们男人做什么去了？&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0104&#x27;</span>,<span class="string">&#x27;芙蓉姐姐&#x27;</span>,<span class="string">&#x27;猪扒&#x27;</span>,to_date(<span class="string">&#x27;1980-05-05 10:11:55&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="string">&#x27;膘肥体壮&#x27;</span>,<span class="number">85.8</span>,<span class="number">166</span>,<span class="string">&#x27;如果不努力学习技术，将来就会娶个芙蓉姐姐，哼哼。&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(id,name,yz,birthday,sc,weight,height,memo)</span></span></span><br><span class="line"><span class="function">  <span class="title">values</span><span class="params">(<span class="string">&#x27;0105&#x27;</span>,<span class="string">&#x27;神密猫女&#x27;</span>,null,to_date(<span class="string">&#x27;1989-12-08 12:10:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">         null,<span class="number">48.5</span>,<span class="number">171</span>,<span class="string">&#x27;不知道是什么人，她脸上有一个%符号，很神密。&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在上面的insert语句中，字段的值如果是字符串，要用单引号包含起来，日期字段要用to_date函数转换，数字直接书写。</p><p>插入数据的SQL语句还有一种写法，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 <span class="built_in">values</span> (字段<span class="number">1</span>的值, 字段<span class="number">2</span>的值,..... 字段n的值);</span><br></pre></td></tr></table></figure><p>这种写法省略了字段名列表，但是，这种写法一定不能出现在程序中，因为只要表结构发生改变，或字段的位置改变，SQL语句就会出错。</p><h2 id="2-查询表中的记录"><a class="markdownIt-Anchor" href="#2-查询表中的记录"></a> 2、查询表中的记录</h2><p>insert into命令用于从表中查询记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 字段名<span class="number">1</span>,字段名<span class="number">2</span>,......字段名n from 表名 where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br><span class="line">select * from 表名 where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="keyword">and</span> sc=<span class="string">&#x27;火辣&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在select关键字之后，可以用星号表示全部的字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_GIRL where yz=<span class="string">&#x27;漂亮&#x27;</span> <span class="keyword">and</span> sc=<span class="string">&#x27;火辣&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在上面的SQL语句中，用星号*表示列出全部的字段，这种写法一定不能出现在程序中，因为只要表结构发生改变，或字段的位置改变，程序就会出现混乱。</p><p>where关键字后面的条件表达式涉及的知识非常多，以后再详细介绍。</p><h2 id="3-修改表中的记录"><a class="markdownIt-Anchor" href="#3-修改表中的记录"></a> 3、修改表中的记录</h2><p>update命令用于修改表中的记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名<span class="number">1</span>=值<span class="number">1</span>,字段名<span class="number">2</span>=值<span class="number">2</span>,......字段名n=值n where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br></pre></td></tr></table></figure><p>在set关键字之后把需要修改的字段名和新的值一一列出来。</p><p>where关键字后面是条件表达式，如果没有条件表达式，就会更新表中全部的记录。</p><p>超女选秀活动开始后，芙蓉姐姐体重反弹了3公斤，像个大恐龙，出生日期也有隐瞒，组委会修改了她的基本资料，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T_GIRL set weight=<span class="number">89.5</span>,yz=<span class="string">&#x27;恐龙&#x27;</span>,birthday=<span class="built_in">to_date</span>(<span class="string">&#x27;1978-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) where name=<span class="string">&#x27;芙蓉姐姐&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="4-删除表中的记录"><a class="markdownIt-Anchor" href="#4-删除表中的记录"></a> 4、删除表中的记录</h2><p>delete命令用于删除表中的记录，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> from 表名 where 条件<span class="number">1</span> <span class="keyword">and</span> 条件<span class="number">2</span> ...... 条件n;</span><br></pre></td></tr></table></figure><p>where关键字后面是条件表达式，如果没有条件表达式，就删除表中全部的记录。</p><p>随着超女选秀活动的继续，芙蓉姐姐的体重在持续反弹中，组委会实在受不了了，决定把芙蓉姐姐除名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> from T_GIRL where name=<span class="string">&#x27;芙蓉姐姐&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="四-表的约束"><a class="markdownIt-Anchor" href="#四-表的约束"></a> 四、表的约束</h1><p>表的约束有非空约束、唯一性约束、检查约束、主建约束和外键约束四种，主键约束和外键约束涉及到数据结构方面的知识，以后再介绍。</p><h2 id="1-非空约束"><a class="markdownIt-Anchor" href="#1-非空约束"></a> 1、非空约束</h2><p>创建表的时候，可以指定字段的值是否允许为空，缺省是null允许为空（表示是可选字段），not null不允许为空（表示是必填字段）。</p><p>例示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span> <span class="params">(c1 varchar2(<span class="number">10</span>),c2 varchar2(<span class="number">10</span>) <span class="keyword">not</span> null)</span></span>;</span><br></pre></td></tr></table></figure><p>创建表tt，c1字段允许为空，c2字段不允许为空。</p><p><img src="https://img-blog.csdnimg.cn/20200310165554927.png" alt="在这里插入图片描述" /></p><h2 id="2-唯一性约束"><a class="markdownIt-Anchor" href="#2-唯一性约束"></a> 2、唯一性约束</h2><p>唯一性约束有两种，一种是表的主键，另一种是表的唯一索引，唯一索引以后再介绍。</p><p>表的主键字段不允许存在值相同的记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">tt</span> <span class="params">(id varchar2(<span class="number">10</span>),name varchar2(<span class="number">10</span>),primary key(id))</span></span>;</span><br></pre></td></tr></table></figure><p>创建表tt，id字段是主键。</p><p><img src="https://img-blog.csdnimg.cn/20200310165653992.png" alt="在这里插入图片描述" /></p><h2 id="3-检查约束"><a class="markdownIt-Anchor" href="#3-检查约束"></a> 3、检查约束</h2><p>检查约束是指检查字段的值是否合法。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">TT</span>  </span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   c1   number(<span class="number">6</span>) constraint CKC_C1_TT check (c1 &gt;= <span class="number">10</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">   c2   number(<span class="number">6</span>) constraint CKC_C2_TT check (c2 &lt;= <span class="number">20</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">   c3   number(<span class="number">6</span>) constraint CKC_C3_TT check (c3 in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>创建表TT，c1字段的最小值是10，c2字段的最大值是20，C3字段的取值必须在(1,2,3)中取其一。</p><p><img src="https://img-blog.csdnimg.cn/2020031016574632.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310165755162.png" alt="在这里插入图片描述" /></p><h1 id="五-字段的缺省值"><a class="markdownIt-Anchor" href="#五-字段的缺省值"></a> 五、字段的缺省值</h1><p>在创建表的时候，可以为字段指定缺省值。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">TT</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   name     varchar2(<span class="number">10</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   crttime  date         <span class="keyword">default</span> sysdate <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">   rsts     number(<span class="number">1</span>)    <span class="keyword">default</span> <span class="number">1</span> <span class="keyword">not</span> null constraint CKC_RSTS_TT check (rsts in (<span class="number">1</span>,<span class="number">2</span>))</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>创建表，字段crttime的缺省值是sysdate（当前时间），rsts的缺省值是1。</p><p><img src="https://img-blog.csdnimg.cn/20200310165843154.png" alt="在这里插入图片描述" /></p><h1 id="六-表的存储空间"><a class="markdownIt-Anchor" href="#六-表的存储空间"></a> 六、表的存储空间</h1><p>每个数据库用户有一个缺省表空间，创建的表、主键和索引存放在缺省表空间中，也可以指定其它的表空间。</p><h2 id="1-查看当前用户的缺省表空间"><a class="markdownIt-Anchor" href="#1-查看当前用户的缺省表空间"></a> 1、查看当前用户的缺省表空间</h2><p>从数据字典USER_USERS中可以查看当前用户的缺省表空间。</p><p><img src="https://img-blog.csdnimg.cn/20200310165907549.png" alt="在这里插入图片描述" /></p><h2 id="2-指定表的表空间"><a class="markdownIt-Anchor" href="#2-指定表的表空间"></a> 2、指定表的表空间</h2><p>指定表空间的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table 表名</span><br><span class="line">(</span><br><span class="line">  ......   -- 字段列表</span><br><span class="line">) tablespace 表空间名;</span><br></pre></td></tr></table></figure><p>例如创建T_GIRL表，指定使用USERS表空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">T_GIRL</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  id        <span class="type">char</span>(<span class="number">4</span>)         <span class="keyword">not</span> null,   -- 编号</span></span></span><br><span class="line"><span class="params"><span class="function">  name      varchar2(<span class="number">30</span>)    <span class="keyword">not</span> null,   -- 姓名</span></span></span><br><span class="line"><span class="params"><span class="function">  yz        varchar2(<span class="number">20</span>)        null,   -- 颜值</span></span></span><br><span class="line"><span class="params"><span class="function">  sc        varchar2(<span class="number">20</span>)        null,   -- 身材</span></span></span><br><span class="line"><span class="params"><span class="function">  weight    number(<span class="number">4</span>,<span class="number">1</span>)     <span class="keyword">not</span> null,   -- 体重</span></span></span><br><span class="line"><span class="params"><span class="function">  height    number(<span class="number">3</span>)       <span class="keyword">not</span> null,   -- 身高</span></span></span><br><span class="line"><span class="params"><span class="function">  birthday  date            <span class="keyword">not</span> null,   -- 出生时间</span></span></span><br><span class="line"><span class="params"><span class="function">  memo      varchar2(<span class="number">1000</span>)      null    -- 备注</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> tablespace USERS</span>;</span><br></pre></td></tr></table></figure><p>表还有其它与存储相关的选项，但应用场景比较少，本文就不介绍了。</p><h1 id="七-修改表结构"><a class="markdownIt-Anchor" href="#七-修改表结构"></a> 七、修改表结构</h1><p>Oracle修改表的命令是alter table，它的选项非常多，本文只介绍修改表结构的相关知识。</p><h2 id="1-增加字段"><a class="markdownIt-Anchor" href="#1-增加字段"></a> 1、增加字段</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 字段名 数据类型 其它选项;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL add address <span class="title">varchar2</span><span class="params">(<span class="number">50</span>)</span> null</span>;</span><br><span class="line"><span class="function">alter table T_GIRL add rsts <span class="title">number</span><span class="params">(<span class="number">1</span>)</span> constraint CKC_RSTS_GIRL <span class="title">check</span> <span class="params">(rsts in (<span class="number">1</span>,<span class="number">2</span>))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-修改字段的属性"><a class="markdownIt-Anchor" href="#2-修改字段的属性"></a> 2、修改字段的属性</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 字段名 数据类型 其它选项;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table T_GIRL modify address <span class="title">varchar2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">alter table T_GIRL modify address <span class="title">varchar2</span><span class="params">(<span class="number">100</span>)</span> <span class="keyword">not</span> null</span>;</span><br><span class="line">alter table T_GIRL drop constraint CKC_RSTS_GIRL;</span><br><span class="line"><span class="function">alter table T_GIRL modify rsts constraint CKC_RSTS_GIRL <span class="title">check</span> <span class="params">(rsts in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>修改字段属性的时候要注意一个问题，如果表中已存在数据，修改可能会失败，包括但不限于以下的情况：</p><p>1）把字段由null改为not null时，表中记录存在null的情况。</p><p>2）把字段的取值范围由较大（例如number(10)）改较小（例如number(5)），表中记录存在大于较小取值范围的情况，例如已经存在123456的值，如果把数据类型改为number(5)，无法存放123456。</p><p>3）把字段的数据类型时，表中存在记录并且新旧数据类型不兼容的情况。例如原来的数据类型是varchar2(10)，表中存在记录的值是’freecplus’，如果要修改为number(10)，Oracle无法把’freecplus’转换为number(10)。</p><h2 id="3-修改字段名"><a class="markdownIt-Anchor" href="#3-修改字段名"></a> 3、修改字段名</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename column 列名 to 新列名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL rename column memo to remark;</span><br></pre></td></tr></table></figure><h2 id="4-删除字段"><a class="markdownIt-Anchor" href="#4-删除字段"></a> 4、删除字段</h2><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 dorp column 字段名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL drop column rsts;</span><br><span class="line">alter table T_GIRL drop column address;</span><br></pre></td></tr></table></figure><h1 id="八-修改表名"><a class="markdownIt-Anchor" href="#八-修改表名"></a> 八、修改表名</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename to 新表名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table T_GIRL rename to T_BEAUTY;</span><br></pre></td></tr></table></figure><p>注意，如果修改了表名，表的约束、索引、主键的名称不会改变。</p><h1 id="九-删除表"><a class="markdownIt-Anchor" href="#九-删除表"></a> 九、删除表</h1><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table T_GIRL;</span><br></pre></td></tr></table></figure><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据类型</title>
      <link href="/posts/2b739d38.html"/>
      <url>/posts/2b739d38.html</url>
      
        <content type="html"><![CDATA[<p>Oracle的数据类型有二十多种，包括字符串类型、数字类型、日期类型、LOB类型、LONG RAW&amp; RAW类型、ROWID &amp; UROWID类型。太多的数据类型很容易让初学者感到迷茫，在本文中，我将以程序员的视角，结合实际开发的需求来介绍Oracle的数据类型。</p><p>Oracle的数据类型虽然很多，但实用的只有以下几种：</p><p>1）字符串类型：char和varchar2，可表达任何字符串。</p><p>2）数字类型：number(m,n)，可表达任何数字，m是数字的总长度，n是小数点后的位数，如果n为0则表示是一个整数。</p><p>3）日期类型：date，存放日期和时间，包括年（yyyy）、月（mm）、日（dd）、小时（hh24）、分（mi）、秒（ss）。</p><p>4）clob类型，存放单字节字符串或多字节字符串数据，如文本文件、xml文件。</p><p>5）blob类型，存放非结构化的二进制数据，如图片、音频、视频、office文档等。</p><p>6）rowid类型，存放表中记录在数据库中的物理地址。</p><h1 id="一-字符串类型"><a class="markdownIt-Anchor" href="#一-字符串类型"></a> 一、字符串类型</h1><p>在C/C++语言中用，字符串用双引号包含起来，在Oracle数据库中，字符串用单引号包含起来的，如下：</p><p>‘<a href="http://www.freecplus.net">www.freecplus.net</a>’</p><p>‘码农有道’</p><p>'一只傻傻鸟 ’</p><h2 id="1-固定长度的字符串"><a class="markdownIt-Anchor" href="#1-固定长度的字符串"></a> 1、固定长度的字符串</h2><p>固定长度字符串用char表示，当存入数据内容的长度不够时，Oracle将在数据内容后面自动填充空格以达到其固定的长度，例如char(10)总是包含10字节信息。</p><p>char字段最多可以存储2000字节的内容。</p><h2 id="2-变长度的字符串"><a class="markdownIt-Anchor" href="#2-变长度的字符串"></a> 2、变长度的字符串</h2><p>变长度字符串用varchar2表示，与char类型不同，Oracle不会在数据内容后面填充任何内容。</p><p>varchar2字段最多可以存储4000字节的内容，从Oracle 12c版本开始，可以存储32767字节的内容。</p><h2 id="3-char和varchar2的比较"><a class="markdownIt-Anchor" href="#3-char和varchar2的比较"></a> 3、char和varchar2的比较</h2><p>char(10)，如果存入’freecplus’，在数据库中将存储’freecplus '，在最后补了一个空格。</p><p>varchar2(10)，如果存入’freecplus’，在数据库中将存储’freecplus’，什么也不会补。</p><p>在实际应用中，我们并不希望Oracle给字符串后面补空格，那么是不是可以弃用char类型呢？不是，我们一般用char类型存放固定大小的数据内容，例如身份证号码，固定是18位的，用char(18)就非常合适，能用varchar2(18)可以存放身份证号码吗？当然可以，但是，char(18)的效率比varchar2(18)的效率要高很多。</p><p>总结一下，如果确定、肯定、一定、保证存入字符串的长度是固定不变的，例如性别、身份证号码、手机号码，用char类型，否则用varchar2类型，例如姓名、学历、地址、兴趣爱好等，char虽然死板，但是效率高。</p><h2 id="4-汉字的存储"><a class="markdownIt-Anchor" href="#4-汉字的存储"></a> 4、汉字的存储</h2><p>每个汉字占多少字节要看具体的编码方式，如UTF-8（1-3字节）、GB2312（2字节）、GBK（2字节）、GB18030（1、2、4字节）。</p><h1 id="二-数字类型"><a class="markdownIt-Anchor" href="#二-数字类型"></a> 二、数字类型</h1><p>Oracle用number类型来存放数字，该类型能存储精度最多达38位，远远高于编程语言中常规的 long int和double类型。</p><p>number( m,n)，m表示总长度，n表示小数位的精度，如果存入的数据的小数位的精度超过了n，则取四舍五入后的值。</p><p>例如：number(10,3)，10是总长度，3是小数后的位数，如123.456。</p><p>如果存入123.4567，实际际将是123.457。</p><p>如果存入12345679.899，总长度超出了10，Oracle将提示错误。</p><p>如果打算存入整数，用number(m)就可以了，m表示可以存入数据的最大位数。</p><h1 id="三-日期类型"><a class="markdownIt-Anchor" href="#三-日期类型"></a> 三、日期类型</h1><p>Oracle采用date类型表示日期和时间，这是一个7字节的固定宽度的数据类型，有7个属性，包括：世纪、世纪中哪一年、月份、月中的哪一天、小时、分钟和秒。</p><p>对编程语言来说，日期和时间是用字符串来显示和书写的，Oracle提供了to_date和to_char两个函数在date类型和字符串类型之间转换。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert into <span class="title">T_GIRL</span><span class="params">(name,birthday)</span> <span class="title">values</span><span class="params">(<span class="string">&#x27;西施&#x27;</span>,to_date(<span class="string">&#x27;2000-01-01 01:12:35&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>))</span></span>;</span><br><span class="line">select name,<span class="built_in">to_char</span>(birthday,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) from T_GIRL where name=<span class="string">&#x27;西施&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="四-clob和blob类型"><a class="markdownIt-Anchor" href="#四-clob和blob类型"></a> 四、clob和blob类型</h1><p>clob类型，变长的字符串大对象，最长可达4GB，clob可以存储单字节字符串或多字节字符串数据，clob被认为是一个更大的字符串。当数据库的字符集发生转换时，clob类型会受到影响。</p><p>blob类型，变长的二进制大对象，最长可达4GB，blob主要用于保存带格式的非结构化数据，如图片、音频、视频、Office文档等。当数据库的字符集发生转换时，blob类型不会受到影响，Oracle数据库不关心存放的是什么内容。</p><h1 id="五-rowid类型"><a class="markdownIt-Anchor" href="#五-rowid类型"></a> 五、rowid类型</h1><p>Oracle数据库中每个表的每行记录都有一个存储的物理位置，即表的rowid伪列，采用rowid作为where条件的访问效率最高。</p><p>rowid的访问效率虽然是最高的，但是，在实际应用中要谨慎，需要注意两个问题：</p><p>1）rowid存放的是表记录的物理位置，在数据整理、数据备份和迁移的时候，记录的物理位置会发生改变；</p><p>2）rowid是Oracle数据库专有的数据类型，与其它的数据库不兼容。</p><h1 id="六-其它数据类型"><a class="markdownIt-Anchor" href="#六-其它数据类型"></a> 六、其它数据类型</h1><p>在上面的内容中，介绍了Oracle最常用的数据类型，可以满足99%以上的应用场景。</p><p>Oracle提供了22中不同的SQL数据类型，其它的数据类型不一定实用，但我还是把它们全部列出来，大家了解一下，不必深入研究。二十年来，其它的数据类型我从未使用过。</p><p>char：定长字符串，会用空格填充来达到最大长度。非null的char(10)包含10个字节信息。char字段最多可以存储2000个字节信息。</p><p>nchar：包含unicode格式数据的定长字符串。nchar字段最多可存储2000字节的信息。</p><p>varchar2：是varchar的同义词。这是一个变长字符串，与char类型不同，它不会用空格将字段或变量填充至最大长度。varchar(10)可能包含0~10字节的信息，最多可存储4000字节信息。从12c起，可以存储32767字节信息。</p><p>nvarchar2：包含unicode格式数据的变长字符串。最多可存储4000字节信息。从12c起，可以存储32767字节信息。</p><p>raw：一种变长二进制数据类型，采用这种数据类型存储的数据不会发生字符集转换。</p><p>number：能存储精度最多高达38位的数字。这种类型的数据会以变长方式来存储，长度在0~22字节。</p><p>binary_float：32位单精度浮点数，可以支持至少6位精度，占用磁盘上5个字节的存储空间。</p><p>binary_double：64位双精度浮点数，可以支持至少15位精度，占用磁盘上9个字节的存储空间。</p><p>long：这种类型能存储最多2GB的字符数据</p><p>long raw：long raw类型能存储多达2GB的二进制信息</p><p>date：这是一个7字节的定宽日期/时间数据类型，其中包含7个属性：世纪、世纪中的哪一年、月份、月中的哪一天、小时、分钟、秒。</p><p>timestamp：这是一个7字节或11字节的定宽日期/时间数据类型，它包含小数秒。</p><p>timestamp with time zone：这是一个13字节的timestamp，提供了时区支持。</p><p>timestamp with local time zone：这是一个7字节或11字节的定宽日期/时间数据类型，在数据的插入和读取时会发生时区转换。</p><p>interval year to month：这是一个5字节的定宽数据类型，用于存储一个时段。</p><p>interval day to second：这是一个11字节的定宽数据类型，用于存储一个时段。将时段存储为天/小时/分钟/秒数，还可以有9位小数秒。</p><p>blob：这种类型能够存储最多4GB的数据。</p><p>clob：这种类型能够存储最多4GB的数据。当字符集发生转换时，这种类型会受到影响。</p><p>nclob：这种类型能够存储最多4GB的数据。当字符集发生转换时，这种类型会受到影响。</p><p>bfile：这种数据类型可以在数据库列中存储一个oracle目录对象和一个文件名，我们可以通过它来读取这个文件。</p><p>rowid：实际上是数据库表中行的地址，它有10字节长。</p><p>urowid：是一个通用的rowid，没有固定的rowid的表。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle环境变量</title>
      <link href="/posts/283c6f87.html"/>
      <url>/posts/283c6f87.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-oracle环境变量"><a class="markdownIt-Anchor" href="#一-oracle环境变量"></a> 一、Oracle环境变量</h1><p>Oracle数据库的安装和运行都需要环境变量，常用的Oracle环境变量如下。</p><h2 id="1-oracle_home"><a class="markdownIt-Anchor" href="#1-oracle_home"></a> 1、ORACLE_HOME</h2><p>Oracle软件安装的根目录，存放了Oracle的可执行程序、管理工具、函数库、java虚拟机、帮助文档、示例代码等。</p><h2 id="2-oracle_base"><a class="markdownIt-Anchor" href="#2-oracle_base"></a> 2、ORACLE_BASE</h2><p>Oracle实例（数据库）的根目录，存放了实例的控制文件、数据文件、日志文件、审计日志、错误报告等。</p><h2 id="3-oracle_sid"><a class="markdownIt-Anchor" href="#3-oracle_sid"></a> 3、ORACLE_SID</h2><p>Oracle的实例名。</p><h2 id="4-nls_lang"><a class="markdownIt-Anchor" href="#4-nls_lang"></a> 4、NLS_LANG</h2><p>Oracle客户端的字符集，必须与服务端的Oracle实例保持一致，否则会出现中文乱码。</p><h2 id="5-path"><a class="markdownIt-Anchor" href="#5-path"></a> 5、PATH</h2><p>PATH是Linux操作系统的环境变量（可执行程序的搜索目录），在PATH中增加$ORACLE_HOME/bin是为了方便执行Oracle的应用程序。</p><h2 id="6-ld_library_path"><a class="markdownIt-Anchor" href="#6-ld_library_path"></a> 6、LD_LIBRARY_PATH</h2><p>LD_LIBRARY_PATH是Linux操作系统的环境变量（动态链接库文件的搜索目录），在LD_LIBRARY_PATH中增加$ORACLE_HOME/lib。只有C/C++程序员才关心LD_LIBRARY_PATH环境变量。</p><h2 id="7-classpath"><a class="markdownIt-Anchor" href="#7-classpath"></a> 7、CLASSPATH</h2><p>CLASSPATH是Linux操作系统的环境变量，在CLASSPATH中增加$ORACLE_HOME/jdk/jre:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib，只有java程序员才关心CLASSPATH环境变量。</p><h2 id="8-其它环境变量"><a class="markdownIt-Anchor" href="#8-其它环境变量"></a> 8、其它环境变量</h2><p>Oracle其它的环境变量意义不大，一般不必设置，如TNS_ADMIN、ORACLE_OWNER、ORACLE_TERM等。</p><h1 id="二-oracle环境的配置"><a class="markdownIt-Anchor" href="#二-oracle环境的配置"></a> 二、Oracle环境的配置</h1><p>在Linux中，配置Oracle环境变量有多种方法，假设环境变量的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ORACLE_HOME=/oracle/home</span><br><span class="line"><span class="keyword">export</span> ORACLE_BASE=/oracle/base</span><br><span class="line"><span class="keyword">export</span> ORACLE_SID=snorcl11g</span><br><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin:.</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib:.</span><br><span class="line">CLASSPATH=$ORACLE_HOME/jdk/jre:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib:.</span><br><span class="line"><span class="keyword">export</span> CLASSPATH</span><br></pre></td></tr></table></figure><h2 id="1-在oracle用户的bash_profile中配置"><a class="markdownIt-Anchor" href="#1-在oracle用户的bash_profile中配置"></a> 1、在oracle用户的.bash_profile中配置</h2><p>如果在oracle用户的.bash_profile中配置Oracle的环境变量，只对oracle一个用户生效。</p><h2 id="2-在etcprofile中配置"><a class="markdownIt-Anchor" href="#2-在etcprofile中配置"></a> 2、在/etc/profile中配置</h2><p>在/etc/profile文件中配置Oracle的环境变量，可以对全部的用户生效。</p><p>但是，/etc/profile文件开始几行的内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310151646483.png" alt="在这里插入图片描述" /></p><p>Linux不建议在/etc/profile文件中配置环境变量。</p><h2 id="3-在etcprofiled中配置"><a class="markdownIt-Anchor" href="#3-在etcprofiled中配置"></a> 3、在/etc/profile.d中配置</h2><p>在/etc/profile.d目录中增加环境变量配置文件，<a href="http://xn--oracle-hh4k.sh">如oracle.sh</a>。</p><p>如果把Oracle环境变量的配置文件放在/etc/profile.d中，可以对全部的用户生效。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle11g客户端安装配置</title>
      <link href="/posts/4464eb0c.html"/>
      <url>/posts/4464eb0c.html</url>
      
        <content type="html"><![CDATA[<p>Oracle数据库管理员和开发者一定希望在自己台式电脑的Windows系统中搭建Oracle客户端工作环境。</p><p>Oracle客户端工作环境主要包括两个部分：1）Oracle数据库客户端软件，提供了Oracle客户端驱动和配置工具；2）PL/SQL<br />Developer软件，在该软件中，可以很方便的查看和管理Oracle数据库对象，编写、调试和运行SQL语句。</p><h1 id="一-oracle数据库客户端的安装"><a class="markdownIt-Anchor" href="#一-oracle数据库客户端的安装"></a> 一、Oracle数据库客户端的安装</h1><h2 id="1-下载软件安装包"><a class="markdownIt-Anchor" href="#1-下载软件安装包"></a> 1、下载软件安装包</h2><p>Oracle数据库客户端软件包名是 win64_11gR2_client.zip ，可以从Oracle公司的官网下载，链接如下：</p><p><a href="https://www.oracle.com/database/technologies/112010-win64soft.html">https://www.oracle.com/database/technologies/112010-win64soft.html</a></p><p>或者登录C语言技术网，在资源下载栏目中可以下载。</p><p>安装Oracle数据库客户端软件不需要软件授权license，不存在破解版的说法。</p><h2 id="2-解压运行安装程序"><a class="markdownIt-Anchor" href="#2-解压运行安装程序"></a> 2、解压运行安装程序</h2><p><strong>1）运行安装程序。</strong></p><p>点击sertup运行后，会弹出一个DOS窗口，可能需要等几十秒。</p><p><img src="https://img-blog.csdnimg.cn/20200310144744705.png" alt="在这里插入图片描述" /></p><p><strong>2）如果出现了以下窗口，选“是(Y)”继续。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144759484.png" alt="在这里插入图片描述" /></p><p><strong>3）安装类型选择“管理员”。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144811400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>4）语言选择“简体中文”和“英语”。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144826435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>5）指定Oracle的基目录和软件安装位置，可以用缺省值，也可以如下图。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144836311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>6）执行先决条件检查。</strong></p><p>如果出现了“执行先决条件检查”失败，勾选“全部忽略”后再下一步。</p><p><img src="https://img-blog.csdnimg.cn/20200310144850859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>7）确认安装信息。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144901294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>8）安装进行中。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310144925596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>9）安全中心警报。</strong></p><p>如果安装进行中出现Windows安全中心警报，选择“允许访问”。</p><p><img src="https://img-blog.csdnimg.cn/20200310144949508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>10）安装完成。</strong></p><p><img src="https://img-blog.csdnimg.cn/2020031014505356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="二-plsql-developer的安装"><a class="markdownIt-Anchor" href="#二-plsql-developer的安装"></a> 二、PL/SQL Developer的安装</h1><p>连接Oracle数据库的客户端软件比较多，如Navicat Premium，但是，PL/SQL Developer专为Oracle数据库定制开发的，功能强大，使用方便，是最佳的选择。</p><h2 id="1-下载软件安装包-2"><a class="markdownIt-Anchor" href="#1-下载软件安装包-2"></a> 1、下载软件安装包</h2><p>PL/SQL Developer是一款收费的软件。</p><p>官网地址：<a href="https://www.allroundautomations.com">https://www.allroundautomations.com</a></p><p>或者登录C语言技术网，在资源下载栏目中可以下载。</p><p>PL/SQL Developer安装过程中需要软件授权license，各位可以百度，解决方法很多。</p><p>PL/SQL Developer软件有多个版本，建议安装11以上版本。</p><h2 id="2-安装软件包"><a class="markdownIt-Anchor" href="#2-安装软件包"></a> 2、安装软件包</h2><p>PL/SQL Developer软件的安装没有任何技术含量，下一步再下一步就可以了。</p><h1 id="三-配置oracle客户端环境"><a class="markdownIt-Anchor" href="#三-配置oracle客户端环境"></a> 三、配置Oracle客户端环境</h1><h2 id="1-配置数据库参数"><a class="markdownIt-Anchor" href="#1-配置数据库参数"></a> 1、配置数据库参数</h2><p>Oracle数据库客户端软件安装完成后，数据库参数配置文件（tnsnames.ora）是不存在的。</p><p>从（Oracle客户端软件的安装位置）\network\admin\sample目录中把nsnames.ora文件复制到（Oracle客户端软件的安装位置）\network\admin目录。</p><p><img src="https://img-blog.csdnimg.cn/20200310145135894.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310145335283.png" alt="在这里插入图片描述" /></p><p>用写字板或其它的文本编辑软件（必须以系统管理员身证运行）打开tnsnames.ora，输入数据库配置参数，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310145359421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>文本内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">snorcl11g_143 =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = <span class="number">122.152</span><span class="number">.209</span><span class="number">.143</span>)(PORT = <span class="number">1521</span>))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SID = snorcl11g)</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>以上的参数中，您只需要关心四个内容。</p><p>1）数据库名，或数据库服务名，或tnsname，这个名称由您自定义，如<code>snorcl11g_143</code></p><p>2）数据库服务器的ip地址，您的服务器ip是多少就填多少，如：<code>(HOST = 122.152.209.143)</code></p><p>3）数据库服务器监听的端口，缺省是1521，如：<code>(PORT = 1521)</code></p><p>4）数据库的SID，即ORACLE_SID，如：<code>(SID = snorcl11g)</code></p><h2 id="2-启动plsql-developer软件"><a class="markdownIt-Anchor" href="#2-启动plsql-developer软件"></a> 2、启动PL/SQL Developer软件</h2><p>输入登录数据库的用户名、密码和数据库名。</p><h2 id="在这里插入图片描述3-打开sql窗口"><a class="markdownIt-Anchor" href="#在这里插入图片描述3-打开sql窗口"></a> <img src="https://img-blog.csdnimg.cn/20200310145557934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />3、打开SQL窗口</h2><p><img src="https://img-blog.csdnimg.cn/20200310145610862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="4-执行sql语句"><a class="markdownIt-Anchor" href="#4-执行sql语句"></a> 4、执行SQL语句</h2><p><img src="https://img-blog.csdnimg.cn/2020031014562860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-最常用的objects窗口"><a class="markdownIt-Anchor" href="#5-最常用的objects窗口"></a> 5、最常用的Objects窗口</h2><p><img src="https://img-blog.csdnimg.cn/20200310145640402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="四-客户端环境变量"><a class="markdownIt-Anchor" href="#四-客户端环境变量"></a> 四、客户端环境变量</h1><h2 id="1-path环境变量"><a class="markdownIt-Anchor" href="#1-path环境变量"></a> 1、Path环境变量</h2><p>Oracle客户端软件安装完成后，会修改Windows系统变量的Path环境变量，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310145702206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-注册表"><a class="markdownIt-Anchor" href="#2-注册表"></a> 2、注册表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regedit.exe</span><br></pre></td></tr></table></figure><p>HKEY_LOCAL_MACHINE -&gt; SOFTWARE -&gt; ORACLE -&gt; KEY_OraClient11g_home1</p><p><img src="https://img-blog.csdnimg.cn/20200310145728965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-判断客户端是否能连上数据库"><a class="markdownIt-Anchor" href="#五-判断客户端是否能连上数据库"></a> 五、判断客户端是否能连上数据库</h1><h2 id="1-打开dos窗口"><a class="markdownIt-Anchor" href="#1-打开dos窗口"></a> 1、打开DOS窗口</h2><p><img src="https://img-blog.csdnimg.cn/2020031014574439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-判断数据库的监听端口"><a class="markdownIt-Anchor" href="#2-判断数据库的监听端口"></a> 2、判断数据库的监听端口</h2><p>telnet数据库服务器的1521端口。</p><p>如果成功，会出现一个空白窗口，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310145801960.png" alt="在这里插入图片描述" /></p><p>如果失败，会出现如下提示：</p><p><img src="https://img-blog.csdnimg.cn/20200310145820149.png" alt="在这里插入图片描述" /></p><p>如果telnet数据库的1521端口成功，表示网络和防火墙都没有问题。如果失败，有四种可能：1）Oracle数据库没有启动监听服务；2）Oracle数据库服务器的防火墙没有开通1521端口；3）云平台的安全组（或访问策略）没有开通1521端口；4）网络故障，网络不通。</p><h2 id="3-tnsping判断数据库客户端配置"><a class="markdownIt-Anchor" href="#3-tnsping判断数据库客户端配置"></a> 3、tnsping判断数据库客户端配置</h2><p><img src="https://img-blog.csdnimg.cn/20200310145842729.png" alt="在这里插入图片描述" /></p><p>以上成功的情况，如果出现其它内容，则表示tnsnames.ora文件中的配置不正确。但是，要注意一个问题，如果tnsname中的sid配置不正确，tnsping也是成功的，所以tnsping成功，并不表示客户端可以正常连接。</p><h2 id="4-windows下的sqlplus"><a class="markdownIt-Anchor" href="#4-windows下的sqlplus"></a> 4、Windows下的sqlplus</h2><p>Oracle的客户端软件自带sqlplus工具，也可以登录数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200310145902725.png" alt="在这里插入图片描述" /></p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle11g数据库快速安装</title>
      <link href="/posts/2b2262da.html"/>
      <url>/posts/2b2262da.html</url>
      
        <content type="html"><![CDATA[<p>关于Oracle数据库安装的文章网上到处都是，百度一下就能找到很多，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200310112336403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>能百度到的Oracle安装是常规的方法，我就不讲了，本文向大家介绍一种更简单的非常规的安装方法，这种方法适用于初学者。</p><h1 id="一-oracle安装存在的问题"><a class="markdownIt-Anchor" href="#一-oracle安装存在的问题"></a> 一、Oracle安装存在的问题</h1><p>Oracle数据库系统对服务器的硬件和软件要求比较严格，一般来说，用于Oracle生产环境的服务器配置非常好，内存在16GB以上，在图形界面中安装Oracle非常容易，极少失败。</p><p>但是，对初学者来说，学习资源有限，一般是在VMWare虚拟机上安装CentOS操作系统，或租用最低配置的云服务器（1核1G/2G内存），不可能有那么好的服务器来安装Oracle，也可能没有图形界面。在虚拟机或低配置的云服务器上安装Oracle问题很多，莫名其妙，根本找不到问题的原因和解决方法，困难重重，让人欲哭无泪。</p><h1 id="二-如何解决oracle安装的问题"><a class="markdownIt-Anchor" href="#二-如何解决oracle安装的问题"></a> 二、如何解决Oracle安装的问题</h1><p>解决虚拟机或低配置的云服务器上安装Oracle的方法有两种：</p><p>1）不用图形界面，采用静默方式安装，这种方法的技术难度比较大，Oracle的DBA经常采用这种方法，而普通程序员很难掌握。</p><p>2）把已经安装好的Oracle软件、数据库实例和环境参数打包压缩，然后在目标服务上解压恢复，对初学者来说，这是搭建Oracle数据库学习环境的最佳方案，也是本文采用的方案。</p><p><strong>在安装Oracle之前，您必须已经掌握了Linux的常用命令，具备Oracle数据库系统的基础知识。</strong></p><h1 id="三-获得oracle压缩包"><a class="markdownIt-Anchor" href="#三-获得oracle压缩包"></a> 三、获得Oracle压缩包</h1><p>登录C语言技术网，在“资源下载”栏目中下载软件安装包，文件名是oracle11gR2.tgz。</p><h1 id="四-软件需求"><a class="markdownIt-Anchor" href="#四-软件需求"></a> 四、软件需求</h1><p>建议采用CentOS7系列版本的操作系统，CentOS6和CentOS7在系统配置和操作上有较大差别，CentOS8以上版本对初学者来说没有必要。</p><p>建议先把CentOS7操作系统的字符集设置为zh_CN.gbk。</p><h1 id="五-硬件需求"><a class="markdownIt-Anchor" href="#五-硬件需求"></a> 五、硬件需求</h1><h2 id="1-查看内存和交换区的大小"><a class="markdownIt-Anchor" href="#1-查看内存和交换区的大小"></a> 1、查看内存和交换区的大小</h2><p>采用<code>free -m</code>命令查看系统的内存和交换区，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310112432223.png" alt="在这里插入图片描述" /></p><p><code>Mem:</code>行显示的是物理内存的大小和使用情况，<code>Swap:</code>行显示的是交换区的大小和使用情况，单位是MB。</p><p>安装Oracle的物理内存要求在1024MB以上，交换区的要求如下：</p><table><thead><tr><th>可用内存</th><th>交换区大小</th></tr></thead><tbody><tr><td>1024MB到2048MB之间。</td><td>1.5倍于物理内存。</td></tr><tr><td>2049MB到8192MB之间。</td><td>1倍于物理内存。</td></tr><tr><td>大于8192MB。</td><td>0.75倍于物理内存。</td></tr></tbody></table><h2 id="2-创建交换区"><a class="markdownIt-Anchor" href="#2-创建交换区"></a> 2、创建交换区</h2><p>如果没有交换区或交换区太小，先创建交换区，交换区的大小见上表的对应关系，以下步骤将创建一个2048M的交换区。</p><p>1）用root用户执行dd命令创建/swap1文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/swap1 bs=<span class="number">1024</span> count=<span class="number">2048000</span></span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310112541735.png" alt="在这里插入图片描述" /></p><p>2）把/swap1文件设置成交换区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/mkswap /swap1</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310112616800.png" alt="在这里插入图片描述" /></p><p>3）把/swap1交换区设置为有效状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/swapon /swap1</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310121957730.png" alt="在这里插入图片描述" /></p><p>4）用<code>free -m</code>命令查看交换区，确认已生效。</p><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310122017555.png" alt="在这里插入图片描述" /></p><p>5）修改/etc/fstab文件，让CentOS操作系统在每次重启时自动加载/swap1交换区。</p><p>在/etc/fstab文件中增加以下内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swap1 swap swap defaults <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310122044518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>6）重启操作系统，重启后再确认一下交换区/swap1是否已加载。</p><h2 id="3-删除交换区"><a class="markdownIt-Anchor" href="#3-删除交换区"></a> 3、删除交换区</h2><p>如果创建的交换区不符合要求，可以用以下步骤删除它。</p><p>1）停止正在使用的swap分区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff /swap1</span><br></pre></td></tr></table></figure><p>2）删除swap分区文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /swap1</span><br></pre></td></tr></table></figure><p>3）修改/etc/fstab文件，删除开机自动挂载/swap1的命令。</p><h1 id="六-安装对应的依赖包"><a class="markdownIt-Anchor" href="#六-安装对应的依赖包"></a> 六、安装对应的依赖包</h1><p>安装Oracle之前，还需要安装一些CentOS的软件包，用以下命令执行安装（用root用户执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y binutils* compat-libstdc* elfutils-libelf* gcc* glibc* ksh* libaio* libgcc* libstdc* make* sysstat* libXp*  glibc-kernheaders ksh binutils compat-libstdc++<span class="number">-33</span> elfutils-libelf elfutils-libelf-devel gcc gcc-c++ glibc glibc-common glibc-devel libaio libaio-devel libgcc libstdc++ libstdc++-devel make numactl sysstat libXp unixODBC unixODBC-devel</span><br></pre></td></tr></table></figure><p>这些软件包依赖关系比较复杂，不管它，多执行几次以上命令，直到全部的软件包都是最新版本。</p><h1 id="七-修改系统核心参数"><a class="markdownIt-Anchor" href="#七-修改系统核心参数"></a> 七、修改系统核心参数</h1><h2 id="1-修改etcsysctlconf文件"><a class="markdownIt-Anchor" href="#1-修改etcsysctlconf文件"></a> 1、修改/etc/sysctl.conf文件</h2><p>/etc/sysctl.conf是操作系统的核心参数配置文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max = <span class="number">6815744</span></span><br><span class="line">fs.aio-max-nr = <span class="number">1048576</span></span><br><span class="line">kernel.shmall = <span class="number">2097152</span></span><br><span class="line">kernel.shmmax= <span class="number">2147483648</span></span><br><span class="line">kernel.shmmni= <span class="number">4096</span></span><br><span class="line">kernel.sem = <span class="number">250</span> <span class="number">32000100</span> <span class="number">128</span></span><br><span class="line">net.ipv4.ip_local_port_range= <span class="number">9000</span> <span class="number">65500</span></span><br><span class="line">net.core.rmem_default= <span class="number">262144</span></span><br><span class="line">net.core.rmem_max= <span class="number">4194304</span></span><br><span class="line">net.core.wmem_default = <span class="number">262144</span></span><br><span class="line">net.core.wmem_max= <span class="number">1048576</span></span><br></pre></td></tr></table></figure><p>注意，kernel.shmmax参数的值为操作系统内存的一半，单位是字节。例如，操作系统总内存如果是1024MB，那么kernel.shmmax的值应该是512*1024*1024=536870912，即kernel.shmmax=536870912</p><p>其它的参数照抄。</p><h2 id="2-修改etcsecuritylimitsconf文件"><a class="markdownIt-Anchor" href="#2-修改etcsecuritylimitsconf文件"></a> 2、 修改/etc/security/limits.conf文件</h2><p>/etc/security/limits.conf是操作系统对用户使用资源的配置文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oracle           soft    nproc     <span class="number">2047</span></span><br><span class="line">oracle           hard    nproc    <span class="number">16384</span></span><br><span class="line">oracle           soft    nofile    <span class="number">1024</span></span><br><span class="line">oracle           hard    nofile   <span class="number">65536</span></span><br><span class="line">oracle           hard    stack    <span class="number">10240</span></span><br></pre></td></tr></table></figure><h2 id="3-修改etcpamdlogin文件"><a class="markdownIt-Anchor" href="#3-修改etcpamdlogin文件"></a> 3、 修改/etc/pam.d/login文件</h2><p>/etc/pam.d/login是用户认证文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session    required     /lib64/security/pam_limits.so</span><br></pre></td></tr></table></figure><h2 id="4-修改etcprofile文件"><a class="markdownIt-Anchor" href="#4-修改etcprofile文件"></a> 4、 修改/etc/profile文件</h2><p>/etc/profile是系统环境参数配置文件，在文件最后增加以下行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $USER = <span class="string">&quot;oracle&quot;</span> ]; then</span><br><span class="line">        <span class="keyword">if</span> [ $SHELL = <span class="string">&quot;/bin/ksh&quot;</span> ]; then</span><br><span class="line">              ulimit -p <span class="number">16384</span></span><br><span class="line">              ulimit -n <span class="number">65536</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">              ulimit -u <span class="number">16384</span> -n <span class="number">65536</span></span><br><span class="line">        fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="5-修改etcselinuxconfig文件"><a class="markdownIt-Anchor" href="#5-修改etcselinuxconfig文件"></a> 5、 修改/etc/selinux/config文件</h2><p>/etc/selinux/config是SELinux配置文件，修改SELINUX的值，禁用它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><h2 id="6-重启服务器"><a class="markdownIt-Anchor" href="#6-重启服务器"></a> 6、重启服务器</h2><p><code>init 6</code> 或 <code>reboot</code></p><h1 id="八-创建oracle用户和组"><a class="markdownIt-Anchor" href="#八-创建oracle用户和组"></a> 八、创建Oracle用户和组</h1><p>Oracle的安装用户是oracle，组是dba，oracle用户的根目录是/oracle，不能采用其它目录（注意是小写的字母），如果/oracle目录的空间不够，可以采用软链接的方式，把有/oracle链接到其它有足够空间的目录。</p><p>1）创建dba组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd dba</span><br></pre></td></tr></table></figure><p>2）创建oracle用户，组名是dba，用户根目录是/oracle，不可改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -n oracle -g dba -d /oracle</span><br></pre></td></tr></table></figure><p>3）修改oracle用户的密码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd oracle</span><br></pre></td></tr></table></figure><h1 id="九-解开压缩包"><a class="markdownIt-Anchor" href="#九-解开压缩包"></a> 九、解开压缩包</h1><p>把Oracle的压缩包文件oracle11gR2.tgz上传到服务器的/tmp目录。</p><p>采用<code>su - oracle</code>切换到oracle用户，在根目录下执行解开压缩包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su - oracle</span><br><span class="line">cd /</span><br><span class="line">tar zxvf /tmp/oracle11gR2.tgz</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p><strong>注意，解压缩包后，一定要退出oracle用户，否则oracle用户的环境变量不会生效。</strong></p><h1 id="十-数据库的参数"><a class="markdownIt-Anchor" href="#十-数据库的参数"></a> 十、数据库的参数</h1><p>oracle11gR2.tgz解压后，会生成/oracle/.bash_profile文件，包括了Oracle数据库的安装参数，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ORACLE_BASE=/oracle/base</span><br><span class="line"><span class="keyword">export</span> ORACLE_HOME=/oracle/home</span><br><span class="line"><span class="keyword">export</span> ORACLE_SID=snorcl11g</span><br><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/lib</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin:.</span><br></pre></td></tr></table></figure><h1 id="十一-数据库的启动"><a class="markdownIt-Anchor" href="#十一-数据库的启动"></a> 十一、数据库的启动</h1><p>用oracle用户登录，执行<code>lsnrctl start</code>启动网络监听服务，执行<code>dbstart</code>启动数据库系统。</p><p><img src="https://img-blog.csdnimg.cn/20200310125054387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310125103846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="十二-数据库的关闭"><a class="markdownIt-Anchor" href="#十二-数据库的关闭"></a> 十二、数据库的关闭</h1><p>用oracle用户登录，执行<code>lsnrctl stop</code>关闭网络监听服务，执行<code>dbshut</code>关闭数据库系统。</p><p><strong>在重启或关闭服务器操作系统之前，一定要关闭数据库，否则数据库损坏的概率非常大。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200310125138444.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310125146429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="十三-采用sqlplus登录数据库"><a class="markdownIt-Anchor" href="#十三-采用sqlplus登录数据库"></a> 十三、采用sqlplus登录数据库</h1><p>用oracle用户登录CentOS系统。</p><p>执行<code>sqlplus scott/tiger</code>，以scott用户的身份登录数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200310125223438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>在sqlplus中，输入<code>exit</code>;退出sqlplus。</p><p>在Shell中，执行<code>sqlplus / as sysdba</code>以系统管理员身份登录数据库。</p><p><img src="https://img-blog.csdnimg.cn/20200310125257850.png" alt="在这里插入图片描述" /></p><h1 id="十四-查询数据库的版本"><a class="markdownIt-Anchor" href="#十四-查询数据库的版本"></a> 十四、查询数据库的版本</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from v$version;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200310125330225.png" alt="在这里插入图片描述" /></p><h1 id="十五-服务器防火墙配置"><a class="markdownIt-Anchor" href="#十五-服务器防火墙配置"></a> 十五、服务器防火墙配置</h1><p>Oracle数据库缺省的通信端口是1521，如果想从远程连接Oracle数据库，需要开通服务器防火墙的1521端口。</p><p>CentOS7和CentOS6的防火墙设置不同，CentOS7采用以下命令开通1521端口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">1521</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>以下是CentOS7防火墙的相关操作命令。</p><h2 id="1-查看防火墙的命令"><a class="markdownIt-Anchor" href="#1-查看防火墙的命令"></a> 1、查看防火墙的命令</h2><p>1）查看防火墙的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --version</span><br></pre></td></tr></table></figure><p>2）查看firewall的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>3）查看firewall服务状态（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>4）查看防火墙全部的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>5）查看防火墙已开通的端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-port</span><br></pre></td></tr></table></figure><p>6）查看防火墙已开通的服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-service</span><br></pre></td></tr></table></figure><p>7）查看全部的服务列表（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><p>8）查看防火墙服务是否开机启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled firewalld</span><br></pre></td></tr></table></figure><h2 id="2-配置防火墙的命令"><a class="markdownIt-Anchor" href="#2-配置防火墙的命令"></a> 2、配置防火墙的命令</h2><p>1）启动、重启、关闭防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#启动</span><br><span class="line">systemctl start firewalld</span><br><span class="line">#重启</span><br><span class="line">systemctl restart firewalld</span><br><span class="line">#关闭</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>2）开放、移去1521端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放<span class="number">1521</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">1521</span>/tcp --permanent</span><br><span class="line">#移去<span class="number">1521</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-port=<span class="number">1521</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>4）设置开机时启用、禁用防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启用服务</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">#禁用服务</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h1 id="十六-云平台访问策略配置"><a class="markdownIt-Anchor" href="#十六-云平台访问策略配置"></a> 十六、云平台访问策略配置</h1><p>如果Oracle数据库安装在云服务器上，需要登录云服务器提供商的管理平台开通访问策略（或安全组），开通1521端口的访问策略。</p><p>不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。</p><h1 id="十七-版权声明"><a class="markdownIt-Anchor" href="#十七-版权声明"></a> 十七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库介绍</title>
      <link href="/posts/adfcc7f1.html"/>
      <url>/posts/adfcc7f1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-oracle数据库"><a class="markdownIt-Anchor" href="#一-oracle数据库"></a> 一、Oracle数据库</h1><p>Oracle Database，又名Oracle RDBMS，简称Oracle数据库。</p><p>Oracle数据库系统是美国Oracle公司（甲骨文）提供的以分布式数据库为核心的一系列软件产品，是目前世界上使用最为广泛的数据库管理系统，具备完整的数据管理功能，真正实现了分布式处理功能。</p><p>Oracle数据库最新版本为Oracle Database 19c。Oracle数据库12c 引入了一个新的多承租方架构，使用该架构可轻松部署和管理数据库云。此外，一些新特性可最大限度地提高资源使用率和灵活性，这些独一无二的技术进步再加上在可用性、安全性和大数据支持方面的增强，使得Oracle数据库12c 成为私有云和公有云部署的理想平台。</p><h1 id="二-支持平台"><a class="markdownIt-Anchor" href="#二-支持平台"></a> 二、支持平台</h1><p>在2001年发布的Oracle9i之前，甲骨文公司把他们的数据库产品广泛的移植到了不同的平台上，支持各种主流的操作系统。近期，甲骨文公司巩固了少部分的操作系统平台。</p><h1 id="三-oracle数据库的特点"><a class="markdownIt-Anchor" href="#三-oracle数据库的特点"></a> 三、Oracle数据库的特点</h1><p>该用什么词语来描述Oracle的特点呢？高可用？高稳定？最高安全级别？性能卓越？无与伦比？我认为，这些形容词不足以表达Oracle数据库的的特点，它的强大超出您的想象。</p><p>既然说不清楚Oracle数据库的优点，那就说说它的缺点吧，Oracle的缺点很好找：</p><p>1）贵、价格很贵。</p><p>2）贵，很高贵，连Oracle的安装也是一个技术活，对于习惯“下一步”的初学者还说，Oracle的安装实在太麻烦，不过这一点有所改善，在Oracle 18c中，已经支持rpm一键安装了。</p><p>3）Oracle提供的OCI函数库极其强大，但是难以驾驭，近年来，Oracle公司提供了一些帮助文档和示例代码，网上也有一些非常棒的开源库。</p><h1 id="四-与其它数据库的比较"><a class="markdownIt-Anchor" href="#四-与其它数据库的比较"></a> 四、与其它数据库的比较</h1><p>其它的数据库产品，如Sybase、SQL Server、MySQL等与Oracle根本不是同一级别的软件产品，没有可比性。如果一定要比较，其它的数据库像拖拉机或皮卡，Oracle是重卡。</p><h1 id="五-就业前景"><a class="markdownIt-Anchor" href="#五-就业前景"></a> 五、就业前景</h1><p>没有搞过Oracle数据库的程序员不好意思说自己熟悉数据库，熟悉Oracle数据库的程序员可以认为经历过了项目的毒打。</p><h1 id="六-初学者的误区"><a class="markdownIt-Anchor" href="#六-初学者的误区"></a> 六、初学者的误区</h1><p>1）2019年9月DB-Engines的数据库流行度排行榜如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310111425160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2）2019年12月前程无忧发布的招聘职位中，分别以Oracle、MySQL和 SQL Server 为关键字搜索，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200310111440865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/202003101114586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200310111509212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>从DB-Engines的数据库流行度排行榜和前程无忧招聘的数据上看，MySQL的受欢迎程度和职位数似乎与Oracle不相上下，那么MySQL和Oracle真的有可比性吗？<br />这里说说我的一些观点。</p><p>1）Oracle是收费的（企业版售价约20-30万人民币），MySQL是免费的，举个例子，比如去市场买菜，有免费的猪肉和收费的猪肉，如果最终选择免费猪肉和收费猪肉的顾客人数相当，那么您还会认为这两种猪肉的品质相当吗？</p><p>2）Oracle数据库的运行环境难以搭建，Oracle的安装就是一个技术活，对开发者的技术门槛也比较高，以C/C<ins>程序员为例，Oracle提供了OCI函数库，但是，如果不采用第三方的开源软件，能熟练运用OCI函数库的C/C</ins>程序员如凤毛麟角。</p><p>3）在某些国企和政府部门，提倡采用免费的数据库产品，这是非常草率的决定，最后的结局往往是：a）免费的数据库产品无法满足应用的需求；b）免费的数据库在可用性和可维护性方面比较差，需要更多技术人员的投入，增加的人力成本远远超过购买Oracle数据库软件的费用。</p><p>4）Oracle是收费的，很贵，但是贵有贵的道理，便宜不是那么好捡的。</p><p>5）顺便提一下，MySQL已经被Oracle公司收购，Oracle想把MySQL怎么样就怎么样，MySQL的前景有一百万个可能，唯一不可能的是希望Oracle会对MySQL有任何的提升。</p><p>6）我们的目标是成为职业的程序员，学习最有竞争力的软件产品和技术是明智的选择。</p><p>7）SQL Server一直是个边缘化的产品。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7配置rsync实现文件同步</title>
      <link href="/posts/40b4a6a3.html"/>
      <url>/posts/40b4a6a3.html</url>
      
        <content type="html"><![CDATA[<p>rsync（remote synchronize ）是一个远程文件同步工具，支持多个操作系统，用于在多台服务器之间同步目录和文件。rsync采用增量传输文件的方法，只传输新文件和修改过的文件，而不是每次都全部传输，效率比较高。</p><p>rsync有以下特点：</p><p>1）支持目录和文件的上传和下载功能；</p><p>2）可以镜像保存整个目录树和文件系统；</p><p>3）传输效率高，只传输新增和修改过的文件。</p><h1 id="一-安装软件包"><a class="markdownIt-Anchor" href="#一-安装软件包"></a> 一、安装软件包</h1><p>rsync的客户端和服务器软件的安装包都是rsync。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install rsync</span><br></pre></td></tr></table></figure><h1 id="二-修改系统配置"><a class="markdownIt-Anchor" href="#二-修改系统配置"></a> 二、修改系统配置</h1><h2 id="1-关闭selinux"><a class="markdownIt-Anchor" href="#1-关闭selinux"></a> 1、关闭SELINUX</h2><p>修改/etc/selinux/config文件，把SELINUX参数的值改为disabled。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX =disabled</span><br></pre></td></tr></table></figure><p>重启linux系统或执行 setenforce 0 使修改马上生效。</p><h2 id="2-开通防火墙端口"><a class="markdownIt-Anchor" href="#2-开通防火墙端口"></a> 2、开通防火墙端口</h2><p>rsync缺省的端口是873，您可以修改配置文件中的端口。</p><p>1）防火墙开通873端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">873</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>2）重启防火墙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="3-启用rsyncd服务"><a class="markdownIt-Anchor" href="#3-启用rsyncd服务"></a> 3、启用rsyncd服务</h2><p>rsync的服务名是rsyncd。</p><p>1）启动rsyncd服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rsyncd</span><br></pre></td></tr></table></figure><p>2）把rsyncd服务设置为开机自启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rsyncd</span><br></pre></td></tr></table></figure><h1 id="三-配置rsync"><a class="markdownIt-Anchor" href="#三-配置rsync"></a> 三、配置rsync</h1><p>接下来我用示例来显示文件同步的配置和使用，需求如下：</p><p>1）我只用一台服务器来测试，IP地址是192.168.1.129，既是服务器，也是客户端；</p><p>2）服务端的目录是/tmp/docs；</p><p>3）我将创建两个客户端用户：client1和client2；</p><p>4）客户端client1的目录是/tmp/docs1；</p><p>5）客户端client2的目录是/tmp/docs2；</p><p>6）客户端client1把/tmp/docs1目录中的文件发送给服务端；</p><p>7）客户端client2从服务端下载文件，存放在/tmp/docs2目录中。</p><p>rsync的服务器和客户端，这是一个逻辑的概念，并不是物理的，如果您有三个服务器，就可以用三台服务器来测试，原理是一样的。</p><h2 id="1-创建操作系统用户"><a class="markdownIt-Anchor" href="#1-创建操作系统用户"></a> 1、创建操作系统用户</h2><p>操作系统用户可以是普通的用户，也可以是简单的、无需登录的、没有HOME目录的用户，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin rsync -g bin  # 创建rsync用户，指定组为bin（其它组也行）。</span><br></pre></td></tr></table></figure><p>注意，这个用户是在服务器上创建的，不是客户端。</p><h2 id="2-创建测试目录和文件"><a class="markdownIt-Anchor" href="#2-创建测试目录和文件"></a> 2、创建测试目录和文件</h2><p>执行以下脚本，创建/tmp/docs目录，生成测试和文件，并指定用户和组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/docs /tmp/docs1 /tmp/docs2  # 删除测试目录。</span><br><span class="line">mkdir /tmp/docs /tmp/docs1 /tmp/docs2  # 创建三个测试目录。</span><br><span class="line">ls /usr &gt; /tmp/docs1/usr.txt  # 把ls /usr的结果输出到/tmp/docs1/usr.txt文件。</span><br><span class="line">ls /etc &gt; /tmp/docs1/etc.txt  # 把ls /etc的结果输出到/tmp/docs1/etc.txt文件。</span><br><span class="line">chown -R rsync:rsync /tmp/docs # 修改/tmp/docs目录及文件用户和组。</span><br></pre></td></tr></table></figure><h2 id="3-创建rsnyc登录用户密码文件"><a class="markdownIt-Anchor" href="#3-创建rsnyc登录用户密码文件"></a> 3、创建rsnyc登录用户密码文件</h2><p>在rsync服务器上创建登录用户/密码文件/etc/rsyncd.passwd，用于客户端的身份认证，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client1:pwd1</span><br><span class="line">client2:pwd2</span><br></pre></td></tr></table></figure><p>以上文件包括了两个用户（用户名/密码分别是client/pwd1和client2/pwd2）。</p><p><strong>把/etc/rsyncd.passwd文件的权限设置为600，如果不这么做，客户端登录会失败。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">600</span> /etc/rsync.passwd</span><br></pre></td></tr></table></figure><h2 id="4-配置rsync服务器参数"><a class="markdownIt-Anchor" href="#4-配置rsync服务器参数"></a> 4、配置rsync服务器参数</h2><p>rsync服务器的配置文件是/etc/rsyncd.conf，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># /etc/rsyncd: configuration file <span class="keyword">for</span> rsync daemon mode</span><br><span class="line"># See rsyncd.conf man page <span class="keyword">for</span> more options.</span><br><span class="line"></span><br><span class="line"><span class="meta"># rsyncd全局参数。</span></span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line">port = <span class="number">873</span></span><br><span class="line">fake super = yes</span><br><span class="line">use chroot = no</span><br><span class="line">max connections = <span class="number">200</span></span><br><span class="line">timeout = <span class="number">600</span></span><br><span class="line">ignore errors</span><br><span class="line">read only = <span class="literal">false</span></span><br><span class="line">list = <span class="literal">false</span></span><br><span class="line">auth users = client1,client2</span><br><span class="line">secrets file = /etc/rsync.passwd</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line"># 同步模块配置。</span><br><span class="line">[docs]</span><br><span class="line">comment = welcome to docs!</span><br><span class="line">path = /tmp/docs</span><br></pre></td></tr></table></figure><p><strong>注意，不要在参数后面加#和说明文字，是非法的。</strong></p><p>全局参数说明：</p><p>1）uid = rsync，rsync服务端操作系统的用户，即上面第1点中创建的操作系统用户，您可以创建新的操作系统用户，也可以用现有的用户。</p><p>2）gid = rsync，rsync服务端操作系统的用户的组，即uid用户的组。</p><p>3）port = 873，用于通信的TCP端口，缺省是873。</p><p>4）fake super = yes，rsync服务端操作系统的用户可以不用root。</p><p>5）use chroot = no，关闭假根功能。</p><p>6）max connections = 200，客户端最大连接数。</p><p>7）timeout = 600，超时时间。</p><p>8）ignore errors，忽略错误信息。</p><p>9）read only = false，是否为只读方式。</p><p>10）list = false，不允许查看模块信息。</p><p>11）auth users = client1,client2，指定允许登录的客户端认证用户清单，用逗号分隔，必须是/etc/rsync.passwd文件中配置的用户。</p><p>12）secrets file = /etc/rsync.passwd，定义rsync客户端用户认证的密码文件。</p><p>13）log file = /var/log/rsyncd.log，rsync服务运行日志文件，注意，日志文件日积月累，必须保证有足够的磁盘空间。</p><p>同步参数说明：</p><p>1）[docs]，模块名称，自定义的名称，不一定要与同步目录相同。</p><p>2）comment = welcome to docs!，模块说明文字。</p><p>3）path = /tmp/docs，同步的目录名，必须是uid参数指定的用户和gid参数指定的组。</p><h2 id="5-把客户端的文件同步上传到服务器"><a class="markdownIt-Anchor" href="#5-把客户端的文件同步上传到服务器"></a> 5、把客户端的文件同步上传到服务器</h2><p>1）采用client1用户，把客户端/tmp/docs1目录下的文件同步到服务器，命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /tmp/docs1<span class="comment">/* client1@192.168.1.129::docs</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200401195721644.png" alt="在这里插入图片描述" /></p><p>2）检查服务端的/tmp/docs目录和客户端的/tmp/docs目录下的文件是否相同。</p><p>3）再生成一些测试文件：创建/tmp/docs1/aaa/tmp.txt文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/docs1/aaa</span><br><span class="line">ls /tmp &gt; /tmp/docs1/aaa/tmp.txt</span><br></pre></td></tr></table></figure><p>4）再执行一次同步。<br /><img src="https://img-blog.csdnimg.cn/20200401195805550.png" alt="在这里插入图片描述" /></p><h2 id="6-从服务器同步下载文件到客户端"><a class="markdownIt-Anchor" href="#6-从服务器同步下载文件到客户端"></a> 6、从服务器同步下载文件到客户端</h2><p>1）采用client2用户，把服务器的文件下载到客户端/tmp/docs2目录命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz client2@<span class="number">192.168</span><span class="number">.1</span><span class="number">.129</span>::docs /tmp/docs2</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200401195835906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1Y3oxMjIxNDA3Mjk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意，我用client1用户上传文件，用client2下载文件，其目的是为了演示多个客户端帐号的配置和使用方法，您也可以只用一个帐号上传和下载文件。</p><h2 id="7-客户端的密码配置"><a class="markdownIt-Anchor" href="#7-客户端的密码配置"></a> 7、客户端的密码配置</h2><p>以上演示客户端同步文件的时候，需要手工的输入密码，但是在实际应用中，命令可能在后台运行，不希望手工输入密码，这个需求有两种解决方法：</p><p>1）设置客户端的密码文件。</p><p>例如client1用户，密码文件是/etc/client1.passwd，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo pwd1 &gt; /etc/client1.passwd</span><br><span class="line">chmod <span class="number">600</span> /etc/client1.passwd</span><br></pre></td></tr></table></figure><p><strong>注意，客户端的密码文件权限一定要是600，否则认证会失败。</strong></p><p>同步上传的命令如下：<br />rsync -avz /tmp/docs1/* <a href="mailto:client1@192.168.1.129">client1@192.168.1.129</a>::docs --password-file=/etc/client1.passwd</p><p>2）设置客户端的密码环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> RSYNC_PASSWORD=pwd1</span><br></pre></td></tr></table></figure><p>同步上传的命令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /tmp/docs1<span class="comment">/* client1@192.168.1.129::docs</span></span><br></pre></td></tr></table></figure><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><h2 id="1-小心有坑"><a class="markdownIt-Anchor" href="#1-小心有坑"></a> 1、小心有坑</h2><p>rsrync的配置有两个坑：1）配置文件/etc/rsyncd.conf中，参数后面不要用#注释；2）服务端和客户端密码文件的权限一定要是600，否则认证失败。</p><h2 id="2-客户端权限问题"><a class="markdownIt-Anchor" href="#2-客户端权限问题"></a> 2、客户端权限问题</h2><p>客户端可以用任何用户来执行，只要该用户对本地目录有足够的权限就可以了。</p><h2 id="3-日志文件的问题"><a class="markdownIt-Anchor" href="#3-日志文件的问题"></a> 3、日志文件的问题</h2><p>小心服务端的日志文件（log file）越积越大。</p><h2 id="4-效率问题"><a class="markdownIt-Anchor" href="#4-效率问题"></a> 4、效率问题</h2><p>rsync同步文件采用的是增量同步的方法，本质上就是在传输文件之前，先判断客户端与服务器目录的文件变量情况，如果待同步目录下的文件太多，这个判断很费时间。</p><h2 id="5-rsyncsersync架构"><a class="markdownIt-Anchor" href="#5-rsyncsersync架构"></a> 5、rsync+sersync架构</h2><p>上面提到的rsync存在效率问题，最终的解决方法是采用rsync+sersync架构。</p><p>1）sersync可以记录被监听目录中发生变化的（增，删，改）具体某个文件或目录的名字；</p><p>2）rsync在同步时，只同步发生变化的文件或目录（每次发生变化的数据相对整个同步目录数据来说很小，rsync在遍历查找对比文件时，速度很快），因此效率很高。</p><p>rsync+sersync架构在本文就不介绍了，各位真的有需求时再研究它。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7配置samba共享文件系统</title>
      <link href="/posts/2dc95266.html"/>
      <url>/posts/2dc95266.html</url>
      
        <content type="html"><![CDATA[<p>我们知道Windows系统之间可以共享文件系统和打印机，Linux系统采用Samba来实现共享文件系统和打印机的功能。通过SMB协议，Windows和Linux系统之间的文件系统和打印机可以互相访问。</p><p>SMB（Server Messages Block）协议是一种在局域网上共享文件系统和打印机的TCP应用层协议，它为局域网内的不同计算机之间提供文件系统和打印机的共享服务。SMB协议是客户/服务器型，Samba是在Linux系统上实现SMB协议的一个免费软件。</p><h1 id="一-安装软件包"><a class="markdownIt-Anchor" href="#一-安装软件包"></a> 一、安装软件包</h1><p>Samba涉及到四个软件包，有些功能您可能用不上，但是安装了也不会有问题。</p><p>1）samba：Samba服务器。</p><p>2）samba-client：Samba客户端。</p><p>3）samba-common：Samba服务器和客户端相关的软件。</p><p>4）cifs-utils：通用的Internet文件系统实用程序，支持与Windows、OS X和其他Unix系统进行跨平台文件共享。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install samba samba-client samba-common cifs-utils</span><br></pre></td></tr></table></figure><h1 id="二-修改系统配置"><a class="markdownIt-Anchor" href="#二-修改系统配置"></a> 二、修改系统配置</h1><h2 id="1-关闭selinux"><a class="markdownIt-Anchor" href="#1-关闭selinux"></a> 1、关闭SELINUX</h2><p>修改/etc/selinux/config文件，把SELINUX参数的值改为disabled。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX =disabled</span><br></pre></td></tr></table></figure><p>重启linux系统或执行 setenforce 0 使修改马上生效。</p><h2 id="2-开通防火墙端口"><a class="markdownIt-Anchor" href="#2-开通防火墙端口"></a> 2、开通防火墙端口</h2><p>Samba 涉及到以四个端口：UDP 137、UDP 138、TCP 139、TCP 445。</p><p>1）防火墙开通samba服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-service=samba --permanent</span><br></pre></td></tr></table></figure><p>2）重启防火墙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="3-启用smb服务"><a class="markdownIt-Anchor" href="#3-启用smb服务"></a> 3、启用smb服务</h2><p>Samba的服务名是smb。</p><p>1）启动smb服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start smb</span><br></pre></td></tr></table></figure><p>2）把smb服务设置为开机自启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable smb</span><br></pre></td></tr></table></figure><h1 id="三-samba服务的参数文件"><a class="markdownIt-Anchor" href="#三-samba服务的参数文件"></a> 三、Samba服务的参数文件</h1><p>Samba服务的参数文件是/etc/samba/smb.conf，在CentOS7版本的系统中，该文件的原始内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># See smb.conf.example <span class="keyword">for</span> a more detailed config file <span class="keyword">or</span></span><br><span class="line"><span class="meta"># read the smb.conf manpage.</span></span><br><span class="line"># Run <span class="string">&#x27;testparm&#x27;</span> to verify the config is correct after</span><br><span class="line"><span class="meta"># you modified it.</span></span><br><span class="line">[global]</span><br><span class="line">        workgroup = SAMBA</span><br><span class="line">        security = user</span><br><span class="line">        passdb backend = tdbsam</span><br><span class="line">        printing = cups</span><br><span class="line">        printcap name = cups</span><br><span class="line">        load printers = yes</span><br><span class="line">        cups options = raw</span><br><span class="line">[homes]</span><br><span class="line">        comment = Home Directories</span><br><span class="line">        valid users = %S, %D%w%S</span><br><span class="line">        browseable = No</span><br><span class="line">        read only = No</span><br><span class="line">        inherit acls = Yes</span><br><span class="line">[printers]</span><br><span class="line">        comment = All Printers</span><br><span class="line">        path = /var/tmp</span><br><span class="line">        printable = Yes</span><br><span class="line">        create mask = <span class="number">0600</span></span><br><span class="line">        browseable = No</span><br><span class="line">[print$]</span><br><span class="line">        comment = Printer Drivers</span><br><span class="line">        path = /var/lib/samba/drivers</span><br><span class="line">        write list = @printadmin root</span><br><span class="line">        force group = @printadmin</span><br><span class="line">        create mask = <span class="number">0664</span></span><br><span class="line">        directory mask = <span class="number">0775</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[global]组是全局参数，根据不同的需求，我们会修改部分参数。</p><p>[homes]组是用户主目录参数，我们不关心它。</p><p>[printers]和[print$]组是共享打印机参数，我们不关心它。</p><p>testparm命令可以测试smb.conf配置是否正确。</p><p>testparm -v命令可以详细的列出smb.conf支持的配置参数。</p><p>smb.conf文件的配置比较麻烦，网上有很多资料，但大部分不准确。我先不介绍smb.conf文件中参数的含义，我用实际应用的场景来介绍它的配置。</p><p><strong>共享文件系统的应用场景主要有两种：</strong></p><p><strong>1）匿名方式：不需要输入用户名和密码，任何人都可以访问共享文件系统；</strong></p><p><strong>2）用户名/密码方式：需要用户名和密码成功登录后才可以访问共享文件系统。</strong></p><h1 id="四-配置任何人都可以访问的共享文件系统"><a class="markdownIt-Anchor" href="#四-配置任何人都可以访问的共享文件系统"></a> 四、配置任何人都可以访问的共享文件系统</h1><p>例如您想把服务器/tmp/docs目录共享出来。</p><h2 id="1-创建测试目录和文件"><a class="markdownIt-Anchor" href="#1-创建测试目录和文件"></a> 1、创建测试目录和文件</h2><p>执行以下脚本，创建/tmp/docs目录，生成测试和文件，并指定用户和组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/docs  # 创建/tmp/docs目录。</span><br><span class="line">ls /usr &gt; /tmp/docs/usr.txt  # 把ls /usr的结果输出到/tmp/docs/usr.txt文件。</span><br><span class="line">ls /etc &gt; /tmp/docs/etc.txt  # 把ls /etc的结果输出到/tmp/docs/etc.txt文件。</span><br><span class="line">chown -R nobody:nobody /tmp/docs # 修改/tmp/docs目录及文件用户和组。</span><br></pre></td></tr></table></figure><h2 id="2-配置etcsambasmbconf文件"><a class="markdownIt-Anchor" href="#2-配置etcsambasmbconf文件"></a> 2、配置/etc/samba/smb.conf文件</h2><p>在[global]组中增加以下行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map to guest = Bad User</span><br></pre></td></tr></table></figure><p>在文件最后增加以下行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[docs]</span><br><span class="line">comment = Fully shared directory</span><br><span class="line">path = /tmp/docs</span><br><span class="line"><span class="keyword">public</span> = yes</span><br><span class="line">read only = no</span><br></pre></td></tr></table></figure><p>[docs]为待共享的文件系统起个名称，不要求与目录名相同，在windows下将看到这个名称。</p><p>comment参数是说明文字。</p><p>path是待共享的Linux目录。</p><p>public指定guest用户可以访问。</p><p>read only是否为只读，yes或no。</p><p>完整的/etc/samba/smb.conf文件的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">workgroup = SAMBA</span><br><span class="line">security = user</span><br><span class="line">map to guest = Bad User</span><br><span class="line"></span><br><span class="line">[docs]</span><br><span class="line">comment = Fully shared <span class="built_in">docs</span>(read/write)</span><br><span class="line">path = /tmp/docs</span><br><span class="line"><span class="keyword">public</span> = yes</span><br><span class="line">read only = no</span><br></pre></td></tr></table></figure><p>和打印机相关的参数我删除掉了，留着也没用。</p><h2 id="3-重启samba服务验证结果"><a class="markdownIt-Anchor" href="#3-重启samba服务验证结果"></a> 3、重启samba服务，验证结果</h2><p>每次修改/etc/samba/smb.conf文件后，要重启smb服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart smb</span><br></pre></td></tr></table></figure><p>在windows上的我的电脑中，输入\\服务器IP，不需要输入服户名和密码就可以访问Linux共享文件系统，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200331113054113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>您可以修改docs目录中的文件，也可以创建新的目录和文件。</p><h2 id="4-注意事项"><a class="markdownIt-Anchor" href="#4-注意事项"></a> 4、注意事项</h2><p>1）security参数要用user，不能用share，share已不支持；</p><p>2）map to guest = Bad User，这个配置的意思是将所有用户都映射成guest用户，所以访问共享文件时就不再需要用户名和密码了。</p><p>3）待共享的目录和文件的用户和组要设置成nobody。</p><p>4）/etc/samba/smb.conf文件中，global只能一组，共享目录可以配置多个。</p><h1 id="五-配置需要用户名密码才能访问的共享文件系统"><a class="markdownIt-Anchor" href="#五-配置需要用户名密码才能访问的共享文件系统"></a> 五、配置需要用户名/密码才能访问的共享文件系统</h1><h2 id="1-创建操作系统用户"><a class="markdownIt-Anchor" href="#1-创建操作系统用户"></a> 1、创建操作系统用户</h2><p>操作系统用户可以是普通的用户，也可以是简单的、无需登录的、没有HOME目录的用户，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin test -g bin  # 创建test用户，指定组为bin（其它组也行）。</span><br></pre></td></tr></table></figure><h2 id="2-创建测试目录和文件"><a class="markdownIt-Anchor" href="#2-创建测试目录和文件"></a> 2、创建测试目录和文件</h2><p>执行以下脚本，创建/tmp/docs目录，生成测试和文件，并指定用户和组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/docs  # 创建/tmp/docs目录。</span><br><span class="line">ls /usr &gt; /tmp/docs/usr.txt  # 把ls /usr的结果输出到/tmp/docs/usr.txt文件。</span><br><span class="line">ls /etc &gt; /tmp/docs/etc.txt  # 把ls /etc的结果输出到/tmp/docs/etc.txt文件。</span><br><span class="line">chown -R test:bin /tmp/docs # 修改/tmp/docs目录及文件用户和组。</span><br></pre></td></tr></table></figure><h2 id="3-添加-samba-用户"><a class="markdownIt-Anchor" href="#3-添加-samba-用户"></a> 3、添加 Samba 用户</h2><p>操作系统用户不能直接用于Samba服务的登录<br />，采用smbpasswd命令把操作系统用户添加到Samba的用户中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a test</span><br></pre></td></tr></table></figure><p>执行以上命令后，按系统提示两次输入密码，注意，输入的是用于登录Samba服务器的密码，与操作系统的密码没有关系。</p><p>smbpasswd 命令是用于维护 Samba 服务器的用户帐号的，具体如下：</p><p>1）添加 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a sambauser</span><br></pre></td></tr></table></figure><p>2）删除 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -x sambauser</span><br></pre></td></tr></table></figure><p>3）禁用 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -d sambauser</span><br></pre></td></tr></table></figure><p>4）启用 Samba 用户帐号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -e sambauser</span><br></pre></td></tr></table></figure><h2 id="4-配置etcsambasmbconf文件"><a class="markdownIt-Anchor" href="#4-配置etcsambasmbconf文件"></a> 4、配置/etc/samba/smb.conf文件</h2><p>/etc/samba/smb.conf文件的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">        security = USER</span><br><span class="line">        workgroup = SAMBA</span><br><span class="line">[docs]</span><br><span class="line">        comment = Shared <span class="built_in">docs</span>(read/write)</span><br><span class="line">        path = /tmp/docs</span><br><span class="line">        read only = No</span><br></pre></td></tr></table></figure><p>注意：在/etc/samba/smb.conf文件中，global只能一组，共享目录可以配置多个。</p><h2 id="5-重启samba服务验证结果"><a class="markdownIt-Anchor" href="#5-重启samba服务验证结果"></a> 5、重启samba服务，验证结果</h2><p>每次修改/etc/samba/smb.conf文件后，要重启smb服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart smb</span><br></pre></td></tr></table></figure><p>在windows上的我的电脑中，输入\\服务器IP后，按提示输入用户名和密码就可以访问Linux共享文件系统，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200331113701698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="六-smbconf文件详解"><a class="markdownIt-Anchor" href="#六-smbconf文件详解"></a> 六、smb.conf文件详解</h1><p>smb.conf文件的参数非常多，也很麻烦，如果您有更多的需求，请阅读/etc/samba/smb.conf.example文件，或man 5 smb.conf查看帮助。</p><p>我从网上找了一些说明文字，供大家参考，但是，我不保证这些说明文字是正确的，我没有测试验证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"># 全局参数</span><br><span class="line"># ==================Global Settings =================== #</span><br><span class="line">[global]</span><br><span class="line">config file = /usr/local/samba/lib/smb.conf.%m</span><br><span class="line">说明：config file可以让你使用另一个配置文件来覆盖缺省的配置文件。如果文件不存在，则该项无效。这个参数很有用，可以使得samba配置更灵活，可以让一台 samba服务器模拟多台不同配置的服务器。比如，你想让PC1（主机名）这台电脑在访问Samba Server时使用它自己的配置文件，那么先在/etc/samba/host/下为PC1配置一个名为smb.conf.pc1的文件，然后在 smb.conf中加入：config file = /etc/samba/host/smb.conf.%m。这样当PC1请求连接Samba Server时，smb.conf.%m就被替换成smb.conf.pc1。这样，对于PC1来说，它所使用的Samba服务就是由 smb.conf.pc1定义的，而其他机器访问Samba Server则还是应用smb.conf。</span><br><span class="line"></span><br><span class="line">workgroup = WORKGROUP</span><br><span class="line">说明：设定 Samba Server 所要加入的工作组或者域。</span><br><span class="line"></span><br><span class="line">server string = Samba Server Version %v</span><br><span class="line">说明：设定 Samba Server 的注释，可以是任何字符串，也可以不填。宏%v表示显示Samba的版本号。</span><br><span class="line"></span><br><span class="line">netbios name = smbserver</span><br><span class="line">说明：设置Samba Server的NetBIOS名称。如果不填，则默认会使用该服务器的DNS名称的第一部分。netbios name和workgroup名字不要设置成一样了。</span><br><span class="line"></span><br><span class="line">interfaces = lo eth0 <span class="number">192.168</span><span class="number">.12</span><span class="number">.2</span>/<span class="number">24</span> <span class="number">192.168</span><span class="number">.13</span><span class="number">.2</span>/<span class="number">24</span></span><br><span class="line">说明：设置Samba Server监听哪些网卡，可以写网卡名，也可以写该网卡的IP地址。</span><br><span class="line"></span><br><span class="line">hosts allow = <span class="number">127.</span> <span class="number">192.168</span><span class="number">.1</span>. <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br><span class="line">说明：表示允许连接到Samba Server的客户端，多个参数以空格隔开。可以用一个IP表示，也可以用一个网段表示。hosts deny 与hosts allow 刚好相反。</span><br><span class="line">例如：hosts allow=<span class="number">172.17</span><span class="number">.2</span>.EXCEPT172<span class="number">.17</span><span class="number">.2</span><span class="number">.50</span></span><br><span class="line">表示容许来自<span class="number">172.17</span><span class="number">.2</span>.*的主机连接，但排除<span class="number">172.17</span><span class="number">.2</span><span class="number">.50</span></span><br><span class="line">hosts allow=<span class="number">172.17</span><span class="number">.2</span><span class="number">.0</span>/<span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">表示容许来自<span class="number">172.17</span><span class="number">.2</span><span class="number">.0</span>/<span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>子网中的所有主机连接</span><br><span class="line">hosts allow=M1，M2</span><br><span class="line">表示容许来自M1和M2两台计算机连接</span><br><span class="line">hosts allow=@pega</span><br><span class="line">表示容许来自pega网域的所有计算机连接</span><br><span class="line"></span><br><span class="line">max connections = <span class="number">0</span></span><br><span class="line">说明：max connections用来指定连接Samba Server的最大连接数目。如果超出连接数目，则新的连接请求将被拒绝。<span class="number">0</span>表示不限制。</span><br><span class="line"></span><br><span class="line">deadtime = <span class="number">0</span></span><br><span class="line">说明：deadtime用来设置断掉一个没有打开任何文件的连接的时间。单位是分钟，<span class="number">0</span>代表Samba Server不自动切断任何连接。</span><br><span class="line"></span><br><span class="line">time server = yes/no</span><br><span class="line">说明：time server用来设置让nmdb成为windows客户端的时间服务器。</span><br><span class="line"></span><br><span class="line">log file = /var/log/samba/log.%m</span><br><span class="line">说明：设置Samba Server日志文件的存储位置以及日志文件名称。在文件名后加个宏%m（主机名），表示对每台访问Samba Server的机器都单独记录一个日志文件。如果pc1、pc2访问过Samba Server，就会在/var/log/samba目录下留下log.pc1和log.pc2两个日志文件。</span><br><span class="line"></span><br><span class="line">max log size = <span class="number">50</span></span><br><span class="line">说明：设置Samba Server日志文件的最大容量，单位为kB，<span class="number">0</span>代表不限制。</span><br><span class="line"></span><br><span class="line">security = user</span><br><span class="line">说明：设置用户访问Samba Server的验证方式，一共有四种验证方式。</span><br><span class="line"><span class="number">1</span>）share：用户访问Samba Server不需要提供用户名和口令, 安全性能较低，已不兼容。</span><br><span class="line"><span class="number">2</span>）user：Samba Server共享目录只能被授权的用户访问,由Samba Server负责检查账号和密码的正确性。账号和密码要在本Samba Server中建立。</span><br><span class="line"><span class="number">3</span>）server：依靠其他Windows NT/<span class="number">2000</span>或Samba Server来验证用户的账号和密码,是一种代理验证。此种安全模式下,系统管理员可以把所有的Windows用户和口令集中到一个NT系统上,使用 Windows NT进行Samba认证, 远程服务器可以自动认证全部用户和口令,如果认证失败,Samba将使用用户级安全模式作为替代的方式。</span><br><span class="line"><span class="number">4</span>）domain：域安全级别,使用主域控制器(PDC)来完成认证。</span><br><span class="line"></span><br><span class="line">passdb backend = tdbsam</span><br><span class="line">说明：passdb backend就是用户后台的意思。目前有三种后台：smbpasswd、tdbsam和ldapsam。sam应该是security account manager（安全账户管理）的简写。</span><br><span class="line"><span class="number">1</span>）smbpasswd：该方式是使用smb自己的工具smbpasswd来给系统用户（真实用户或者虚拟用户）设置一个Samba密码，客户端就用这个密码来访问Samba的资源。smbpasswd文件默认在/etc/samba目录下，不过有时候要手工建立该文件。</span><br><span class="line"><span class="number">2</span>）tdbsam： 该方式则是使用一个数据库文件来建立用户数据库。数据库文件叫passdb.tdb，默认在/etc/samba目录下。passdb.tdb用户数据库 可以使用smbpasswd –a来建立Samba用户，不过要建立的Samba用户必须先是系统用户。我们也可以使用pdbedit命令来建立Samba账户。pdbedit命令的 参数很多，我们列出几个主要的。</span><br><span class="line">　　pdbedit –a username：新建Samba账户。</span><br><span class="line">　　pdbedit –x username：删除Samba账户。</span><br><span class="line">　　pdbedit –L：列出Samba用户列表，读取passdb.tdb数据库文件。</span><br><span class="line">　　pdbedit –Lv：列出Samba用户列表的详细信息。</span><br><span class="line">　　pdbedit –c “[D]” –u username：暂停该Samba用户的账号。</span><br><span class="line">　　pdbedit –c “[]” –u username：恢复该Samba用户的账号。</span><br><span class="line"><span class="number">3</span>）ldapsam：该方式则是基于LDAP的账户管理方式来验证用户。首先要建立LDAP服务，然后设置“passdb backend = ldapsam:ldap:<span class="comment">//LDAP Server”</span></span><br><span class="line"></span><br><span class="line">encrypt passwords = yes/no</span><br><span class="line">说明：是否将认证密码加密。因为现在windows操作系统都是使用加密密码，所以一般要开启此项。不过配置文件默认已开启。</span><br><span class="line"></span><br><span class="line">smb passwd file = /etc/samba/smbpasswd</span><br><span class="line">说明：用来定义samba用户的密码文件。smbpasswd文件如果没有那就要手工新建。</span><br><span class="line"></span><br><span class="line">username map = /etc/samba/smbusers</span><br><span class="line">说明：用来定义用户名映射，比如可以将root换成administrator、admin等。不过要事先在smbusers文件中定义好。比如：root = administrator admin，这样就可以用administrator或admin这两个用户来代替root登陆Samba Server，更贴近windows用户的习惯。</span><br><span class="line"></span><br><span class="line">guest account = nobody</span><br><span class="line">说明：用来设置guest用户名。</span><br><span class="line"></span><br><span class="line">socket options = TCP_NODELAY SO_RCVBUF=<span class="number">8192</span> SO_SNDBUF=<span class="number">8192</span></span><br><span class="line">说明：用来设置服务器和客户端之间会话的Socket选项，可以优化传输速度。</span><br><span class="line"></span><br><span class="line">domain master = yes/no</span><br><span class="line">说明：设置Samba服务器是否要成为网域主浏览器，网域主浏览器可以管理跨子网域的浏览服务。</span><br><span class="line"></span><br><span class="line">local master = yes/no</span><br><span class="line">说明：local master用来指定Samba Server是否试图成为本地网域主浏览器。如果设为no，则永远不会成为本地网域主浏览器。但是即使设置为yes，也不等于该Samba Server就能成为主浏览器，还需要参加选举。</span><br><span class="line"></span><br><span class="line">preferred master = yes/no</span><br><span class="line">说明：设置Samba Server一开机就强迫进行主浏览器选举，可以提高Samba Server成为本地网域主浏览器的机会。如果该参数指定为yes时，最好把domain master也指定为yes。使用该参数时要注意：如果在本Samba Server所在的子网有其他的机器（不论是windows NT还是其他Samba Server）也指定为首要主浏览器时，那么这些机器将会因为争夺主浏览器而在网络上大发广播，影响网络性能。</span><br><span class="line">如果同一个区域内有多台Samba Server，将上面三个参数设定在一台即可。</span><br><span class="line"></span><br><span class="line">os level = <span class="number">200</span></span><br><span class="line">说明：设置samba服务器的os level。该参数决定Samba Server是否有机会成为本地网域的主浏览器。os level从<span class="number">0</span>到<span class="number">255</span>，winNT的os level是<span class="number">32</span>，win95/<span class="number">98</span>的os level是<span class="number">1</span>。Windows <span class="number">2000</span>的os level是<span class="number">64</span>。如果设置为<span class="number">0</span>，则意味着Samba Server将失去浏览选择。如果想让Samba Server成为PDC，那么将它的os level值设大些。</span><br><span class="line"></span><br><span class="line">domain logons = yes/no</span><br><span class="line">说明：设置Samba Server是否要做为本地域控制器。主域控制器和备份域控制器都需要开启此项。</span><br><span class="line"></span><br><span class="line">logon script = %u.bat</span><br><span class="line">说明：当使用者用windows客户端登陆，那么Samba将提供一个登陆档。如果设置成%u.bat，那么就要为每个用户提供一个登陆档。如果人比较多， 那就比较麻烦。可以设置成一个具体的文件名，比如start.bat，那么用户登陆后都会去执行start.bat，而不用为每个用户设定一个登陆档了。 这个文件要放置在[netlogon]的path设置的目录路径下。</span><br><span class="line"></span><br><span class="line">wins support = yes/no</span><br><span class="line">说明：设置samba服务器是否提供wins服务。</span><br><span class="line"></span><br><span class="line">wins server = wins服务器IP地址</span><br><span class="line">说明：设置Samba Server是否使用别的wins服务器提供wins服务。</span><br><span class="line"></span><br><span class="line">wins proxy = yes/no</span><br><span class="line">说明：设置Samba Server是否开启wins代理服务。</span><br><span class="line"></span><br><span class="line">dns proxy = yes/no</span><br><span class="line">说明：设置Samba Server是否开启dns代理服务。</span><br><span class="line"></span><br><span class="line">load printers = yes/no</span><br><span class="line">说明：设置是否在启动Samba时就共享打印机。</span><br><span class="line"></span><br><span class="line">printcap name = cups</span><br><span class="line">说明：设置共享打印机的配置文件。</span><br><span class="line"></span><br><span class="line">printing = cups</span><br><span class="line">说明：设置Samba共享打印机的类型。现在支持的打印系统有：bsd, sysv, plp, lprng, aix, hpux, qnx</span><br><span class="line"> </span><br><span class="line"># 共享参数</span><br><span class="line"># ================== Share Definitions ================== #</span><br><span class="line"></span><br><span class="line">[共享名]</span><br><span class="line">comment = 任意字符串</span><br><span class="line">说明：comment是对该共享的描述，可以是任意字符串。</span><br><span class="line"></span><br><span class="line">path = 共享目录路径</span><br><span class="line">说 明：path用来指定共享目录的路径。可以用%u、%m这样的宏来代替路径里的unix用户和客户机的Netbios名，用宏表示主要用于[homes] 共享域。例如：如果我们不打算用home段做为客户的共享，而是在/home/share/下为每个Linux用户以他的用户名建个目录，作为他的共享目 录，这样path就可以写成：path = /home/share/%u; 。用户在连接到这共享时具体的路径会被他的用户名代替，要注意这个用户名路径一定要存在，否则，客户机在访问时会找不到网络路径。同样，如果我们不是以用 户来划分目录，而是以客户机来划分目录，为网络上每台可以访问samba的机器都各自建个以它的netbios名的路径，作为不同机器的共享资源，就可以 这样写：path = /home/share/%m 。</span><br><span class="line"></span><br><span class="line">browseable = yes/no</span><br><span class="line">说明：browseable用来指定该共享是否可以浏览。</span><br><span class="line"></span><br><span class="line">writable = yes/no</span><br><span class="line">说明：writable用来指定该共享路径是否可写。</span><br><span class="line"></span><br><span class="line">available = yes/no</span><br><span class="line">说明：available用来指定该共享资源是否可用。</span><br><span class="line"></span><br><span class="line">admin users = 该共享的管理者</span><br><span class="line">说明：admin users用来指定该共享的管理员（对该共享具有完全控制权限）。</span><br><span class="line">例如：admin users =david，sandy（多个用户中间用逗号隔开）。</span><br><span class="line"></span><br><span class="line">valid users = 允许访问该共享的用户</span><br><span class="line">说明：valid users用来指定允许访问该共享资源的用户。</span><br><span class="line">例如：valid users = david，@dave，@tech（多个用户或者组中间用逗号隔开，如果要加入一个组就用“@组名”表示。）</span><br><span class="line"></span><br><span class="line">invalid users = 禁止访问该共享的用户</span><br><span class="line">说明：invalid users用来指定不允许访问该共享资源的用户。</span><br><span class="line">例如：invalid users = root，@bob（多个用户或者组中间用逗号隔开。）</span><br><span class="line"></span><br><span class="line">write list = 允许写入该共享的用户</span><br><span class="line">说明：write list用来指定可以在该共享下写入文件的用户。</span><br><span class="line">例如：write list = david，@dave</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> = yes/no</span><br><span class="line">说明：<span class="keyword">public</span>用来指定该共享是否允许guest账户访问。</span><br><span class="line"></span><br><span class="line">guest ok = yes/no</span><br><span class="line">说明：意义同<span class="keyword">public</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux开机启动程序</title>
      <link href="/posts/f284833.html"/>
      <url>/posts/f284833.html</url>
      
        <content type="html"><![CDATA[<p>在CentOS7中，实现开机启动程序主要有两种方法：</p><p>1）把要启动的程序配置成自定义的系统服务，该方法我已经介绍过，请阅读：<a href="http://www.freecplus.net/web/list.jsp?typeId=41a73911ba7b45f4931a344387a6a794&amp;navId=056c325857234b9bb0db62329af213ef">CentOS7添加自定义系统服务</a>。</p><p>2）在/etc/rc.local脚本文件中编写启动程序的脚本，本文将详细介绍这种方法。</p><h2 id="1-etcrclocal是etcrcdrclocal的软链接"><a class="markdownIt-Anchor" href="#1-etcrclocal是etcrcdrclocal的软链接"></a> 1、/etc/rc.local是/etc/rc.d/rc.local的软链接</h2><p>执行<code>ls -l /etc/rc.local</code>看看。<br /><img src="https://img-blog.csdnimg.cn/20200328084556723.png" alt="在这里插入图片描述" /><br />/etc/rc.local是/etc/rc.d/rc.local文件的软链接，也就是说他们是同一个文件。</p><h2 id="2-rclocal文件的原始内容"><a class="markdownIt-Anchor" href="#2-rclocal文件的原始内容"></a> 2、rc.local文件的原始内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line">#</span><br><span class="line"># It is highly advisable to create own systemd services <span class="keyword">or</span> udev rules</span><br><span class="line"><span class="meta"># to run scripts during boot instead of using this file.</span></span><br><span class="line">#</span><br><span class="line"># In contrast to previous versions due to parallel execution during boot</span><br><span class="line"><span class="meta"># this script will NOT be run after all other services.</span></span><br><span class="line">#</span><br><span class="line"># Please note that you must run <span class="string">&#x27;chmod +x /etc/rc.d/rc.local&#x27;</span> to ensure</span><br><span class="line"><span class="meta"># that this script will be executed during boot.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">touch /var/lock/subsys/local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中文意思如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加此文件是为了兼容。</span><br><span class="line"># 强烈建议创建自己的systemd服务或udev规则，以便在引导期间运行脚本，而不是使用此文件。</span><br><span class="line"># 与以前版本不同，由于在引导期间并行执行，此脚本不会在所有其他服务之后运行。</span><br><span class="line"># 请注意，必须运行<span class="string">&#x27;chmod+x/etc/rc.d/rc.local&#x27;</span>，以确保在引导期间执行此脚本。</span><br></pre></td></tr></table></figure><p>明白了吧。</p><p>虽然Linux强烈建议采用自定义的系统服务实现开机自启动程序，不过我认为在rc.local中配置开机启动程序也是一个不错的方法，因为rc.local的配置更简单明了，所以仍被广泛的使用。</p><h2 id="3-rclocal文件的配置"><a class="markdownIt-Anchor" href="#3-rclocal文件的配置"></a> 3、rc.local文件的配置</h2><p>rc.local本质上是一个shell脚本文件，可以把启动时需要执行的命令写在里面，启动时将按顺序执行。</p><p>接下来我们来测试它。</p><p>1）在rc.local中添加以下脚本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/date &gt;&gt; /tmp/date1.log # 把当前时间追加写入到/tmp/date1.log中。</span><br><span class="line">/usr/bin/sleep <span class="number">10</span> # 睡眠<span class="number">10</span>秒。</span><br><span class="line">/usr/bin/date &gt;&gt; /tmp/date2.log # 把当前时间追加写入到/tmp/date2.log中。</span><br></pre></td></tr></table></figure><p>2）修改/etc/rc.d/rc.local的可执行权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><p>3）重启服务器。</p><p>4）查看日志文件/tmp/date1.log和/tmp/date2.log的内容。<br /><img src="https://img-blog.csdnimg.cn/20200328084831361.png" alt="在这里插入图片描述" /></p><h2 id="4-应用经验"><a class="markdownIt-Anchor" href="#4-应用经验"></a> 4、应用经验</h2><p>1）rc.local脚本在操作系统启动时只执行一次。</p><p>2）环境变量的问题。</p><p>在rc.local脚本中执行程序时是没有环境变量的，如果您执行的程序需要环境变量，可以在脚本中设置环境变量，也可以用su切换用户来执行，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - oracle -c <span class="string">&quot;sqlplus scott/tiger @/tmp/test.sql&quot;</span></span><br></pre></td></tr></table></figure><p>以上命令的含义就是以oracle用户登录再执行sqlplus命令。</p><p>3）不要让rc.local挂起。</p><p>rc.local是一个脚本，是按顺序执行的，执行完一个程序后才会执行下一个程序，如果某程序不是后台程序，就应该加&amp;让程序运行在后台，否则rc.local会挂起。</p><p>可以用以下脚本来测试，rc.local的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/date &gt;&gt; /tmp/date1.log  # 把当前时间追加写入到/tmp/date1.log中。</span><br><span class="line">/usr/bin/sleep <span class="number">100</span> # 睡眠<span class="number">100</span>秒。</span><br><span class="line">/usr/bin/date &gt;&gt; /tmp/date2.log  # 把当前时间追加写入到/tmp/date2.log中。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果采用了以上脚本，Linux系统在启动完成100后，才会出现以下的登录界面。<br /><img src="https://img-blog.csdnimg.cn/20200328084946139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-版权声明"><a class="markdownIt-Anchor" href="#5-版权声明"></a> 5、版权声明</h2><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7配置IP地址和DNS</title>
      <link href="/posts/bce3b467.html"/>
      <url>/posts/bce3b467.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-查看ip地址"><a class="markdownIt-Anchor" href="#一-查看ip地址"></a> 一、查看IP地址</h1><h2 id="1-ifconfig命令"><a class="markdownIt-Anchor" href="#1-ifconfig命令"></a> 1、ifconfig命令</h2><p>ifconfig是Linux查看和配置网卡的命令，</p><p><img src="https://img-blog.csdnimg.cn/20200326144626655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>上图中，我们重点关注五方面信息：</p><p>1）网卡名：即网卡设备名，lo是本机（全称loopback，是回环地址，经常被分配到127.0.0.1地址上，用于本机通信，经过内核处理后直接返回，不会在任何网络中出现）；eth0是真实的网卡，如果服务器有多个网卡，网卡命名将是eth0、eth1、eth2、……。注意：真实网卡的名称不一定是eth打头，还可以是no（由主板bios内置的网卡）、ens（代表有主板bios内置的PCI-E网卡）、enp2s（PCI-E独立网卡）等，后面的编号也不一定从0开始。</p><p>2）IP地址：inet后的内容是IP地址，我们现在常说的IP地址是指IPV4，IPV6的地址是inet6之后的内容，暂时不关注。</p><p>3）子网掩码：netmask后的内容是子网掩码。</p><p>4）网卡状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span><br></pre></td></tr></table></figure><p>UP：网卡处于启动状态。</p><p>BROADCAST：网卡有广播地址，可以发生广播包。</p><p>MULTICAST：网卡可以发生多播包。</p><p>LOWER_UP：L1是启动的，即网线是插着的。</p><p>5）MAC地址：MAC地址是生产厂家定的，每个网卡拥有的一个地址，相当于设备的序列号。</p><h2 id="2-ip-addr命令"><a class="markdownIt-Anchor" href="#2-ip-addr命令"></a> 2、ip addr命令</h2><p><img src="https://img-blog.csdnimg.cn/20200326144730778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>ip addr命令显示的内容和ifconfig差不多，就不解释了。注意：ip<br />addr命令把IP地址和子网掩码在一起显示，如：<code>172.16.0.7/20</code>。</p><h1 id="二-配置网卡"><a class="markdownIt-Anchor" href="#二-配置网卡"></a> 二、配置网卡</h1><p>每一个网卡都有一个配置文件，存放在/etc/sysconfig/network-scripts目录中，文件名是<code>ifcfg-网卡</code>，网卡eth0的配置文件是<code>ifcfg-eth0</code>，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200326144859680.png" alt="在这里插入图片描述" /></p><h2 id="1-动态ip地址"><a class="markdownIt-Anchor" href="#1-动态ip地址"></a> 1、动态IP地址</h2><p>如果采用的是动态分配IP的方法，ifcfg-eth0的配置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet  # 网卡类型。</span><br><span class="line">PROXY_METHOD=none  # 代理模式。</span><br><span class="line">BROWSER_ONLY=no  # 只是浏览器。</span><br><span class="line">BOOTPROTO=dhcp  <span class="meta"># dhcp-动态分配，static-静态分配（重要）。</span></span><br><span class="line">DEFROUTE=yes  # 启动默认路由。</span><br><span class="line">IPV4_FAILURE_FATAL=no  # 不启用IPV4错误检测功能。</span><br><span class="line">IPV6INIT=yes  # 启用IPV6协议。</span><br><span class="line">IPV6_AUTOCONF=yes  # 自动配置IPV6地址。</span><br><span class="line">IPV6_DEFROUTE=yes  # 用IPV6默认路由。</span><br><span class="line">IPV6_FAILURE_FATAL=no  # 不启用IPV6错误检测功能。</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy  # IPV6地址生成模型。</span><br><span class="line">NAME=eth0  # 网卡物理设备名称（重要）。</span><br><span class="line">UUID=<span class="number">63749b</span>32<span class="number">-6852</span><span class="number">-4535</span><span class="number">-96</span>a9<span class="number">-58</span>d24732771d</span><br><span class="line">DEVICE=eth0  # 网卡设备名称, 必须和NAME值相同（重要）。</span><br><span class="line">ONBOOT=yes  # 是否开机引导。</span><br></pre></td></tr></table></figure><p>以上参数是系统缺省的，只需要关注NOBOOT参数就可以了。</p><h2 id="2-静态ip地址"><a class="markdownIt-Anchor" href="#2-静态ip地址"></a> 2、静态IP地址</h2><p>如果采用的是静态设置IP，ifcfg-eth0的配置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet  # 网卡类型。</span><br><span class="line">PROXY_METHOD=none  # 代理模式。</span><br><span class="line">BROWSER_ONLY=no  # 只是浏览器。</span><br><span class="line">BOOTPROTO=<span class="type">static</span>  <span class="meta"># dhcp-动态分配，static-静态分配（重要）。</span></span><br><span class="line">DEFROUTE=yes  # 启动默认路由。</span><br><span class="line">IPV4_FAILURE_FATAL=no  # 不启用IPV4错误检测功能。</span><br><span class="line">IPV6INIT=yes  # 启用IPV6协议。</span><br><span class="line">IPV6_AUTOCONF=yes  # 自动配置IPV6地址。</span><br><span class="line">IPV6_DEFROUTE=yes  # 用IPV6默认路由。</span><br><span class="line">IPV6_FAILURE_FATAL=no  # 不启用IPV6错误检测功能。</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy  # IPV6地址生成模型。</span><br><span class="line">NAME=eth0  # 网卡物理设备名称（重要，不必修改）。</span><br><span class="line">UUID=<span class="number">63749b</span>32<span class="number">-6852</span><span class="number">-4535</span><span class="number">-96</span>a9<span class="number">-58</span>d24732771d</span><br><span class="line">DEVICE=eth0  # 网卡设备名称, 必须和NAME值相同（重要，不必修改）。</span><br><span class="line">ONBOOT=yes  # 是否开机引导。</span><br></pre></td></tr></table></figure><br/><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNS1=<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span>  # 第<span class="number">1</span>个DSN服务器的IP地址（重要）。</span><br><span class="line">DNS2=<span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span>  # 第<span class="number">2</span>个DSN服务器的IP地址（重要）。</span><br></pre></td></tr></table></figure><br/><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=<span class="number">192.168</span><span class="number">.126</span><span class="number">.128</span>  # IP地址（重要）。</span><br><span class="line">NETMARSK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  # 子网掩码（重要）。</span><br><span class="line">GATEWAY=<span class="number">192.168</span><span class="number">.126</span><span class="number">.2</span>  # 网关（重要）。</span><br></pre></td></tr></table></figure><h2 id="3-重启网卡"><a class="markdownIt-Anchor" href="#3-重启网卡"></a> 3、重启网卡</h2><p>采用root用户，执行以下命令重启网络服务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h1 id="三-注意事项"><a class="markdownIt-Anchor" href="#三-注意事项"></a> 三、注意事项</h1><p><strong>1）如果在VMWare虚拟机中，CentOS7最小安装的网卡设备名缺省是ens33，配置文件名是ifcfg-ens33。</strong></p><p><strong>2）CentOS7最小化安装缺省是不启动网卡的，需要手工修改网卡配置文件，设置<code>ONBOOT=yes</code>。</strong></p><p><strong>3）DNS服务器的参数可以在网卡的配置文件中设置，也可以在/etc/resolv.conf文件中设置，如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Generated by NetworkManager</span><br><span class="line">nameserver <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">nameserver <span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span></span><br></pre></td></tr></table></figure><p><strong>4）如果在VMWare虚拟机中，把CentOS7修改为静态IP后，可能无法上网，处理方法见下一章节。</strong></p><h1 id="四-本地虚拟机设置静态ip后不能上网的解决方法"><a class="markdownIt-Anchor" href="#四-本地虚拟机设置静态ip后不能上网的解决方法"></a> 四、本地虚拟机设置静态IP后不能上网的解决方法</h1><p>在VMWare中安装的本地虚拟机CentOS7操作系统，动态IP地址会经常变化，设置成静态IP地址后，本地局域网可以互相访问，但CentOS7系统无法访问互联网，按以下步骤解决这个问题。</p><h2 id="1-以系统管理员打开vmware"><a class="markdownIt-Anchor" href="#1-以系统管理员打开vmware"></a> 1、以系统管理员打开VMWare</h2><p><img src="https://img-blog.csdnimg.cn/20200326145801288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-选择虚拟网络编辑器菜单"><a class="markdownIt-Anchor" href="#2-选择虚拟网络编辑器菜单"></a> 2、选择虚拟网络编辑器菜单</h2><p><img src="https://img-blog.csdnimg.cn/20200326145816287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="3-选择vmnet8这一行"><a class="markdownIt-Anchor" href="#3-选择vmnet8这一行"></a> 3、选择VMnet8这一行</h2><p><img src="https://img-blog.csdnimg.cn/20200326145841317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="4-还原vmnet8的默认设置"><a class="markdownIt-Anchor" href="#4-还原vmnet8的默认设置"></a> 4、还原VMnet8的默认设置</h2><p><img src="https://img-blog.csdnimg.cn/20200326150003691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="5-修改vmnet8的参数"><a class="markdownIt-Anchor" href="#5-修改vmnet8的参数"></a> 5、修改VMnet8的参数</h2><p><img src="https://img-blog.csdnimg.cn/2020032615002036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>虚拟机子网IP地址段和子网掩码由您自己来定，如果你不熟练，就按上图中的内容来设置也没有问题。</strong></p><h2 id="6-nat设置"><a class="markdownIt-Anchor" href="#6-nat设置"></a> 6、NAT设置</h2><p><img src="https://img-blog.csdnimg.cn/20200326150034808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200326150048884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="7-保存设置"><a class="markdownIt-Anchor" href="#7-保存设置"></a> 7、保存设置</h2><p><img src="https://img-blog.csdnimg.cn/20200326150112836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="8-确认虚拟机为nat模式"><a class="markdownIt-Anchor" href="#8-确认虚拟机为nat模式"></a> 8、确认虚拟机为NAT模式</h2><p><img src="https://img-blog.csdnimg.cn/20200326150125711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="9-启动虚拟机centos7"><a class="markdownIt-Anchor" href="#9-启动虚拟机centos7"></a> 9、启动虚拟机CentOS7</h2><h2 id="10-设置centos7的不静态ip地址"><a class="markdownIt-Anchor" href="#10-设置centos7的不静态ip地址"></a> 10、设置CentOS7的不静态IP地址</h2><p>修改虚拟机网卡配置文件，如/etc/sysconfig/network-scripts/ifcfg-ens33，注意，文件名不一定是ifcfg-ens33，根据您的实际情况决定。</p><p>1）修改BOOTPROTO参数，把地址协议改为静态IP方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=<span class="type">static</span>  <span class="meta"># dhcp-动态分配，static-静态分配（重要）。</span></span><br></pre></td></tr></table></figure><p>2）修改ONBOOT参数，把开机启动选项ONBOOT设置为yes。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBOOT=yes  # 是否开机引导。</span><br></pre></td></tr></table></figure><p>3）设置DSN服务器的IP，添加以下内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNS1=<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span>  # 第<span class="number">1</span>个DSN服务器的IP地址。</span><br><span class="line">DNS2=<span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span>  # 第<span class="number">2</span>个DSN服务器的IP地址。</span><br></pre></td></tr></table></figure><p>4）设置CentOS7的IP地址、子网掩码和网关参数，添加以下内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=<span class="number">192.168</span><span class="number">.226</span><span class="number">.128</span>  # IP地址（重要）。</span><br><span class="line">NETMARSK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  # 子网掩码（重要）。</span><br><span class="line">GATEWAY=<span class="number">192.168</span><span class="number">.226</span><span class="number">.2</span>   # 网关（重要）。</span><br></pre></td></tr></table></figure><h2 id="11-重启centos7的网络服务"><a class="markdownIt-Anchor" href="#11-重启centos7的网络服务"></a> 11、重启CentOS7的网络服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h2 id="12-测试效果"><a class="markdownIt-Anchor" href="#12-测试效果"></a> 12、测试效果</h2><p>ping一下百度。</p><p><img src="https://img-blog.csdnimg.cn/20200326150749789.png" alt="在这里插入图片描述" /><br />ok。</p><h2 id="13-注意事项"><a class="markdownIt-Anchor" href="#13-注意事项"></a> 13、注意事项</h2><p>如果您对网络知识不熟悉，或对虚拟机不熟悉，建议按本文章依葫芦画瓢，照抄参数。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7添加自定义系统服务</title>
      <link href="/posts/c61bfc2f.html"/>
      <url>/posts/c61bfc2f.html</url>
      
        <content type="html"><![CDATA[<p>CentOS 6版本的系统服务是/etc/init.d启动脚本的方式，CentOS 7采用强大的systemctl来管理系统服务，大幅提高了系统服务的运行效率，但是服务的配置和以前版本完全不同，这是很大的进步，systemctl太简单易用了。</p><p>CentOS7添加自定义系统服务的步骤如下：</p><p>1）编写自定义的系统服务脚本文件；</p><p>2）用systemctl命令把自定义的系统服务设置为开机/关机自启动/停止。</p><p>本文以Oracle数据库为例子来介绍添加自定义系统服务的知识。假设ORACLE_HOME环境变量的值是/oracle/home，各位根据自己的实际情况调整脚本的内容，把文中/oracle/home替换成您ORACLE_HOME的值。</p><h1 id="一-编写oracle数据库启动重启关闭的脚本"><a class="markdownIt-Anchor" href="#一-编写oracle数据库启动重启关闭的脚本"></a> 一、编写Oracle数据库启动/重启/关闭的脚本</h1><h2 id="1-启动oracle数据库的shell脚本"><a class="markdownIt-Anchor" href="#1-启动oracle数据库的shell脚本"></a> 1、启动Oracle数据库的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbstart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改脚本的权限为可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /oracle/home/bin/dbstart</span><br></pre></td></tr></table></figure><h2 id="2-重启oracle数据库的shell脚本"><a class="markdownIt-Anchor" href="#2-重启oracle数据库的shell脚本"></a> 2、重启Oracle数据库的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbrestart，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">startup;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改脚本的权限为可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /oracle/home/bin/dbrestart</span><br></pre></td></tr></table></figure><h2 id="3-关闭oracle数据库的shell脚本"><a class="markdownIt-Anchor" href="#3-关闭oracle数据库的shell脚本"></a> 3、关闭Oracle数据库的shell脚本</h2><p>启动Oracle数据库的脚本为/oracle/home/bin/dbshut，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba &lt;&lt;EOF</span><br><span class="line">shutdown immediate;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>修改脚本的权限为可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /oracle/home/bin/dbshut</span><br></pre></td></tr></table></figure><h1 id="二-编写自定义服务的配置文件"><a class="markdownIt-Anchor" href="#二-编写自定义服务的配置文件"></a> 二、编写自定义服务的配置文件</h1><p>系统服务的启动/重启/停止由它的配置文件决定，本文把Oracle数据库的系统服务命名为oracle.service。</p><p>创建服务配置文件/usr/lib/systemd/system/oracle.service，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle RDBMS</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbstart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbrestart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbshut &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>接下来介绍服务配置文件各部分的含义。</p><h2 id="1-unit部分"><a class="markdownIt-Anchor" href="#1-unit部分"></a> 1、Unit部分</h2><p>Unit部分是启动顺序与依赖关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Oracle RDBMS</span><br><span class="line">After=network.target</span><br></pre></td></tr></table></figure><p>Description字段：给出当前服务的简单描述。</p><p>Documentation字段：给出文档位置。</p><p>After字段：表示本服务应该在某服务之后启动。</p><p>Before字段：表示本服务应该在某服务之前启动。</p><p>After和Before字段只涉及启动顺序，不涉及依赖关系。设置依赖关系，需要使用Wants字段和Requires字段。</p><p>Wants字段：表示本服务与某服务之间存在“依赖”系，如果被依赖的服务启动失败或停止运行，不影响本服务的继续运行。</p><p>Requires字段，表示本服务与某服务之间存在“强依赖”系，如果被依赖的服务启动失败或停止运行，本服务也必须退出。</p><h2 id="2-service部分"><a class="markdownIt-Anchor" href="#2-service部分"></a> 2、Service部分</h2><p>Service部分定义如何启动/重启/停止服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbstart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecReload=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbrestart &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">ExecStop=/usr/bin/su - oracle -c <span class="string">&quot;/oracle/home/bin/dbshut &gt;&gt; /tmp/oracle.log&quot;</span></span><br><span class="line">RemainAfterExit=yes</span><br></pre></td></tr></table></figure><p>1）启动类型（Type字段）</p><p>Type字段定义启动类型。它可以设置的值如下。</p><p>simple（默认值）：ExecStart字段启动的进程为主进程。</p><p>forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程。</p><p>oneshot：类似于simple，但只执行一次，Systemd会等它执行完，才启动其他服务。</p><p>dbus：类似于simple，但会等待D-Bus信号后启动。</p><p>notify：类似于simple，启动结束后会发出通知信号，然后Systemd再启动其他服务。</p><p>idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。</p><p>2）启动服务（ExecStart字段）</p><p>启动服务时执行的命令，可以是可执行程序、系统命令或shell脚本。</p><p>3）重启服务（ExecReload字段）</p><p>重启服务时执行的命令，可以是可执行程序、系统命令或shell脚本。</p><p>4）停止服务（ExecStop字段）</p><p>停止服务时执行的命令，可以是可执行程序、系统命令或shell脚本。</p><p>5）如果RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。</p><p>6）服务配置文件还可以读取环境变量参数文件，我个人认为比较麻烦，没有必要，就不介绍了，设置程序的环境变量有很多种方法，可以在脚本中配置，也可以用“su<br />–”的方法。</p><h2 id="3-install部分"><a class="markdownIt-Anchor" href="#3-install部分"></a> 3、Install部分</h2><p>Install部分定义如何安装这个配置文件，即怎样做到开机启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>WantedBy字段：表示该服务所在的Target。</p><p>Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，oracle所在的Target是multi-user.target（多用户模式）。</p><p>这个设置非常重要，因为执行systemctl enable<br />oracle.service命令时，oracle.service会被链接到/etc/systemd/system/multi-user.target.wants目录之中，实现开机启动的功能。</p><h2 id="4-重启行为"><a class="markdownIt-Anchor" href="#4-重启行为"></a> 4、重启行为</h2><p>Service部分还有一些字段，定义了重启行为。</p><p>1）KillMode字段</p><p>KillMode字段定义Systemd如何停止sshd服务，可以设置的值如下：</p><p>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉。</p><p>process：只杀主进程。</p><p>mixed：主进程将收到SIGTERM信号，子进程收到SIGKILL信号。</p><p>none：没有进程会被杀掉，只是执行服务的stop命令。</p><p>2）Restart字段</p><p>Restart字段定义了服务程序退出后，Systemd的重启方式，可以设置的值如下：</p><p>no（默认值）：退出后不会重启。</p><p>on-success：只有正常退出时（退出状态码为0），才会重启。</p><p>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启。</p><p>on-abnormal：只有被信号终止和超时，才会重启。</p><p>on-abort：只有在收到没有捕捉到的信号终止时，才会重启。</p><p>on-watchdog：超时退出，才会重启。</p><p>always：不管是什么退出原因，总是重启。</p><p>3）RestartSec字段。</p><p>RestartSec字段：表示Systemd重启服务之前，需要等待的秒数。</p><h1 id="三-使用自定义的服务"><a class="markdownIt-Anchor" href="#三-使用自定义的服务"></a> 三、使用自定义的服务</h1><h2 id="1-重新加载服务配置文件"><a class="markdownIt-Anchor" href="#1-重新加载服务配置文件"></a> 1、重新加载服务配置文件</h2><p>每次修改了服务配置文件后，需要执行以下命令重新加载服务的配置文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="2-启动停止启重oracle服务"><a class="markdownIt-Anchor" href="#2-启动停止启重oracle服务"></a> 2、启动/停止/启重oracle服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start oracle # 启动oracle服务。</span><br><span class="line"></span><br><span class="line">systemctl restart oracle # 重启oracle服务。</span><br><span class="line"></span><br><span class="line">systemctl stop oracle # 关闭oracle服务。</span><br></pre></td></tr></table></figure><h2 id="3-把oracle服务设置为开机关机自启动停止"><a class="markdownIt-Anchor" href="#3-把oracle服务设置为开机关机自启动停止"></a> 3、把oracle服务设置为开机/关机自启动/停止</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled oracle # 查看oracle服务是否是开机自启动。</span><br><span class="line"></span><br><span class="line">systemctl enable oracle # 把oracle服务设置为开机自启动。</span><br></pre></td></tr></table></figure><h2 id="4-查看oracle实例启动停止的日志"><a class="markdownIt-Anchor" href="#4-查看oracle实例启动停止的日志"></a> 4、查看Oracle实例启动/停止的日志</h2><p>Oracle实例启动的日志在/tmp/oracle.log文件中。</p><p>注意，只有通过systemctl启动/关闭Oracle实例和监听才会写日志，手工执行脚本不写日志。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7计划任务crontab</title>
      <link href="/posts/c1035555.html"/>
      <url>/posts/c1035555.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-计划任务的基本概念"><a class="markdownIt-Anchor" href="#一-计划任务的基本概念"></a> 一、计划任务的基本概念</h1><p>linux系统采用crond守护进程来控制系统和用户的计划任务，实现周期性的执行某种任务或处理某些事件。</p><p>Linux系统本身就有很多的计划任务，所以crond服务是默认安装和启动的。crond服务每分钟都会检查是否有需要执行的任务，如果有则自动执行该任务。执行以下命令可以看到crond服务的运行情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status crond</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200321091236120.png" alt="在这里插入图片描述" /></p><p>Linux下的计划任务分为两种：用户计划任务和系统计划任务。</p><h1 id="二-用户计划任务"><a class="markdownIt-Anchor" href="#二-用户计划任务"></a> 二、用户计划任务</h1><p>Linux的每个用户可以定义自己的计划任务，周期性的执行脚本或程序。计划任务的内容存放在crontab文件中，每个用户都有自己的crontab文件。</p><h2 id="1-查看crontab文件"><a class="markdownIt-Anchor" href="#1-查看crontab文件"></a> 1、查看crontab文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l [-u 用户名]</span><br></pre></td></tr></table></figure><p>root用户可以用-u参数查看指定用户的计划任务，如果没有-u参数，表示查看自己的计划任务。普通用户只查看自己的计划任务，不允许使用-u参数。</p><h2 id="2-编辑crontab文件"><a class="markdownIt-Anchor" href="#2-编辑crontab文件"></a> 2、编辑crontab文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e [-u 用户名]</span><br></pre></td></tr></table></figure><p>root用户可以用-u参数编辑指定用户的计划任务，如果没有-u参数，表示编辑自己的计划任务。普通用户只能编辑自己的计划任务，不允许使用-u参数。crontab缺省的编辑工具是vi。</p><h2 id="3-删除crontab文件"><a class="markdownIt-Anchor" href="#3-删除crontab文件"></a> 3、删除crontab文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -r [-u 用户名]</span><br></pre></td></tr></table></figure><p>root用户可以用-u参数删除指定用户的计划任务，如果没有-u参数，表示删除自己的计划任务。普通用户只删除自己的计划任务，不允许使用-u参数。</p><h2 id="4-crontab文件格式"><a class="markdownIt-Anchor" href="#4-crontab文件格式"></a> 4、crontab文件格式</h2><p><img src="https://img-blog.csdnimg.cn/20200321091331306.png" alt="在这里插入图片描述" /><br />crontab文件中的每个任务由两部分组成，执行时间和执行命令。</p><p><strong>1）执行时间，有5个参数：</strong></p><p>第1部分：分钟（minute），取值0-59。</p><p>第2部分：小时（hour），取值0-23。</p><p>第3部分：月当中的天（day of month），取值1-31，。</p><p>第4部分：月份（month），取值1-12，或采用月份单词的英文简写。</p><p>第5部分：星期中的天（day of week），取值0-6，或采用星期单词的英文简写。</p><p>在以上各部分中，还可以使用以下特殊字符：</p><p>星号（*）：代表全部的值，例如day of month字段如果是星号，则表示在满足其它字段的制约条件后每天执行该任务。</p><p>逗号（,）：可以用逗号分隔开的值指定一个列表，例如，“1,2,5,7,8,9”。</p><p>中杠（-）：可以中杠表示一个范围，例如“2-6”表示“2,3,4,5,6”。</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如minute字段，“0-30/5”表示在0-30的范围内每5分钟执行一次；“*/5”表示每十分钟执行一次。</p><p><strong>2）执行命令：任务执行的程序，可以是shell脚本，也可以是其它的可执行文件，但是要注意几个问题：</strong></p><p>a）crontab中执行程序的时候，不会先执行系统和用户的环境变量文件，如果待执行的程序需要环境变量，程序将无法执行；</p><p>b）crontab中执行的程序必须采用全路径。</p><h2 id="5-crontab示例"><a class="markdownIt-Anchor" href="#5-crontab示例"></a> 5、crontab示例</h2><p>1）每两分钟执行一次date命令，结果输出到/tmp/date.log文件（下同）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">2</span> * * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>2）在每个小时的05、10、15分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span> * * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>3）在每个小时20-30分之间的每一分钟执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span><span class="number">-30</span> * * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>4）在每天的10:30分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">10</span> * * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>5）在每个月1号的02:30分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">02</span> <span class="number">1</span> * * /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>6）在每星期天的02:30分执行一次date命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">02</span> * * <span class="number">0</span> /usr/bin/date \&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><h1 id="三-系统计划任务"><a class="markdownIt-Anchor" href="#三-系统计划任务"></a> 三、系统计划任务</h1><p>网上很多文章认为系统计划任务是执行系统级别的周期性任务，例如系统备份、把缓存数据写入硬盘、清理日志文件等。这些说法有些片面，我不这么认为，我先介绍系统计划任务的相关知识，然后通过示例来演示。</p><p>系统计划任务在/etc/crontab文件配置，以下缺省/etc/crontab文件的内容：<br /><img src="https://img-blog.csdnimg.cn/20200321091603618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />系统计划任务的/etc/crontab文件中，**可以设置环境变量，可以指定执行任务的用户。**系统计划任务的执行时间的与用户计划任务的执行时间含义相同，不再描述。</p><p>示例：</p><p>Oracle数据库提供了sqlplus工具，执行sqlplus需要环境变量，如ORACLE_HOME、ORACLE_BASE等，如果采用系统计划任务执行一个SQL脚本，步骤如下：</p><p>1）准备/tmp/test.sql脚本文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">to_char</span><span class="params">(sysdate,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>)</span> from dual</span>;</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>2）在/etc/crontab文件中增加环境变量和任务，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 设置Oracle的环境变量。</span><br><span class="line">ORACLE_BASE=/oracle/base</span><br><span class="line">ORACLE_HOME=/oracle/home</span><br><span class="line">ORACLE_SID=snorcl11g</span><br><span class="line">NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line">LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/usr/lib</span><br><span class="line"></span><br><span class="line"># 每分钟调用sqlplus执行/tmp/test.sql脚本，结果输出到/tmp/test.log文件。</span><br><span class="line">*/<span class="number">1</span> * * * * oracle /oracle/home/bin/sqlplus scott/tiger @/tmp/test.sql &gt;/tmp/test.log</span><br></pre></td></tr></table></figure><p>3）每隔一分钟查看/tmp/test.log文件的内容，如下：<br /><img src="https://img-blog.csdnimg.cn/20200321091806802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="四-如何在用户计划任务中执行需要环境变量的程序"><a class="markdownIt-Anchor" href="#四-如何在用户计划任务中执行需要环境变量的程序"></a> 四、如何在用户计划任务中执行需要环境变量的程序</h1><p>用户的计划任务无法设置环境变量，那么如何在用户计划任务中执行需要环境变量的程序呢？我们可以这么做：</p><p>1）编写一个shell脚本；</p><p>2）在脚本中设置环境变量；</p><p>3）在脚本中执行需要环境变量的程序。</p><p>示例：</p><p>1）编写/tmp/test.sh脚本文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置系统环境变量。</span><br><span class="line">source /etc/profile</span><br><span class="line"># 设置oracle用户的环境变量。</span><br><span class="line">source /oracle/.bash_profile</span><br><span class="line"># 执行/tmp/test.sql脚本。</span><br><span class="line">/oracle/home/bin/sqlplus scott/tiger @/tmp/test.sql &gt; /tmp/test1.log</span><br></pre></td></tr></table></figure><p>2）准备/tmp/test.sql脚本文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">to_char</span><span class="params">(sysdate,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>)</span> from dual</span>;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>3）设置oracle用户的计划任务文件，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每分钟执行一次/tmp/test.sh脚本。</span><br><span class="line">*/<span class="number">1</span> * * * * /bin/sh /tmp/test.sh</span><br></pre></td></tr></table></figure><p>4）每隔一分钟查看/tmp/test1.log文件的内容，如下：<br /><img src="https://img-blog.csdnimg.cn/20200321091956752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>用户计划任务和系统计划任务没有本质的区别，都可以达到相同的目的。</p><p>在实际项目中我偏向用户的计划任务，虽然用户计划任务的crontab文件中不能设置环境变量，但可以通过脚本文件来解决，并且，脚本文件中编写指令比crontab文件更灵活。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ftp命令详解</title>
      <link href="/posts/7b2debb7.html"/>
      <url>/posts/7b2debb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-安装ftp客户端软件包"><a class="markdownIt-Anchor" href="#一-安装ftp客户端软件包"></a> 一、安装ftp客户端软件包</h1><p>在CentOS7中，采用yum来安装ftp客户端软件包，如果已经安装，再次执行yum就会把软件包升级到最新版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp</span><br></pre></td></tr></table></figure><h1 id="二-ftp的用户"><a class="markdownIt-Anchor" href="#二-ftp的用户"></a> 二、ftp的用户</h1><p>缺省情况下，ftp服务器操作系统用户名/密码也是ftp客户端登录的用户名/密码。root用户的权限过大，不允许登录ftp服务器。</p><h1 id="三-登录服务器"><a class="markdownIt-Anchor" href="#三-登录服务器"></a> 三、登录服务器</h1><p>方法一：输入<code>ftp 服务器ip地址</code>，回车后根据提示输入用户名和密码，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310101306304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>方法二：输入<code>ftp</code>，用<code>open 服务器ip地址</code>，连上服务器后再输入用户名和密码，如下图：</p><p><img src="https://img-blog.csdnimg.cn/2020031010134425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>方法三：输入<code>ftp -n 服务器ip地址</code>，再输入<code>user 用户名 密码登录</code>，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310101428852.png" alt="在这里插入图片描述" /></p><h1 id="四-切换工作目录"><a class="markdownIt-Anchor" href="#四-切换工作目录"></a> 四、切换工作目录</h1><p>注意，如果目录名中有特殊符号，如空格，可以用双引号把目录名包含起来。</p><h2 id="1-查看服务器工作目录"><a class="markdownIt-Anchor" href="#1-查看服务器工作目录"></a> 1、查看服务器工作目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h2 id="2-切换服务器工作目录"><a class="markdownIt-Anchor" href="#2-切换服务器工作目录"></a> 2、切换服务器工作目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 目录名</span><br></pre></td></tr></table></figure><h2 id="3-切换本地工作目录"><a class="markdownIt-Anchor" href="#3-切换本地工作目录"></a> 3、切换本地工作目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd 目录名</span><br></pre></td></tr></table></figure><h1 id="五-查看服务器上的目录和文件"><a class="markdownIt-Anchor" href="#五-查看服务器上的目录和文件"></a> 五、查看服务器上的目录和文件</h1><h2 id="1-列出目录或文件名的详细信息"><a class="markdownIt-Anchor" href="#1-列出目录或文件名的详细信息"></a> 1、列出目录或文件名的详细信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls  目录或文件名</span><br><span class="line">dir 目录或文件名</span><br></pre></td></tr></table></figure><p>ls和dir都可以用于查看目录和文件信息，常用ls，语法和Linux的ls命令相同。</p><p><img src="https://img-blog.csdnimg.cn/20200310101543989.png" alt="在这里插入图片描述" /></p><h2 id="2-仅列出目录和文件名"><a class="markdownIt-Anchor" href="#2-仅列出目录和文件名"></a> 2、仅列出目录和文件名</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nlist 目录或文件名 [本地文件名]</span><br></pre></td></tr></table></figure><p>1）列出/freecplus目录下的匹配*.h的文件名信息。</p><p><img src="https://img-blog.csdnimg.cn/20200310101803702.png" alt="在这里插入图片描述" /></p><p>2）列出/freecplus目录下的匹配*.h的文件名信息，结果输出到本地的/tmp/freecplus.list文件中。</p><p><img src="https://img-blog.csdnimg.cn/20200310101831141.png" alt="在这里插入图片描述" /></p><p>查看/tmp/freecplus.list内容。</p><p><img src="https://img-blog.csdnimg.cn/20200310101843361.png" alt="在这里插入图片描述" /></p><h1 id="六-下载上传文件"><a class="markdownIt-Anchor" href="#六-下载上传文件"></a> 六、下载/上传文件</h1><h2 id="1-文件传输入的模式"><a class="markdownIt-Anchor" href="#1-文件传输入的模式"></a> 1、文件传输入的模式</h2><p>ftp的传输模式分为二进制和ASCII码两种模式，二进制模式可以传输任何文件，包括压缩包、可执行程序、图片、视频、音频等，而ASCII模式只能传输.txt、.htm等ascii码文件（文本文件）。在实际开发中，不管什么文件，都用二进制方式传输文件。</p><p>1）查看当前的传输模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type</span><br></pre></td></tr></table></figure><p>2）设定传输模式为二进制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin</span><br></pre></td></tr></table></figure><p>3）设定传输模式为ASCII。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200310101912441.png" alt="在这里插入图片描述" /></p><h2 id="2-下载文件"><a class="markdownIt-Anchor" href="#2-下载文件"></a> 2、下载文件</h2><p>1）下载单个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get/recv 服务器文件名 [本地文件名]</span><br></pre></td></tr></table></figure><p>使用说明：</p><p>a）下载文件用get和recv都可以。</p><p>b）文件名不允许用通配符。</p><p>c）服务器文件名和本地文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p><p>d）如果本地文件名省略不写，表示把服务器文件下载到本地的当前工作目录，文件名与服务器文件名相同。</p><p>2）下载多个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget 服务器文件<span class="number">1</span> 服务器文件<span class="number">2</span> 服务器文件<span class="number">3</span> …… 服务器文件n</span><br></pre></td></tr></table></figure><p>使用说明：</p><p>a）待下载的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p><p>b）下载的文件，存放在本地当前工作目录中。</p><p>c）下载文件时，会一一提示，如果想关闭都显示信息，先输入prompt命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt</span><br></pre></td></tr></table></figure><h2 id="3-上传文件"><a class="markdownIt-Anchor" href="#3-上传文件"></a> 3、上传文件</h2><p>1）上传单个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put/send 本地文件名 [服务器文件名]</span><br></pre></td></tr></table></figure><p>a）上传文件用put和send都可以。</p><p>b）文件名不允许用通配符。</p><p>c）本地文件名和服务器文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p><p>d）如果服务器文件名省略不写，表示把本地文件上传到服务器的当前工作目录，文件名与本地文件名相同。</p><p>2）上传多个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mput 本地文件<span class="number">1</span> 本地文件<span class="number">2</span> 本地文件<span class="number">3</span> …… 本地文件n</span><br></pre></td></tr></table></figure><p>使用说明：</p><p>a）待上传的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p><p>b）上传的文件，存放在服务器当前工作目录中。</p><p>c）上传文件时，会一一提示，如果想关闭都显示信息，先输入prompt命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt</span><br></pre></td></tr></table></figure><h1 id="七-其它ftp命令"><a class="markdownIt-Anchor" href="#七-其它ftp命令"></a> 七、其它ftp命令</h1><p>1）重命名服务器上的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename 旧文件名 新文件名</span><br></pre></td></tr></table></figure><p>2）删除ftp服务器上单个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> 文件名</span><br></pre></td></tr></table></figure><p>3）删除多个文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdelete 文件名<span class="number">1</span> 文件名<span class="number">2</span> 文件名<span class="number">3</span> …… 文件名n</span><br></pre></td></tr></table></figure><p>4）在服务器上创建目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir pathname</span><br></pre></td></tr></table></figure><p>5）删除服务器上的目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir pathname</span><br></pre></td></tr></table></figure><p>6）切换传输模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passive</span><br></pre></td></tr></table></figure><p>7）显示帮助信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help [命令名]</span><br></pre></td></tr></table></figure><p>显示ftp命令的帮助信息，如果不输入命令名，则显示全ftp命令的帮助信息。</p><p>8）退出ftp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bye</span><br></pre></td></tr></table></figure><h1 id="八-windows的ftp客户端"><a class="markdownIt-Anchor" href="#八-windows的ftp客户端"></a> 八、Windows的ftp客户端</h1><p>在Windows的DOS命令提示符下输入ftp命令，但是不好用。</p><p>打开资源管理器，输入：<a href="ftp://%E6%9C%8D%E5%8A%A1%E5%99%A8ip%E5%9C%B0%E5%9D%80">ftp://服务器ip地址</a>，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310102206728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>在空白的位置点鼠标右键，选择登录菜单，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310102328728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />输入用户名和密码登录ftp服务器，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310102356906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>接下来的操作就像windows的目录文件操作一样了。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7配置防火墙</title>
      <link href="/posts/b47381a7.html"/>
      <url>/posts/b47381a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-防火墙的概念"><a class="markdownIt-Anchor" href="#一-防火墙的概念"></a> 一、防火墙的概念</h1><p>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。</p><p>专业的防火墙由软件和硬件组成，可以保护整个网络，价格也很贵，从几万到几十万的都有，功能非常强大，主要包括入侵检测、网络地址转换、网络操作的审计监控、强化网络安全服务等功能。</p><p>操作系统（Windows和Linux自带的）的防火墙只有软件部分，用于保护本操作系统，功能比较简单，只能防范简单的攻击。</p><p>本文的内容以介绍CentOS7以上版本防火墙的使用和配置为主。</p><h1 id="二-防火墙配置"><a class="markdownIt-Anchor" href="#二-防火墙配置"></a> 二、防火墙配置</h1><p>CentOS7的防火墙比CentOS6的功能更强大，配置方法和操作命令也完全不同。</p><p>CentOS7的防火墙规则既可以是端口，也可以是服务。</p><p>防火墙查看和配置以下介绍的命令，如果没有特别说明就表示需要管理员权限执行。</p><h2 id="1-查看防火墙的命令"><a class="markdownIt-Anchor" href="#1-查看防火墙的命令"></a> 1、查看防火墙的命令</h2><p>1）查看防火墙的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --version</span><br></pre></td></tr></table></figure><p>2）查看firewall的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>3）查看firewall服务状态（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>4）查看防火墙全部的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>5）查看防火墙已开通的端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-port</span><br></pre></td></tr></table></figure><p>6）查看防火墙已开通的服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-service</span><br></pre></td></tr></table></figure><p>7）查看全部的服务列表（普通用户可执行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><p>8）查看防火墙服务是否开机启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled firewalld</span><br></pre></td></tr></table></figure><h2 id="2-配置防火墙的命令"><a class="markdownIt-Anchor" href="#2-配置防火墙的命令"></a> 2、配置防火墙的命令</h2><p>1）启动、重启、关闭防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#启动</span><br><span class="line">systemctl start firewalld</span><br><span class="line">#重启</span><br><span class="line">systemctl restart firewalld</span><br><span class="line">#关闭</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>2）开放、移去某个端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放<span class="number">80</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">#移去<span class="number">80</span>端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-port=<span class="number">80</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>3）开放、移去范围端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放<span class="number">5000</span><span class="number">-5500</span>之间的端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">5000</span><span class="number">-5500</span>/tcp --permanent</span><br><span class="line">#移去<span class="number">5000</span><span class="number">-5500</span>之间的端口</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-port=<span class="number">5000</span><span class="number">-5500</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>4）开放、移去服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开放ftp服务</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-service=ftp --permanent</span><br><span class="line">#移去http服务</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --remove-service=ftp --permanent</span><br></pre></td></tr></table></figure><p>5）重新加载防火墙配置（修改配置后要重新加载防火墙配置或重启防火墙服务）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>6）设置开机时启用、禁用防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启用服务</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">#禁用服务</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h1 id="三-centos7以下版本"><a class="markdownIt-Anchor" href="#三-centos7以下版本"></a> 三、centos7以下版本</h1><p>1）开放80，22，8080 端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport <span class="number">80</span> -j ACCEPT</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport <span class="number">8080</span> -j ACCEPT</span><br></pre></td></tr></table></figure><p>2）保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure><p>3）查看打开的端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure><p>4）启动、关闭防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启动服务</span><br><span class="line">service iptables start</span><br><span class="line">#关闭服务</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p>5）设置开机时启用、禁用防火墙服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启用服务</span><br><span class="line">chkconfig iptables on</span><br><span class="line">#禁用服务</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure><h1 id="四-云平台访问策略配置"><a class="markdownIt-Anchor" href="#四-云平台访问策略配置"></a> 四、云平台访问策略配置</h1><p>如果您购买的是云服务器，除了配置云服务器的防火墙，还需要登录云服务器提供商的管理平台配置访问策略（或安全组）。</p><p>不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7系统服务管理</title>
      <link href="/posts/2764ee64.html"/>
      <url>/posts/2764ee64.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-systemctl介绍"><a class="markdownIt-Anchor" href="#一-systemctl介绍"></a> 一、systemctl介绍</h1><p>CentOS7启用了新的系统和服务管理器，采用systemctl命令代替了老版本的service和chkconfig。为了保持兼容性，在CentOS7中，老版本的service和chkconfig命令仍然可以使用。</p><p>systemctl命令是system（系统）和control（控制）两个单词的简写，它是一个功能强大的命令，本文只介绍与服务管理相关的用法。</p><p>systemctl命令有一点不足，就是很多命令执行后没有提示信息，例如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200310092636364.png" alt="在这里插入图片描述" /></p><p>上图中，执行启动和停止服务命令后没有“服务已启动”或“服务已关闭”等提示信息，让人很不习惯。还有，start和stop各执行了两次，也没有任何提示信息，这也让人很不习惯。</p><h1 id="二-systemctl常用命令"><a class="markdownIt-Anchor" href="#二-systemctl常用命令"></a> 二、systemctl常用命令</h1><h2 id="1-启动服务"><a class="markdownIt-Anchor" href="#1-启动服务"></a> 1、启动服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start name.service</span><br></pre></td></tr></table></figure><p>注意name.service的.service可以省略不写，以下两条命令的效果相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd             # 启动ftp服务。</span><br><span class="line">systemctl start vsftpd.service      # 启动ftp服务。</span><br></pre></td></tr></table></figure><h2 id="2-停止服务"><a class="markdownIt-Anchor" href="#2-停止服务"></a> 2、停止服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop name.service</span><br></pre></td></tr></table></figure><h2 id="3-重启服务"><a class="markdownIt-Anchor" href="#3-重启服务"></a> 3、重启服务</h2><p>如果服务没有启动，就启动它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart name.service</span><br></pre></td></tr></table></figure><h2 id="4-查看服务是否已启动"><a class="markdownIt-Anchor" href="#4-查看服务是否已启动"></a> 4、查看服务是否已启动</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-active name.service</span><br></pre></td></tr></table></figure><h2 id="5-查看服务的状态"><a class="markdownIt-Anchor" href="#5-查看服务的状态"></a> 5、查看服务的状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status name.service</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200310092839233.png" alt="在这里插入图片描述" /></p><p>Loaded：关于服务是否已经加载的信息，文件的绝对路径以及是否被启用的注释。</p><p>Active：服务是否正在运行,然后是启动时间信息。</p><p>Process：进程额外信息。</p><p>Main PID：服务主进程pid。</p><p>CGroup:Control Groups额外信息。</p><h2 id="6-启用开机自启动服务"><a class="markdownIt-Anchor" href="#6-启用开机自启动服务"></a> 6、启用开机自启动服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable name.service</span><br></pre></td></tr></table></figure><h2 id="7-停用开机自启动服务"><a class="markdownIt-Anchor" href="#7-停用开机自启动服务"></a> 7、停用开机自启动服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable name.service</span><br></pre></td></tr></table></figure><h2 id="8-查看服务是否为开机自启动"><a class="markdownIt-Anchor" href="#8-查看服务是否为开机自启动"></a> 8、查看服务是否为开机自启动</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled name.service</span><br></pre></td></tr></table></figure><h2 id="9-只重启正在运行中的服务"><a class="markdownIt-Anchor" href="#9-只重启正在运行中的服务"></a> 9、只重启正在运行中的服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">try</span>-restart name.service</span><br></pre></td></tr></table></figure><h2 id="10-显示所有的服务状态"><a class="markdownIt-Anchor" href="#10-显示所有的服务状态"></a> 10、显示所有的服务状态</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type service --all</span><br></pre></td></tr></table></figure><h2 id="11-查看启动成功的服务列表"><a class="markdownIt-Anchor" href="#11-查看启动成功的服务列表"></a> 11、查看启动成功的服务列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files|grep enabled</span><br></pre></td></tr></table></figure><h2 id="12-查看启动失败的服务列表"><a class="markdownIt-Anchor" href="#12-查看启动失败的服务列表"></a> 12、查看启动失败的服务列表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --failed</span><br></pre></td></tr></table></figure><h2 id="13-查看所有服务的状态"><a class="markdownIt-Anchor" href="#13-查看所有服务的状态"></a> 13、查看所有服务的状态</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --type service</span><br></pre></td></tr></table></figure><h2 id="14-列出在指定服务之前启动的服务依赖"><a class="markdownIt-Anchor" href="#14-列出在指定服务之前启动的服务依赖"></a> 14、列出在指定服务之前启动的服务（依赖）</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies --after name.service</span><br></pre></td></tr></table></figure><h2 id="15-列出在指定服务之后启动的服务被依赖"><a class="markdownIt-Anchor" href="#15-列出在指定服务之后启动的服务被依赖"></a> 15、列出在指定服务之后启动的服务（被依赖）</h2><p>按空格键显示下一页，按q键退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies --before name.service</span><br></pre></td></tr></table></figure><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装软件包的方法</title>
      <link href="/posts/27bd545e.html"/>
      <url>/posts/27bd545e.html</url>
      
        <content type="html"><![CDATA[<p>Linux有多种发行版本，各种发行版本之间安装软件包的方法和命令不一样，同发行版本之间安装软件包的方法也有不同。Linux主要有三大派系：红帽子派系（Redhat、Centos、Oracle Linux）、Debian派（Ubuntu、Kali），SUSE派系（SuSe、OpenSUSE）等。</p><p>红帽子派是Linux服务器操作系统的主流，本文重点介绍红帽子派系中rpm和yum安装软件包的方法。</p><h1 id="一-rpm安装"><a class="markdownIt-Anchor" href="#一-rpm安装"></a> 一、rpm安装</h1><p>RPM是RedHat Package Manager的缩写，由RedHat推出的软件包管理管理工具，在Fedora、Redhat、CentOS、Mandriva、SuSE、YellowDog等主流发行版本，以及在这些版本基础上二次开发出来的发行版采用。</p><p>RPM包里面包含可执行的二进制程序，自身所带的附加文件，版本文件（软件包的依赖关系）。</p><h2 id="1-查看系统中已安装的软件包"><a class="markdownIt-Anchor" href="#1-查看系统中已安装的软件包"></a> 1、查看系统中已安装的软件包</h2><p>1）查看已安装的软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端和ftp服务端软件包：</p><p><img src="https://img-blog.csdnimg.cn/20200309172432513.png" alt="在这里插入图片描述" /></p><p>2）查看软件包安装的目录和文件（包括了可执行程序、配置文件和帮助文档）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql ftp</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030917260113.png" alt="在这里插入图片描述" /></p><p>3）查看已安装软件包的详细信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端（显示内容太多，部分截图）：</p><p><img src="https://img-blog.csdnimg.cn/20200309172652175.png" alt="在这里插入图片描述" /></p><p>4）查看已安装软件包的配置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qc 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp服务端：</p><p><img src="https://img-blog.csdnimg.cn/20200309172731769.png" alt="在这里插入图片描述" /></p><p>5）查看已安装软件包所依赖的软件包及文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qR 软件包名</span><br></pre></td></tr></table></figure><p>例如查看ftp客户端（显示内容太多，部分截图）：</p><p><img src="https://img-blog.csdnimg.cn/20200309172811756.png" alt="在这里插入图片描述" /></p><h2 id="2-查看软件包的安装文件"><a class="markdownIt-Anchor" href="#2-查看软件包的安装文件"></a> 2、查看软件包的安装文件</h2><p>安装包文件的后缀是.rpm，以CentOS7为例，系统安装的光盘映像文件是CentOS-7-x86_64-DVD-1908.iso，解开后在Packages目录中有软件包的安装文件，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200309172824524.png" alt="在这里插入图片描述" /></p><p>接下来以ftp的客户端安装包文件ftp-0.17-67.el7.x86_64.rpm为例来介绍安装包文件的查看方法。</p><p>1）查看一个软件包的安装文件的详细信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpi 软件包的安装文件名</span><br></pre></td></tr></table></figure><p>（显示内容太多，部分截图）</p><p><img src="https://img-blog.csdnimg.cn/2020030917285624.png" alt="在这里插入图片描述" /></p><p>2）查看软件包的安装文件所包含的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpl 软件安装包文件名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309172931664.png" alt="在这里插入图片描述" /></p><p>3）查看软件包的依赖关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qpR 软件包的安装文件名</span><br></pre></td></tr></table></figure><p>（显示内容太多，部分截图）</p><p><img src="https://img-blog.csdnimg.cn/20200309173013619.png" alt="在这里插入图片描述" /></p><h2 id="3-安装升级软件包"><a class="markdownIt-Anchor" href="#3-安装升级软件包"></a> 3、安装/升级软件包</h2><p>如果待安装/升级的软件与其它的软件有依赖关系，请解决依赖关系，即先安装/升级依赖关系的软件包。如果没有解决好依赖关系，可以强制安装/升级，不推荐采用强制的方法，因为有可能导致软件不可用。</p><p>1）安装软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 软件包的安装文件名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309173042545.png" alt="在这里插入图片描述" /></p><p>2）升级软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh 软件包的安装文件名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309173114715.png" alt="在这里插入图片描述" /></p><p>3）强制安装软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 软件包的安装文件名 --nodeps --force</span><br></pre></td></tr></table></figure><p>4）强制升级软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpv -Uvh 软件包的安装文件名 --nodeps --force</span><br></pre></td></tr></table></figure><h2 id="4-删除软件包"><a class="markdownIt-Anchor" href="#4-删除软件包"></a> 4、删除软件包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e 软件包名</span><br></pre></td></tr></table></figure><p>例如删除ftp客户端软件包：</p><p><img src="https://img-blog.csdnimg.cn/2020030917324431.png" alt="在这里插入图片描述" /></p><h1 id="二-yum安装"><a class="markdownIt-Anchor" href="#二-yum安装"></a> 二、yum安装</h1><p>rpmp安装软件包的虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件包需要安装多个其他软件包，还有不同版本的兼容性问题，很复杂。yum解决了这些问题，yum是rpm的前端程序，设计的主要目的就是为了自动解决rpm的依赖关系，有以下优点：</p><ol><li><p>自动解决依赖关系；</p></li><li><p>可以对rpm进行分组，基于组进行安装操作；</p></li><li><p>引入仓库概念，支持多个仓库；</p></li><li><p>配置简单。</p></li></ol><h2 id="1-yum的语法"><a class="markdownIt-Anchor" href="#1-yum的语法"></a> 1、yum的语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure><p>options：可选参数：1）-h帮助；2）-y，当安装过程提示选择全部为yes，不需要再次确认；3）-q，不显示安装的过程。</p><p>command：待操作的命令。</p><p>package：待操作的软件包名，多个软件包之间用空格分开，支持用星号*匹配。</p><h2 id="2-yum的常用命令"><a class="markdownIt-Anchor" href="#2-yum的常用命令"></a> 2、yum的常用命令</h2><p>最最常用的命令加粗显示。</p><p><strong>1）安装/升级软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 软件包名/软件包文件名</span><br></pre></td></tr></table></figure><p><strong>2）升级软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update 软件包名</span><br></pre></td></tr></table></figure><p><strong>3）删除软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove 软件包名</span><br></pre></td></tr></table></figure><p><strong>4）查找软件包。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search 软件包名</span><br></pre></td></tr></table></figure><p>5）列出所有可更新的软件包清单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></table></figure><p>6）更新所有软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p>7）列出所有可安装软件包的清单；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list</span><br></pre></td></tr></table></figure><p>8）清除缓存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean [headers|packages|metadata|dbcache|plugins|expire-cache|all]</span><br></pre></td></tr></table></figure><h2 id="3-示例"><a class="markdownIt-Anchor" href="#3-示例"></a> 3、示例</h2><p>1）安装/升级ftp客户端软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp<span class="number">-0.17</span><span class="number">-67.</span>el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>2）升级ftp客户端软件包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update ftp</span><br></pre></td></tr></table></figure><p>3）删除ftp客户端软件包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove ftp</span><br></pre></td></tr></table></figure><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>1）rpm安装/升级软件包需要手工的解决包的依赖关系，这一点让人确实很烦，所以，软件包的安装/升级一般采用yum命令。</p><p>2）rpm的某些功能，例如查看软件包的详细信息、软件包的安装目录、软件包的配置文件等还是有实用价值的。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7设置中文字符集</title>
      <link href="/posts/27842c1f.html"/>
      <url>/posts/27842c1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-字符编码和字符集"><a class="markdownIt-Anchor" href="#一-字符编码和字符集"></a> 一、字符编码和字符集</h1><h2 id="1-字符编码character-encoding"><a class="markdownIt-Anchor" href="#1-字符编码character-encoding"></a> 1、字符编码（character encoding）：</h2><p>字符编码是一种法则，在数字与符号之间建立的对应关系。不同的国家有不同的语言，包含的文字、标点符号、图形符号各有不同。例如在ASCII编码中，用数字97表达字符’a’与字符集相对应，常见的字符编码有ASCII，GBK，GB18030，Unicode等。</p><h2 id="2-字符集character-set"><a class="markdownIt-Anchor" href="#2-字符集character-set"></a> 2、字符集（Character set）</h2><p>字符集是字符的集合，字符是文字和符号的总称，用ASCII编码的字符集称之为ASCII字符集，用GBK编码的字符集称之为GBK字符集。</p><h2 id="3-国际编码unicode"><a class="markdownIt-Anchor" href="#3-国际编码unicode"></a> 3、国际编码（Unicode）</h2><p>为了解决传统的字符编码方案的局限，1994年发布了Unicode（国际编码、统一码、万国码、单一码、通用码），它是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 将全世界所有的字符统一化，统一编码，再也不存在字符集不兼容和字符转换的问题。</p><p>Unicode 有以下三种编码方式：</p><p>1）UTF-8：兼容ASCII编码；拉丁文、希腊文等使用两个字节；包括汉字在内的其它常用字符使用三个字节；剩下的极少使用的字符使用四个字节。</p><p>2）UTF-16：对相对常用的60000余个字符使用两个字节进行编码，其余的使用4字节。</p><p>3）UTF-32：固定使用4个字节来表示一个字符，存在空间利用效率的问题。</p><h1 id="二-汉字的编码"><a class="markdownIt-Anchor" href="#二-汉字的编码"></a> 二、汉字的编码</h1><h2 id="1-汉字的编码"><a class="markdownIt-Anchor" href="#1-汉字的编码"></a> 1、汉字的编码</h2><p>支持汉字（简体中文）的编码有GB2312、GB13000、GBK、GB18030和Unicode（UTF-8、UTF-16、UTF-32）。</p><p>1）GB2312</p><p>仅包含大部分的常用简体汉字，但已经不能适应现在的需要。</p><p>2）GB13000</p><p>由于GB2312的局限性，国家标准化委员会制定了GB13000编码；但由于当时的硬件和软件都已经支持了GB2312，而GB13000与GB2312完全不兼容，所以没有能够得到大范围的推广使用。</p><p>3）GBK</p><p>有了GB13000的教训，中国国家标准化委员会制定了GBK标准，并兼容了GB2312标准，同时在GB2312标准的基础上扩展了GB13000包含的字；由于该标准有微软的支持，得到了广泛的应用。</p><p>4）GB18030</p><p>GB18030编码比GBK又新增了几千个汉字，但由于码位不足使用了2byte与4byte混合编码方式，这给软件开发增加了难度。</p><p>5）Unicode</p><p>包含全世界所有国家需要用到的字符，是国际编码，通用性强。</p><h2 id="2-汉字的编码选择"><a class="markdownIt-Anchor" href="#2-汉字的编码选择"></a> 2、汉字的编码选择</h2><p>在操作系统和数据库中，常用的汉字编码有GBK、GB18030和Unicode，GBK和GB18030的优势是占用空间小，Unicode的优势是全球化的支持。</p><p>在应用开发中，如果不考虑全球化，最好的选择是GBK和GB18030。</p><h2 id="3-编码的转换"><a class="markdownIt-Anchor" href="#3-编码的转换"></a> 3、编码的转换</h2><p>GBK和GB18030与Unicode编码之间需要转换，否则会出现汉字乱码。</p><h1 id="三-设置linux的字符集"><a class="markdownIt-Anchor" href="#三-设置linux的字符集"></a> 三、设置Linux的字符集</h1><h2 id="1-查看当前系统已安装的字符集"><a class="markdownIt-Anchor" href="#1-查看当前系统已安装的字符集"></a> 1、查看当前系统已安装的字符集</h2><p>1）locale命令用于查看当前系统全部的已安装的字符集，Linux支持的符集约800种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a</span><br></pre></td></tr></table></figure><p>2）查看已安装的中文字符集（只查看中国大陆的，不包括香港和台湾）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a|grep zh_CN</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311112001745.png" alt="在这里插入图片描述" /></p><p>上图表示已经安装了中文字符集。</p><h2 id="2-安装中文字符集"><a class="markdownIt-Anchor" href="#2-安装中文字符集"></a> 2、安装中文字符集</h2><p>如果您的Linux系统没有安装中文字符集，可以用yum命令安装。</p><p>我查了一些资料，安装中文字符集软件包的方法比较多，没找到准确的说法，所以把多种方法都写了进来，以下命令都可以执行，不会有副作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall chinese-support</span><br><span class="line">yum -y install chinese-support</span><br><span class="line">yum -y install kde-l10n-Chinese</span><br><span class="line">yum -y install ibus-table-chinese<span class="number">-1.4</span><span class="number">.6</span><span class="number">-3.</span>el7.noarch</span><br></pre></td></tr></table></figure><p>安装后，执行<code>locale -a|grep zh_CN</code>，如果显示的内容如下，表示安装成功。</p><p><img src="https://img-blog.csdnimg.cn/20200311112105986.png" alt="在这里插入图片描述" /></p><h2 id="3-修改字符集配置文件"><a class="markdownIt-Anchor" href="#3-修改字符集配置文件"></a> 3、修改字符集配置文件</h2><p>CentOS6.x 字符集配置文件在/etc/sysconfig/i18n文件中。</p><p>CentOS7.x 字符集配置文件在/etc/locale.conf文件中，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200311112120723.png" alt="在这里插入图片描述" /></p><p>执行以下命令或者重启系统使修改生效。</p><p>CentOS6.x</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/sysconfig/i18n</span><br></pre></td></tr></table></figure><p>CentOS7.x:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/locale.conf</span><br></pre></td></tr></table></figure><h1 id="四-lang环境变量"><a class="markdownIt-Anchor" href="#四-lang环境变量"></a> 四、LANG环境变量</h1><p>LANG环境变量存放的是Linux系统的语言、地区、字符集，它不需要系统管理员手工设置，/etc/profile会调用/etc/profile.d/lang.sh脚本完成对PATH的设置。</p><h1 id="五-修改客户端的字符集"><a class="markdownIt-Anchor" href="#五-修改客户端的字符集"></a> 五、修改客户端的字符集</h1><p>客户端的字符集必须与Linux服务端一致，否则会出现乱码，以SecureCRT为例。修改会话的属性，在Appearance界面中的Character<br />encoding下拉框中选择。</p><p><img src="https://img-blog.csdnimg.cn/20200311112259313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="六-字符集转换工具"><a class="markdownIt-Anchor" href="#六-字符集转换工具"></a> 六、字符集转换工具</h1><p>Linux提供了iconv命令把文件内容从一种编码转换成另一种编码。</p><p>参数说明：</p><p>--list：列出iconv支持的编码列表。</p><p>-f encoding：源文件内容的编码。</p><p>-t encoding：目标文件内容的编码。</p><p>-o file：指定输出文件。</p><p>-c：忽略输出的非法字符。</p><p>-l：列出已知的编码字符集。</p><p>-s：禁止警告信息，但不是错误信息。</p><p>--verbose：显示进度信息。</p><p>示例：</p><p>把当前目录的book1.c由gbk转换成utf-8，结果输出到/tmp/book1_utf8.c中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f gbk -t utf<span class="number">-8</span> book1.c -o /tmp/book1_utf8.c</span><br></pre></td></tr></table></figure><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>1）Linux系统在业务化之前，就应该确定字符集，然后不再改变。系统在业务化后，修改字符集是一件很麻烦的事情，最好别惹这个麻烦。</p><p>2）如果项目没有全球化的需求，Linux的字符集建议采用zh_CN.gbk。</p><p>3）虽然gb18030字符集比gbk更丰富，但是gb18030中有部分汉字是4字节，这一点让程序员很郁闷，所以，程序员更倾向gbk字符集。</p><p>4）设置Linux的字符集时，还要考虑WEB系统和数据库系统采用的字符集，最好是大家都保持一致。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7设置环境变量</title>
      <link href="/posts/922d601b.html"/>
      <url>/posts/922d601b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-环境变量的概念"><a class="markdownIt-Anchor" href="#一-环境变量的概念"></a> 一、环境变量的概念</h1><h2 id="1-环境变量的含义"><a class="markdownIt-Anchor" href="#1-环境变量的含义"></a> 1、环境变量的含义</h2><p>程序（操作系统命令和应用程序）的执行都需要运行环境，这个环境是由多个环境变量组成的。</p><h2 id="2-环境变量的分类"><a class="markdownIt-Anchor" href="#2-环境变量的分类"></a> 2、环境变量的分类</h2><p>1）按生效的范围分类。</p><p><strong>系统环境变量</strong>：公共的，对全部的用户都生效。</p><p><strong>用户环境变量</strong>：用户私有的、自定义的个性化设置，只对该用户生效。</p><p>2）按生存周期分类。</p><p><strong>永久环境变量</strong>：在环境变量脚本文件中配置，用户每次登录时会自动执行这些脚本，相当于永久生效。</p><p><strong>临时环境变量</strong>：使用时在Shell中临时定义，退出Shell后失效。</p><h2 id="3-linux环境变量"><a class="markdownIt-Anchor" href="#3-linux环境变量"></a> 3、Linux环境变量</h2><p>Linux环境变量也称之为Shell环境量变，以下划线和字母打头，由下划线、字母（区分大小写）和数字组成，习惯上使用大写字母，例如PATH、HOSTNAME、LANG等。</p><h1 id="二-常用的环境变量"><a class="markdownIt-Anchor" href="#二-常用的环境变量"></a> 二、常用的环境变量</h1><h2 id="1-查看环境变量"><a class="markdownIt-Anchor" href="#1-查看环境变量"></a> 1、查看环境变量</h2><p>1）env命令</p><p>在Shell下，用env命令查看当前用户全部的环境变量。</p><p><img src="https://img-blog.csdnimg.cn/20200309153619141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>上图只截取了部分环境变量，并非全部。</p><p>用env命令的时候，满屏显示了很多环境变量，不方便查看，可以用grep筛选。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env|grep 环境变量名</span><br></pre></td></tr></table></figure><p>例如查看环境变量名中包含PATH的环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env|grep PATH</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309153737428.png" alt="在这里插入图片描述" /></p><p>2）echo命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $环境变量名</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309154019391.png" alt="在这里插入图片描述" /></p><p>注意，符号$不能缺少，这是语法规定。</p><h2 id="2-常用的环境变量"><a class="markdownIt-Anchor" href="#2-常用的环境变量"></a> 2、常用的环境变量</h2><p>1）PATH</p><p>可执行程序的搜索目录，可执行程序包括Linux系统命令和用户的应用程序，PATH变量的具体用法本文后面的章节中有详细的介绍。</p><p><img src="https://img-blog.csdnimg.cn/2020030915405165.png" alt="在这里插入图片描述" /></p><p>2）LANG</p><p>Linux系统的语言、地区、字符集，LANG变量的具体用法本文后面的章节中有详细的介绍。</p><p><img src="https://img-blog.csdnimg.cn/20200309154112233.png" alt="在这里插入图片描述" /></p><p>3）HOSTNAME</p><p>服务器的主机名。</p><p>4）SHELL</p><p>用户当前使用的Shell解析器。</p><p>5）HISTSIZE</p><p>保存历史命令的数目。</p><p>6）USER</p><p>当前登录用户的用户名。</p><p>7）HOME</p><p>当前登录用户的主目录。</p><p>8）PWD</p><p>当前工作目录。</p><p>9）LD_LIBRARY_PATH</p><p>C/C<ins>语言动态链接库文件搜索的目录，它不是Linux缺省的环境变量，但对C/C</ins>程序员来说非常重要，具体用法本文后面的章节中有详细的介绍。</p><p>10）CLASSPATH</p><p>JAVA语言库文件搜索的目录，它也不是Linux缺省的环境变量，但对JAVA程序员来说非常重要，具体用法本文后面的章节中有详细的介绍。</p><h1 id="三-设置环境量"><a class="markdownIt-Anchor" href="#三-设置环境量"></a> 三、设置环境量</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名=<span class="string">&#x27;值&#x27;</span></span><br><span class="line"><span class="keyword">export</span> 变量名</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> 变量名=<span class="string">&#x27;值&#x27;</span></span><br></pre></td></tr></table></figure><p>如果环境变量的值没有空格等特殊符号，可以不用单引号包含。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ORACLE_HOME=/oracle/home</span><br><span class="line"><span class="keyword">export</span> ORACLE_BASE=/oracle/base</span><br><span class="line"><span class="keyword">export</span> ORACLE_SID=snorcl11g</span><br><span class="line"><span class="keyword">export</span> NLS_LANG=<span class="string">&#x27;Simplified Chinese_China.ZHS16GBK&#x27;</span></span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin:.</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib:.</span><br></pre></td></tr></table></figure><p>采用export设置的环境变量，在退出Shell后就会失效，下次登录时需要重新设置。如果希望环境变量永久生效，需要在登录脚本文件中配置。</p><h2 id="1-系统环境变量"><a class="markdownIt-Anchor" href="#1-系统环境变量"></a> 1、系统环境变量</h2><p>系统环境变量对全部的用户生效，设置系统环境变量有三种方法。</p><p>1）在/etc/profile文件中设置。</p><p>用户登录时执行/etc/profile文件中设置系统的环境变量。但是，Linux不建议在/etc/profile文件中设置系统环境变量。</p><p>2）在/etc/profile.d目录中增加环境变量脚本文件，这是Linux推荐的方法。</p><p>/etc/profile在每次启动时会执行/etc/profile.d下全部的脚本文件。/etc/profile.d比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d下对应的 shell 脚本即可。</p><p>/etc/profile.d目录下有很多脚本文件，例如：</p><p><img src="https://img-blog.csdnimg.cn/20200309154305141.png" alt="在这里插入图片描述" /></p><p>在以上示例中，/etc/profile.d目录中的oracle.sh是Oracle数据库的环境变量配置文件，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200309154317585.png" alt="在这里插入图片描述" /></p><p>3）在/etc/bashrc文件中设置环境变量。</p><p>该文件配置的环境变量将会影响全部用户使用的bash shell。但是，Linux也不建议在/etc/bashrc文件中设置系统环境变量。</p><h2 id="2-用户环境变量"><a class="markdownIt-Anchor" href="#2-用户环境变量"></a> 2、用户环境变量</h2><p>用户环境变量只对当前用户生效，设置用户环境变量也有多种方法。</p><p>在用户的主目录，有几个特别的文件，用<code>ls</code>是看不见的，用 <code>ls .bash_*</code> 可以看见。</p><p><img src="https://img-blog.csdnimg.cn/20200309155024757.png" alt="在这里插入图片描述" /></p><p>1）.bash_profile（推荐首选）</p><p>当用户登录时执行，每个用户都可以使用该文件来配置专属于自己的环境变量。</p><p>2）.bashrc</p><p>当用户登录时以及每次打开新的Shell时该文件都将被读取，不推荐在里面配置用户专用的环境变量，因为每开一个Shell，该文件都会被读取一次，效率肯定受影响。</p><p>3）.bash_logout</p><p>当每次退出系统（退出bash shell）时执行该文件。</p><p>4）.bash_history</p><p>保存了当前用户使用过的历史命令。</p><h2 id="3-环境变量脚本文件的执行顺序"><a class="markdownIt-Anchor" href="#3-环境变量脚本文件的执行顺序"></a> 3、环境变量脚本文件的执行顺序</h2><p>环境变量脚本文件的执行顺序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile-&gt;/etc/profile.d-&gt;/etc/bashrc-&gt;用户的.bash_profile-&gt;用户的.bashrc</span><br></pre></td></tr></table></figure><p>同名的环境变量，如果在多个脚本中有配置，以最后执行的脚本中的配置为准。</p><p>还有一个问题需要注意，在/etc/profile中执行了/etc/profile.d的脚本，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in /etc/profile.d<span class="comment">/*.sh ; do</span></span><br><span class="line"><span class="comment">    if [ -r &quot;$i&quot; ]; then</span></span><br><span class="line"><span class="comment">        if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then</span></span><br><span class="line"><span class="comment">            . &quot;$i&quot;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            . &quot;$i&quot; &gt;/dev/null</span></span><br><span class="line"><span class="comment">        fi</span></span><br><span class="line"><span class="comment">    fi</span></span><br><span class="line"><span class="comment">done</span></span><br></pre></td></tr></table></figure><p>所以，/etc/profile.d和/etc/profile的执行顺序还要看代码怎么写。</p><h1 id="四-重要环境变量的详解"><a class="markdownIt-Anchor" href="#四-重要环境变量的详解"></a> 四、重要环境变量的详解</h1><h2 id="1-path环境变量"><a class="markdownIt-Anchor" href="#1-path环境变量"></a> 1、PATH环境变量</h2><p>可执行程序的搜索目录，可执行程序包括Linux系统命令和用户的应用程序。如果可执行程序的目录不在PATH指定的目录中，执行时需要指定目录。</p><p>1）PATH环境变量存放的是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=目录<span class="number">1</span>:目录<span class="number">2</span>:目录<span class="number">3</span>:......目录n:.</span><br></pre></td></tr></table></figure><p>2）PATH缺省包含了Linux系统命令所在的目录（/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin），如果不包含这些目录，Linux的常用命令也无法执行（要输入绝对路径才能执行）。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200309155421291.png" alt="在这里插入图片描述" /></p><p>3）在用户的.bash_profile文件中，会对PATH进行扩充，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure><p>4）如果PATH变量中没有包含圆点.，执行当前目录下的程序需要加./或使用绝对路径。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200309155459804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="2-lang环境变量"><a class="markdownIt-Anchor" href="#2-lang环境变量"></a> 2、LANG环境变量</h2><p>LANG环境变量存放的是Linux系统的语言、地区、字符集，它不需要系统管理员手工设置，/etc/profile会调用/etc/profile.d/lang.sh脚本完成对PATH的设置。</p><p>CentOS6.x  字符集配置文件在/etc/syscconfig/i18n文件中。</p><p>CentOS7.x 字符集配置文件在/etc/locale.conf文件中，内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200309155523512.png" alt="在这里插入图片描述" /></p><h2 id="3-ld_library_path环境变量"><a class="markdownIt-Anchor" href="#3-ld_library_path环境变量"></a> 3、LD_LIBRARY_PATH环境变量</h2><p>C/C<ins>语言动态链接库文件搜索的目录，它不是Linux缺省的环境变量，但对C/C</ins>程序员来说非常重要。</p><p>LD_LIBRARY_PATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=目录<span class="number">1</span>:目录<span class="number">2</span>:目录<span class="number">3</span>:......目录n:.</span><br></pre></td></tr></table></figure><h2 id="4-classpath"><a class="markdownIt-Anchor" href="#4-classpath"></a> 4、CLASSPATH</h2><p>JAVA语言库文件搜索的目录，它也不是Linux缺省的环境变量，但对JAVA程序员来说非常重要。</p><p>CLASSPATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。</p><h1 id="五-环境变量的生效"><a class="markdownIt-Anchor" href="#五-环境变量的生效"></a> 五、环境变量的生效</h1><p>1）在Shell下，用export设置的环境变量对当前Shell立即生效，Shell退出后失效。</p><p>2）在脚本文件中设置的环境变量不会立即生效，退出Shell后重新登录时才生效，或者用source命令让它立即生效，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h1 id="六-应用经验"><a class="markdownIt-Anchor" href="#六-应用经验"></a> 六、应用经验</h1><p>虽然设置环境变量的方法有多种，但是建议系统环境变量建议在/etc/profile.d目录中配置，用户环境变量在用户的.bash_profile中配置，不建议在其它脚本文件中配置环境变，会增加运维的麻烦，容易出错。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vi常用命令</title>
      <link href="/posts/5e60c079.html"/>
      <url>/posts/5e60c079.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-关于vi"><a class="markdownIt-Anchor" href="#一-关于vi"></a> 一、关于vi</h1><p>vi是最强大的文本编辑器，没有之一。尽管 vi已经是古董级的软件，但还是有无数新人迎着困难去学习，可见其经典与受欢迎的程度。</p><p>无论是小说中还是电视剧，真正强大的武器都不容易驾驭，需要付出一些努力才能收获到更加强大的力量，对于vi这<strong>上古神器</strong>说更是如此。由于它全程使用键盘操作，很多首次接触<br />vi的人会觉得不习惯而中途放弃。然而，坚持下来的朋友就会渐渐地发现这种键盘操作的设计绝妙，经典之所以能成为经典，必然有它的道理，不用解释太多。</p><p>观察一个程序员对vi的熟练程度，可以判断它的技术水平，如果他对vi不熟悉，就肯定不是Linux平台下的程序员，说vi不好用的人也肯定不熟悉vi和Linux，没有例外。</p><h1 id="二-创建打开文件"><a class="markdownIt-Anchor" href="#二-创建打开文件"></a> 二、创建/打开文件</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名</span><br></pre></td></tr></table></figure><p>打开一个文件，如果文件不存在，就创建它。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi book.c</span><br></pre></td></tr></table></figure><h1 id="三-vi的三种模式"><a class="markdownIt-Anchor" href="#三-vi的三种模式"></a> 三、vi的三种模式</h1><p>vi<br />有三种模式，命令行模式、插入模式和替换模式，在命令行模式下，任何键盘输入都是命令，在插入模式和替换模式下，键盘输入的才是字符。</p><p>插入模式和替换模式也合称为编辑模式。</p><h1 id="四-vi的常用命令"><a class="markdownIt-Anchor" href="#四-vi的常用命令"></a> 四、vi的常用命令</h1><p>Esc 从编辑模式切换到命令行模式。</p><p>i 在光标所在位置前面开始插入。</p><p>a 在光标所在的位置后面开始插入。</p><p>o 在光标所在位置行的下面插入空白行。</p><p>O 在光标所在位置行的上面插入空白行。</p><p>I 在光标所在位置行的行首开始插入。</p><p>A 在光标所在位置行的行末开始插入。</p><p>k 类似方向键上。</p><p>j 类似方向键下。</p><p>h 类似方向键左。</p><p>l 类是方向键右。</p><p>Ctrl+u 向上翻半页。</p><p>Ctrl+d 向下翻页。</p><p>nG 光标跳到文件的第n行行首。</p><p>G 光标跳到文件最后一行。</p><p>:5回车 光标跳到第5行。</p><p>:n回车 光标跳到第n行。</p><p>0 光标跳到当前行的行首。</p><p>$ 光标跳到当前行的行尾。</p><p>w 光标跳到下个单词的开头。</p><p>b 光标跳到上个单词的开头。</p><p>e 光标跳到本单词的尾部。</p><p>x 每按一次，删除光标所在位置的一个字符。</p><p>nx 如&quot;3x&quot;表示删除光标所在位置开始的3个字符。</p><p>dw 删除光标所在位置到本单词结尾的字符。</p><p>D 删除本行光标所在位置后面全部的内容。</p><p>dd 删除光标所在位置的一行。</p><p>ndd 如&quot;3dd&quot;表示删除光标所在位置开始的3行。</p><p>yy 将光标所在位置的一行复制到缓冲区。</p><p>nyy 将光标所在位置的n行复制到缓冲区。</p><p>p 将缓冲区里的内容粘贴到光标所在位置。</p><p>r 替换光标所在位置的一个字符 replace。</p><p>R 从光标所在位置开始替换，直到按下&quot;Esc&quot;。</p><p>cw 从光标所在位置开始替换单词，直到按下&quot;Esc&quot;。</p><p>u 撤销命令，可多次撤销。</p><p>J 把当前行的下一行接到当前行的尾部。</p><p>Ctrl+g 显示光标所在位置的行号和文件的总行数。</p><p>/abcd 在当前打开的文件中查找“abcd”文本内容。</p><p>n 查找下一个。</p><p>N 查找上一下。</p><p>. 重复执行上一次执行的vi命令。</p><p>~ 对光标当前所在的位置的字符进行大小写转换。</p><p>列操作</p><p>Ctrl+V 光标上或下 大写的I 输入内容 Esc</p><p>:w回车 存盘。</p><p>:w!回车 强制存盘。</p><p>:wq回车 存盘退出。</p><p>:x回车 存盘退出。</p><p>:q回车 不存盘退出。</p><p>:q!回车 不存盘强制退出。</p><p>:g/aaaaaaaaa/s//bbbbbb/g回车 把文件中全部的aaaaaaaaa替换成bbbbbb。</p><p>Ctl+insert 复制鼠标选中的文本，相当于Ctl+c。</p><p>Shift+insert 输出鼠标选中的文本，相当于Ctl+v。</p><p>以上两个命令在windows和UNIX中是通用的。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。</p><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）</p><p>作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/posts/d0edc1ed.html"/>
      <url>/posts/d0edc1ed.html</url>
      
        <content type="html"><![CDATA[<p>Linux的命令有几百个，对程序员来说，常用的并不多，并不需要全部掌握。如果在学习和工作中遇到了陌生的Linux命令，不要轻易放过，多查资料，掌握它，日积月累，知识面就会宽广。</p><p>本文介绍的是Linux的常用命令，对初学者来说，建议系统化的学习Linux基础知识。</p><p>推荐视频：<a href="https://www.bilibili.com/video/av18156598">https://www.bilibili.com/video/av18156598</a></p><p>这个视频非本人录制，因为好所以推荐。</p><h2 id="1-开机"><a class="markdownIt-Anchor" href="#1-开机"></a> 1、开机</h2><p>物理机服务器：按下电源开关，就像Windows开机一样。</p><p>本地虚拟机：在VMware中点击“开启此虚拟机”。</p><h2 id="2-登录"><a class="markdownIt-Anchor" href="#2-登录"></a> 2、登录</h2><p>启动完成后，输入用户名和密码，一般情况下，不要用root用户登录，<strong>root用户的权限太大，如果产生了误操作，后果相当严重。</strong></p><h2 id="3-切换用户"><a class="markdownIt-Anchor" href="#3-切换用户"></a> 3、切换用户</h2><p>在命令提示符下输入：<code>su - root</code> ，然后按提示输入root的密码后将切换到root用户。</p><p>从root用户切换到其它普通用户不需要输入密码，从普通用户切换到任何用户都需要输入密码。</p><p><img src="https://img-blog.csdnimg.cn/2020030911452493.png" alt="在这里插入图片描述" /></p><h2 id="4-重启和关机"><a class="markdownIt-Anchor" href="#4-重启和关机"></a> 4、重启和关机</h2><p>重启和关机需要系统管理员用户权限。</p><p>1）重启。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init <span class="number">6</span> 或 reboot</span><br></pre></td></tr></table></figure><p>2）关机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init <span class="number">0</span> 或 halt</span><br></pre></td></tr></table></figure><p>如果没有执行关机命令，强制断电或关闭本地虚拟机的窗口，会导致Linux操作系统文件的损坏，严重的可能导致系统无法正常启动。</p><h2 id="5-清屏"><a class="markdownIt-Anchor" href="#5-清屏"></a> 5、清屏</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><p>清除当前屏幕上显示的内容。</p><h2 id="6-查看服务器的ip地址"><a class="markdownIt-Anchor" href="#6-查看服务器的ip地址"></a> 6、查看服务器的ip地址</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309114609137.png" alt="在这里插入图片描述" /></p><p>上图中，框中显示的就是IP地址。</p><h2 id="7-时间操作"><a class="markdownIt-Anchor" href="#7-时间操作"></a> 7、时间操作</h2><p>普通用户可以查看时间，但设置时区和时间要系统管理员用户登录 。</p><p>1）查看时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p>2）设置时区为中国上海时间（注意不是北京时间）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure><p>3）设置时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s <span class="string">&quot;yyyy-mm-dd hh:mi:ss&quot;</span></span><br></pre></td></tr></table></figure><p>例如：<code>date -s &quot;2020-01-02 12:35:28&quot;</code></p><p>4）把操作系统的时间写入CMOS。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock -w</span><br></pre></td></tr></table></figure><h2 id="8-目录和文件"><a class="markdownIt-Anchor" href="#8-目录和文件"></a> 8、目录和文件</h2><p>文件系统是像一棵树，树干是/（根）目录，树枝是子目录，树枝后面还有树枝（子目录中还有子目录），树枝最后是树叶，目录的最后是文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114643132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>严谨的说，文件名是由<strong>目录+文件名</strong>组成的。</p><p>对于目录和文件，有一些约定的表述，我们以/usr/etc/readme.txt为例。</p><p>1）<strong>全路径文件名</strong>包含了完整的目录名和文件名，即/usr/etc/readme.txt，还有一个称呼是“绝<strong>对路径文件名</strong>”。</p><p>2）readme.txt是文件名，它在/usr/etc目录中。</p><p>3）目录和文件的<strong>绝对路径</strong>是从根（/）算起，在任何时候都不会有岐义。</p><p>4）登录Linux后，一定处在目录树的某个目录中，这个目录称之为当前工作目录，简称<strong>当前目录</strong>。</p><p>5）目录和文件的<strong>相对路径</strong>是从当前目录算起，如果当前目录是/usr，etc/readme.txt等同于/usr/etc/readme.txt；如果当前目录是/usr/etc，readme.txt等同于/usr/etc/readme.txt。</p><p>6）用Linux的命令操作目录和文件的时候，采用绝对路径和相对路径都可以。</p><p>7）一个圆点.表示当前目录；</p><p>8）两个圆点…表示当前目录的上一级目录。</p><p><strong>理解绝对路径和相对路径的概念非常重要，在日常操作中，绝对路径和相对路径会同时使用，但是程序员在编写的程序中极少使用相对路径。</strong></p><h2 id="9-正则表达式"><a class="markdownIt-Anchor" href="#9-正则表达式"></a> 9、正则表达式</h2><p>正则表达式又称规则表达式、通配符，目录和文件名都支持正则表达式，正则表达式的规则比较多，在这里我只介绍最常用的两种：星号“*”和问号“?”。</p><p>星号“*”：匹配任意数量的字符。</p><p>问号“?”：匹配一个的字符。</p><p>示例：</p><p>当前目录下有以下几个文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book15  book15.c  book1.c  book5.c  makefile</span><br></pre></td></tr></table></figure><p>1）列出全部的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114820457.png" alt="在这里插入图片描述" /></p><p>2）列出文件名以book打头，.c结尾，中间可以是任意数量的字符的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114828791.png" alt="在这里插入图片描述" /></p><p>3）列出文件名以book打头，.c结尾，中间只能有一个字符的文件。</p><p><img src="https://img-blog.csdnimg.cn/20200309114842120.png" alt="在这里插入图片描述" /></p><h2 id="10-查看当前目录"><a class="markdownIt-Anchor" href="#10-查看当前目录"></a> 10、查看当前目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309144153568.png" alt="在这里插入图片描述" /></p><h2 id="11-改变当前目录"><a class="markdownIt-Anchor" href="#11-改变当前目录"></a> 11、改变当前目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 目录名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）进入/tmp目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br></pre></td></tr></table></figure><p>2）进入上一级目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>3）进入用户的主目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure><h2 id="12-列出目录和文件信息"><a class="markdownIt-Anchor" href="#12-列出目录和文件信息"></a> 12、列出目录和文件信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-lt] 目录或文件名</span><br></pre></td></tr></table></figure><p>ls是list的缩写，通过ls命令不仅可以查看目录和文件信息，还可以目录和文件权限、大小、主人和组等信息。</p><p>选项-l列出目录和文件的详细信息。</p><p>选项-lt列出目录和文件的详细信息，按时间降序显示。</p><p>示例：</p><p>1）列出当前目录下全部的目录和文件名信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309115133910.png" alt="在这里插入图片描述" /></p><p>2）列出当前目录下全部的目录和文件名详细的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309115207241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>3）列出/tmp目录下全部的目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030911524922.png" alt="在这里插入图片描述" /></p><p>4）列出/tmp目录下以匹配exp*.dmp的目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp/exp*.dmp</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309115317418.png" alt="在这里插入图片描述" /></p><p>5）列出/tmp目录下匹配*.log的目录和文件，按时间降序显示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp<span class="comment">/*.log</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030911535932.png" alt="在这里插入图片描述" /></p><h2 id="13-创建目录"><a class="markdownIt-Anchor" href="#13-创建目录"></a> 13、创建目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 目录名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）在当前目录下创建aaa目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir aaa</span><br></pre></td></tr></table></figure><p>2）在当前目录的aaa目录下创建bbb目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir aaa/bbb</span><br></pre></td></tr></table></figure><p>3）创建/tmp/aaa目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/aaa</span><br></pre></td></tr></table></figure><h2 id="14-删除目录和文件"><a class="markdownIt-Anchor" href="#14-删除目录和文件"></a> 14、删除目录和文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-rf] 目录或文件列表</span><br></pre></td></tr></table></figure><p>选项-r可以删除目录，如果没有-r只能删除文件。</p><p>选项-f表示强制删除，不需要确认。</p><p>目录和文件列表中间用空格分隔。</p><p>示例：</p><p>1）删除当前目录下匹配*.log的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm *.log</span><br></pre></td></tr></table></figure><p>2）强制删除当前目录下匹配*.log的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f *.log</span><br></pre></td></tr></table></figure><p>3）删除/tmp/aaa目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r /tmp/aaa</span><br></pre></td></tr></table></figure><p>4）强制删除/tmp目录下匹配exp*的全部目录和文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/exp*</span><br></pre></td></tr></table></figure><p>5）强制删除当前目录下的book和book.c文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf book book.c</span><br></pre></td></tr></table></figure><h2 id="15-移动目录和文件"><a class="markdownIt-Anchor" href="#15-移动目录和文件"></a> 15、移动目录和文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 旧目录或文件名 新目录或文件名</span><br></pre></td></tr></table></figure><p>如果第二个参数是已经存在的目录，则把第一个参数（旧目录或文件名）移动到该目录中。</p><p>示例：</p><p>1）把当前目录中的book.c文件重命名为book1.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv book.c book1.c</span><br></pre></td></tr></table></figure><p>2）如果/tmp/test3是一个已经存在的目录，以下命令将把当前目录下的book.c文件移动到/tmp/test3目录中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv book.c /tmp/test3</span><br></pre></td></tr></table></figure><p>3）如果/tmp/test3目录不存在，以下命令将把当前目录下的book.c文件改名为/tmp/test3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv book.c /tmp/test3</span><br></pre></td></tr></table></figure><h2 id="16-复制目录和文件"><a class="markdownIt-Anchor" href="#16-复制目录和文件"></a> 16、复制目录和文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [-r] 旧目录或文件名 新目录或文件名</span><br></pre></td></tr></table></figure><p>选项-r可以复制目录，如果没有选项-r只能复制文件。</p><p>示例：</p><p>1）把当前目录下的book1.c文件复制为book2.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp book1.c book2.c</span><br></pre></td></tr></table></figure><p>2）把当前目录下的aaa目录复制为bbb</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r aaa bbb</span><br></pre></td></tr></table></figure><p>3）把当前目录下的book1.c文件复制为/tmp/book1.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp book1.c /tmp/book1.c</span><br><span class="line">cp book1.c /tmp/.</span><br></pre></td></tr></table></figure><p>以上两个命令的效果相同。</p><p>4）把当前目录下的aaa目录复制为/tmp/aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -r aaa /tmp/aaa</span><br><span class="line">cp -r aaa /tmp/.</span><br></pre></td></tr></table></figure><p>以上两个命令的效果相同。</p><h2 id="17-修改用户的密码"><a class="markdownIt-Anchor" href="#17-修改用户的密码"></a> 17、修改用户的密码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [用户名]</span><br></pre></td></tr></table></figure><p>修改用户的密码，按提示两次输入新密码，如果两次输入的密码相同就修改成功。</p><p>普通用户只能修改自己的密码，只输入passwd就可以了，不能指定用户名。</p><p>系统管理员可以修改任何用户的密码，passwd后需要指定用户名。</p><h2 id="18-打包压缩和解包解压"><a class="markdownIt-Anchor" href="#18-打包压缩和解包解压"></a> 18、打包压缩和解包解压</h2><p>tar命令用来打包压缩和解包解压文件，类似windows的winrar工具。</p><p>打包压缩的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf压缩包文件名 目录或文件名列表</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）把当前目录的aaa、bbb和ccc目录打包压缩成123.tgz文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf <span class="number">123.</span>tgz aaa bbb ccc</span><br></pre></td></tr></table></figure><p>2）把/home/oracle/aaa、/home/oracle/bbb和/home/oracle/ccc目录打包压缩成/tmp/123.tgz文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf /tmp/<span class="number">123.</span>tgz /home/oracle/aaa /home/oracle/bbb /home/oracle/ccc</span><br></pre></td></tr></table></figure><p>解包解压的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf压缩包文件名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）把/tmp/123.tgz压缩包文件在当前目录下解压。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf /tmp/<span class="number">123.</span>tgz</span><br></pre></td></tr></table></figure><p>2）把/tmp/123.tgz压缩包文件在/tmp/aaa目录下解压。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/aaa</span><br><span class="line">tar zxvf /tmp/<span class="number">123.</span>tgz</span><br></pre></td></tr></table></figure><p>注意：</p><p>1）用tar命令打包和解包的目录和文件没有绝对路径的说法，都成了相对的，在包中相对的。</p><p>2）用tar命令打包的文件，用winrar可以解开。</p><p>3）在Linux系统中，还有其它的打包压缩和解包解压命令，例如zip/unzip和gzip/gunzip。</p><h2 id="19-判断网络是否连通"><a class="markdownIt-Anchor" href="#19-判断网络是否连通"></a> 19、判断网络是否连通</h2><p>Windows系统：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -n 包的个数 ip地址或域名</span><br></pre></td></tr></table></figure><p>Linux系统：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 包的个数 ip地址或域名</span><br></pre></td></tr></table></figure><p>ping用于确定本地主机是否能与另一台主机成功交换数据包，判断网络是否通畅。</p><p>127.0.0.1是指本地的ip地址，ping 127.0.0.1总是可以通的。</p><p>示例：</p><p>1）向本地主机（127.0.0.1）ping五个包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c <span class="number">5</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309141836638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2）向新浪的服务器（<a href="http://www.sina.com.xn--cnping-jm68a">www.sina.com.cn）ping</a>五个包。</p><p><img src="https://img-blog.csdnimg.cn/20200309141908845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>新浪的服务器是可以ping通的。</p><p>3）向谷歌的服务器（<a href="http://www.google.xn--comping-bt93b">www.google.com）ping</a> 五个包。</p><p><img src="https://img-blog.csdnimg.cn/20200309141947524.png" alt="在这里插入图片描述" /></p><p>谷歌的服务器是ping不通的。</p><h2 id="20-显示文本文件的内容"><a class="markdownIt-Anchor" href="#20-显示文本文件的内容"></a> 20、显示文本文件的内容</h2><p>显示文本文件的内容有三个命令：cat、more和tail。</p><p>1）cat命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件名</span><br></pre></td></tr></table></figure><p>cat命令一次显示整个文件的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat book1.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309142130768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>2）more命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more 文件名</span><br></pre></td></tr></table></figure><p>为了方便阅读，more命令分页显示文件的内容，按空格键显示下一页，按b键显上一页，按q键退出。</p><p>3）tail命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f 文件名</span><br></pre></td></tr></table></figure><p>tail -f用于显示文本文件的最后几行，如果文件的内容有增加，就实时的刷新。对程序员来说，tail<br />-f极其重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行。</p><h2 id="21-统计文本文件的行数-单词数和字节数"><a class="markdownIt-Anchor" href="#21-统计文本文件的行数-单词数和字节数"></a> 21、统计文本文件的行数、单词数和字节数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc 文件名</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）统计当前目录处book2*.c文件的行数、单词数和字节数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc book2*.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200309142402897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="22-搜索文件中的内容"><a class="markdownIt-Anchor" href="#22-搜索文件中的内容"></a> 22、搜索文件中的内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;内容&quot;</span> 文件名</span><br></pre></td></tr></table></figure><p>注意，如果内容中没有空格等特殊字符，可以不用双引号括起来。</p><p>示例：</p><p>1）在*.c文件中搜索max</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep max *.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020030914245064.png" alt="在这里插入图片描述" /></p><h2 id="23-搜索文件"><a class="markdownIt-Anchor" href="#23-搜索文件"></a> 23、搜索文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 目录名 -name 文件名 -print</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>目录名：待搜索的目录，搜索文件的时候，除了这个目录名，还包括它的各级子目录。</p><p>文件名：待搜索的文件名匹配的规则。</p><p>示例：</p><p>1）从/tmp目录开始搜索，把全部的*.c文件显示出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -name *.c -print</span><br></pre></td></tr></table></figure><p>2）从当前目录开始搜索，把全部的*.c文件显示出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name *.c -print</span><br></pre></td></tr></table></figure><h2 id="24-增加删除用户组"><a class="markdownIt-Anchor" href="#24-增加删除用户组"></a> 24、增加/删除用户组</h2><p>1）增加用户组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd dba</span><br></pre></td></tr></table></figure><p>2）删除用户组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel dba</span><br></pre></td></tr></table></figure><h2 id="25-增加删除用户"><a class="markdownIt-Anchor" href="#25-增加删除用户"></a> 25、增加/删除用户</h2><p>1）增加用户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -n 用户名 -g 组名 -d 用户的主目录</span><br></pre></td></tr></table></figure><p>例如增加一个用户，用户名为wucz，属于dba组，用户的主目录是/home/wucz，各位兄弟，wucz是我的名字，您可以改为您自己的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd  -n  wucz  -g  dba  -d  /home/wucz</span><br></pre></td></tr></table></figure><p>2）删除用户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure><p>例如删除wucz用户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel wucz</span><br></pre></td></tr></table></figure><h2 id="26-修改目录和文件的主人和组"><a class="markdownIt-Anchor" href="#26-修改目录和文件的主人和组"></a> 26、修改目录和文件的主人和组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chwon [-R] 用户名:组名 目录或文件名列表</span><br></pre></td></tr></table></figure><p>chown将目录或文件的拥有者修改为参数指定的用户名和组，目录或文件名列表用空格分隔。</p><p>-R 选项表示处理各及子目录。</p><p>示例：</p><p>1）把/oracle/home和/oracle/base及其子目录的主人改为oracle，组改为dba。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R oracle:dba /oracle/home /oracle/base</span><br></pre></td></tr></table></figure><h2 id="27-查看系统磁盘空间"><a class="markdownIt-Anchor" href="#27-查看系统磁盘空间"></a> 27、查看系统磁盘空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [-h] [-T]</span><br></pre></td></tr></table></figure><p>选项-h 以方便阅读的方式显示信息。</p><p>选项-T 列出文件系统类型。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20200309143023101.png" alt="在这里插入图片描述" /></p><p><img src="https://img-blog.csdnimg.cn/20200309143032655.png" alt="在这里插入图片描述" /></p><h2 id="28-版权声明"><a class="markdownIt-Anchor" href="#28-版权声明"></a> 28、版权声明</h2><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7的安装和配置</title>
      <link href="/posts/7ad62309.html"/>
      <url>/posts/7ad62309.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-ftp简介"><a class="markdownIt-Anchor" href="#一-ftp简介"></a> 一、ftp简介</h1><p>ftp（File Transfer Protocol文件传输协议）是基于TCP/IP协议的应用层协议，用于文件的传输，包括ftp服务器（或服务端）和ftp客户端。</p><p>ftp客户端与服务器创建网络连接，请求登录服务器，登录成功后，就可以进行文件传输，主要包括开载文件和上传文件两种操作。</p><p>ftp协议很古老，有人说它技术太落后，不安全，对于这种说法我不于评论。但是，ftp的应用场景仍非常广泛，这是不争的事实。</p><p>在Linux系统中，ftp客户端和ftp服务器是操作系统自带的，但不一定会缺省安装。</p><h1 id="二-安装ftp软件包"><a class="markdownIt-Anchor" href="#二-安装ftp软件包"></a> 二、安装ftp软件包</h1><p>在CentOS7中，采用yum来安装ftp软件包，包括ftp服务器和ftp客户端。如果已经安装，再次执行yum就会把软件包升级到最新版本。</p><h2 id="1-安装ftp服务器"><a class="markdownIt-Anchor" href="#1-安装ftp服务器"></a> 1、安装ftp服务器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vsftpd</span><br></pre></td></tr></table></figure><h2 id="2-安装ftp客户端"><a class="markdownIt-Anchor" href="#2-安装ftp客户端"></a> 2、安装ftp客户端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ftp</span><br></pre></td></tr></table></figure><h1 id="三-配置ftp服务器"><a class="markdownIt-Anchor" href="#三-配置ftp服务器"></a> 三、配置ftp服务器</h1><p>ftp的传输模式有被动模式和主动式两种，缺省是被动模式，主动模式的应用场景极少，为了方便表达，在接下来的内容中只介绍被动模式，主动模式在本文中也有介绍。</p><h2 id="1-关闭selinux"><a class="markdownIt-Anchor" href="#1-关闭selinux"></a> 1、关闭SELINUX</h2><p>修改/etc/selinux/config文件，把SELINUX参数的值改为disabled。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX =disabled</span><br></pre></td></tr></table></figure><p>重启linux系统或执行<code>setenforce 0</code>使修改马上生效。</p><h2 id="2-配置ftp数据端口参数"><a class="markdownIt-Anchor" href="#2-配置ftp数据端口参数"></a> 2、配置ftp数据端口参数</h2><p>ftp的数据端口也称为高端口，在/etc/vsftpd/vsftpd.conf文件中配置，由pasv_min_port和pasv_max_port两个参数指定，如果文件中没有这两个参数，手工的加进去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pasv_min_port=<span class="number">5000</span>   # 高端口范围的最小值。</span><br><span class="line">pasv_max_port=<span class="number">5500</span>   # 高端口范围的最大值。</span><br></pre></td></tr></table></figure><h2 id="3-开通防火墙"><a class="markdownIt-Anchor" href="#3-开通防火墙"></a> 3、开通防火墙</h2><p>开通防火墙的方法有两种：</p><p>1）开通ftp服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-service=ftp --permanent</span><br></pre></td></tr></table></figure><p>2）开通ftp服务需要的端口，21是控制端口，5000-5500是数据端口范围，也就是上一节中在/etc/vsftpd/vsftpd.conf文件中配置的pasv_min_port和pasv_max_port参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">21</span>/tcp --permanent</span><br><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">5000</span><span class="number">-5500</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>重启防火墙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><h2 id="4-启动vsftpd服务"><a class="markdownIt-Anchor" href="#4-启动vsftpd服务"></a> 4、启动vsftpd服务</h2><p>ftp服务器的服务名是vsftpd，相关的操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start    vsftpd   # 启动服务。</span><br><span class="line">systemctl stop    vsftpd    # 停止服务。</span><br><span class="line">systemctl restart vsftpd    # 重启服务。</span><br><span class="line">systemctl status  vsftpd    # 查看服务状态。</span><br><span class="line">systemctl enable  vsftpd    # 启用开机自动动vsftpd服务。</span><br><span class="line">systemctl disable vsftpd    # 禁用开机自动动vsftpd服务。</span><br></pre></td></tr></table></figure><h2 id="5-云平台访问策略配置"><a class="markdownIt-Anchor" href="#5-云平台访问策略配置"></a> 5、云平台访问策略配置</h2><p>如果您购买的是云服务器上，需要登录云服务器提供商的管理平台开通访问策略（或安全组），开通21和高端口的访问策略。</p><p>不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。</p><p>如果云服务器的ftp服务不对建立数据会话，在百度中输入“被动模式下FTP不能建立数据会话问题“可以找到解决问题的方法，目前的阿里云服务器就存在这个问题。</p><h1 id="四-主动模式和被动模式"><a class="markdownIt-Anchor" href="#四-主动模式和被动模式"></a> 四、主动模式和被动模式</h1><p>ftp有两种模式，分别是port模式（主动模式）和pasv模式（被动模式）。</p><h2 id="1-主动模式"><a class="markdownIt-Anchor" href="#1-主动模式"></a> 1、主动模式</h2><p>客户端给服务端的21端口发命令说：我要输传文件，我已经打开了自己的20端口，您向我的20端口发起TCP连接，我们来传输文件。服务端知道后，就会主动向客户端的20端口发起连接，连接成功后开始传输文件。</p><p><img src="https://img-blog.csdnimg.cn/20200310100630418.png" alt="在这里插入图片描述" /></p><p>在主动模式下，ftp请求是由客户端TCP连接的；传输数据的时候，TCP连接却是由服务端发起的。</p><h2 id="2-被动模式"><a class="markdownIt-Anchor" href="#2-被动模式"></a> 2、被动模式</h2><p>客户端给服务器端的21端口发命令说：我要传输文件。服务器端知道后打开一个空闲的高端口，然后告诉客户端，我已经打开了某某端口，您向我这个端口发起TCP连接，然后我们用这个端口来传输文件。<br /><img src="https://img-blog.csdnimg.cn/20200310100719255.png" alt="在这里插入图片描述" /><br />在被动模式下，不管是ftp命令，还是传输数据，都是由客户端向服务端发起TCP连接。</p><h2 id="3-从主动模式到被动模式"><a class="markdownIt-Anchor" href="#3-从主动模式到被动模式"></a> 3、从主动模式到被动模式</h2><p>在很久以前每台电脑都有一个ip地址，ftp只有主动模式，后来出现了共享上网技术，所以也就有了下面的问题。</p><p>共享上网就是多台电脑共享一个公网ip去使用internet，例如某个局域网出口的公网ip是210.33.25.108，当内网用户（192.168.1.100）访问外网的ftp服务器时，如果采用主动模式，192.168.1.100告诉了ftp服务器我需要某个文件和我打开了20端口之后，由于共享上网的原因，192.168.1.100在出网关的时候ip已经被转换成了210.33.25.108，所以ftp服务器端收到的消息是210.33.25.108需要某个文件并打开了20端口，ftp服务器就会尝试连接210.33.25.108的20端口，这样当然不会成功。</p><p>在主动模式中，ftp的两个端口是相对固定的，如果命令端口是n的话，那数据端口就是n-1，也就是说默认情况下，命令端口是21，数据端口就是20，如果您把ftp服务的端口改成了521，那么数据端口就是520，这样配置防火墙很方便，只需要开通两个端口就可以了。但是，在共享上网的环境中无法使用主动模式。</p><p>在被动模式中，默认情况下命令端口是21，数据端口是随机分配的。但是，被动模式中数据端口的范围可以配置，防火墙也可以配置端口范围。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习环境</title>
      <link href="/posts/349a5512.html"/>
      <url>/posts/349a5512.html</url>
      
        <content type="html"><![CDATA[<p>有三种方法可以获得Linux学习环境：安装本地虚拟机、购买云服务器和使用我们提供的服务器。</p><h1 id="一-安装本地虚拟机"><a class="markdownIt-Anchor" href="#一-安装本地虚拟机"></a> 一、安装本地虚拟机</h1><p>在您个人电脑的Windows系统中安装VMWare软件，然后在VMWare中安装CentOS7操作系统。对初学者来说，折腾一下本地虚拟机是有必要的。对职业的程序员来说，基本上不用本地虚拟机。</p><h2 id="1-优点"><a class="markdownIt-Anchor" href="#1-优点"></a> 1、优点</h2><p>1）可以让您熟悉Linux系统的安装和配置方面的知识。</p><p>2）让您对Linux的启动、关闭，操作界面等有直观的了解。</p><p>3）完全属于您自己的Linux系统，爱怎么折腾就怎么折腾。</p><p>4）备份和恢复很简单，时间短。</p><h2 id="2-缺点"><a class="markdownIt-Anchor" href="#2-缺点"></a> 2、缺点</h2><p>麻烦很多，不稳定，有些故障找不到原因。如果您的本地虚拟机不幸难产或夭折，也不用花太多时间和精力去抢救。</p><h1 id="二-购买云服务器"><a class="markdownIt-Anchor" href="#二-购买云服务器"></a> 二、购买云服务器</h1><p>云服务器本质上也是虚拟机，但是采用的虚拟化技术和本地虚拟机完全不同。本地虚拟机仅用于学习，云平台虚拟机是企业级的服务器，目前，互联网上的服务器有80%以上是采用云服务器。</p><p>国内主要的云服务器提供商有腾讯、阿里和华为，他们提供的产品没什么差别，谁家有优惠就用谁的。目前，云服务器的价格在100元/年之内，学生还有更多优惠。</p><p>和本地虚拟机相比，云服务器稳定可靠，但是您无法体验Linux的安装、配置、启动、关闭、操作界面等。</p><p>如果您打算深入的学习C/C++语言，购买云服务器是非常有必要的，它的意义远远超过购买任何书籍。</p><h1 id="三-使用我们的服务器"><a class="markdownIt-Anchor" href="#三-使用我们的服务器"></a> 三、使用我们的服务器</h1><p>为了方便大家学习，我们购买了云服务器，在云服务器上可以给大家分配操作系统用户，具体请前往C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）了解。</p><p>在我们的服务器上，您可以学习Linux系统的基本知识和C/C++语言，但是您只有普通用户权限，没有系统管理员权限。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统简介</title>
      <link href="/posts/cf0ea7a1.html"/>
      <url>/posts/cf0ea7a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-linux-简介"><a class="markdownIt-Anchor" href="#一-linux-简介"></a> 一、Linux 简介</h1><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix以网络为核心的设计思想，是一个稳定高性能的多用户网络操作系统。</p><h1 id="二-linux-的发行版"><a class="markdownIt-Anchor" href="#二-linux-的发行版"></a> 二、Linux 的发行版</h1><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p><p><img src="https://img-blog.csdnimg.cn/20200309100643901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>目前市面上较知名的发行版有：RedHat、CentOS、Debian、Fedora、SuSE、Ubuntu、OpenSUSE、Arch Linux、SolusOS 等。</p><p><img src="https://img-blog.csdnimg.cn/20200309100717525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-linux-应用领域"><a class="markdownIt-Anchor" href="#三-linux-应用领域"></a> 三、Linux 应用领域</h1><p>1）根据前程无忧官网发布的招聘职位的数据统计，Linux与Windows开发岗的职位比例约为3:1。<br /><img src="https://img-blog.csdnimg.cn/20200324132630771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20200324132651700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />2）今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了主导地位。</p><p>3）目前 Linux 在家庭的应用很少，但在企业和政府中很受欢迎。</p><p>4）巴西联邦政府由于支持 Linux 而世界闻名。</p><p>5）有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</p><p>6）印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</p><p>7）中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</p><p>8）在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</p><p>9）葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalhes 笔记本电脑和 e-escola 政府软件。</p><p>10）法国和德国同样开始逐步采用 Linux。</p><p>11）微软的windows系统在个人电脑市场占统治地位，并不是因为windows有多好，而是生态圈已成熟，比windows更好的操作也没有生存空间。但是，智能手机是近十五年才出现，占统治地位的是苹果的IOS和谷歌的Android，它们的操作系统都是Linux（UNIX）。微软也推出过手机操作系统，但已经被人们遗忘。</p><h1 id="四-linux-vs-windows"><a class="markdownIt-Anchor" href="#四-linux-vs-windows"></a> 四、Linux vs Windows</h1><h2 id="1-免费与收费"><a class="markdownIt-Anchor" href="#1-免费与收费"></a> 1、 免费与收费</h2><p>Windows需要付费购买；</p><p>Linux 免费或少许费用。</p><h2 id="2-软件与支持"><a class="markdownIt-Anchor" href="#2-软件与支持"></a> 2、软件与支持</h2><p>Windows平台：数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务；</p><p>Linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；由全球所有的Linux开发者和自由软件社区提供支持。</p><h2 id="3-安全性"><a class="markdownIt-Anchor" href="#3-安全性"></a> 3、安全性</h2><p>Windows 平台：三天两头打补丁安装系统安全更新，还是会中病毒木马；</p><p>Linux 平台：要说 Linux 没有安全问题，那当然是不可能的，这一点仁者见仁智者见智，相对来说肯定比 Windows平台要更加安全，使用 Linux 您也不用装某杀毒、某毒霸。</p><h2 id="4-使用习惯"><a class="markdownIt-Anchor" href="#4-使用习惯"></a> 4、使用习惯</h2><p>Windows：普通用户基本都是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易，入门简单；</p><p>Linux：兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导（这正是我们要做的事情），一旦熟练之后效率极高。</p><h2 id="5-可定制性"><a class="markdownIt-Anchor" href="#5-可定制性"></a> 5、可定制性</h2><p>Windows：这些年之前算是全封闭的，系统可定制性很差；</p><p>Linux：您想怎么做就怎么做，Windows 能做到得它都能，Windows 做不到的，它也能。</p><h2 id="6-应用范畴"><a class="markdownIt-Anchor" href="#6-应用范畴"></a> 6、应用范畴</h2><p>或许您之前不知道 Linux ，要知道，您之前在 Windows 使用百度、谷歌，上淘宝，聊 QQ 时，支撑这些软件和服务的，是后台成千上万的 Linux服务器主机，它们时时刻刻都在忙碌地进行着数据处理和运算，可以说世界上大部分软件和服务都是运行在Linux 之上的。</p><h2 id="7-linux的优点"><a class="markdownIt-Anchor" href="#7-linux的优点"></a> 7、Linux的优点</h2><p>1）极其稳定</p><p>2）性能卓越</p><p>3）安全性和漏洞的快速修补</p><p>4）多用户</p><p>5）用户和用户组的规划</p><p>6）相对较少的系统资源占用</p><p>7）可定制裁剪，移植到嵌入式平台（如安卓设备）</p><p>8）可选择的多种图形用户界面（如 GNOME，KDE）</p><h2 id="8-windows的优点"><a class="markdownIt-Anchor" href="#8-windows的优点"></a> 8、Windows的优点</h2><p>1）微软公司强大的支持</p><p>2）足够的游戏娱乐支持度</p><p>3）足够的专业软件支持度</p><h1 id="五-文章版权"><a class="markdownIt-Anchor" href="#五-文章版权"></a> 五、文章版权</h1><p>本文引用了菜鸟教程和CSDN博客的文章内容，原文地址如下。<br />菜鸟教程：<a href="https://www.runoob.com/linux/linux-intro.html">https://www.runoob.com/linux/linux-intro.html</a><br />CSDN博客：<a href="https://blog.csdn.net/qq_40530943/article/details/82349167">https://blog.csdn.net/qq_40530943/article/details/82349167</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux静态库与动态库</title>
      <link href="/posts/6d3dd625.html"/>
      <url>/posts/6d3dd625.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-源代码的组织"><a class="markdownIt-Anchor" href="#一-源代码的组织"></a> 一、源代码的组织</h1><p>我们通常把公用的自定义函数和类从主程序中分离出来，函数和类的声明在头文件中，定义在程序文件中，主程序中要包含头文件，编译时要和程序文件一起编译。</p><p><strong>示例（public.h）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：public.h，公共功能函数声明的头文件，用于测试静态和动态链接</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUBLIC_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;   <span class="comment">// 自定义函数的声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>示例（public.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：public.cpp，公共功能函数定义的程序文件，用于测试静态和动态链接</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span>  <span class="comment">// 包含自定义函数声明的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span>   <span class="comment">// 自定义函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br><span class="line">  <span class="comment">//printf(&quot;生活美好如鲜花，不懂享受是傻瓜；\n&quot;);</span></span><br><span class="line">  <span class="comment">//printf(&quot;傻呀傻呀傻呀傻，比不上小鸟和乌鸦。\n&quot;);</span></span><br><span class="line">  <span class="comment">//printf(&quot;芳草地啊美如画，谁要不去是傻瓜；\n&quot;);</span></span><br><span class="line">  <span class="comment">//printf(&quot;我是一只傻傻鸟，独在枯枝丫上趴。\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例（book265.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book265.cpp，此程序用于测试静态和动态链接</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span>  <span class="comment">// 把public.h头文件包含进来</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译指令</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/202003060949331.png" alt="在这里插入图片描述" /></p><p>公用函数库的程序文件public.cpp程序文件是源代码，对任何程序员是可见的，没有安全性可言，但是，在实际开发中，出于技术保密或其它方面考虑，开发者并不希望提供公用函数库的源代码。</p><p>C/C++提供了一个可以保证代码安全性的方法，把公共的程序文件编译成库文件，库文件时一种可执行代码的二进制形式，可以与其它的源程序一起编译，也可以被操作系统载入内存执行。</p><p>库文件分为静态库与动态库。</p><h1 id="二-静态库"><a class="markdownIt-Anchor" href="#二-静态库"></a> 二、静态库</h1><p>静态库在编译的时候，主程序文件与静态库一起编译，把主程序与主程序中用到的库函数一起整合进了目标文件。这样做优点是在编译后的可执行程序可以独立运行，因为所使用的函数都已经被编译进去了。缺点是，如果所使用的静态库发生更新改变，我们的程序必须重新编译。</p><p>静态库文件名的命名方式是“libxxx.a”,库名前加”lib”，后缀用”.a”，“xxx”为静态库名。</p><p>把程序文件public.cpp编译成静态库的指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o libpublic.a <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p>使用静态库的方法一，直接把调用者源代码和静态库文件名一起编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp libpublic.a</span><br></pre></td></tr></table></figure><p>使用静态库的方法二，采用L参数指定静态库文件的目录，-l参数指定静态库名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp -L/home/wucz/demo -lpublic</span><br></pre></td></tr></table></figure><p>执行程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book265</span><br></pre></td></tr></table></figure><p>运行效果。</p><p><img src="https://img-blog.csdnimg.cn/20200306095203413.png" alt="在这里插入图片描述" /></p><p>注意：1）如果要指定多个静态库文件的目录，用法是“-L/目录1 -L目录2 -L目录3”；2）链接库的文件名是libpublic.a，但链接库名是”public”，不是“libpublic.a”；3）如果要指定多个静态库，用法是“-l库名1 -l库名2 -l库名3”。</p><h1 id="三-动态库"><a class="markdownIt-Anchor" href="#三-动态库"></a> 三、动态库</h1><p>动态库在编译时并不会被连接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要指定动态库的目录。</p><p>动态库的命名方式与静态库类似，前缀相同，为“lib”，后缀变为“.so” “xxx”为动态库名。</p><p>把程序文件public.cpp编译成动态库的指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared -o libpublic.so <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p>使用动态库的方法与使用静态库的方法相同。</p><p>如果在动态库文件和静态库文件同时存在，优先使用动态库编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o book265 book265.cpp -L/home/wucz/demo -lpublic</span><br></pre></td></tr></table></figure><p>执行程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book265</span><br></pre></td></tr></table></figure><p>执行程序book265时，出现以下提示。</p><p><img src="https://img-blog.csdnimg.cn/20200306095527876.png" alt="在这里插入图片描述" /></p><p>这是因为采用了动态链接库的可执行程序在运行时需要指定动态库文件的目录，Linux系统中采用LD_LIBRARY_PATH环境变量指定动态库文件的目录。</p><p>采用以下命令设置LD_LIBRARY_PATH环境变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=/home/wucz/demo:.</span><br></pre></td></tr></table></figure><p>注意：1）如果要指定多个动态库文件的目录，用法是“export LD_LIBRARY_PATH=目录1:目录2:目录3:.”，目录之间用半角的冒号分隔，最后的圆点指当前目录。</p><p>接下来修改动态库中func函数的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生活美好如鲜花，不懂享受是傻瓜；\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;傻呀傻呀傻呀傻，比不上小鸟和乌鸦。\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;芳草地啊美如画，谁要不去是傻瓜；\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是一只傻傻鸟，独在枯枝丫上趴。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>重新编译动态库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared -o libpublic.so <span class="keyword">public</span>.cpp</span><br></pre></td></tr></table></figure><p>无需重新编译book265，直接执行程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book265</span><br></pre></td></tr></table></figure><p>执行效果。</p><p><img src="https://img-blog.csdnimg.cn/20200306095850185.png" alt="在这里插入图片描述" /><br />动态库在编译的时候只做语法检查，并没有被编译进目标代码，当程序执行到动态库中的函数时才调用该函数库里的代码。动态函数库并没有整合进程序，所以程序的运行环境必须提供动态库路径。优点是，如果所使用的动态库发生更新改变，程序不需要重新编译，所以动态库升级比较方便。</p><h1 id="四-静态库与动态库的优缺点"><a class="markdownIt-Anchor" href="#四-静态库与动态库的优缺点"></a> 四、静态库与动态库的优缺点</h1><h2 id="1-优点"><a class="markdownIt-Anchor" href="#1-优点"></a> 1、优点</h2><p>静态链接相当于复制一份库文件到可执行程序中，不需要像动态库那样有动态加载和识别函数地址的开销，也就是说采用静态链接编译的可执行程序运行更快。</p><h2 id="2-缺点"><a class="markdownIt-Anchor" href="#2-缺点"></a> 2、缺点</h2><p>1）静态链接生成的可执行程序比动态链接生成的大很多，运行时占用的内存也更多。</p><p>2）库文件的更新不会反映到可执行程序中，可执行程序需要重新编译。</p><h1 id="五-动态库的优缺点"><a class="markdownIt-Anchor" href="#五-动态库的优缺点"></a> 五、动态库的优缺点</h1><h2 id="1-优点-2"><a class="markdownIt-Anchor" href="#1-优点-2"></a> 1、优点</h2><p>1）相对于静态库，动态库在时候更新（修复bug，增加新的功能）不需要重新编译。</p><p>2）全部的可执行程序共享动态库的代码，运行时占用的内存空间更少。</p><h2 id="2-缺点-2"><a class="markdownIt-Anchor" href="#2-缺点-2"></a> 2、缺点</h2><p>1）使可执行程序在不同平台上移植变得更复杂，因为它需要为每每个不同的平台提供相应平台的共享库。</p><p>2）增加可执行程序运行时的时间和空间开销，因为应用程序需要在运行过程中查找依赖的库函数，并加载到内存中。</p><h1 id="六-编译的优先级"><a class="markdownIt-Anchor" href="#六-编译的优先级"></a> 六、编译的优先级</h1><p>静态库与动态库各有优缺点，该怎么选择，要看应用的场景。</p><p>所谓有得必有失，动态库在程序运行时被链接，故程序的运行速度和链接静态库的版本相比必然会打折扣。然而瑕不掩瑜，动态库的不足相对于它带来的好处在现今硬件下简直是微不足道的，所以链接程序在链接时一般是优先链接动态库的，除非用-static参数指定链接静态库。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux调用可执行程序</title>
      <link href="/posts/5a838d54.html"/>
      <url>/posts/5a838d54.html</url>
      
        <content type="html"><![CDATA[<p>在C/C<ins>程序中，经常需要调用其它的程序来先成某项任务，例如其它的C/C</ins>程序、操作系统命令或Shell脚本，C/C++提供了exec函数族和system函数来实现这个功能。</p><h1 id="一-exec函数族"><a class="markdownIt-Anchor" href="#一-exec函数族"></a> 一、exec函数族</h1><p>exec函数族提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新的进程替换了。还有，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。</p><p>exec函数族的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,..., <span class="type">char</span> * <span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>path：要执行的程序路径。可以是绝对路径或者是相对路径。在execv、execl和execle这三个函数中，使用带路径名的文件名作为参数。</p><p>file：要执行的程序名称。如果该参数中包含“/”字符，则视为路径名直接执行；否则视为单独的文件名，系统将根据PATH环境变量指定的路径顺序搜索指定的文件。</p><p>argv：命令行参数的数组。</p><p>envp：带有该参数的exec函数可以在调用时指定一个环境变量数组。其他不带该参数的exec函数则使用调用者进程的环境变量。</p><p>arg：程序的第0个参数，即程序名自身。相当于argv[0]。</p><p>…：命令行参数列表。调用相应程序时有多少命令行参数，就需要有多少个输入参数项。注意：在使用此类函数时，在所有命令行参数的最后应该增加一个空的参数项(NULL)，表明命令行参数结束。</p><p>如果执行失败则直接返回-1，失败原因存于errno 中。</p><p>如果执行成功则函数不会返回，这句话可能难以理解，当在主程序中成功调用execl后，被调用的程序将取代调用者程序，也就是说，execl函数之后的代码都不会被执行。</p><p>在实际开发中，最常用的是execl函数，其它的极少使用，我就不介绍了，如果大家认为execl满足不了实际开发的需求，再去研究其它几个函数。</p><p><strong>示例（book266.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book266.cpp，此程序用于演示用execl函数执行程序。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> iret=<span class="built_in">execl</span>(<span class="string">&quot;/bin/lss&quot;</span>,<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/usr/include/stdio.h&quot;</span>,<span class="number">0</span>);   <span class="comment">// /bin/lss不存在，执行不能成功。</span></span><br><span class="line">  <span class="comment">// int iret=execl(&quot;/bin/ls&quot;,&quot;/bin/ls&quot;,&quot;-l&quot;,&quot;/usr/include/stdio.h&quot;,0); // 可以调用成功的代码。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>,iret);</span><br><span class="line">  <span class="keyword">if</span> (iret==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先测试执行失败的情况，启用以下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iret=<span class="built_in">execl</span>(<span class="string">&quot;/bin/lss&quot;</span>,<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/usr/include/stdio.h&quot;</span>,<span class="number">0</span>);   <span class="comment">// /bin/lss不存在，执行不能成功。</span></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306093252273.png" alt="在这里插入图片描述" /></p><p>再测试执行成功的情况，启用以下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iret=<span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/usr/include/stdio.h&quot;</span>,<span class="number">0</span>); <span class="comment">// 可以调用成功的代码。</span></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306093322697.png" alt="在这里插入图片描述" /></p><p>从book266执行的结果可以看出，主程序中成功调用execl后，execl函数之后的代码都不会被执行。</p><h1 id="二-system函数"><a class="markdownIt-Anchor" href="#二-system函数"></a> 二、system函数</h1><p>system函数提供了另一种简单的执行程序的方法，把需要执行的命令用一个参数传给system函数。</p><p>system函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * string)</span></span>;</span><br></pre></td></tr></table></figure><p>system会调用fork产生子进程，由子进程来调用/bin/sh -c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。在调用system期间SIGCHLD信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。</p><p>如果fork失败 返回-1，出现错误。</p><p>如果execl失败，表示不能执行shell，返回值相当于shell执行了exit（127）。</p><p>如果执行成功则返回子shell的终止状态。</p><p>如果system在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针（NULL），仅当命令处理程序可用时，返回非零值。如果system调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为system调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。</p><p><strong>示例（book269.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book269.cpp，此程序用于演示用system函数执行程序。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> iret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用不成功的代码。</span></span><br><span class="line">  iret=<span class="built_in">system</span>(<span class="string">&quot;/bin/lss -l /usr/include/stdio.h&quot;</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>,iret);</span><br><span class="line">  <span class="keyword">if</span> (iret==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以调用成功的代码。</span></span><br><span class="line">  iret=<span class="built_in">system</span>(<span class="string">&quot;/bin/ls -l /usr/include/stdio.h&quot;</span>); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>,iret);</span><br><span class="line">  <span class="keyword">if</span> (iret==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306093517519.png" alt="在这里插入图片描述" /></p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>============<br />C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux线程同步</title>
      <link href="/posts/b7bd7fa2.html"/>
      <url>/posts/b7bd7fa2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-线程同步的概念"><a class="markdownIt-Anchor" href="#一-线程同步的概念"></a> 一、线程同步的概念</h1><p>线程同步？怎么同步？一起运行？一起停止？我当年听说线程同步这个词的时候，也是一头雾水。</p><p>在人们的日常生活中的锁大概有两种：一种是不允许访问；另一种是资源忙，同一时间只允许一个使用者占用，其它使用者必须要等待。</p><p>1）不允许访问的锁容易理解，就像每家每户的门锁，不允许外人进入。</p><p>2）第二种锁，例如火车上的厕所，它是公共的，空闲的时候任何人可以进入，人进去以后就会把它锁起来，其它的人如果要上厕所，必须等待解锁，即里面的人出来。还有红绿灯，红灯是加锁，绿灯是解锁。</p><p>对多线程来说，资源是共享的，基本上不存在不允许访问的情况，但是，共享的资源在某一时间点只能有一个线程占用，所以需要给资源加锁。</p><p>不知道是什么人采用了线程同步这个词，如果让我的命名，我会定义为线程锁，锁线程吗？不是，是锁共享资源，线程给共享资源加的锁。</p><p>线程的锁的种类有互斥锁、读写锁、条件变量、自旋锁、信号灯。</p><p>在本章节中，只介绍互斥锁，其它的锁应用场景复杂，开发难度很大，不合适初学者。</p><h1 id="二-互斥锁"><a class="markdownIt-Anchor" href="#二-互斥锁"></a> 二、互斥锁</h1><p>互斥锁机制是同一时刻只允许一个线程占有共享的资源。</p><h2 id="1-初始化锁"><a class="markdownIt-Anchor" href="#1-初始化锁"></a> 1、初始化锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex,<span class="type">const</span> <span class="type">pthread_mutex_attr_t</span> *mutexattr)</span></span>;</span><br></pre></td></tr></table></figure><p>其中参数 mutexattr 用于指定锁的属性（见下），如果为NULL则使用缺省属性。</p><p>互斥锁的属性在创建锁的时候指定，当资源被某线程锁住的时候，其它的线程在试图加锁时表现将不同。当前有四个值可供选择：</p><p>1）PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。</p><p>2）PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。</p><p>3）PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。</p><p>4）PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，等待解锁后重新竞争。</p><h2 id="2-阻塞加锁"><a class="markdownIt-Anchor" href="#2-阻塞加锁"></a> 2、阻塞加锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>如果是锁是空闲状态，本线程将获得这个锁；如果锁已经被占据，本线程将排队等待，直到成功的获取锁。</p><h2 id="3-非阻塞加锁"><a class="markdownIt-Anchor" href="#3-非阻塞加锁"></a> 3、非阻塞加锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">( <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数语义与 pthread_mutex_lock() 类似，不同的是在锁已经被占据时立即返回<br />EBUSY，不是挂起等待。</p><h2 id="4-解锁"><a class="markdownIt-Anchor" href="#4-解锁"></a> 4、解锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>线程把自己持有的锁释放。</p><h2 id="5-销毁锁此时锁必需unlock状态否则返回ebusy"><a class="markdownIt-Anchor" href="#5-销毁锁此时锁必需unlock状态否则返回ebusy"></a> 5、销毁锁（此时锁必需unlock状态，否则返回EBUSY）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>销毁锁之前，锁必需是空闲状态（unlock）。</p><h1 id="三-示例程序"><a class="markdownIt-Anchor" href="#三-示例程序"></a> 三、示例程序</h1><p>多线程可以共享资源（变量和对象），对编程带来了方便，但是某些对象虽然可以共享，但在同一个时间只能由一个线程使用，多个线程同时使用会产生冲突，例如socket连接，数据库连接池。</p><p>我们把前几章节的socket客户端程序book247.cpp修改为多线程。</p><p><strong>示例（book263.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book263.cpp，此程序用于演示多线程的互斥锁</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xx pthread_mutex_t mutex; // 申明一个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pth_main</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> pno=(<span class="type">long</span>)arg;   <span class="comment">// 线程编号</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">3</span>;ii++)    <span class="comment">// 与服务端进行3次交互。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//xx pthread_mutex_lock(&amp;mutex);  // 加锁</span></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;线程%d：这是第%d个超级女生，编号%03d。&quot;</span>,pno,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程%d接收：%s\n&quot;</span>,pno,strbuffer);</span><br><span class="line">    <span class="comment">//xx pthread_mutex_unlock(&amp;mutex);  // 释放锁</span></span><br><span class="line">    <span class="comment">// usleep(100);   // usleep(100)，否则其它的线程无法获得锁。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;172.16.0.15&quot;</span>,<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;172.16.0.15\&quot;,5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//xx pthread_mutex_init(&amp;mutex,0); // 创建锁</span></span><br><span class="line"></span><br><span class="line">  <span class="type">pthread_t</span> pthid1,pthid2;</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pthid1,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)<span class="number">1</span>);   <span class="comment">// 创建第一个线程</span></span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;pthid2,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)<span class="number">2</span>);   <span class="comment">// 创建第二个线程</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_join</span>(pthid1,<span class="literal">NULL</span>);    <span class="comment">// 等待线程1退出。</span></span><br><span class="line">  <span class="built_in">pthread_join</span>(pthid2,<span class="literal">NULL</span>);    <span class="comment">// 等待线程2退出。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//xx pthread_mutex_lock(&amp;mutex);   // 销毁锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book263.cpp程序中，客户端成功连上服务器后，创建两个线程，同时与服务端进行通信，发送3个请求报文并接收服务端的回应。</p><p>book263.cpp暂时不启用锁，先试试效果。</p><p>启动服务端程序book261，然后再启动book263。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306091730718.png" alt="在这里插入图片描述" /></p><p>大家仔细研究一下book263运行的结果，可以发现客户端的两个线程的报文收发出现了混乱。</p><p>把book263.cpp的线程锁代码启用，编译运行。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200306091744817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />非常棒，这正在我们想要的结果。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程</title>
      <link href="/posts/293980e9.html"/>
      <url>/posts/293980e9.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-线程的概念"><a class="markdownIt-Anchor" href="#一-线程的概念"></a> 一、线程的概念</h1><p>和多进程相比，多线程是一种比较节省资源的多任务操作方式。启动一个新的进程必须分配给它独立的地址空间，每个进程都有自己的堆栈段和数据段，系统开销比较高，进行数据的传递只能通过进行间通信的方式进行。在同一个进程中，可以运行多个线程，运行于同一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享全局变量和对象，启动一个线程所消耗的资源比启动一个进程所消耗的资源要少。</p><h1 id="二-线程的使用"><a class="markdownIt-Anchor" href="#二-线程的使用"></a> 二、线程的使用</h1><h2 id="1-创建线程"><a class="markdownIt-Anchor" href="#1-创建线程"></a> 1、创建线程</h2><p>在Linux下，采用pthread_create函数来创建一个新的线程，函数声明：</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数thread为为指向线程标识符的地址。</p><p>参数attr用于设置线程属性，一般为空，表示使用默认属性。</p><p>参数start_routine是线程运行函数的地址，填函数名就可以了。</p><p>参数arg是线程运行函数的参数。新创建的线程从start_routine函数的地址开始运行，该函数只有一个无类型指针参数arg。若要想向start_routine传递多个参数，可以将多个参数放在一个结构体中，然后把结构体的地址作为arg参数传入，<strong>但是要非常慎重，程序员一般不会这么做。</strong></p><p>在编译时注意加上-lpthread参数，以调用静态链接库。因为pthread并非Linux系统的默认库。</p><h2 id="2-线程的终止"><a class="markdownIt-Anchor" href="#2-线程的终止"></a> 2、线程的终止</h2><p>如果进程中的任一线程调用了exit，则整个进程会终止，所以，在线程的start_routine函数中，不能采用exit。</p><p>线程的终止有三种方式：</p><p>1）线程的start_routine函数代码结束，自然消亡。</p><p>2）线程的start_routine函数调用pthread_exit结束。</p><p>3）被主进程或其它线程中止。</p><p>pthread_exit函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><p>参数retval填空，即0。</p><h2 id="3-多线程的socket服务端"><a class="markdownIt-Anchor" href="#3-多线程的socket服务端"></a> 3、多线程的socket服务端</h2><p>我们把TCP通信的服务端（book250.cpp）程序改一下，由多进程改为多线程。</p><p><strong>示例（book261.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book261.cpp，此程序用于演示多线程的socket通信服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_listenfd;   <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="type">int</span> m_clientfd;   <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">int</span> port)</span></span>;  <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;  <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// void CloseClient();    // 关闭客户端的socket，多线程服务端不需要这个函数。</span></span><br><span class="line">  <span class="comment">// void CloseListen();    // 关闭用于监听的socket，多线程服务端不需要这个函数。</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT和SIGTERM的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;程序退出，信号值=%d\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  TcpServer.~<span class="built_in">CTcpServer</span>();  <span class="comment">// 手动调用析构函数，释放资源</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pth_main</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 忽略全部的信号</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">50</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,EXIT); <span class="built_in">signal</span>(SIGTERM,EXIT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pthid;   <span class="comment">// 创建一线程，与新连接上来的客户端通信</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;pthid,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)((<span class="type">long</span>)TcpServer.m_clientfd))!=<span class="number">0</span>)</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;创建线程失败，程序退出。n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端通信的线程已创建。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">  m_listenfd=m_clientfd=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_listenfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  m_listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (m_clientfd=<span class="built_in">accept</span>(m_listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与客户端通信线程的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pth_main</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> clientfd=(<span class="type">long</span>) arg; <span class="comment">// arg参数为新客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd,strbuffer,<span class="built_in">sizeof</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd,strbuffer,<span class="built_in">strlen</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(clientfd);  <span class="comment">// 关闭客户端的连接。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意几个问题：</p><p>1）线程主函数的函数体中，不能使用<code>return;</code>语句，如果想退出线程，可以用<code>pthread_exit(0);</code>返回。</p><p>2）线程可以共享全局变量，当然也可以共享TcpServer的m_clientfd成员变量，但是，创建线程的时候，为什么要把客户端的socket用参数传给线程主函数，而不是直接获取TcpServer.m_clientfd的值，因为主进程调用pthread_create创建线程后，立即返回循环重新Accept，创建线程需要时间，如果在这段时间内有新的客户端连接上来，TcpServer.m_clientfd的值会发生改变。</p><p>3）TcpServer.m_clientfd的强制转换，在创建线程的时候，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;pthid,<span class="literal">NULL</span>,pth_main,(<span class="type">void</span>*)((<span class="type">long</span>)TcpServer.m_clientfd))!=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>线程中的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> clientfd=(<span class="type">long</span>) arg; <span class="comment">// arg参数为新客户端的socket。</span></span><br></pre></td></tr></table></figure><p>这种数据类型的转换方法可能会让初学者不理解，在学习指针的时候说过，指针是用来存放变量的地址，不能把整数赋给指针，那现在这是怎么回事？这么说吧，C语言很灵活，数据类型可以强制转换，怎么转过去就怎么转回来。举个例子：水桶是用来装水的，特殊情况下用水桶来装板砖其实也可以，但是，板砖放入水桶的方法和从水桶中取出板砖的方法与水不同，怎么放进去就怎么取出来。</p><p>4）book261.cpp程序有一个漏洞，没有保存客户端的socket，主程序退出时，没有关闭客户端的socket，资源没有释放，这么说您可能难以理解，没有关系，等您真的需要编写多线程的socket服务端程序的时候就明白了。</p><h1 id="三-线程资源的回收"><a class="markdownIt-Anchor" href="#三-线程资源的回收"></a> 三、线程资源的回收</h1><p>线程有joinable和unjoinable两种状态，如果线程是joinable状态，当线程主函数终止时（自己退出或调用pthread_exit退出）不会释放线程所占用内存资源和其它资源，这种线程被称为“僵尸线程”。创建线程时默认是非分离的，或者称为可连接的（joinable）。</p><p>避免僵尸线程就是如何正确的回收线程资源，有四种方法：</p><p>1）方法一：创建线程前，调用pthread_attr_setdetachstate将线程设为detached，这样线程退出时，系统自动回收线程资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"><span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr,PTHREAD_CREATE_DETACHED);  <span class="comment">// 设置线程的属性。</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;pthid,&amp;attr,pth_main,(<span class="type">void</span>*)((<span class="type">long</span>)TcpServer.m_clientfd);</span><br></pre></td></tr></table></figure><p>2）方法二：创建线程后，在创建线程的程序中调用pthread_detach将新创建的线程设置为detached状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(pthid);</span><br></pre></td></tr></table></figure><p>3）方法3：创建线程后，在创建线程的程序中调用pthread_join等待线程退出，一般不会采用这种方法，因为pthread_join会发生阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span>(pthid,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>4）方法4：在线程主函数中调用pthread_detach改变自己的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());</span><br></pre></td></tr></table></figure><h1 id="四-查看线程"><a class="markdownIt-Anchor" href="#四-查看线程"></a> 四、查看线程</h1><p>1）在top命令中，如果加上-H参数，top中的每一行显示的不是进程，而是一个线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H</span><br></pre></td></tr></table></figure><p>2）在ps命令中加-xH参数也可以显示线程，加grep可以过滤内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -xH</span><br><span class="line">ps -xH|grep book261</span><br></pre></td></tr></table></figure><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>Linux没有真正意义上的线程，它的实现是由进程来模拟，属于用户级线程。所以，在Linux系统下，进程与线程在性能和资源消耗方面没有本质的差别。</p><p><strong>对我们程序员来说，进程不能共享全局数据，线程可以共享全局数据，各位可以根据应用场景选择采用多进程或多线程。</strong></p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号量</title>
      <link href="/posts/4ba52713.html"/>
      <url>/posts/4ba52713.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-信号量的概念"><a class="markdownIt-Anchor" href="#一-信号量的概念"></a> 一、信号量的概念</h1><p>信号量（信号灯）本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读/写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</p><p>信号量是一个特殊的变量，只允许进程对它进行等待信号和发送信号操作。最简单的信号量是取值0和1的二元信号量，这是信号量最常见的形式。</p><p>通用信号量（可以取多个正整数值）和信号量集方面的知识比较复杂，应用场景也比较少。</p><p>本文只介绍二元信号量。</p><h1 id="二-相关函数"><a class="markdownIt-Anchor" href="#二-相关函数"></a> 二、相关函数</h1><p>Linux中提供了一组函数用于操作信号量，程序中需要包含以下头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="1-semget函数"><a class="markdownIt-Anchor" href="#1-semget函数"></a> 1、semget函数</h2><p>semget函数用来获取或创建信号量，它的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><p>1）参数key是信号量的键值，typedef unsigned int key_t，是信号量在系统中的编号，不同信号量的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。</p><p>2）参数nsems是创建信号量集中信号量的个数，该参数只在创建信号量集时有效，这里固定填1。</p><p>3）参数sem_flags是一组标志，如果希望信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。如果没有设置IPC_CREAT标志并且信号量不存在，就会返错误（errno的值为2，No such file or directory）。</p><p>4）如果semget函数成功，返回信号量集的标识；失败返回-1，错误原因存于error中。</p><p>示例：</p><p>1）获取键值为0x5000的信号量，如果该信号量不存在，就创建它，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> semid=<span class="built_in">semget</span>(<span class="number">0x5000</span>,<span class="number">1</span>,<span class="number">0640</span>|IPC_CREAT); </span><br></pre></td></tr></table></figure><p>2）获取键值为0x5000的信号量，如果该信号量不存在，返回-1，errno的值被设置为2，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> semid= <span class="built_in">semget</span>(<span class="number">0x5000</span>,<span class="number">1</span>,<span class="number">0640</span>)；</span><br></pre></td></tr></table></figure><h2 id="2-semctl函数"><a class="markdownIt-Anchor" href="#2-semctl函数"></a> 2、semctl函数</h2><p>该函数用来控制信号量（常用于设置信号量的初始值和销毁信号量），它的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>1）参数semid是由semget函数返回的信号量标识。</p><p>2）参数sem_num是信号量集数组上的下标，表示某一个信号量，填0。</p><p>3）参数cmd是对信号量操作的命令种类，常用的有以下两个：</p><p><strong>IPC_RMID</strong>：销毁信号量，不需要第四个参数；</p><p><strong>SETVAL</strong>：初始化信号量的值（信号量成功创建后，需要设置初始值），这个值由第四个参数决定。第四参数是一个自定义的共同体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于信号灯操作的共同体。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4）如果semctl函数调用失败返回-1；如果成功，返回值比较复杂，暂时不关心它。</p><p>示例：</p><p>1）销毁信号量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">semctl</span>(semid,<span class="number">0</span>,IPC_RMID);</span><br></pre></td></tr></table></figure><p>2）初始化信号量的值为1，信号量可用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">sem_union.val = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">semctl</span>(semid,<span class="number">0</span>,SETVAL,sem_union);</span><br></pre></td></tr></table></figure><h2 id="3-semop函数"><a class="markdownIt-Anchor" href="#3-semop函数"></a> 3、semop函数</h2><p>该函数有两个功能：1）等待信号量的值变为1，如果等待成功，立即把信号量的值置为0，这个过程也称之为等待锁；2）把信号量的值置为1，这个过程也称之为释放锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure><p>1）参数semid是由semget函数返回的信号量标识。</p><p>2）参数nsops是操作信号量的个数，即sops结构变量的个数，设置它的为1（只对一个信号量的操作）。</p><p>3）参数sops是一个结构体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">short</span> sem_num;   <span class="comment">// 信号量集的个数，单个信号量设置为0。</span></span><br><span class="line">  <span class="type">short</span> sem_op;    <span class="comment">// 信号量在本次操作中需要改变的数据：-1-等待操作；1-发送操作。</span></span><br><span class="line">  <span class="type">short</span> sem_flg;   <span class="comment">// 把此标志设置为SEM_UNDO，操作系统将跟踪这个信号量。</span></span><br><span class="line">                   <span class="comment">// 如果当前进程退出时没有释放信号量，操作系统将释放信号量，避免资源被死锁。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><p>1）等待信号量的值变为1，如果等待成功，立即把信号量的值置为0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>2）把信号量的值置为1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"><span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="三-示例程序"><a class="markdownIt-Anchor" href="#三-示例程序"></a> 三、示例程序</h1><p>为了便于理解，我把信号量的操作封装成CSEM类，称之为信号灯，类似互斥锁，包括初始化信号灯、等待信号灯、挂出信号灯和销毁信号灯。</p><h2 id="1-示例book259cpp"><a class="markdownIt-Anchor" href="#1-示例book259cpp"></a> 1、示例（book259.cpp）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book259.cpp，此程序用于演示信号量的使用方法。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSEM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">semun</span>  <span class="comment">// 用于信号灯操作的共同体。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span>  sem_id;  <span class="comment">// 信号灯描述符。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">key_t</span> key)</span></span>; <span class="comment">// 如果信号灯已存在，获取信号灯；如果信号灯不存在，则创建信号灯并初始化。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span>;          <span class="comment">// 等待信号灯挂出。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span></span>;          <span class="comment">// 挂出信号灯。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">destroy</span><span class="params">()</span></span>;       <span class="comment">// 销毁信号灯。</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   CSEM sem;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始信号灯。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">init</span>(<span class="number">0x5000</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.init failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.init ok\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">wait</span>()==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.wait failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.wait ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">50</span>);  <span class="comment">// 在sleep的过程中，运行其它的book259程序将等待锁。</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">post</span>()==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.post failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.post ok\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 销毁信号灯。</span></span><br><span class="line">   <span class="comment">// if (sem.destroy()==false) &#123; printf(&quot;sem.destroy failed.\n&quot;); return -1; &#125;</span></span><br><span class="line">   <span class="comment">// printf(&quot;sem.destroy ok\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::init</span><span class="params">(<span class="type">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取信号灯。</span></span><br><span class="line">  <span class="keyword">if</span> ( (sem_id=<span class="built_in">semget</span>(key,<span class="number">1</span>,<span class="number">0640</span>)) == <span class="number">-1</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">// 如果信号灯不存在，创建它。</span></span><br><span class="line">    <span class="keyword">if</span> (errno==<span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (sem_id=<span class="built_in">semget</span>(key,<span class="number">1</span>,<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;init 1 semget()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 信号灯创建成功后，还需要把它初始化成可用的状态。</span></span><br><span class="line">      <span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">      sem_union.val = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id,<span class="number">0</span>,SETVAL,sem_union) &lt;  <span class="number">0</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;init semctl()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="built_in">perror</span>(<span class="string">&quot;init 2 semget()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;destroy semctl()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">  sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">  sem_b.sem_op = <span class="number">-1</span>; </span><br><span class="line">  sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;wait semop()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CSEM::post</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">  sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">  sem_b.sem_op = <span class="number">1</span>;   </span><br><span class="line">  sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;post semop()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-测试方法"><a class="markdownIt-Anchor" href="#2-测试方法"></a> 2、测试方法</h2><p>第一步：运行book259程序，它会创建键值为5000的信号灯，并持有锁，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305180130425.png" alt="在这里插入图片描述" /></p><p>第二步：立即再运行一个book259程序，它会获取键值为5000的信号灯，并等待锁，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305180139481.png" alt="在这里插入图片描述" /></p><p>第三步，当第一次运行的book259程序sleep完50秒之后，释放锁，第二个运行book259的程序将获得锁；</p><p>第四步，可以启动更多的book259程序，它们将排队等待锁。</p><h1 id="四-其它的操作命令"><a class="markdownIt-Anchor" href="#四-其它的操作命令"></a> 四、其它的操作命令</h1><p>用ipcs -s 可以查看系统的信号量，内容有键值（key），信号量编号（semid），创建者（owner），权限（perms），信号量数（nsems）。</p><p><img src="https://img-blog.csdnimg.cn/2020030518094350.png" alt="在这里插入图片描述" /></p><p>用ipcrm -sem 信号量编号，可以手工删除信号量，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305180959334.png" alt="在这里插入图片描述" /></p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>============</p><p>课后作业，编写示例程序，利用信号灯给共享内存加锁。</p><p>注意一个问题，程序对共享内存的操作是很快的，很难测试出读/写共享冲突的情况，可以在程序员采用sleep语句，假设程序操作共享内存需要时间。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux共享内存</title>
      <link href="/posts/fef582bb.html"/>
      <url>/posts/fef582bb.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-共享内存的概念"><a class="markdownIt-Anchor" href="#一-共享内存的概念"></a> 一、共享内存的概念</h1><p>共享内存（Shared Memory）就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的读/写加锁，可以使用信号灯。</p><h1 id="二-相关函数"><a class="markdownIt-Anchor" href="#二-相关函数"></a> 二、相关函数</h1><p>Linux中提供了一组函数用于操作共享内存，程序中需要包含以下头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="1-shmget函数"><a class="markdownIt-Anchor" href="#1-shmget函数"></a> 1、shmget函数</h2><p>shmget函数用来获取或创建共享内存，它的声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数key是共享内存的键值，是一个整数，typedef unsigned int key_t，是共享内存在系统中的编号，不同共享内存的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。</p><p>参数size是待创建的共享内存的大小，以字节为单位。</p><p>参数shmflg是共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存。</p><h2 id="2-shmat函数"><a class="markdownIt-Anchor" href="#2-shmat函数"></a> 2、shmat函数</h2><p>把共享内存连接到当前进程的地址空间。它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数shm_id是由shmget函数返回的共享内存标识。</p><p>参数shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p>参数shm_flg是一组标志位，通常为0。</p><p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p><h2 id="3-shmdt函数"><a class="markdownIt-Anchor" href="#3-shmdt函数"></a> 3、shmdt函数</h2><p>该函数用于将共享内存从当前进程中分离，相当于shmat函数的反操作。它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>参数shmaddr是shmat函数返回的地址。</p><p>调用成功时返回0，失败时返回-1.</p><h2 id="4-shmctl函数"><a class="markdownIt-Anchor" href="#4-shmctl函数"></a> 4、shmctl函数</h2><p>删除共享内存，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>参数shm_id是shmget函数返回的共享内存标识符。</p><p>参数command填IPC_RMID。</p><p>参数buf填0。</p><p>解释一下，shmctl是控制共享内存的函数，其功能不只是删除共享内容，但其它的功能没什么用，所以不介绍了。</p><p><strong>注意，用root创建的共享内存，不管创建的权限是什么，普通用户无法删除。</strong></p><h1 id="三-示例程序"><a class="markdownIt-Anchor" href="#三-示例程序"></a> 三、示例程序</h1><p><strong>示例（book258.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book258.cpp，此程序用于演示共享内存的用法</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> shmid; <span class="comment">// 共享内存标识符</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建共享内存，键值为0x5005，共1024字节。</span></span><br><span class="line">  <span class="keyword">if</span> ( (shmid = <span class="built_in">shmget</span>((<span class="type">key_t</span>)<span class="number">0x5005</span>, <span class="number">1024</span>, <span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;shmat(0x5005) failed\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="type">char</span> *ptext=<span class="number">0</span>;   <span class="comment">// 用于指向共享内存的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将共享内存连接到当前进程的地址空间，由ptext指针指向它</span></span><br><span class="line">  ptext = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作本程序的ptext指针，就是操作共享内存</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;写入前：%s\n&quot;</span>,ptext);</span><br><span class="line">  <span class="built_in">sprintf</span>(ptext,<span class="string">&quot;本程序的进程号是：%d&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;写入后：%s\n&quot;</span>,ptext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">  <span class="built_in">shmdt</span>(ptext);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 删除共享内存</span></span><br><span class="line">  <span class="comment">// if (shmctl(shmid, IPC_RMID, 0) == -1)</span></span><br><span class="line">  <span class="comment">// &#123; printf(&quot;shmctl(0x5005) failed\n&quot;); return -1; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305173508356.png" alt="在这里插入图片描述" /></p><p>注意，程序第一次运行的时候，共享内存未创建，所以第一次运行程序的时候，共享内存中的内容为空。之后程序每次运行都能获取到上一次程序运行写入的内容。</p><h1 id="四-其它的操作命令"><a class="markdownIt-Anchor" href="#四-其它的操作命令"></a> 四、其它的操作命令</h1><p>用ipcs -m可以查看系统的共享内存，内容有键值（key），共享内存编号（shmid），创建者（owner），权限（perms），大小（bytes）。</p><p><img src="https://img-blog.csdnimg.cn/20200305173535830.png" alt="在这里插入图片描述" /></p><p>用ipcrm -m 共享内存编号，可以手工删除共享内存，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305173546999.png" alt="在这里插入图片描述" /></p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>============</p><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号</title>
      <link href="/posts/99134621.html"/>
      <url>/posts/99134621.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-如何让程序在后台运行"><a class="markdownIt-Anchor" href="#一-如何让程序在后台运行"></a> 一、如何让程序在后台运行</h1><p>在之前的章节中，如果要运行程序，在命令提示行下输入程序名后回车，程序被执行，然后等待程序运行完成，在程序运行的过程中，也可以用Ctrl+c中止它。</p><p>在实际开发中，我们需要让程序在后台运行，没有界面，没有用户输入数据，例如socket服务端程序book250。</p><p>如果想让程序在后台运行，有两种方法。</p><h2 id="1-加符号"><a class="markdownIt-Anchor" href="#1-加符号"></a> 1、加“&amp;”符号</h2><p>如果想让程序在后台运行，执行程序的时候，命令的最后面加“&amp;”符号。</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book250 &amp;</span><br></pre></td></tr></table></figure><p>程序就在后台运行了。</p><p><img src="https://img-blog.csdnimg.cn/20200305164356719.png" alt="在这里插入图片描述" /></p><p>在后台运行的程序，用Ctrl+c无法中断，并且就算终端退出了，程序仍在后台运行。</p><p>如果终端退出了，后台运行的程序将由系统托管。</p><p><img src="https://img-blog.csdnimg.cn/20200305164452174.png" alt="在这里插入图片描述" /></p><p>在第一张图中，book250的父进程是12178，第二张图中，book250的父进程是1。</p><p>为了不影响接下来的学习，用killall book250指令让book250程序退出。</p><p><img src="https://img-blog.csdnimg.cn/20200305164516214.png" alt="在这里插入图片描述" /></p><h2 id="2-采用fork"><a class="markdownIt-Anchor" href="#2-采用fork"></a> 2、采用fork</h2><p>另一种方法是采用fork，主程序执行fork，生成一个子进程，然后父进程退出，留下子进程继续运行，子进程将由系统托管。</p><p>在book250的main函数后增加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>重新编译后执行book250，运行效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305165858732.png" alt="在这里插入图片描述" /></p><p>上图中，20752是fork后的子进程，它的父进程号是1，是系统进程（亲爹没了，天地日月为父）。</p><h2 id="3-如何让中止后台运行中程序"><a class="markdownIt-Anchor" href="#3-如何让中止后台运行中程序"></a> 3、如何让中止后台运行中程序</h2><p>问题来了，程序在后台运行了，离开了终端控制，用Ctrl+c上也无法中止，那怎么让它停下来呢？暂时用一个笨方法，杀了它。</p><p>杀程序有两个方法：</p><p>1）killall 程序名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall book250</span><br></pre></td></tr></table></figure><p><strong>执行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305165933274.png" alt="在这里插入图片描述" /><br />2）先用“ps -ef|grep 程序名”找到程序的进程编号，然后用“kill 进程编号”。</p><p><strong>执行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305170052532.png" alt="在这里插入图片描述" /></p><h1 id="二-signal信号"><a class="markdownIt-Anchor" href="#二-signal信号"></a> 二、signal信号</h1><p>signal信号是Linux编程中非常重要的部分，接下来将详细介绍信号的基本概念、实现和使用，和与信号的几个系统调用（库函数）。</p><p>signal信号是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断，从它的命名可以看出，它的实质和使用很象中断。信号是进程控制的一部分。</p><h2 id="1-信号的基本概念"><a class="markdownIt-Anchor" href="#1-信号的基本概念"></a> 1、信号的基本概念</h2><p>软中断信号（signal，又简称为信号）用来通知进程发生了事件。进程之间可以通过调用kill库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。</p><p>注意，信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种：</p><p>1）第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。</p><p>2）第二种是设置中断的处理函数，收到信号后，由该函数来处理。</p><p>3）第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。</p><h2 id="2-信号的类型"><a class="markdownIt-Anchor" href="#2-信号的类型"></a> 2、信号的类型</h2><p>发出信号的原因很多，这里按发出信号的原因简单分类，以了解各种信号：</p><table><thead><tr><th>信号名</th><th>信号值</th><th>默认处 理动作</th><th>发出信号的原因</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>A</td><td>终端挂起或者控制进程终止</td></tr><tr><td><strong>SIGINT</strong></td><td><strong>2</strong></td><td><strong>A</strong></td><td><strong>键盘中断Ctrl+c</strong></td></tr><tr><td>SIGQUIT</td><td>3</td><td>C</td><td>键盘的退出键被按下</td></tr><tr><td>SIGILL</td><td>4</td><td>C</td><td>非法指令</td></tr><tr><td>SIGABRT</td><td>6</td><td>C</td><td>由abort(3)发出的退出指令</td></tr><tr><td>SIGFPE</td><td>8</td><td>C</td><td>浮点异常</td></tr><tr><td><strong>SIGKILL</strong></td><td><strong>9</strong></td><td><strong>AEF</strong></td><td><strong>采用kill -9 进程编号 强制杀死程序。</strong></td></tr><tr><td><strong>SIGSEGV</strong></td><td><strong>11</strong></td><td><strong>C</strong></td><td><strong>无效的内存引用</strong></td></tr><tr><td>SIGPIPE</td><td>13</td><td>A</td><td>管道破裂:写一个没有读端口的管道</td></tr><tr><td>SIGALRM</td><td>14</td><td>A</td><td>由alarm(2)发出的信号</td></tr><tr><td><strong>SIGTERM</strong></td><td><strong>15</strong></td><td><strong>A</strong></td><td><strong>采用“kill 进程编号”或“killall 程序名”通知程序。</strong></td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>A</td><td>用户自定义信号1</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>A</td><td>用户自定义信号2</td></tr><tr><td><strong>SIGCHLD</strong></td><td><strong>20,17,18</strong></td><td><strong>B</strong></td><td><strong>子进程结束信号</strong></td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td></td><td>进程继续（曾被停止的进程）</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>DEF</td><td>终止进程</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>D</td><td>控制终端（tty）上按下停止键</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>D</td><td>后台进程企图从控制终端读</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>D</td><td>后台进程企图从控制终端写</td></tr></tbody></table><p>处理动作一项中的字母含义如下</p><p>A 缺省的动作是终止进程。</p><p>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。</p><p>C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员<br />提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</p><p>D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去。</p><p>E 信号不能被捕获。</p><p>F 信号不能被忽略。</p><h2 id="3-signal库函数"><a class="markdownIt-Anchor" href="#3-signal库函数"></a> 3、signal库函数</h2><p>signal库函数可以设置程序对信号的处理方式。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><p>参数signum表示信号的编号。</p><p>参数handler表示信号的处理方式，有三种情况：</p><p>1）SIG_IGN：忽略参数signum所指的信号。</p><p>2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。</p><p>3）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。</p><p>程序员不关心signal的返回值。</p><h2 id="4-信号有什么用"><a class="markdownIt-Anchor" href="#4-信号有什么用"></a> 4、信号有什么用</h2><p>服务程序运行在后台，如果想让中止它，强行杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有释放资源，会影响系统的稳定，用Ctrl+c中止与杀程序是相同的效果。</p><p>如果能向后台程序发送一个信号，后台程序收到这个信号后，调用一个函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。</p><p>信号还可以用于网络服务程序抓包等，这是较复杂的应用场景，暂时不介绍。</p><h2 id="5-信号应用示例"><a class="markdownIt-Anchor" href="#5-信号应用示例"></a> 5、信号应用示例</h2><p>在实际开发中，在main函数开始的位置，程序员会先屏蔽掉全部的信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">100</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN);</span><br></pre></td></tr></table></figure><p>这么做的目的是不希望程序被干扰。然后，再设置程序员关心的信号的处理函数。</p><p>程序员关心的信号有三个：SIGINT、SIGTERM和SIGKILL。</p><p>程序在运行的进程中，如果按Ctrl+c，将向程序发出SIGINT信号，信号编号是2。</p><p>采用“kill 进程编号”或“killall 程序名”向程序发出的是SIGTERM信号，编号是15。</p><p>采用“kill -9 进程编号”向程序发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p><p>所以，程序员只要设置SIGINT和SIGTERM两个信号的处理函数就可以了，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p><p><strong>示例（book257.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book257.cpp，此程序用于演示用信号通知后台服务程序退出。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;收到了信号%d，程序退出。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里添加释放资源的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">// 程序退出。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">100</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN); <span class="comment">// 屏蔽全部的信号</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,EXIT);  <span class="built_in">signal</span>(SIGTERM,EXIT); <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">// 一个死循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305170352818.png" alt="在这里插入图片描述" /></p><p>不管是用Ctrl+c还是kill，程序都能体面的退出。</p><h1 id="三-发送信号"><a class="markdownIt-Anchor" href="#三-发送信号"></a> 三、发送信号</h1><p>Linux操作系统提供了kill命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>kill函数将参数sig指定的信号给参数pid 指定的进程。</p><p>参数pid 有几种情况：</p><p>1）pid&gt;0 将信号传给进程号为pid 的进程。</p><p>2）pid=0将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。</p><p>3）pid=-1将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。</p><p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。</p><p>返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。</p><p>EINVAL：指定的信号码无效（参数 sig 不合法）。</p><p>EPERM：权限不够无法传送信号给指定进程。</p><p>ESRCH：参数 pid 所指定的进程或进程组不存在。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>本章节的重点是介绍信号的应用场景，属于概念性的知识，代码其实很简单，只要各位理解了信号原理和应用就可以了。</p><p>但是，文章中提到的知识点，大家一定要用程序去测试它。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程间通信</title>
      <link href="/posts/e0738fea.html"/>
      <url>/posts/e0738fea.html</url>
      
        <content type="html"><![CDATA[<p>进程的数据空间是独立的，私有的，不能相互访问，但是在某些情况下进程之间需要通信来实现某功能或交换数据，包括：</p><p>1）数据传输：一个进程需要将它的数据发送给另一个进程。</p><p>2）共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p><p>3）通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如通知进程退出）。</p><p>4）进程控制：一个进程希望控制另一个进程的运行。</p><h1 id="一-进程通信"><a class="markdownIt-Anchor" href="#一-进程通信"></a> 一、进程通信</h1><p>进程通信的方式大概分为六种。</p><p>1）管道：包括无名管道（pipe）及命名管道（named pipe），无名管道可用于具有父进程和子进程之间的通信。命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p>2）消息队列（message）：进程可以向队列中添加消息，其它的进程则可以读取队列中的消息。</p><p>3）信号（signal）：信号用于通知其它进程有某种事件发生。</p><p>4）共享内存（shared memory）：多个进程可以访问同一块内存空间。</p><p>5）信号量（semaphore）：也叫信号灯，用于进程之间对共享资源进行加锁。</p><p>6）套接字（socket）：可用于不同计算机之间的进程间通信。</p><h1 id="二-应用经验"><a class="markdownIt-Anchor" href="#二-应用经验"></a> 二、应用经验</h1><p>1）管道和消息队列太过时了，实在没什么应用价值，了解概念就行。</p><p>2）socket可以用于不同系统之间的进程通信，完全可以代替只能在同一系统中进程之间通信的管道和消息队列。</p><p>3）信号的应用场景非常多，主要用于进程的控制，例如通知正在运行中的后台服务程序退出。</p><p>4）同一系统中，进程之间采用共享内存交换数据的效率是最高的，但是，共享内存没有加锁的机制，所以经常与信号灯结合一起来使用，在高性能的网络服务端程序中，可以用共享内存作为的数据缓存（cache）。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多进程的应用</title>
      <link href="/posts/4e0c5a44.html"/>
      <url>/posts/4e0c5a44.html</url>
      
        <content type="html"><![CDATA[<p>前面的章节介绍socket通信的时候，socket的服务端在同一时间只能和一个客户端通信，并不是服务端有多忙，而是因为单进程的程序在同一时间只能做一件事情，不可能一边等待客户端的新连接一边与其它的客户端进行通信。</p><h1 id="一-并发的服务端"><a class="markdownIt-Anchor" href="#一-并发的服务端"></a> 一、并发的服务端</h1><p>如果把socket服务端改为多进程，在每次accept到一个客户端的连接后，生成一个子进程，让子进程负责和这个客户端通信，父进程继续accept客户端的连接，socket的服务端在监听新客户端的同时，还可以与多个客户端进行通信。这就是并发，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200305155612655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="1-服务端"><a class="markdownIt-Anchor" href="#1-服务端"></a> 1、服务端</h2><p>把book248.cpp修改一下，改为多进程。</p><p><strong>示例（book250.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book250.cpp，此程序用于演示多进程的socket通信服务端。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_listenfd;   <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="type">int</span> m_clientfd;   <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">int</span> port)</span></span>;  <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;  <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;    <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;    <span class="comment">// 关闭用于监听的socket</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// signal(SIGCHLD,SIG_IGN);  // 忽略子进程退出的信号，避免产生僵尸进程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) &#123; TcpServer.<span class="built_in">CloseClient</span>(); <span class="keyword">continue</span>; &#125;  <span class="comment">// 父进程回到while，继续Accept。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程负责与客户端进行通信，直到客户端断开连接。</span></span><br><span class="line">    TcpServer.<span class="built_in">CloseListen</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端已连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">    <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">      <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 或者exit(0)，子进程退出。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">  m_listenfd=m_clientfd=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_listenfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  m_listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (m_clientfd=<span class="built_in">accept</span>(m_listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span>    <span class="comment">// 关闭客户端的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_clientfd); m_clientfd=<span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span>    <span class="comment">// 关闭用于监听的socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：</p><p>1）在CTcpServer中增加了两个成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;    <span class="comment">// 关闭客户端的socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;    <span class="comment">// 关闭用于监听的socket</span></span><br></pre></td></tr></table></figure><p>2）当有客户端连上来的时候，主进程执行fork，这时候会客户端的socket（m_clientfd）被复制了一份，对父进程来说，只负责监听客户端的连接，不需要与客户端通信，所以父进程关闭m_clientfd，注意，父进程关闭m_clientfd对子进程中的m_clientfd没有影响。</p><p>3）当有客户端连上来的时候，主进程执行fork，这时候服务端用于监听的socket（m_listenfd）也会被复制了一份，对子进程来说，只需要与客户端通信，不需要监听客户端的连接，所以子进程关闭监听的m_listenfd，同理，子进程关闭m_listenfd对父进程中的m_listenfd没有影响。</p><p>4）子进程执行完任务后，要调用retrun或exit(0)退出，如果没有调用return或exit(0)，子进程将又会回到while循环首部。</p><h2 id="2-客户端"><a class="markdownIt-Anchor" href="#2-客户端"></a> 2、客户端</h2><p>把book247.cpp修改一下，循环的次数改为50，每次与服务端完成报文交互后sleep一秒，方便观察程序运行的效果。</p><p><strong>示例（book249.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book249.cpp，此程序对book247.cpp略作修改，用于测试多进程的socket通信客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_sockfd;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpClient</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;172.16.0.15&quot;</span>,<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;172.16.0.15\&quot;,5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">50</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// sleep一秒，方便观察程序的运行。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  m_sockfd=<span class="number">0</span>;  <span class="comment">// 构造函数初始化m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::~<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_sockfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_sockfd);  <span class="comment">// 析构函数关闭m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpClient::ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">  <span class="keyword">if</span> ( (h=<span class="built_in">gethostbyname</span>(serverip))==<span class="number">0</span> ) </span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port); </span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(m_sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr))!=<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动服务端book250，然后启动多个book249，可以看到服务端可以同时与多个客户端进行通信，查看服务端的进行如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305160034649.png" alt="在这里插入图片描述" /><br />注意，服务端book250的主程序的while是一个死循环，没有退出机制，可以按Ctrl+c强制中止它，这不是正确的办法，后面我会介绍正确的方法。</p><h1 id="二-僵尸进程"><a class="markdownIt-Anchor" href="#二-僵尸进程"></a> 二、僵尸进程</h1><h2 id="1-僵尸进程产生的原因"><a class="markdownIt-Anchor" href="#1-僵尸进程产生的原因"></a> 1、僵尸进程产生的原因</h2><p>一个子进程在调用return或exit(0)结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个僵尸进程。</p><p>先启动服务端程序book250，然后多次启动客户端程序book249，马上查看book250的进程，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200305160112991.png" alt="在这里插入图片描述" /></p><p>等全部的客户端book249程序运行完成后，再查看book250的进程，如下图。</p><p><img src="https://img-blog.csdnimg.cn/20200305160124882.png" alt="在这里插入图片描述" /></p><p>被选中的就是僵尸进程，有&lt;defunct&gt;标志。</p><p>如果按Ctrl+c终止book250后，父进程退出，僵尸进程随之消失。</p><h2 id="2-僵尸进程的危害"><a class="markdownIt-Anchor" href="#2-僵尸进程的危害"></a> 2、僵尸进程的危害</h2><p>僵尸进程是子进程结束时，父进程又没有回收子进程占用的资源。</p><p>僵尸进程在消失之前会继续占用系统资源。</p><p>如果父进程先退出，子进程被系统接管，子进程退出后系统会回收其占用的相关资源，不会成为僵尸进程。父进和先退出的应用场景在以后的章节中介绍。</p><h2 id="3-如何解决僵尸进程"><a class="markdownIt-Anchor" href="#3-如何解决僵尸进程"></a> 3、如何解决僵尸进程</h2><p>解决僵尸进程的方法有两种。</p><p>子进程退出之前，会向父进程发送一个信号，父进程调用waid函数等待这个信号，只要等到了，就不会产生僵尸进程。这话说得容易，在并发的服务程序中这是不可能的，因为父进程要做其它的事，例如等待客户端的新连接，不可能去等待子进程的退出信号，这个方法我就不介绍了。</p><p>另一种方法就是父进程直接忽略子进程的退出信号，具体做法很简单，在主程序中启用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGCHLD,SIG_IGN);  <span class="comment">// 忽略子进程退出的信号，避免产生僵尸进程</span></span><br></pre></td></tr></table></figure><p>signal函数的用法暂时不介绍，以后会有详细说明。</p><p>先启动服务端程序book250，然后多次启动客户端程序book249，等book249运行结束后再查看book250的进程，不再有僵尸进程。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>在学习了多进程的基础知识之后，初学者可能会认为多进程是一个高大上的技术，认为多进程处理数据肯定比单进程快，其实不是。在实际开发中，采用多进程的主要目的是处理多个并发的任务，而不是为了提高程序的效率。</p><p>从效率方面来说，某些场景下多进程的效率比单进程低，原因很简单，因为在有限的硬件资源中，多进程程序的内存开销更大，还会产生资源的竞争。就像多个人端着一盆水，不如一个人端着一盆水走得快。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>本章节的重点是介绍多进程的应用场景，属于概念性的知识，代码其实很简单，只要各位理解了多进程应用的原理就行了。</p><p>但是，文章中提到的知识点，大家一定要用程序去测试它。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多进程</title>
      <link href="/posts/3fdf8525.html"/>
      <url>/posts/3fdf8525.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-进程的概念"><a class="markdownIt-Anchor" href="#一-进程的概念"></a> 一、进程的概念</h1><p>什么是进程？进程这个概念是针对系统而不是针对程序员的，对程序员来说，我们面对的概念是程序，当输入指令执行一个程序的时候，对系统而言，它将启动一个进程。</p><p>进程就是正在内存中运行中的程序，Linux下一个进程在内存里有三部分的数据，就是“代码段”、”堆栈段”和”数据段”。”代码段”，顾名思义，就是存放了程序代码。“堆栈段”存放的就是程序的返回地址、程序的参数以及程序的局部变量。而“数据段”则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用new函数分配的空间）。</p><p>系统如果同时运行多个相同的程序，它们的“代码段”是相同的，“堆栈段”和“数据段”是不同的（相同的程序，处理的数据不同）。</p><h1 id="二-进程的编号"><a class="markdownIt-Anchor" href="#二-进程的编号"></a> 二、进程的编号</h1><h2 id="1-查看进程"><a class="markdownIt-Anchor" href="#1-查看进程"></a> 1、查看进程</h2><p>ps 查看当前终端的进程。</p><p><img src="https://img-blog.csdnimg.cn/20200305153006162.png" alt="在这里插入图片描述" /></p><p>ps -ef 查看系统全部的进程。</p><p>ps -ef |more 查看系统全部的进程，结果分页显示。</p><p><img src="https://img-blog.csdnimg.cn/2020030515302358.png" alt="在这里插入图片描述" /></p><p>UID ：启动进程的操作系统用户。</p><p>PID ：进程编号。</p><p>PPID ：进程的父进程的编号。</p><p>C          ：CPU使用的资源百分比。</p><p>STIME ：进程启动时间。</p><p>TTY     ：进程所属的终端。</p><p>TIME   ：使用掉的CPU时间。</p><p>CMD   ：执行的是什么指令。</p><p>ps -ef |grep book查看系统全部的进程，然后从结果集中过滤出包含“book”单词的记录。程序员用得最多的指令就是这个了。</p><p><img src="https://img-blog.csdnimg.cn/20200305153045677.png" alt="在这里插入图片描述" /></p><h2 id="2-getpid库函数"><a class="markdownIt-Anchor" href="#2-getpid库函数"></a> 2、getpid库函数</h2><p>getpid库函数的功能是获取本程序运行时进程的编号。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>函数没有参数，返回值是进程的编号，pid_t就是typedef int pid_t。</p><p><strong>示例（book251.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book251.cpp，此程序用于演示获取程序运行时的进程编号</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本程序的进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">30</span>);    <span class="comment">// 是为了方便查看进程在shell下用ps -ef|grep book251查看本进程的编号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030515321396.png" alt="在这里插入图片描述" /></p><p>在book251运行时，切换到其它的窗口，执行ps -ef|grep book251可以查看进程，如下。</p><p><img src="https://img-blog.csdnimg.cn/20200305153319436.png" alt="在这里插入图片描述" /></p><p>注意两个细节：</p><p>1）进程的编号是系统动态分配的，相同的程序在不同的时间执行，进程的编号是不同的。</p><p>2）进程的编号会循环使用，但是，在同一时间，进程的编号是唯一的，也就是说，不管任何时间，系统不可能存在两个编号相同的进程。</p><h1 id="三-多进程"><a class="markdownIt-Anchor" href="#三-多进程"></a> 三、多进程</h1><p>fork在英文中是“分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork函数，就产生了另一个进程，于是进程就“分叉”了，所以这个名字取得很形象。下面就看看如何具体使用fork函数，这段程序演示了使用fork的基本框架。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>fork函数用于产生一个新的进程，函数返回值pid_t是一个整数，在父进程中，返回值是子进程编号，在子进程中，返回值是0。</p><p><strong>示例（book252.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book252.cpp，此程序用于演示用fork生成一个子进程。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本程序的进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ipid=fork();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);       <span class="comment">// sleep等待进程的生成。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>,ipid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ipid!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;父进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;子进程编号是：%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">30</span>);    <span class="comment">// 是为了方便查看进程在shell下用ps -ef|grep book252查看本进程的编号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305153451933.png" alt="在这里插入图片描述" /></p><p>查看进程情况，出现了两个book进程。</p><p><img src="https://img-blog.csdnimg.cn/20200305153528656.png" alt="在这里插入图片描述" /><br />初学者可能用点接受不了现实。</p><p>1）一个函数（fork）返回了两个值？</p><p>2）if和else中的代码能同时被执行？</p><p>那么调用这个fork函数时发生了什么呢？fork函数创建了一个新的进程，新进程（子进程）与原有的进程（父进程）一模一样。子进程和父进程使用相同的代码段；子进程拷贝了父进程的堆栈段和数据段。子进程一旦开始运行，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。</p><p>fork函数对返回值做了特别的处理，调用fork函数之后，在子程序中fork的返回值是0，在父进程中fork的返回值仍是原进程的编号，程序员可以通过fork的返回值来区分父进程和子进程，然后再执行不同的代码。</p><p><strong>示例（book253.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book253.cpp，此程序用于演示用fork生成一个子进程后，父子进程进入不同的流程。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fatchfunc</span><span class="params">()</span>  <span class="comment">// 父进程流程的主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我是老子，我喜欢孩子他娘。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">childfunc</span><span class="params">()</span>  <span class="comment">// 子进程流程的主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我是儿子，我喜欢西施。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;这是父进程，将调用fatchfunc()。\n&quot;</span>); <span class="built_in">fatchfunc</span>();&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;这是子进程，将调用childfunc()。\n&quot;</span>);  <span class="built_in">childfunc</span>();&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;父子进程执行完自己的函数后都来这里。\n&quot;</span>); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305153634305.png" alt="在这里插入图片描述" /></p><p>在上文上已提到过，子进程拷贝了父进程的堆栈段和数据段，也就是说，在父进程中定义的变量子进程中会复制一个副本，fork之后，子进程对变量的操作不会影响交父进程，父进程对变量的操作也不会影响子进程。</p><p><strong>示例（book254.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book254.cpp，此程序用于演示用fork之后的父子进程在内存中是独立的数据空间。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ii=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> jj=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    ii=<span class="number">11</span>;jj=<span class="number">21</span>; <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="built_in">printf</span>(<span class="string">&quot;父进程：ii=%d,jj=%d\n&quot;</span>,ii,jj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; </span><br><span class="line">    ii=<span class="number">12</span>;jj=<span class="number">22</span>; <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="built_in">printf</span>(<span class="string">&quot;子进程：ii=%d,jj=%d\n&quot;</span>,ii,jj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305153744739.png" alt="在这里插入图片描述" /></p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）编写一个多进程程序，验证子进程是复制父进程的内存变量，还是父子进程共享内存变量？</p><p>2）编写一个示例程序，由父进程生成10个子进程，在子进程中显示它是第几个子进程和子进程本身的进程编号。</p><p>3）编写示例程序，由父进程生成子进程，子进程再生成孙进程，共生成第10代进程，在各级子进程中显示它是第几代子进程和子进程本身的进程编号。</p><p>4）利用尽可能少的代码快速fork出更多的进程，试试看能不能把linux系统搞死。</p><p>5）ps -ef |grep book251命令是ps和grep两个系统命令的组合，各位查一下资料，了解一下grep命令的功能，对程序员来，grep是经常用到的命令。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装socket通信类</title>
      <link href="/posts/6e96bc72.html"/>
      <url>/posts/6e96bc72.html</url>
      
        <content type="html"><![CDATA[<p>book241.cpp和book242.cpp程序已经有点长了，有些啰嗦了，如果还想扩展功能，或用于多进程、多线程，程序结构将非常复杂。</p><p>不管是socket通信程序的客户端还是服务端，准备工作的代码又长又难看占地方，影响了主程序的结构，必须分离出来。</p><p>如何分离？ 封装。</p><h1 id="一-c的封装方法"><a class="markdownIt-Anchor" href="#一-c的封装方法"></a> 一、C的封装方法</h1><p>C语言只能把程序代码封装成函数。</p><h2 id="1-客户端"><a class="markdownIt-Anchor" href="#1-客户端"></a> 1、客户端</h2><p><strong>示例（book245.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book245.cpp，此程序用于演示用C语言的方法封装socket客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端连服务端的函数，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connecttoserver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="type">int</span> sockfd=<span class="built_in">connecttoserver</span>(<span class="string">&quot;118.89.50.198&quot;</span>,<span class="number">5051</span>);</span><br><span class="line">  <span class="keyword">if</span> (sockfd&lt;=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;连接服务器失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">10</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(sockfd,strbuffer,<span class="built_in">strlen</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(sockfd,strbuffer,<span class="built_in">sizeof</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端连服务端的函数，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="comment">// 返回值：成功返回已连接socket，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connecttoserver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(serverip)) == <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;gethostbyname&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port); </span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book245.cpp中，把客户端连接服务端的socket操作封装到connecttoserver函数中，主程序的代码更简洁。</p><h2 id="2-服务端"><a class="markdownIt-Anchor" href="#2-服务端"></a> 2、服务端</h2><p><strong>示例（book246.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book246.cpp，此程序用于演示用C语言的方法封装socket服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="comment">// 返回值：成功返回初始化的socket，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> listenfd=<span class="built_in">initserver</span>(<span class="number">5051</span>);  <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="keyword">if</span> (listenfd&lt;=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端初始化失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受客户端的连接。</span></span><br><span class="line">  <span class="type">int</span>  clientfd;                  <span class="comment">// 客户端的socket</span></span><br><span class="line">  <span class="keyword">if</span> ( (clientfd=<span class="built_in">accept</span>(listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;服务端accept失败，程序退出。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd,strbuffer,<span class="built_in">sizeof</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd,strbuffer,<span class="built_in">strlen</span>(strbuffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(clientfd); <span class="built_in">close</span>(listenfd); <span class="comment">// 关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="comment">// 返回值：成功返回初始化的socket，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initserver</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book246.cpp中，把服务端初始化socket操作封装到initserver函数中，主程序的代码更简洁。</p><h1 id="二-c的封装方法"><a class="markdownIt-Anchor" href="#二-c的封装方法"></a> 二、C++的封装方法</h1><p>C++语言可以封装数据和函数，采用的是类。</p><h2 id="1-客户端-2"><a class="markdownIt-Anchor" href="#1-客户端-2"></a> 1、客户端</h2><p><strong>示例（book247.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book247.cpp，此程序用于演示用C++的方法封装socket客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP客户端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_sockfd;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpClient</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span>;</span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpClient</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(<span class="string">&quot;118.89.50.198&quot;</span>,<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(\&quot;118.89.50.198\&quot;,5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  m_sockfd=<span class="number">0</span>;  <span class="comment">// 构造函数初始化m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::~<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_sockfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_sockfd);  <span class="comment">// 析构函数关闭m_sockfd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发起连接，serverip-服务端ip，port通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpClient::ConnectToServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *serverip,<span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">// 创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line">  <span class="keyword">if</span> ( (h=<span class="built_in">gethostbyname</span>(serverip))==<span class="number">0</span> ) </span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务器的地址和端口转换为数据结构</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port); </span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务器发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(m_sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr))!=<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_sockfd); m_sockfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpClient::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_sockfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-服务端-2"><a class="markdownIt-Anchor" href="#2-服务端-2"></a> 2、服务端</h2><p><strong>示例（book248.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book248.cpp，此程序用于演示用C++的方法封装socket服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_listenfd;   <span class="comment">// 服务端用于监听的socket</span></span><br><span class="line">  <span class="type">int</span> m_clientfd;   <span class="comment">// 客户端连上来的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">InitServer</span><span class="params">(<span class="type">int</span> port)</span></span>;  <span class="comment">// 初始化服务端</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;  <span class="comment">// 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向对端发送报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line">  <span class="comment">// 接收对端的报文</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CTcpServer</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="number">5051</span>)==<span class="literal">false</span>)</span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.InitServer(5051) failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>() == <span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.Accept() failed,exit...\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已连接。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strbuffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Recv</span>(strbuffer,<span class="built_in">sizeof</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,strbuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(strbuffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Send</span>(strbuffer,<span class="built_in">strlen</span>(strbuffer))&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,strbuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造函数初始化socket</span></span><br><span class="line">  m_listenfd=m_clientfd=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_listenfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">  <span class="keyword">if</span> (m_clientfd!=<span class="number">0</span>) <span class="built_in">close</span>(m_clientfd);  <span class="comment">// 析构函数关闭socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务端的socket，port为通信端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  <span class="comment">// 创建服务端的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 绑定通信端口</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把socket设置为监听模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">0</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CTcpServer::Accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (m_clientfd=<span class="built_in">accept</span>(m_listenfd,<span class="number">0</span>,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">send</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpServer::Recv</span><span class="params">(<span class="type">void</span> *buf,<span class="type">const</span> <span class="type">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">recv</span>(m_clientfd,buf,buflen,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-c封装的意义"><a class="markdownIt-Anchor" href="#3-c封装的意义"></a> 3、C++封装的意义</h2><p>采用C++封装的意义主要有以下几方面。</p><p>1）把数据初始化的代码放在构造函数中；</p><p>2）把关闭socket等释放资源的代码放在析构函数中；</p><p>3）把socket定义为类的成员变量，类外部的代码根本看不到socket。</p><p>4）代码更简洁，更安全（析构函数自动调用关闭socket，释放资源）。</p><h1 id="三-应用经验"><a class="markdownIt-Anchor" href="#三-应用经验"></a> 三、应用经验</h1><p>本章节演示了如何封装socket，这种封装是最简单的，socket通讯的知识点不算多，但是要用好它并不容易，这么说吧，如果把这两个章节介绍的知识完全掌握，差不多就摸到门槛了，还算不上入门，千万别说自己精通socket通信，后面的路还长。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>充分理解本章节的内容，丰富您的函数库，编写您自己的CTcpClient类和CTcpServer类放入_public.h和_public.cpp中，可以作为您的通用工具。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信基础socket</title>
      <link href="/posts/e32fddd2.html"/>
      <url>/posts/e32fddd2.html</url>
      
        <content type="html"><![CDATA[<p>各位兄弟，在学习Linux编程基础之前，一定要先学习Linux基础知识和计算机网络基础知识，如果对这两方面的基础知识和基本概念不熟，谈不上Linux编程和网络通信编程。</p><h1 id="一-socket通信的概念"><a class="markdownIt-Anchor" href="#一-socket通信的概念"></a> 一、socket通信的概念</h1><p>socket也称作“套接字”，描述了计算机的IP地址和端口，运行在计算机中的程序之间采用socket进行数据通信。通信的两端都有socket，它是一个通道，数据在两个socket之间进行传输。</p><p>socket把复杂的TCP/IP协议族隐藏在socket接口后面，对程序员来说，只要用好socket相关的函数，就可以完成数据通信。</p><h1 id="二-套接字socket"><a class="markdownIt-Anchor" href="#二-套接字socket"></a> 二、套接字（socket）</h1><p>TCP提供了流（stream）和数据报（datagram）两种通信机制，所以套接字也分为流套接字和数据报套接字。</p><p>流套接字的类型是SOCK_STREAM，它提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有出错后重新发送的机制（就像两个人在打电话，聊天您一句我一句，有来有往，没听清楚就再说一次）。</p><p>数据报套接的类型是SOCK_DGRAM，它不需要建立和维持一个连接，采用UDP/IP协议实现。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输，它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它不需要建立和维持连接（就像一个人向另一个人发短信，一条短信发出去，对方不一定能收到）。</p><p>在实际开发中，数据报套接字（即UDP）的应用场景极少，本章节只介绍流套接字。</p><h1 id="三-socket通信的过程"><a class="markdownIt-Anchor" href="#三-socket通信的过程"></a> 三、socket通信的过程</h1><p>1）服务端程序将一个套接字绑定到指定的ip地址和端口，并通过此套接字等待和监听客户的连接请求。</p><p>2）客户程序向服务端程序绑定的地址和端口发出连接请求。</p><p>3）服务端接受连接请求。</p><p>4）客户端和服务端通过读写套接字进行通信。</p><h1 id="在这里插入图片描述四-客户服务端模式"><a class="markdownIt-Anchor" href="#在这里插入图片描述四-客户服务端模式"></a> <img src="https://img-blog.csdnimg.cn/20200305144642607.png" alt="在这里插入图片描述" /><br />四、客户/服务端模式</h1><p>在TCP/IP网络应用中，两个程序之间通信模式是客户/服务端模式（client/server），客户/服务端也叫作客户/服务器，各人习惯。</p><h2 id="服务端的工作流程"><a class="markdownIt-Anchor" href="#服务端的工作流程"></a> 服务端的工作流程</h2><p>1）创建服务端的socket。</p><p>2）把服务端用于通信的地址和端口绑定到socket上。</p><p>3）把socket设置为监听模式。</p><p>4）接受客户端的连接。</p><p>5）与客户端通信，接收客户端发过来的报文后，回复处理结果。</p><p>6）不断的重复第5）步，直到客户端断开连接。</p><p>7）关闭socket，释放资源。</p><p><strong>服务端示例（book242.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book242.cpp，此程序用于演示socket通信的服务端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 第1步：创建服务端的socket。</span></span><br><span class="line">  <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第2步：把服务端用于通信的地址和端口绑定到socket上。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET。</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);          <span class="comment">// 任意ip地址。</span></span><br><span class="line">  <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;118.89.50.198&quot;); // 指定ip地址。</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5051</span>);  <span class="comment">// 指定通信端口。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第3步：把socket设置为监听模式。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第4步：接受客户端的连接。</span></span><br><span class="line">  <span class="type">int</span>  clientfd;                  <span class="comment">// 客户端的socket。</span></span><br><span class="line">  <span class="type">int</span>  socklen=<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in); <span class="comment">// struct sockaddr_in的大小</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;  <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">  clientfd=<span class="built_in">accept</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,(<span class="type">socklen_t</span>*)&amp;socklen);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端（%s）已连接。\n&quot;</span>,<span class="built_in">inet_ntoa</span>(clientaddr.sin_addr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(clientfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">// 接收客户端的请求报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(clientfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">// 向客户端发送响应结果。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第6步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(listenfd); <span class="built_in">close</span>(clientfd);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端的工作流程"><a class="markdownIt-Anchor" href="#2-客户端的工作流程"></a> 2、客户端的工作流程</h2><p>1）创建客户端的socket。</p><p>2）向服务器发起连接请求。</p><p>3）与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</p><p>4）不断的重复第3）步，直到全部的数据被发送完。</p><p>5）第4步：关闭socket，释放资源。</p><p><strong>客户端示例（book241.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book241.cpp，此程序用于演示socket的客户端</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 第1步：创建客户端的socket。</span></span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第2步：向服务器发起连接请求。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h; </span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(<span class="string">&quot;118.89.50.198&quot;</span>)) == <span class="number">0</span> )   <span class="comment">// 指定服务端的ip地址。</span></span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;gethostbyname&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5051</span>); <span class="comment">// 指定服务端的通信端口。</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span>)  <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第3步：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">3</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">send</span>(sockfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;    <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv</span>(sockfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>) <span class="keyword">break</span>;    <span class="comment">// 接收服务端返回的结果。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第4步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在运行程序之前，必须保证服务器的防火墙已经开通了网络访问策略，如果您不明这句话的意思，说明您的Linux基础知识不够，请先学习Linux基础知识之后再来学习socket通信。</strong></p><p>先启动服务端程序book242，服务端启动后，进入等待客户端连接状态，然后启动客户端。</p><p>客户端的输出如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305144923229.png" alt="在这里插入图片描述" /><br />服务端的输出如下：</p><h1 id="在这里插入图片描述五-注意事项"><a class="markdownIt-Anchor" href="#在这里插入图片描述五-注意事项"></a> <img src="https://img-blog.csdnimg.cn/20200305144932953.png" alt="在这里插入图片描述" /><br />五、注意事项</h1><h2 id="1-别去纠缠细节"><a class="markdownIt-Anchor" href="#1-别去纠缠细节"></a> 1、别去纠缠细节</h2><p>在socket通信的客户端和服务器的程序里，出现了多种数据结构，调用了多个函数，涉及到很多方面的知识，对初学者来说，更重要的是了解socket通信的过程、每段代码的用途和函数调用的功能，不要去纠缠这些结构体和函数的参数，这些函数和参数虽然比较多，但可以修改的非常少，别抄错就可以了，需要注意的地方我会提出。</p><h2 id="2-服务端程序绑定地址"><a class="markdownIt-Anchor" href="#2-服务端程序绑定地址"></a> 2、服务端程序绑定地址</h2><p>如果服务器有多个网卡，多个IP地址，socket通信可以指定用其中一个地址来进行通信，也可以任意ip地址。</p><p>1）指定ip地址的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.149.129&quot;</span>); <span class="comment">// 指定ip地址</span></span><br></pre></td></tr></table></figure><p>2）任意ip地址的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本主机的任意ip地址</span></span><br></pre></td></tr></table></figure><p>在实际开发中，采用任意ip地址的方式比较多。</p><h2 id="3-服务端程序绑定的通信端口"><a class="markdownIt-Anchor" href="#3-服务端程序绑定的通信端口"></a> 3、服务端程序绑定的通信端口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5000</span>);  <span class="comment">// 通信端口</span></span><br></pre></td></tr></table></figure><h2 id="4-客户端程序指定服务端的ip地址"><a class="markdownIt-Anchor" href="#4-客户端程序指定服务端的ip地址"></a> 4、客户端程序指定服务端的ip地址</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* h; <span class="comment">// ip地址信息的数据结构</span></span><br><span class="line"><span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(<span class="string">&quot;192.168.149.129&quot;</span>)) == <span class="number">0</span> )</span><br><span class="line">&#123; <span class="built_in">perror</span>(<span class="string">&quot;gethostbyname&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="5-客户端程序指定服务端的通信端口"><a class="markdownIt-Anchor" href="#5-客户端程序指定服务端的通信端口"></a> 5、客户端程序指定服务端的通信端口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="6-send函数"><a class="markdownIt-Anchor" href="#6-send函数"></a> 6、send函数</h2><p>send函数用于把数据通过socket发送给对端。不论是客户端还是服务端，应用程序都用send函数来向TCP连接的另一端发送数据。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd为已建立好连接的socket。</p><p>buf为需要发送的数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，内存中有什么就发送什么。</p><p>len需要发送的数据的长度，为buf中有效数据的长度。</p><p>flags填0, 其他数值意义不大。</p><p>函数返回已发送的字符数。出错时返回-1，错误信息errno被标记。</p><p>注意，就算是网络断开，或socket已被对端关闭，send函数不会立即报错，要过几秒才会报错。</p><p>如果send函数返回的错误（&lt;=0），表示通信链路已不可用。</p><h2 id="7-recv函数"><a class="markdownIt-Anchor" href="#7-recv函数"></a> 7、recv函数</h2><p>recv函数用于接收对端socket发送过来的数据。</p><p>recv函数用于接收对端通过socket发送过来的数据。不论是客户端还是服务端，应用程序都用recv函数接收来自TCP连接的另一端发送过来数据。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd为已建立好连接的socket。</p><p>buf为用于接收数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，只要是一块内存就行了。</p><p>len需要接收数据的长度，不能超过buf的大小，否则内存溢出。</p><p>flags填0, 其他数值意义不大。</p><p>如果socket的对端没有发送数据，recv函数就会等待，如果对端发送了数据，函数返回接收到的字符数。出错时返回-1，错误信息errno被标记。如果socket被对端关闭，返回值为0。</p><p>如果recv函数返回的错误（&lt;=0），表示通信通道已不可用。</p><h2 id="8-服务端有两个socket"><a class="markdownIt-Anchor" href="#8-服务端有两个socket"></a> 8、服务端有两个socket</h2><p>对服务端来说，有两个socket，一个是用于监听的socket，还有一个就是客户端连接成功后，由accept函数创建的用于与客户端收发报文的socket。</p><h2 id="9-程序退出时先关闭socket"><a class="markdownIt-Anchor" href="#9-程序退出时先关闭socket"></a> 9、程序退出时先关闭socket</h2><p>socket是系统资源，操作系统打开的socket数量是有限的，在程序退出之前必须关闭已打开的socket，就像关闭文件指针一样，就像delete已分配的内存一样，极其重要。</p><p>值得注意的是，关闭socket的代码不能只在main函数的最后，那是程序运行的理想状态，还应该在main函数的每个return之前关闭。</p><h1 id="六-相关的库函数"><a class="markdownIt-Anchor" href="#六-相关的库函数"></a> 六、相关的库函数</h1><h2 id="1-socket函数"><a class="markdownIt-Anchor" href="#1-socket函数"></a> 1、socket函数</h2><p>socket函数用于创建一个新的socket，也就是向系统申请一个socket资源。socket函数用户客户端和服务端。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>domain：协议域，又称协议族（family）。常用的协议族有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p><p>type：指定socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。流式socket（SOCK_STREAM）是一种面向连接的socket，针对于面向连接的TCP服务应用。数据报式socket（SOCK_DGRAM）是一种无连接的socket，对应于无连接的UDP服务应用。</p><p>protocol：指定协议。常用协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p><p>说了一大堆废话，第一个参数只能填AF_INET，第二个参数只能填SOCK_STREAM，第三个参数只能填0。</p><p>除非系统资料耗尽，socket函数一般不会返回失败。</p><h2 id="2-gethostbyname函数"><a class="markdownIt-Anchor" href="#2-gethostbyname函数"></a> 2、gethostbyname函数</h2><p>把ip地址或域名转换为hostent 结构体表达的地址。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> *<span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span> *name);</span><br></pre></td></tr></table></figure><p>参数name，域名或者主机名，例如&quot;192.168.1.3&quot;、&quot;<a href="http://www.freecplus.net">www.freecplus.net</a>&quot;等。</p><p>返回值：如果成功，返回一个hostent结构指针，失败返回NULL。</p><p>gethostbyname只用于客户端。</p><p>gethostbyname只是把字符串的ip地址转换为结构体的ip地址，只要地址格式没错，一般不会返回错误。函数失败不会设置errno的值。</p><h2 id="3-connect函数"><a class="markdownIt-Anchor" href="#3-connect函数"></a> 3、connect函数</h2><p>向服务器发起连接请求。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr * serv_addr, <span class="type">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>函数说明：connect函数用于将参数sockfd 的socket 连至参数serv_addr<br />指定的服务端，参数addrlen为sockaddr的结构长度。</p><p>返回值：成功则返回0, 失败返回-1, 错误原因存于errno 中。</p><p>connect函数只用于客户端。</p><p>如果服务端的地址错了，或端口错了，或服务端没有启动，connect一定会失败。</p><h2 id="4-bind函数"><a class="markdownIt-Anchor" href="#4-bind函数"></a> 4、bind函数</h2><p>服务端把用于通信的地址和端口绑定到socket上。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数sockfd，需要绑定的socket。</p><p>参数addr，存放了服务端用于通信的地址和端口。</p><p>参数addrlen表示addr结构体的大小。</p><p>如果绑定的地址错误，或<strong>端口已被占用</strong>，bind函数一定会报错，否则一般不会返回错误。</p><h2 id="5-listen函数"><a class="markdownIt-Anchor" href="#5-listen函数"></a> 5、listen函数</h2><p>listen函数把主动连接套接字变为被动连接的套接字，使得这个socket可以接受其它socket的连接请求，从而成为一个服务端的socket。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>返回：0-成功， -1-失败</p><p>参数sockfd是已经被bind过的套接字。socket函数返回的套接字是一个主动连接的套接字，在服务端的编程中，程序员希望这个套接字可以接受外来的连接请求，也就是被动等待客户端来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告诉系统，程序员通过调用listen函数来完成这件事。</p><p>参数backlog，这个参数涉及到一些网络的细节，比较麻烦，填5、10都行，一般不超过30。</p><p>当调用listen之后，服务端的套接字就可以调用accept来接受客户端的连接请求。</p><p>listen函数一般不会返回错误。</p><h2 id="6-accept函数"><a class="markdownIt-Anchor" href="#6-accept函数"></a> 6、accept函数</h2><p>服务端接受客户端的连接。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数sockfd是已经被listen过的套接字。</p><p>参数addr用于存放客户端的地址信息，用sockaddr结构体表达，如果不需要客户端的地址，可以填0。</p><p>参数addrlen用于存放addr参数的长度，如果addr为0，addrlen也填0。</p><p>accept函数等待客户端的连接，如果没有客户端连上来，它就一直等待，这种方式称之为阻塞。</p><p>accept等待到客户端的连接后，创建一个新的套接字，函数返回值就是这个新的套接字，服务端使用这个新的套接字和客户端进行报文的收发。</p><p>accept在等待的过程中，如果被中断或其它的原因，函数返回-1，表示失败，如果失败，可以重新accept。</p><h2 id="7-函数小结"><a class="markdownIt-Anchor" href="#7-函数小结"></a> 7、函数小结</h2><p>服务端函数调用的流程是：socket-&gt;bind-&gt;listen-&gt;accept-&gt;<strong>recv/send</strong>-&gt;close</p><p>客户端函数调用的流程是：socket-&gt;connect-&gt;<strong>send/recv</strong>-&gt;close</p><p>其中<strong>send/recv</strong>可以进行多次交互。</p><h1 id="七-课后作业"><a class="markdownIt-Anchor" href="#七-课后作业"></a> 七、课后作业</h1><p>1）把book241.cpp和book242.cpp抄下来，编译运行，试试修改参数再运行。</p><p>2）book241.cpp和book242.cpp程序中，有些代码不能动，有些代码可以动，把能动的都动一下，就算是抄代码，也要抄个明白。</p><p>3）服务端的accept函数会阻塞，阻塞是专业名词，即等待，可以用代码测试一下。</p><p>4）不管是服务端还是客户端recv函数也会阻塞，可以用代码测试一下。</p><p>5）修改book241.cpp和book242.cpp，实现点对点的聊天功能，用户在客户端输入一个字符串，然后发送给服务端，服务端收到客户端的报文后，也提示用户输入一个字符串，返回给客户端，如果服务端收到客户端的报文是“bye”通信结束。</p><p>6）如果以上作业都能完成，建议再把本文章的内容再看一次，对文章开始部分的理论知识将有新的理解。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Linux编程前的准备</title>
      <link href="/posts/b8c80ece.html"/>
      <url>/posts/b8c80ece.html</url>
      
        <content type="html"><![CDATA[<p>如果您是非计算机相关专业零基础兄弟，在学习Linux编程基础之前，建议先学习计算机基础、Linux操作系统基础知识和计算机网络基础知识。</p><p>计算机基础知识包括了很多常识性的内容，学了不一定有用，但是如果对一些基本常识不了解，可能会闹笑话。</p><p>我们学习的目标是成为C/C++程序员，不是Linux系统管理员，也不是网络管理员。作为一个程序员，只需要了解Linux操作系统和计算机网络的基础知识就可以了，不需要深入研究它们的原理。大家不要去买这两方面书籍，建议大家去买一个云服务器，腾讯、华为、阿里的都可以，一年不超过100元，云服务器对学习非常有帮助，<strong>远远超过任何书籍。</strong></p><p>最好的学习方法是到网上找<strong>免费的视频教程</strong>，例如B站、腾讯课堂、CSDN学院等，这些很基础的知识网上非常多。</p><p><strong>总的来说，以学习概念和扩充知识面为主，不要深入理论，不要学习算法，应用为王。</strong></p><h1 id="一-计算机基础知识的学习"><a class="markdownIt-Anchor" href="#一-计算机基础知识的学习"></a> 一、计算机基础知识的学习</h1><p>====================</p><p>1）计算机历史。</p><p>2）计算机的应用领域。</p><p>3）二进制、十进制、十六进制的基本概念。</p><p>4）计算机总线、外部设备。</p><p>5）计算机软件、操作系统基本概念。</p><p>6）学习时间不超过20小时。</p><p>7）推荐视频<a href="https://www.bilibili.com/video/av80537766">https://www.bilibili.com/video/av80537766</a></p><h1 id="二-linux操作系统的学习内容"><a class="markdownIt-Anchor" href="#二-linux操作系统的学习内容"></a> 二、Linux操作系统的学习内容</h1><p>1）Linux系统简介。</p><p>2）Linux系统的安装。</p><p>3）远程登录命令（以ssh为主，了解telnet）。</p><p>4）Linux常用命令，注意，Linux的命令上千个，常用的约50个，能看懂多少就多少，看不懂的就算了，与程序员相关的Linux命令我会在教程中提到。</p><p>5）Linux用户和组的管理。</p><p>6）Linux文件系统。</p><p>7）Shell基础，注意，Shell可以很复杂，Shell脚本也是一种编程语言，但是，我们是C/C++程序员，一般不会采用Shell编写脚本程序，运维人员使用Shell脚本比较多。</p><p>8）Linux进程方面的基础知识。</p><p>9）Linux防火墙配置。</p><p>10）学习的时间不必超过50小时。</p><p>11）推荐视频<a href="https://www.bilibili.com/video/av18156598">https://www.bilibili.com/video/av18156598</a></p><h1 id="三-计算机网络的学习内容"><a class="markdownIt-Anchor" href="#三-计算机网络的学习内容"></a> 三、计算机网络的学习内容</h1><p>1）计算机网络的基本概念。</p><p>2）局域网、广域网和互联网。</p><p>3）ISO参考模型。</p><p>4）TCP协议（粗略的了解一下UDP）。</p><p>5）IP地址、网关、子网掩码、DHCP协议。</p><p>6）万维网和HTTP和HTTPS协议。</p><p>7）电子邮件和SMTP 协议。</p><p>8）文件传输协议FTP。</p><p>9）远程登录协议（以ssh为主，了解telnet）。</p><p>10）学习的时间不必超过30小时。</p><p>11）推荐视频<a href="https://www.bilibili.com/video/av70228743">https://www.bilibili.com/video/av70228743</a>或<a href="https://www.bilibili.com/video/av9876107">https://www.bilibili.com/video/av9876107</a></p><h1 id="四-学习策略"><a class="markdownIt-Anchor" href="#四-学习策略"></a> 四、学习策略</h1><p><strong>以学习概念和扩充知识面为主，不要深入理论，不要学习算法，应用为王。</strong></p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的多态</title>
      <link href="/posts/8f6e21d8.html"/>
      <url>/posts/8f6e21d8.html</url>
      
        <content type="html"><![CDATA[<p>多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就可能会用到多态。</p><p>C++多态就是当调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><h1 id="一-静态多态"><a class="markdownIt-Anchor" href="#一-静态多态"></a> 一、静态多态</h1><p>我们以前说过的函数重载就是一个简单的静态多态，静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错。</p><p><strong>示例（book236.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book236.cpp，此程序用于演示C++类的静态多态。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>       <span class="comment">// 显示超女基本信息的成员函数体</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\n&quot;</span>,m_name,m_age,m_height,m_sc,m_yz); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CKCon</span>:<span class="keyword">public</span> CGirl   <span class="comment">// 定义王妃类，从超女类继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_ch[<span class="number">50</span>];      <span class="comment">// 称号</span></span><br><span class="line">  <span class="type">char</span> m_palace[<span class="number">50</span>];  <span class="comment">// 居住的宫殿</span></span><br><span class="line">  <span class="type">int</span>  m_sal;         <span class="comment">// 奉禄</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>     <span class="comment">// 显示王妃的称号、宫殿和奉禄</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\n&quot;</span>,m_name,m_ch,m_palace,m_sal); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CKCon KCon;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_name,<span class="string">&quot;杨玉环&quot;</span>);   KCon.m_age=<span class="number">28</span>;            KCon.m_height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_sc,<span class="string">&quot;火辣&quot;</span>);       <span class="built_in">strcpy</span>(KCon.m_yz,<span class="string">&quot;漂亮&quot;</span>); <span class="built_in">strcpy</span>(KCon.m_ch,<span class="string">&quot;杨贵妃&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_palace,<span class="string">&quot;华清宫&quot;</span>); KCon.m_sal=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">  CGirl *pGirl;   <span class="comment">// 基类的指针</span></span><br><span class="line">  CKCon *pCon;   <span class="comment">// 派生类的指针</span></span><br><span class="line"></span><br><span class="line">  pGirl=pCon=&amp;KCon;  <span class="comment">// 都指向派生类</span></span><br><span class="line"></span><br><span class="line">  pGirl-&gt;<span class="built_in">Show</span>();   <span class="comment">// 将调用的是基类的Show方法</span></span><br><span class="line">  pCon-&gt;<span class="built_in">Show</span>();    <span class="comment">// 将调用的是派生类的Show方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305141738165.png" alt="在这里插入图片描述" /></p><p>在book236.cpp的main函数中，创建的是CKCon对象，如果采用基类指针调用Show方法，变成了调用CGirl类的Show方法，而不是CKcon类的Show方法，因为pGirl是CGirl的指针，pGirl-&gt;Show方法在程序编译期间就已经设置好了。</p><h1 id="二-动态多态"><a class="markdownIt-Anchor" href="#二-动态多态"></a> 二、动态多态</h1><p>动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。</p><p>让我们对程序稍作修改，在CGirl类中，Show方法的声明前放置关键字 virtual，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>       <span class="comment">// 显示超女基本信息的成员函数体</span></span></span><br></pre></td></tr></table></figure><p>其它的代码都不变，编译并运行，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305141817988.png" alt="在这里插入图片描述" /></p><p>此时，编译器看的是指针的内容，而不是它的类型。这就是多态的一般使用方式。</p><h1 id="三-虚函数"><a class="markdownIt-Anchor" href="#三-虚函数"></a> 三、虚函数</h1><p>虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义虚函数。</p><p>我们想要的是在程序中可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p><h1 id="四-纯虚函数"><a class="markdownIt-Anchor" href="#四-纯虚函数"></a> 四、纯虚函数</h1><p>我们可以在基类中只声明虚函数，没有函数的定义，在派生类中去实现函数的定义，这个时候就会用到纯虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Show</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">// 申明一个纯虚函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>virtual int Show()=0;;告诉编译器，函数只有声明，没有定义，是纯虚函数。</p><h1 id="五-c-接口抽象类"><a class="markdownIt-Anchor" href="#五-c-接口抽象类"></a> 五、C++ 接口（抽象类）</h1><p>接口描述了类的行为和功能，是标准和规范，而不需要完成类的功能实现。</p><p>C++接口是用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</p><p>设计抽象类的目的，是为了给其他类提供一个可以继承的基类。抽象类不能用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p><p>如果一个基类的派生类需要实例化，则必须实现每个虚函数的定义，如果没有在派生类中纯虚函数的定义会导致编译错误。</p><p>可用于实例化对象的类被称为具体类。</p><h1 id="六-应用经验"><a class="markdownIt-Anchor" href="#六-应用经验"></a> 六、应用经验</h1><p>对初学者来说，类的多态、虚函数这些概念可能难以理解，因为您想不到它的应用场景，在实际开发中，这些知识的应用场景也比较少，在一些大型的项目开发中才可能用到，二十年来我只用过一次。</p><p>各位只要了解一下这些知识就可以了，掌握不了就算了。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的继承与派生</title>
      <link href="/posts/26c0d8f0.html"/>
      <url>/posts/26c0d8f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-继承"><a class="markdownIt-Anchor" href="#一-继承"></a> 一、继承</h1><p>继承是面向对象程序设计中最重要的一个概念。继承允许我们根据一个类来定义另一个类，达到了代码功能重用效果。</p><p>当创建一个类时，如果待创建的类与另一个类存在某些共同特征，程序员不需要全部重新编写成员变量和成员函数，只需指定继承另一个类即可，被继承的类称为基类或父类，新建的类称为派生类或子类。</p><h1 id="二-基类和派生类"><a class="markdownIt-Anchor" href="#二-基类和派生类"></a> 二、基类和派生类</h1><p>定义一个派生类，需要指定它的基类，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式&gt; &lt;基类名&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 派生类类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式是 public、protected 或 private 其中的一个，基类是之前定义过的某个类的名称。如果未指定继承方式，则默认为private。</p><p>选秀之后，被选中的超女成了宫女和王妃，宫女和王妃从超女那里继承了姓名、年龄、身高、身材、颜值等特征，还会具备一些新的特征，如果是王妃，有称号、居住的宫殿、奉䘵、为她服务的太监和宫女数量等。还有，王妃的年龄、身材和颜值都不能随便讨论的，会掉脑袋的。</p><p><strong>示例（book235.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book235.cpp，此程序用于演示C++类的继承与派生。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>       <span class="comment">// 显示超女基本信息的成员函数体 </span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\n&quot;</span>,m_name,m_age,m_height,m_sc,m_yz);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CKCon</span>:<span class="keyword">public</span> CGirl   <span class="comment">// 定义王妃类，从超女类继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_ch[<span class="number">50</span>];      <span class="comment">// 称号</span></span><br><span class="line">  <span class="type">char</span> m_palace[<span class="number">50</span>];  <span class="comment">// 居住的宫殿</span></span><br><span class="line">  <span class="type">int</span>  m_sal;         <span class="comment">// 奉禄</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span>     <span class="comment">// 显示王妃的称号、宫殿和奉禄</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\n&quot;</span>,m_name,m_ch,m_palace,m_sal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CKCon KCon;   <span class="comment">// 实例化一个KCon对象</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_name,<span class="string">&quot;杨玉环&quot;</span>);</span><br><span class="line">  KCon.m_age=<span class="number">28</span>;      </span><br><span class="line">  KCon.m_height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_ch,<span class="string">&quot;杨贵妃&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(KCon.m_palace,<span class="string">&quot;华清宫&quot;</span>);</span><br><span class="line">  KCon.m_sal=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">  KCon.<span class="built_in">Show</span>();   <span class="comment">// 如果子类中没有Show函数，就会调用父类的Show函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305140744151.png" alt="在这里插入图片描述" /></p><h1 id="三-继承方式"><a class="markdownIt-Anchor" href="#三-继承方式"></a> 三、继承方式</h1><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种方式，当使用不同类型的继承时，遵循以下几个规则：</p><p>1）公有继承（public）：当类派生以public方式继承时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</p><p>2）保护继承（protected）： 当类派生以protected方式继承时，基类的公有和保护成员将成为派生类的保护成员。</p><p>3）私有继承（private）：当类派生以private方式继承时，基类的公有和保护成员将成为派生类的私有成员。</p><p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。</p><p>五、基类与派生类的指针</p><p>基类的指针可以指向基类对象，也可以指向派生类对象，但是不能通过基类的指针访问派生类的成员。</p><p>派生类的指针可以指向派生类对象，但不可以指向基类对象。</p><h1 id="六-多继承"><a class="markdownIt-Anchor" href="#六-多继承"></a> 六、多继承</h1><p>多继承即一个派生类可以有多个基类，它继承了多个基类的特性。</p><p>C++ 类可以从多个基类继承成员，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 派生类类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>类的继承与派生在windows环境开发中用得比较多，在Linux环境下用得比较少，这么多年来，我只是偶尔用一下，大家只要了解继承与派生基本用法就行了，如果在实际开发中真的要用到类的继承，再来研究也不迟，这个没什么技术难度。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深理解和映象。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++动态内存管理</title>
      <link href="/posts/9dd7550d.html"/>
      <url>/posts/9dd7550d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-c动态内存"><a class="markdownIt-Anchor" href="#一-c动态内存"></a> 一、C++动态内存</h1><p>在C<ins>程序中，内存需求都是在编写程序的时候声明变量来确定，但是程序在运行过程中需要动态分配内存的情况，C</ins>语言将运算符new和delete合成在一起。</p><h2 id="1-特点"><a class="markdownIt-Anchor" href="#1-特点"></a> 1、特点</h2><p>中通过new关键字向系统内存申请。</p><p>C++中的动态内存分配是基于数据类型进行的。</p><p>delete关键字用于内存释放。</p><h2 id="2-语法"><a class="markdownIt-Anchor" href="#2-语法"></a> 2、语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datatype *pointer = <span class="keyword">new</span> datatype;</span><br><span class="line"><span class="comment">//  其它代码</span></span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br></pre></td></tr></table></figure><p>datatype可以是C语言的基本数据类型，也可以是结构体，还可以是类。</p><p>pointer是一个指针，指向new返回的地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi= <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 动态分配一个整数大小的内存</span></span><br><span class="line">(*pi)=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> pi;  <span class="comment">// 释放pi指向的内存</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGirl *pgirl=<span class="keyword">new</span> CGirl;   <span class="comment">// 动态分配CGirl类</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">strcpy</span>(pgirl-&gt;name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"> pgirl-&gt;age=<span class="number">22</span>;</span><br><span class="line"> pgirl.height=<span class="number">168</span>;</span><br><span class="line"> <span class="built_in">strcpy</span>(pgirl-&gt;sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(pgirl-&gt;yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line"> pgirl-&gt;<span class="built_in">show</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">delete</span> pgirl; <span class="comment">// 释放pgirl指向的内存</span></span><br></pre></td></tr></table></figure><p>如果new出来的是类，相当于创建对象，所以会调用构造函数，delete的时候也会调用析构函数。</p><h1 id="二-应用经验"><a class="markdownIt-Anchor" href="#二-应用经验"></a> 二、应用经验</h1><p>有些程序员认为动态内存分配是高大上的技术，但是，在实际开发中，需要动态分配内存的场景极少，string和vector已经足够方便，如果不是非用不可的情况，采用动态分配内存就是给自己挖坑。</p><p>如果应用开发中一定要用动态内存分配技术，建议把它封装在类中，并在析构函数中编写释放内存的代码，防止内存泄漏。</p><h1 id="三-版权声明"><a class="markdownIt-Anchor" href="#三-版权声明"></a> 三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的vector容器</title>
      <link href="/posts/10540a7c.html"/>
      <url>/posts/10540a7c.html</url>
      
        <content type="html"><![CDATA[<p>我们在声明数组的时候，采用的是datatype array[len]的形式，数组在分配之后，不能调整大小，删除和插入数据时操作十分的繁琐，虽然可以采用链表，但是链表的操作更麻烦，我们希望有更简单的方法。</p><p>与string类一样, 向量vector 同属于STL（Standard Template Library,标准模板库）中的定义的类, vector是一个封装了动态数组的顺序容器（Sequence Container），它能够存放各种类型的数据和对象。</p><p>可以简单的认为vector容器是一个能够存放任意类型的动态数组，与数组相比，vector容器的优点在于它能够根据需要自动调整的大小，随时放入更多的元素。此外, vector也提供了成员函数对自身进行操作。</p><h1 id="一-容器的定义"><a class="markdownIt-Anchor" href="#一-容器的定义"></a> 一、容器的定义</h1><p>首先，如果要在程序中使用vector容器，必须包含头文件 &lt;vector&gt;。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><p>vector类是一个模板类，位于std命名空间内，为方便使用还需要增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>声明一个容器很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi;              <span class="comment">// 定义用于存放整数的容器</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; vd;         <span class="comment">// 定义用于存放浮点数的容器</span></span><br><span class="line">vector&lt;string&gt; vs;           <span class="comment">// 定义用于存放string字符串的容器</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> st_girl&gt; vgirl;  <span class="comment">// 定义用于存放超女结构体的容器</span></span><br><span class="line">vector&lt;CGirl&gt; vGirl;         <span class="comment">// 定义用于存放超女类的容器</span></span><br></pre></td></tr></table></figure><p>vector容器可以存放C语言的基本数据类型，可以存放结构体，还可以存放类，这正是我们想要的简单的方法，链表？我已经有二十年没有用它了。</p><h1 id="二-容器的使用"><a class="markdownIt-Anchor" href="#二-容器的使用"></a> 二、容器的使用</h1><p>vector的功能强大，成员函数很多，我不想按普通教程的方式来介绍它，那样会太烦锁，我根据实际开发中应用的场景，采用示例程序介绍vector常用的用法。</p><h2 id="1-存放整数"><a class="markdownIt-Anchor" href="#1-存放整数"></a> 1、存放整数</h2><p><strong>示例（book220.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book220.cpp，此程序用于演示C++容器存放整数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>      <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>   <span class="comment">// sort函数需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> height=<span class="number">0</span>;             <span class="comment">// 存放从键盘输入的超女身高</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; vheight; <span class="comment">// 存放超女身高的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入超女身高（0-结束输入）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;height);         <span class="comment">// 接受键盘输入的数据</span></span><br><span class="line">    <span class="keyword">if</span> (height==<span class="number">0</span>) <span class="keyword">break</span>;        <span class="comment">// 0-结束输入</span></span><br><span class="line">    vheight.<span class="built_in">push_back</span>(height);   <span class="comment">// 把数据追加入容器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vheight.<span class="built_in">size</span>();ii++) <span class="comment">// 显示排序前容器中的记录</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vheight[%d]=%d\n&quot;</span>,ii,vheight[ii]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(vheight.<span class="built_in">begin</span>(),vheight.<span class="built_in">end</span>());  <span class="comment">// 容器中的记录排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vheight.<span class="built_in">size</span>();ii++) <span class="comment">// 显示排序后容器中的记录</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vheight[%d]=%d\n&quot;</span>,ii,vheight[ii]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vheight.clear();  // 清空容器，可以不写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030511135866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>程序解释如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vheight;   <span class="comment">// 声明容器用于存放整数，超女身高，单位是cm。</span></span><br></pre></td></tr></table></figure><p><strong>void push_back(const T&amp; x)成员函数</strong>：向容器尾部增加一个元素x，x就是您要向容器中增加的变量，在本示例中是一个整数，注意，参数x是一个引用，要用变量的名称，不是变量的地址，如vheight.push_back(height);。</p><p><strong>int size()成员函数</strong>：返回容器中数据的元素总数。</p><p><strong>像数组一样访问容器</strong>：容器像数组一样，可以用数组的下标访问，vheight[0]表示容器的第1个元素，vheight[n]表示容器的第n+1个元素。注意，采用下标方式放问容器的时候，下标不要越界，否则可能会引起内存溢出。</p><p><strong>iterator begin()成员函数</strong>：返回容器头指针，指向第一个元素。</p><p><strong>iterator end()成员函数</strong>：返回容器尾指针，指向容器最后一个元素的下一个位置。</p><p>容器中的元素排序：采用sort()函数对容器中的元素进行排序。如sort(vheight.begin(),vheight.end());表示对容器中全部的元素进行排序。</p><p><strong>void clear()</strong>：清空容器中的全部元素，注意两点：1）容器被声明的时候，本来就是空的；2）容器是类，有析构函数，析构函数中会自动清空容器中的元素，释放内存资源，不需要程序员担心。但是，程序员也可以调clear()函数手工清空容器中的元素。</p><p>示例book220.cpp程序展示了vector容器10%的功能和成员函数，但是，在实际开发中，对容器的操作，95%的内容就是这些。</p><h2 id="2-存放字符串"><a class="markdownIt-Anchor" href="#2-存放字符串"></a> 2、存放字符串</h2><p><strong>示例（book222.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book222.cpp，此程序用于演示C++容器存放字符串</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">char</span> strtmp[<span class="number">50</span>];                <span class="comment">// 存放姓名的临时变量</span></span><br><span class="line">  std::string name;               <span class="comment">// 存放从键盘输入的超女姓名</span></span><br><span class="line">  std::vector&lt;std::string&gt; vname; <span class="comment">// 存放超女姓名的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入超女姓名（0-结束输入）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,strtmp);               <span class="comment">// 接受键盘输入的数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(strtmp,<span class="string">&quot;0&quot;</span>)==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 0-结束输入</span></span><br><span class="line">    vname.<span class="built_in">push_back</span>(strtmp);          <span class="comment">// 把数据追加入容器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vname.<span class="built_in">size</span>();ii++) <span class="comment">// 显示容器中的记录</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vname[%d]=%s\n&quot;</span>,ii,vname[ii].<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305112634930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意几个问题：</p><p>1）用容器存放字符串，数据类型用string，不是C语言用0结尾的字符数组char []，string是一个变量，char []是一组变量。</p><p>2）用vname.push_back()成员函数把数据追加到容器中，参数的类型可以是string，也可以是char[]，但是，这并不是vector的特征，而是string的特征，容器声明的是string类型，string的构造函数支持char []，表面上看push_back()进去的是char []，实际上会被转换为string。</p><h2 id="3-存放结构体"><a class="markdownIt-Anchor" href="#3-存放结构体"></a> 3、存放结构体</h2><p><strong>示例（book225.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book225.cpp，此程序用于演示C++容器存放结构体</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>       <span class="comment">// 超女数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;             <span class="comment">// 超女数据结构</span></span><br><span class="line">  std::vector&lt;<span class="keyword">struct</span> st_girl&gt; vgirl; <span class="comment">// 存放超女结构体的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>); stgirl.age=<span class="number">18</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;杨玉环&quot;</span>); stgirl.age=<span class="number">28</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用数组下标访问容器中的记录</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vgirl.<span class="built_in">size</span>();ii++) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vgirl[%d].name=%s,vgirl[%d].age=%d\n&quot;</span>,\</span><br><span class="line">            ii,vgirl[ii].name,ii,vgirl[ii].age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把容器中的记录复制到结构体</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vgirl.<span class="built_in">size</span>();ii++) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;stgirl,&amp;vgirl[ii],<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stgirl.name=%s,stgirl.age=%d\n&quot;</span>,stgirl.name,stgirl.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305112727654.png" alt="在这里插入图片描述" /></p><p>总的来说，存放结构体的容器和数组的用法基本相同。</p><p>在book225.cpp中，采用了memcpy函数，它是C语言的库函数，用于内存中的数据复制，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>dest：指向用于存储复制内容的目标地址，类型强制转换为 void* 指针。</p><p>src：指向要复制的数据源地址，类型强制转换为 void* 指针。</p><p>n：要被复制的字节数。</p><p>该函数返回dest。</p><h2 id="4-存放类"><a class="markdownIt-Anchor" href="#4-存放类"></a> 4、存放类</h2><p>示例（book222.cpp）演示的存放字符串，string就是类。</p><h1 id="三-其它成员函数"><a class="markdownIt-Anchor" href="#三-其它成员函数"></a> 三、其它成员函数</h1><p>vector的成员函数比较多，为了不增加各位的学习负担，我只介绍常用的。</p><h2 id="1-定位的函数"><a class="markdownIt-Anchor" href="#1-定位的函数"></a> 1、定位的函数</h2><p><code>iterator begin()</code>：返回容器头的指针，指向容器第一个元素的位置。</p><p><code>iterator end()</code>：返回容器尾的指针，指向容器最后一个元素的下一个位置。</p><p>iterator是跌代器，这个名字让人难以理解，那就先不要管它，以下我会举例说明用法，一般来说，begin()和end()成员函数用于其它成员函数的参数中。</p><h2 id="2-增加元素的函数"><a class="markdownIt-Anchor" href="#2-增加元素的函数"></a> 2、增加元素的函数</h2><p><code>void push_back(const T&amp; x)</code>：向容器的尾部增加一个元素x。</p><p><code>iterator insert(iterator it,const T&amp; x)</code>：向容器中指定位置（it）前插入一个元素x。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;王昭群&quot;</span>); stgirl.age=<span class="number">22</span>;</span><br><span class="line">vgirl.<span class="built_in">insert</span>(vgirl.<span class="built_in">begin</span>()+<span class="number">1</span>,stgirl);  <span class="comment">// 在第2个元素前插入一个元素。</span></span><br></pre></td></tr></table></figure><h2 id="3-删除元素的函数"><a class="markdownIt-Anchor" href="#3-删除元素的函数"></a> 3、删除元素的函数</h2><p><code>iterator erase(iterator it)</code>：删除容器中指定位置（it）的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vgirl.<span class="built_in">erase</span>(vgirl.<span class="built_in">begin</span>()+<span class="number">2</span>);  <span class="comment">// 删除容器中第3个元素。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span>：删除容器中最后一个元素。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>：清空容器中全部的元素。</span></span><br></pre></td></tr></table></figure><h2 id="4-判断容器的大小"><a class="markdownIt-Anchor" href="#4-判断容器的大小"></a> 4、判断容器的大小</h2><p><code>bool empty()</code>：判断容器是否为空。</p><p><code>int size()</code>：返回容器中元素的个数。</p><h1 id="四-容器的排序"><a class="markdownIt-Anchor" href="#四-容器的排序"></a> 四、容器的排序</h1><p>在实际开发中，往往需要对vector容器中的元素进行排序，sort函数可以实现排序功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(begin,end,cmp);</span><br></pre></td></tr></table></figure><p>sort函数包含在头文件为#include &lt;algorithm&gt;的c++标准库中，调用排序方法不必知道其内部是如何实现的，只要出现我们想要的结果就行。</p><p>sort函数有三个参数：</p><p>（1）第一个是要排序的数组的起始地址。</p><p>（2）第二个是结束的地址。</p><p>（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时缺省的排序方法是从小到大排序。如果vector容器中元素的数据类型不是基本数据类型，sort函数必须指定排序方法函数。</p><p><strong>示例（book227.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book227.cpp，此程序用于演示C++容器的排序</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>      <span class="comment">// vector需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>   <span class="comment">// sort函数需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>       <span class="comment">// 超女数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序函数，按超女姓名排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sortbyname</span><span class="params">(<span class="type">const</span> st_girl &amp;p1,<span class="type">const</span> st_girl &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p1.name,p2.name)&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序函数，按超女年龄排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sortbyage</span><span class="params">(<span class="type">const</span> st_girl &amp;p1,<span class="type">const</span> st_girl &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p1.age&lt;p2.age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;             <span class="comment">// 超女数据结构</span></span><br><span class="line">  std::vector&lt;<span class="keyword">struct</span> st_girl&gt; vgirl; <span class="comment">// 存放超女结构体的容器</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>); stgirl.age=<span class="number">18</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;杨玉环&quot;</span>); stgirl.age=<span class="number">28</span>;</span><br><span class="line">  vgirl.<span class="built_in">push_back</span>(stgirl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sort(vgirl.begin(),vgirl.end());   // 如果不指定排序函数，编译将报错</span></span><br><span class="line">  <span class="comment">//sort(vgirl.begin(),vgirl.end(),sortbyname); // 按超女的姓名排序</span></span><br><span class="line">  <span class="built_in">sort</span>(vgirl.<span class="built_in">begin</span>(),vgirl.<span class="built_in">end</span>(),sortbyage);  <span class="comment">// 按超女的年龄排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;vgirl.<span class="built_in">size</span>();ii++) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vgirl[%d].name=%s,vgirl[%d].age=%d\n&quot;</span>,\</span><br><span class="line">            ii,vgirl[ii].name,ii,vgirl[ii].age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>1）编写示例程序，类似本章节的book220.cpp、book222.cpp、book225.cpp、book227.cpp，编译并运行它，记住，程序员是写出来的，不是看出来的，熟能生巧，您每天的付出都有意义。</p><p>2）编写示例程序，测试一下vector容器其它成员函数的用法，玩一下就行了，有些成员函数以后可能有用。</p><p>3）丰富您的函数库，写一个类，封装随机数功能，类的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_val;  <span class="comment">// 用于存放生成好的随机数</span></span><br><span class="line">  <span class="built_in">CRand</span>();</span><br><span class="line"> ~<span class="built_in">CRand</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Rand</span><span class="params">(<span class="type">const</span> <span class="type">int</span> minvalue,<span class="type">const</span> <span class="type">int</span> maxvalue,<span class="type">bool</span> brep=<span class="literal">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>(1）随机数的种子不能只用time(0)的秒，还可以利用微秒，同一秒内取到的随机数将不同。</p><p>(2）Rand(const int minvalue,const int maxvalue,bool brep=true)生成指定范围的随机数，minvalue是最小值，maxvalue是最大值，brep是否允许重复。</p><p>4）vector容器的排序在实际开发中应用比较多，必须掌握。</p><p>5）vector容器存放超女类，能不写排序函数吗？如果存放string类，能不写排序函数吗？为什么？</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的string类</title>
      <link href="/posts/aee85e8.html"/>
      <url>/posts/aee85e8.html</url>
      
        <content type="html"><![CDATA[<p>在C语言中，用0结束的字符数组表示字符串，有些不方便：1）数组定义后大小不能改变；2）存入的内容只能比数组小，不能大，如果不小心存多了，会引起内存的溢出，这些问题让程序员有些郁闷。</p><p>C++的string属于STL（Standard Template Library,标准模板库）中的定义的类，它会随存放字符的长度自动伸缩，程序员不必担心内存溢出的问题，string类还和C语言的字符串之间还可以很方便的转换。</p><h1 id="一-string的声明"><a class="markdownIt-Anchor" href="#一-string的声明"></a> 一、string的声明</h1><p>首先，为了在程序中使用string类，必须包含头文件 &lt;string&gt;。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><p>注意这里不是string.h，string.h是C语言字符串头文件。</p><p>string是一个模板类，位于std命名空间内，为方便使用还需要在程序中增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">// 指定缺省的使名空间。</span></span><br><span class="line">string str;       <span class="comment">// 创建string对象。</span></span><br></pre></td></tr></table></figure><p>如果不指定命名空间，也就是说没有using namespace std，创建string对象的方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br></pre></td></tr></table></figure><p><strong>示例（book215.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book215.cpp，此程序用于演示C++string类。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">char</span> str1[<span class="number">31</span>];   <span class="comment">// C语言风格的字符串。</span></span><br><span class="line">  <span class="built_in">memset</span>(str1,<span class="number">0</span>,<span class="built_in">sizeof</span>(str1));</span><br><span class="line">  <span class="built_in">strcpy</span>(str1,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"></span><br><span class="line">  string str2;     <span class="comment">// C++的string字符串</span></span><br><span class="line"></span><br><span class="line">  str2=<span class="string">&quot;沉鱼&quot;</span>;     <span class="comment">// 对str2赋值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str2=%s\n&quot;</span>,str2.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断str2和str1是否相等</span></span><br><span class="line">  <span class="keyword">if</span> (str2!=str1) <span class="built_in">printf</span>(<span class="string">&quot;str2=%s,str1=%s，不相等。\n&quot;</span>,str2.<span class="built_in">c_str</span>(),str1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(str1,str2.<span class="built_in">c_str</span>());   <span class="comment">// 把string的内容赋值给C语言风格的字符串。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str1=%s\n&quot;</span>,str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305110046143.png" alt="在这里插入图片描述" /></p><h1 id="二-string的重载的操作符"><a class="markdownIt-Anchor" href="#二-string的重载的操作符"></a> 二、string的重载的操作符</h1><p>可以用=直接赋值。</p><p>可以用 ==、&gt;、&lt;、&gt;=、&lt;=、和!=比较字符串。</p><p>可以用+或者+=操作符连接两个字符串。</p><p>可以用[]获取指定位置的字符，类似数组。</p><h1 id="三-最重要的一个成员函数"><a class="markdownIt-Anchor" href="#三-最重要的一个成员函数"></a> 三、最重要的一个成员函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span></span>;  </span><br></pre></td></tr></table></figure><p>string类采用动态分配内存的方式来存放字符串，c_str函数返回这个字符串的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str1;</span><br><span class="line">str1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">31</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str2,str1.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h1 id="四-string特性描述函数"><a class="markdownIt-Anchor" href="#四-string特性描述函数"></a> 四、string特性描述函数</h1><p>可用下列函数来获得string的一些特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;             <span class="comment">// 返回当前字符串的大小。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>;           <span class="comment">// 返回当前字符串的长度，注意和size的区别。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;           <span class="comment">// 清空字符串。</span></span><br></pre></td></tr></table></figure><h1 id="五-string的其它成员函数"><a class="markdownIt-Anchor" href="#五-string的其它成员函数"></a> 五、string的其它成员函数</h1><p>string提供了上百个成员函数，非常丰富，丰富得有点眼花，各位自己找资料，有空的时候再研究一下，断章取义的使用。</p><h1 id="六-string的本质"><a class="markdownIt-Anchor" href="#六-string的本质"></a> 六、string的本质</h1><p>string是一个类，通过动态分配内存，实现对字符串的存储，我们来看以下代码。</p><p><strong>示例（book216.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book216.cpp，此程序用于演示C++的string类的字符串的地址。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  std::string str;</span><br><span class="line"></span><br><span class="line">  str=<span class="string">&quot;www&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str=str+<span class="string">&quot;.freecplus&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str=<span class="string">&quot;freecplus&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str=<span class="string">&quot;www.freecplus.net&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305110342525.png" alt="在这里插入图片描述" /></p><p>通过以上的例子，我们可以看到，string对象用于存放字符的内存地址是变化的，当前空间如果不足，就重新分配一个新的内存，同时会释放之前的内存，不是什么神奇的技术。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>C++的string类是一个变长的字符串，不需要程序员担心内存溢出的问题，还提供了很多字符串操作函数，初学者可能会想，用它取代C语言中的字符串（以0结尾的字符数组）一定是个很好的主意。我要告诉各位，这是不可能的，因为string中的字符串存储的内存空间没有固定的位置（它也没办法有固定位置）。</p><p>对初学者来说，用C/C++写一些简单的程序，做一些简单的事情，不懂得实际项目开发的需求，例如Oracle和MySQL数据库提供的接口，在交换数据的时候需要绑定一个固定的地址，string是做不到的。</p><p>我的建议是采用string存放一些需要动态分配内存的临时数据，避开动态内存技术带来的坑，然后转换为C的字符串。C的字符串没有string类那么丰富的成员函数，这个不是问题，我们可以自己写，这也是我不想介绍string成员函数的原因，与其花时间去研究string的成员函数，还不如自己写一个。</p><p>了解string类的原理和一些用得着的成员函数就可以了，不必太深入研究，意义不大。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>上网找C++string的资料，看看它的成员函数和重载的操作符，如果觉得有用，就编写代码测试一下，了解一下大概情况。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符重载</title>
      <link href="/posts/1dfa3723.html"/>
      <url>/posts/1dfa3723.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-运算符重载的概念"><a class="markdownIt-Anchor" href="#一-运算符重载的概念"></a> 一、运算符重载的概念</h1><p>在C语言中，运算符只能用于基本数据类型，例如，可以用==判断两个整数是否相等，但不能用于判断字符串是否相等，不能用于判断结构体，也不能用于判断类。</p><p>在C++中，运算符的重载就是把运算符的符号赋予新的含义，如果类重载了 == 运算符，那么就可以用== 判断两个类是否相等。</p><h1 id="二-运算符重载的实现"><a class="markdownIt-Anchor" href="#二-运算符重载的实现"></a> 二、运算符重载的实现</h1><p>operator是C++的一个关键字，它和运算符一起使用，表示一个运算符重载函数，在理解时可将operator和运算符（如operator==）视为类的一个成员函数名。</p><p><strong>示例（book214.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book214.cpp，此程序用于演示C++运算符重载。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CGirl &amp;Girl)  <span class="comment">// 重载==运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CGirl Girl1,Girl2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Girl1.m_name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(Girl2.m_name,<span class="string">&quot;东施&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (Girl1 == Girl2) <span class="built_in">printf</span>(<span class="string">&quot;Girl1和Girl2是同一个人。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Girl1和Girl2不是同一个人。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> CGirl::<span class="keyword">operator</span>==(<span class="type">const</span> CGirl &amp;Girl)  <span class="comment">// 重载==运算符</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">// 如果两个类的姓名相同，就相等</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(m_name,Girl.m_name)== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGirl类重载了==运算符，定义了operator==函数，用于判断两个对象是否相等，实际上是判断两个对象的成员变量m_name是否相同，如果相同，对象就相等。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305102701815.png" alt="在这里插入图片描述" /></p><p>通过上述结果能够知道，因为操作符重载函数operator==是CGirl类的一个成员函数，所以对象Girl1、Girl2都可以调用该函数。其中的 if (Gril1 ==Gril2) 语句，相当于对象Gril1调用函数operator==，把对象Girl2作为一个参数传递给该函数，从而实现了两个对象的比较。</p><p>我们把语句改为if (Gril1 ！= Gril2) ，会如何？编译如下：</p><p><img src="https://img-blog.csdnimg.cn/20200305102734354.png" alt="在这里插入图片描述" /></p><p>编译无法通过，因为CGirl类并没有重载!=运算符。</p><h1 id="三-个人经验"><a class="markdownIt-Anchor" href="#三-个人经验"></a> 三、个人经验</h1><p>下一章节中将学习C++的string类，它重载了+、=、==、!=等运算符，对程序员来说，确实感觉有些方便。</p><p>在实际开发中，重载运算符有可能会模糊程序员的意图，如果要判断Girl1和Girl2的m_name成员是否相等，我更愿意用strcmp函数。</p><p>很久很久以前，学习了运算符重载的时候，可以把各种运算符重载成奇奇怪怪的功能，觉得很好玩，后来就不玩了，感觉没什么意思。</p><p>运算符重载还有很多其它的知识，我就不介绍了。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>对CGirl重载!=操作符试试。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="/posts/101de459.html"/>
      <url>/posts/101de459.html</url>
      
        <content type="html"><![CDATA[<p>对于习惯使用C进行开发的程序员来说，在看到C<ins>中出现的&amp;符号，可能会犯迷糊，因为在C语言中这个符号表示了取地址符，但是在C</ins>中，它除了取地址，还有其它的用途，叫做引用（reference），引用是C++的新特性。</p><h1 id="一-引用的概念"><a class="markdownIt-Anchor" href="#一-引用的概念"></a> 一、引用的概念</h1><p>引用就是变量的别名，对引用的操作与对变量直接操作完全一样。</p><p>引用的声明方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 &amp;引用名=目标变量名；</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; </span><br><span class="line"><span class="type">int</span> &amp;ra=a;  <span class="comment">// 定义引用ra，它是变量a的引用，即别名。</span></span><br><span class="line">ra=<span class="number">1</span>;  等价于  a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>1）&amp;在此不是求地址运算，而是起标识作用。</p><p>2）类型标识符是指目标变量的类型。</p><p>3）声明引用时，必须同时对其进行初始化，否则编译器会报错，所以，不能再把引用名作为其他变量名的别名。</p><p>4）引用声明后，相当于目标变量名有两个名称。</p><p>5）声明一个引用，不是新定义了一个新的变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。</p><p>6）不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法对数据建立引用。</p><p>7）引用可以用const修饰，表示只读，用这种方式声明的引用，不能通过引用对目标变量的值进行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ra=a;</span><br><span class="line">a=<span class="number">10</span>;    <span class="comment">// 可以</span></span><br><span class="line">ra=<span class="number">10</span>;   <span class="comment">// 不行</span></span><br></pre></td></tr></table></figure><h1 id="二-引用的应用"><a class="markdownIt-Anchor" href="#二-引用的应用"></a> 二、引用的应用</h1><p>引用的主要作用就是作为函数的参数。</p><p>在C语言中函数参数是值传递，如果有大块数据作为参数传递的时候，采用的方案是传递数据的地址。</p><p>在C++中，又增加了一种同样有效率的选择，就是引用。</p><p><strong>示例（book212.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book212.cpp，此程序用于演示C++的引用</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *a)</span> <span class="comment">// a是一个指针变量</span></span></span><br><span class="line"><span class="function"></span>&#123; *a=<span class="number">20</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;ra)</span> <span class="comment">// ra是一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123; ra=<span class="number">30</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>(&amp;ii);  <span class="comment">// 传递变量的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1 ii=%d\n&quot;</span>,ii);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>(ii);   <span class="comment">// 引用</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2 ii=%d\n&quot;</span>,ii);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305100641536.png" alt="在这里插入图片描述" /></p><p>从以上的示例可以看出，传递引用给函数与传递指针的效果是一样的。这时，被调函数的参数就成为调用者调函数中的变量或对象的一个别名来使用，所以在被调函数中对引用的操作就是对目标变量的操作。</p><p>在很多资料中，把引用的优点过于夸大，在我看来，引用的好处就是调用函数的时候，不用填写取地址符&amp;，子函数中也不写取变量符*，结构体和类不用-&gt;取成员。但我更倾向传递地址的方式，更直观，不管是在函数内部还是函数被调用的地方，一眼就能清楚是否是地址。</p><p>引用还可以作为函数的返回值，但我不建议这么用，我实在看不出这样做有什么好处，那就没必要把事情搞得那么复杂，所以这里就不介绍了。</p><h1 id="三-课后作业"><a class="markdownIt-Anchor" href="#三-课后作业"></a> 三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的详解</title>
      <link href="/posts/fbe69a85.html"/>
      <url>/posts/fbe69a85.html</url>
      
        <content type="html"><![CDATA[<p>超女选秀的例子我们玩了很久，为了学习的需要，暂时离开美眉们，我将采用实际项目开发的例子来讲解类的更多知识。</p><p>在C语言基础知识中已学习过文件操作，在实际开发中，为了提高效率，我会把文件操作封装成一个类，类的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件操作类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FILE *m_fp;        <span class="comment">// 文件指针</span></span><br><span class="line">  <span class="type">bool</span>  m_bEnBuffer; <span class="comment">// 是否启用缓冲区，true-启用；false-不启用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer);   <span class="comment">// 类的构造函数</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;  <span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开文件，参数与fopen相同，打开成功true，失败返回false          </span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fprintf向文件写入数据</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ... )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fgets从文件中读取一行</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Fgets</span><span class="params">(<span class="type">char</span> *strBuffer,<span class="type">const</span> <span class="type">int</span> ReadSize)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="一-类成员的访问权限"><a class="markdownIt-Anchor" href="#一-类成员的访问权限"></a> 一、类成员的访问权限</h1><p>C++通过 public、protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是类外面的代码访问该类中成员权限。</p><p>在类的内部，即类的成员函数中，无论成员被声明为 public、protected 还是private，都是可以互相访问的，没有访问权限的限制。</p><p>在类的外部（定义类的代码之外），只能通过对象访问public的成员，不能访问 private、protected属性的成员。</p><p>本节重点介绍 public 和 private，protected 将在以后介绍。</p><p>private 后面的成员都是私有的，如m_fp和m_bEnBuffer，直到有 public出现才会变成共有的；public 之后再无其他限定符，所以 public后面的成员都是共有的。</p><p>private关键字的作用在于更好地隐藏类的内部实现，该向外暴露的接口（能通过对象访问的成员）都声明为public，不希望外部知道、或者只在类内部使用的、或者对外部没有影响的成员，都建议声明为private。</p><p>声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private部分，也可以先出现 public 部分。如果既不写 private 也不写 public，就默认为private。</p><p>在一个类体中，private 和 public可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。</p><p>您可能会说，将成员变量全部设置为 public 省事，确实，这样做 99.9%的情况下都不是一种错误，我也不认为这样做有什么不妥；但是，将成员变量设置为private 是一种软件设计规范，尤其是在大中型项目中，还是请大家尽量遵守这一原则。</p><h1 id="二-成员变量的命名"><a class="markdownIt-Anchor" href="#二-成员变量的命名"></a> 二、成员变量的命名</h1><p>成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的参数名字区分开。</p><p>例如成员函数EnBuffer的函数体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-构造函数"><a class="markdownIt-Anchor" href="#三-构造函数"></a> 三、构造函数</h1><p>在CFile类的声明中，有一些特殊的成员函数CFile()，它就是构造函数（constructor）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数</span></span><br><span class="line"><span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer);   <span class="comment">// 类的构造函数</span></span><br></pre></td></tr></table></figure><p>构造函数的名字和类名相同，没有返回值，不能被显式的调用，而是在创建对象时自动执行。</p><p>构造函数具备以下特点：</p><p>1）构造函数必须是 public 属性。</p><p>2）构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是void 也不允许。</p><p>3）构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。</p><p>4）构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，注意，不能用memset对整下类进行初始化。</p><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CFile::<span class="built_in">CFile</span>()   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::<span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer)   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-析构函数"><a class="markdownIt-Anchor" href="#四-析构函数"></a> 四、析构函数</h1><p>在CFile类的声明中，还有一个特殊的成员函数~CFile()，它就是析构函数（destructor）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数</span></span><br></pre></td></tr></table></figure><p>析构函数的名字在类的名字前加~，没有返回值，但可以被显式的调用，在对象销毁时自动执行，用于进行清理工作，例如释放分配的内存、关闭打开的文件等，这个用途非常重要，可以防止程序员犯错。</p><p>析构函数具备以下特点：</p><p>1）构造函数必须是 public 属性的。</p><p>2）构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是void 也不允许。</p><p>3）析构函数不允许重载的。一个类只能有一个析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFile::~<span class="built_in">CFile</span>()   <span class="comment">// 类的析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Close</span>();  <span class="comment">// 调用Close释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-c程序也很优雅"><a class="markdownIt-Anchor" href="#五-c程序也很优雅"></a> 五、C++程序也很优雅</h1><p>很多人说C/C<ins>程序很烦锁，python程序很优雅，说这话人的很荒谬，那是因为他C/C</ins>并不了解，只要我们愿意，可以写出和python一样优雅简洁的代码，在book210.cpp中，main函数的代码极为精简。</p><p>示例（book210.cpp）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book210.cpp，此程序演示用C++类的更多知识。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件操作类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FILE *m_fp;        <span class="comment">// 文件指针</span></span><br><span class="line">  <span class="type">bool</span>  m_bEnBuffer; <span class="comment">// 是否启用缓冲区，true-启用；false-不启用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer);   <span class="comment">// 类的构造函数</span></span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;  <span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开文件，参数与fopen相同，打开成功true，失败返回false          </span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fprintf向文件写入数据</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,... )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用fgets从文件中读取一行</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Fgets</span><span class="params">(<span class="type">char</span> *strBuffer,<span class="type">const</span> <span class="type">int</span> ReadSize)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭文件指针</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc !=<span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;请输入待打开的文件名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  CFile File;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (File.<span class="built_in">Open</span>(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;File.Open(%s)失败。\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> strLine[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123; <span class="comment">// 从文件中读取每一行</span></span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">Fgets</span>(strLine,<span class="number">300</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,strLine);   <span class="comment">// 把从文件中读到的内容显示到屏幕</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::<span class="built_in">CFile</span>()   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::<span class="built_in">CFile</span>(<span class="type">bool</span> bEnBuffer)   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Close</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_fp!=<span class="number">0</span>) <span class="built_in">fclose</span>(m_fp);  <span class="comment">// 关闭文件指针</span></span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::~<span class="built_in">CFile</span>()   <span class="comment">// 类的析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Close</span>();  <span class="comment">// 调用Close释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::EnBuffer</span><span class="params">(<span class="type">bool</span> bEnBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_bEnBuffer=bEnBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件，参数与fopen相同，打开成功true，失败返回false          </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CFile::Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">const</span> <span class="type">char</span> *openmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Close</span>();  <span class="comment">// 打开新的文件之前，如果已经打开了文件，关闭它。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (m_fp=<span class="built_in">fopen</span>(filename,openmode)) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用fprintf向文件写入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( m_fp == <span class="number">0</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(arg,ap);</span><br><span class="line">  <span class="built_in">vfprintf</span>(m_fp,fmt,ap);</span><br><span class="line">  <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( m_bEnBuffer == <span class="literal">false</span> ) <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用fgets从文件中读取一行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CFile::Fgets</span><span class="params">(<span class="type">char</span> *strBuffer,<span class="type">const</span> <span class="type">int</span> ReadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( m_fp == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strBuffer,<span class="number">0</span>,ReadSize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fgets</span>(strBuffer,ReadSize,m_fp) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>book210运行的效果就是把文件的内容一行一行的显示出来，类型linux系统的cat命令。</p><p><img src="https://img-blog.csdnimg.cn/20200305094411346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="六-类的其它知识"><a class="markdownIt-Anchor" href="#六-类的其它知识"></a> 六、类的其它知识</h1><p>关于类的其它知识，包括this指针、static静态成员、友元等内容，意义不大，我不介绍了，时间太宝贵，有太多重要的知识要学习，没必要把时间浪费在这些不痛不痒又没什么实用价值的知识点上，大家以后有时间了再看也行。</p><h1 id="七-可变参数"><a class="markdownIt-Anchor" href="#七-可变参数"></a> 七、可变参数</h1><p>我们已经介绍过printf、fprintf、sprintf、snprintf函数，它们是一组功能相似的函数，并且有一个共同点，就是函数的参数列表是可以变化的。</p><p>函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;        <span class="comment">// 格式化输出到屏幕</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;  <span class="comment">// 格式化输出到文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;     <span class="comment">// 格式化输出到字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>; <span class="comment">// 格式化输出指定长度的内容到字符串</span></span><br></pre></td></tr></table></figure><p>在实际开发中，我们的自定义函数也会用到可变参数，实现类似上述函数的功能，例如CFile类的Fprintf成员函数。</p><p>C语言采用va_start宏、va_end宏和一系列函数来实现可变参数功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( m_fp == <span class="number">0</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(arg,ap);</span><br><span class="line">  <span class="built_in">vfprintf</span>(m_fp,fmt,ap);</span><br><span class="line">  <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( m_bEnBuffer == <span class="literal">false</span> ) <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以CFile类的Fprintf成员函数为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFile::Fprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,...)</span></span>;     <span class="comment">// 可变参数自定义函数的声明方法</span></span><br></pre></td></tr></table></figure><p>va_list指针、va_start宏、va_end宏用于分析参数，难以理解，大家会用就行，我不详细介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line"><span class="built_in">va_start</span>(ap,fmt);</span><br><span class="line"><span class="built_in">vfprintf</span>(m_fp,fmt,ap);     </span><br><span class="line"><span class="built_in">va_end</span>(ap);</span><br></pre></td></tr></table></figure><p>vfprintf函数把宏分析的结果输出到文件，还有一系列功能相似的函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出的屏幕</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到字符串，第二个参数指定了输出结果的长度，类似snprintf函数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>1）编写示例程序，测试类的类成员的访问权限。</p><p>2）编写示例程序，测试类的构造函数和它的重载，采用gdb跟踪构造函数的执行过程。</p><p>3）编写示例程序，测试类的析构函数，采用gdb跟踪析构造的执行过程。</p><p>4）编写示例程序，实现printf、sprintf和snprintf函数的功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mysprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mysnprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>5）类定义包括成员变量和成员函数的声明以及成员函数的定义，在实际开发中，我们通常将公共类的声明放在头文件中（如_public.h），成员函数的定义放在程序文件中（如_public.cpp），请按这种方式修改book210.cpp程序，增加_public.h和_public.cpp程序，修改makefile。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类和对象</title>
      <link href="/posts/7368673d.html"/>
      <url>/posts/7368673d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-c结构体的新特征"><a class="markdownIt-Anchor" href="#一-c结构体的新特征"></a> 一、C++结构体的新特征</h1><p>C语言的结构体不允许有函数，定义结构体变量的方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名 结构体变量名;</span><br></pre></td></tr></table></figure><p>在C++中，结构体的成员可以有函数，定义结构体变量可以用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体名 结构体变量名;</span><br></pre></td></tr></table></figure><p>struct关键字可以不书写。</p><p><strong>示例（book202.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book202.cpp，此程序用于演示C++结构体的新特征。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">show</span><span class="params">()</span></span>;       <span class="comment">// 声明结构体成员函数show，用于显示其它成员变量的值。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  st_girl stgirl;      <span class="comment">// struct关键定可以不书写</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;stgirl,<span class="number">0</span>,<span class="built_in">sizeof</span>(stgirl));</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">  stgirl.age=<span class="number">22</span>;</span><br><span class="line">  stgirl.height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  stgirl.<span class="built_in">show</span>();  <span class="comment">// 调用结构体的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">st_girl::show</span><span class="params">()</span>   <span class="comment">// 结构体st_girl成员函数的定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\n&quot;</span>,name,age,height,sc,yz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030509035835.png" alt="在这里插入图片描述" /></p><h1 id="二-c-类和对象"><a class="markdownIt-Anchor" href="#二-c-类和对象"></a> 二、C++ 类和对象</h1><p>我们先来做一个测试，修改一下book202.cpp的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">st_girl::show</span><span class="params">()</span>   <span class="comment">// 结构体st_girl成员函数的定义</span></span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">st_girl::show1</span><span class="params">()</span>   <span class="comment">// 结构体st_girl成员函数的定义</span></span></span><br></pre></td></tr></table></figure><p>修改后再编译。</p><p><img src="https://img-blog.csdnimg.cn/20200305090443927.png" alt="在这里插入图片描述" /></p><p>上图中，方框内的文字“未在类st_girl中声明”？我明明写的是一个结构体，怎么成了类？</p><p>C++把结构体看成了类（class），类的成员可以是变量和函数，通过类定义出来的变量也有特定的称呼，叫做对象。</p><p><strong>示例（book205.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book205.cpp，此程序演示用类的基本概念。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>    <span class="comment">// 定义超女类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">Show</span><span class="params">()</span></span>;      <span class="comment">// 申明显示超女基本信息的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CGirl Girl;   <span class="comment">// 实例化一个Girl对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问对象的成员变量，进行赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(Girl.m_name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  Girl.m_age=<span class="number">28</span>;      </span><br><span class="line">  Girl.m_height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(Girl.m_sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(Girl.m_yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Girl.<span class="built_in">Show</span>();   <span class="comment">// 调用对象的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CGirl::Show</span><span class="params">()</span>  <span class="comment">// 显示超女基本信息的成员函数体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s。\n&quot;</span>,m_name,m_age,m_height,m_sc,m_yz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305090548328.png" alt="在这里插入图片描述" /></p><p>解释一下book205.cpp。</p><p><strong>class</strong>是C++的关键字，用于定义类，就像结构体中的<strong>sturct</strong>。</p><p><strong>public</strong>也是C++中的关键字，各位先忽略它，后面再讲解，先这么抄就行。</p><p>类的成员变量和结构体成员变量一样，也有数据类型和名称。</p><p>int CGirl::Show()是类的成员函数的定义，在函数前加上类的名称和两个冒号，表示该函数是这个类的成员函数，类的成员函数的返回值、参数等语法与普通函数相同。</p><p>在C++中，用类定义一个类的变量叫做创建（或实例化）一个对象，成员变量称为类的属性（property），成员函数称为类的方法（method）。</p><p>类的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。</p><h1 id="三-对象数组"><a class="markdownIt-Anchor" href="#三-对象数组"></a> 三、对象数组</h1><p>类可以创建数组对象，就像结构体数组一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGirl Girl[<span class="number">10</span>];    <span class="comment">// 定义10个超女类数组</span></span><br><span class="line"><span class="built_in">strcpy</span>(Girl[<span class="number">0</span>].m_name,<span class="string">&quot;杨玉环&quot;</span>);</span><br><span class="line">Girl[<span class="number">0</span>].m_age=<span class="number">18</span>;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">strcpy</span>(Girl[<span class="number">9</span>].m_name,<span class="string">&quot;陈圆圆&quot;</span>);</span><br><span class="line">Girl[<span class="number">9</span>].m_age=<span class="number">21</span>;</span><br></pre></td></tr></table></figure><h1 id="四-对象的指针"><a class="markdownIt-Anchor" href="#四-对象的指针"></a> 四、对象的指针</h1><p>类是一种自定义的数据类型，对象是内存变量，有内存地址，当然也就有类的指针，就像结构体的指针一样。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGirl queen;</span><br><span class="line">CGirl *pst=&amp;queen;</span><br></pre></td></tr></table></figure><p>通过类指针可以访问对象的成员，书写方法与结构体相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pointer).memberName</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure><p>上面的两种写法是等效的，我们通常采用后面的写法，这样更加直观。</p><h1 id="五-对象作为函数的参数"><a class="markdownIt-Anchor" href="#五-对象作为函数的参数"></a> 五、对象作为函数的参数</h1><p>与结构体一样，对象可以作为参数传递给函数，最好的方法当然是传递对象的地址。</p><h1 id="六-对象的初始化和占用内存的大小"><a class="markdownIt-Anchor" href="#六-对象的初始化和占用内存的大小"></a> 六、对象的初始化和占用内存的大小</h1><p>按我们以前的经验，定义的变量使用前要初始化，C语言的基本数据类型可以直接赋值0，字符串和结构体用memset函数初始化，那么类的对象呢？对象不能用memset初始化，具体做法我们以后再介绍。</p><p>对象可以用sizeof运算符获取占用内存的大小，但是，在实际开发中，程序员不太关心对象占用内存的大小。</p><h1 id="七-小结"><a class="markdownIt-Anchor" href="#七-小结"></a> 七、小结</h1><p>在这个阶段，类就像一个有成员函数的结构体，定义的关键字和语法不同，使用方法完全相同。</p><p>各位可能会认为类好像没什么用，不用类也可以活得很好，这不一定，因为我先用尽可能简单的方式介绍类的基础知识，如果把实际开发的场景搬到教材中，大家可能接受不了，在实际开发中，某些类的代码非常长，类的声明就有好几页，还不包括成员函数体。</p><p>希望各位保持好的心态，循序渐进的学习。</p><h1 id="八-面向对象编程object-oriented-programmingoop"><a class="markdownIt-Anchor" href="#八-面向对象编程object-oriented-programmingoop"></a> 八、面向对象编程（Object Oriented Programming，OOP）</h1><p>类是一个通用的概念，C++、Java、C#、PHP等很多编程语言中都支持类，都可以通过类创建对象。因为 C++、Java、C#、PHP等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言，有点欺负人。</p><p>在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，而在C++中，多了一层封装，就是类（class），不要小看类（class）这一层封装，它有很多特性，极大地提高了程序员的开发效率。</p><p>面向对象编程在程序执行的效率上没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路。</p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>1）编写程序，测试对象数组、对象指针、对象作为函数的参数的用法。</p><p>2）参照book205.cpp程序，增加一个成员函数Level，Level函数根据超女资料，判断超女的级别，级别的判断标准如下：</p><p>妃子：（1）年龄18-25岁；（2）身高165-178cm；（3）身材火辣；（4）颜值漂亮。</p><p>宫女：（1）年龄18-30岁；（2）身高160-165cm；（3）身材火辣或者普通；（4）颜值一般。</p><p>杂役：（1）年龄35-40岁；（2）身高155-165cm；（3）身材普通或者飞机场；（4）颜值一般。</p><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数重载</title>
      <link href="/posts/4f972a4b.html"/>
      <url>/posts/4f972a4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-函数重载的概念"><a class="markdownIt-Anchor" href="#一-函数重载的概念"></a> 一、函数重载的概念</h1><p>在实际开发中，有时候我们需要实现几个功能类似的函数，例如把变量的值写入文件，变量的类型可能是int、long、double、char，通过参数把变量传入函数。在C语言中不允许函数同名，程序员只能设计出四个不同名的函数，其函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_int</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> value)</span></span>;  <span class="comment">// 写入int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_long</span><span class="params">(<span class="type">char</span> *filename,<span class="type">long</span> value)</span></span>;  <span class="comment">// 写入long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_double</span><span class="params">(<span class="type">char</span> *filename,<span class="type">double</span> value)</span></span>; <span class="comment">// 写入double</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile_char</span><span class="params">(<span class="type">char</span> *filename,<span class="type">char</span> *value)</span></span>; <span class="comment">// 写入char字符串</span></span><br></pre></td></tr></table></figure><p>C语言中函数命名不能重复对程序员是一种负担，编程序的时候需要想象出相近的函数名，调用函数的时候，书写函数名也是一件麻烦的事情。</p><p>C++允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading），借助重载，多个功能相近的一系列函数可以使用同一函数名。</p><p>函数的参数列表包括<strong>参数的类型、参数的个数和参数的顺序</strong>，只要有一个不同就叫做参数列表不同。</p><p>使用C++函数重载，把变量的值写入文件的函数声明修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> value)</span></span>;     <span class="comment">// 写入int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">long</span> value)</span></span>;   <span class="comment">// 写入long</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">double</span> value)</span></span>; <span class="comment">// 写入double</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">char</span> *value)</span></span>;   <span class="comment">// 写入char字符串</span></span><br></pre></td></tr></table></figure><p>重载就是在一个作用范围内（同一个程序、同一个类、同一个命名空间等）有多个<strong>名称相同但参数列表不同</strong>的一系列函数。</p><p>在使用重载函数时，同名函数的功能应当相似，不要用相同名称的函数名去实现不相干的功能，虽然程序也能运行，但可读性不好，使人觉得莫名其妙。</p><p>注意，参数列表不同包括参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的，函数返回值也不能作为重载的依据。</p><h1 id="二-c-是如何做到函数重载的"><a class="markdownIt-Anchor" href="#二-c-是如何做到函数重载的"></a> 二、C++ 是如何做到函数重载的</h1><p>编译器在编译C++程序时会根据参数列表对函数进行重命名，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> value)</span></span>;  </span><br></pre></td></tr></table></figure><p>重命名为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _writetofile_char_int(<span class="type">char</span> *filename,<span class="type">int</span> value); </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">writetofile</span><span class="params">(<span class="type">char</span> *filename,<span class="type">long</span> value)</span></span>; </span><br></pre></td></tr></table></figure><p>重命名为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _writetofile_char_long(<span class="type">char</span> *filename,<span class="type">long</span> value);   </span><br></pre></td></tr></table></figure><p>程序被编译时，编译器会根据参数列表逐个匹配，选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。</p><p>所以，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p><h1 id="三-函数重载的示例"><a class="markdownIt-Anchor" href="#三-函数重载的示例"></a> 三、函数重载的示例</h1><p>我们在介绍C语言字符串的时候，学习了strcpy函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>strcpy函数有两个缺陷：1）没有对dest变量进行初始化；2）如果src的长度超过dest，会造成内存溢出。</p><p>我们现在来重写strcpy函数，弥补这两个缺陷，新函数名还是采用strcpy命名，但参数列表不同，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src,<span class="type">size_t</span> destsize)</span></span>;</span><br></pre></td></tr></table></figure><p>dest和src参数的含义与库函数strcpy相同，第三个参数destsize是dest占用内存的大小。</p><p><strong>示例（book201.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book201.cpp，此程序用于演示C++函数重载，修复strcpy函数的缺陷</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载strcpy函数，对dest初始化，防止内存溢出。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src,<span class="type">size_t</span> destsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(dest,<span class="string">&quot;www.freecplus.net&quot;</span>,<span class="built_in">sizeof</span>(dest));  <span class="comment">// 新strcpy</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,dest);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(dest,<span class="string">&quot;www.freecplus.net&quot;</span>);   <span class="comment">// 旧strcpy</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载strcpy函数，对dest初始化，防止内存溢出</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src,<span class="type">size_t</span> destsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dest,<span class="number">0</span>,destsize);  <span class="comment">// 对dest初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算需要复制的字符数，不能超出destsize-1</span></span><br><span class="line">  <span class="type">size_t</span> len=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(src)&lt;=destsize<span class="number">-1</span>) len=<span class="built_in">strlen</span>(src);</span><br><span class="line">  <span class="keyword">else</span> len=destsize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strncpy</span>(dest,src,len);   <span class="comment">// 复制字符串，超出的将扔掉</span></span><br><span class="line">  dest[len]=<span class="number">0</span>;  <span class="comment">// 强制字符串的结尾标志</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305084737560.png" alt="在这里插入图片描述" /></p><p>C语言提供了一些库函数，这些库函数的功能肯定不能满足实际开发的需求，需要程序员重新扩展加固，这是优秀程序员与普通程序员的差别。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><p>2）编写示例程序，测试函数的返回值不同能否作为函数重载的依据。</p><p>3）编写示例程序，测试函数的参数名不同能否作为函数重载的依据。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C到C++</title>
      <link href="/posts/569d6b79.html"/>
      <url>/posts/569d6b79.html</url>
      
        <content type="html"><![CDATA[<p>C<ins>读作“C加加”，是“C Plus Plus”的简称，C</ins>是在C语言的基础上增加新特性，从语法上看，C语言是C++ 的一部分，C语言代码几乎不用修改就能够以 C++ 的方式编译。</p><p>对于C和C<ins>的关系，有很多种说法，从表面上看，很容易认为C</ins>是C的升级版，C<ins>比C高大上，C过时了，有这种想法说明他不了解C/C</ins>语言，我们先来看看世界编程语言排行榜，下表是2019的数据（过去十年的数据也大致如此）。<br /><img src="https://img-blog.csdnimg.cn/20200314150950928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />从上表中看出，这个世界上的C程序员比C++程序员多很多。</p><p>这么多年了，我也搞不清楚自己是C程序员，还是C++程序员，好像没什么差别。</p><p>C<ins>有很多新的特征，这些新特征并不一定实用，甚至很烦人。但是，C</ins>的开发效率确实比C要高，所以我仍然采用断章取义的方式来介绍C<ins>的知识。不管是C还是C</ins>，实用就好。</p><h1 id="一-c程序的命名规则"><a class="markdownIt-Anchor" href="#一-c程序的命名规则"></a> 一、C++程序的命名规则</h1><p>C++头文件一般采用.h后缀，也用有.hpp的。</p><p>C<ins>程序文件一般采用.cpp后缀，也有用.cc的，建议采用.cpp，C</ins>对程序文件的命名没有强制要求，采用.cpp为后缀是大部分程序员的习惯。</p><h1 id="二-c程序的编译"><a class="markdownIt-Anchor" href="#二-c程序的编译"></a> 二、C++程序的编译</h1><p>在某些操作系统中，C和C<ins>是同一个编译器，在CentOS中，C的编译器是gcc，C</ins>的编译器是g++。</p><h2 id="1-安装g编译器"><a class="markdownIt-Anchor" href="#1-安装g编译器"></a> 1、安装g++编译器</h2><p>用root用户登录服务器，执行以下命令安装或升级gcc-c++编译器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install  gcc-c++ </span><br></pre></td></tr></table></figure><p>如果您的CentOS系统没有安装gcc-c++，以上命令就会安装最新版本的gcc-c++，如果已经安装了gcc-c++，就会更新到最新版本的gcc-c++，所以，以上命令不管执行多少次都没有问题。</p><p>安装gcc-c++的前提条件是服务器必须可以访问互联网。</p><h2 id="2-编译c程序"><a class="markdownIt-Anchor" href="#2-编译c程序"></a> 2、编译C++程序</h2><p>编译C程序的命令是gcc，编译C<ins>程序的命令是g</ins>，g<ins>命令和gcc命令的用法相同，把gcc改为g</ins>就可以了，我们在学习C语言时编写的那些示例程序，基本上都可以用g++来编译。</p><p><img src="https://img-blog.csdnimg.cn/20200305083533236.png" alt="在这里插入图片描述" /></p><h1 id="三-c是面向对象语言"><a class="markdownIt-Anchor" href="#三-c是面向对象语言"></a> 三、C++是面向对象语言</h1><p>C语言是面向过程的编程语言，C++是面向对象的编程语言，很多人认为面向对象会比面向过程的方法更先进。仁者和智者的说法各有不同，大家慢慢体会，不能人云亦云。</p><p>C++的对象，确实可以大幅的提升了C程序员的开发效率，降低程序员犯错的机会。</p><h1 id="四-c输入和输出"><a class="markdownIt-Anchor" href="#四-c输入和输出"></a> 四、C++输入和输出</h1><p>在C语言中，我们使用scanf和printf来对数据进行输入输出操作。在C++语言中，增加了cin和cout输入输出，但是我从来不用它，因为它不实用，对格式化的支持实在是太麻烦。</p><p>printf实在太完美，太强大。</p><h1 id="五-c异常"><a class="markdownIt-Anchor" href="#五-c异常"></a> 五、C++异常</h1><p>C++增加了异常机制，但是，它从诞生开始就一直有争议。</p><p>我没有发现C++的异常有什么实用价值，也从来没有用过它。</p><h1 id="六-c命名空间和模板"><a class="markdownIt-Anchor" href="#六-c命名空间和模板"></a> 六、C++命名空间和模板</h1><p>了解一下命名空间和模板的概念和用法是可以的，会使用就行，但我不建议自定义命名空间和模板，没必要把程序搞得那么麻烦。</p><h1 id="七-c布尔类型bool"><a class="markdownIt-Anchor" href="#七-c布尔类型bool"></a> 七、C++布尔类型（bool）</h1><p>C语言并没有彻底从语法上支持“真”和“假”，只是用 0 和非 0来代表。这点在 C<ins>中得到了改善，C</ins><br />新增了 bool 类型（布尔类型），它占用 1 个字节长度。bool 类型只有两个取值，true和 false：true 表示“真”，false 表示“假”。</p><p>bool 是类型名字，也是 C++ 中的关键字，它的用法和 int、char、long是一样的，可以用=赋值，可以用于函数的参数和返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag=<span class="literal">true</span>;  <span class="comment">// 定义bool型变量flag，赋值为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">&quot;flag is true&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;flag is fals&quot;</span>);</span><br><span class="line"></span><br><span class="line">flag=<span class="literal">false</span>;    <span class="comment">// 把flag赋值为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">&quot;flag is true&quot;</span>);       </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;flag is fals&quot;</span>);  </span><br></pre></td></tr></table></figure><h1 id="八-c定义变量的位置"><a class="markdownIt-Anchor" href="#八-c定义变量的位置"></a> 八、C++定义变量的位置</h1><p>ANSI C规定，所有局部变量都必须定义在函数开头，在定义变量之前不能有其他的执行语句。C99标准取消这这条限制，但是某些编译器对C99的支持很不积极，仍然要求变量定义在函数开头，或者只支持一部分。</p><p>取消限制带来的另外一个好处是，可以在 for 循环的控制语句中定义变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">1</span>; ii&lt;=<span class="number">100</span> ;ii++)</span><br><span class="line">&#123;</span><br><span class="line">  total = total + ii;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很棒，程序更简洁，更自由。</p><h1 id="九-c函数的缺省参数"><a class="markdownIt-Anchor" href="#九-c函数的缺省参数"></a> 九、C++函数的缺省参数</h1><p>在C语言中，函数在声明的时候指定了参数列表，调用的时候函数参数的个数、顺序和数据类型必须与函数声明参数列表相同，但是在C++中，声明函数的时候，可以为函数指定缺省参数，调用时缺省参数可以不填写。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">writetofile</span><span class="params">(FILE *fp,<span class="type">char</span> *strbuf,<span class="type">bool</span> enbuffer=<span class="literal">true</span>)</span></span>; <span class="comment">// 指定参数enbuffer的缺省值为true</span></span><br></pre></td></tr></table></figure><p>enbuffer参数表示是否启用缓冲区，writetofile函数被调用的时候，如果只写fp和strbuf参数，不写enbuffer参数，enbuffer参数将缺省为true，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">writetofile</span>(fp,strbuf);  <span class="comment">// 调用函数的时候，如果第三个参数enbuffer不填，就用缺省值true</span></span><br></pre></td></tr></table></figure><p>这个不错，程序更简洁。</p><h1 id="十-c动态内存管理"><a class="markdownIt-Anchor" href="#十-c动态内存管理"></a> 十、C++动态内存管理</h1><p>在C语言中，动态管理内存用 malloc() 函数，释放内存用 free() 函数。</p><p>在C<ins>中，这两个函数仍然可以使用，但是C</ins>又新增了两个关键字，new 和 delete，new用来动态分配内存，delete 用来释放内存。</p><p>和C语言的动态内存管理一样，C++动态内存管理的应用场景不多。</p><h1 id="十一-c的学习的策略"><a class="markdownIt-Anchor" href="#十一-c的学习的策略"></a> 十一、C++的学习的策略</h1><p>在我看来，C<ins>至少有70%的内容没有实用价值，在这个阶段，我们先只学习C</ins>中重要的、有实用价值的内容，十天左右的时间可以完成，如下：</p><p>1）C++函数重载；</p><p>2）类的基本知识。</p><p>3）引用。</p><p>4）string类。</p><p>5）vector容器。</p><p>6）类的继承。</p><p><strong>然后学习Linux编程基础，再进入职业技能教程，在学习完职业技术程后，您的学习能力和判断能力远远超过今日，再回头来看看C++的其它知识，网上的免费视频到处都是，三天就可以完成。</strong></p><p><strong>学习的技巧很重要，在基础知识上花太多的时间容易打击学习的积极性，那些没有实用价值的知识还会浪费您宝贵的时间。</strong></p><h1 id="十二-课后作业"><a class="markdownIt-Anchor" href="#十二-课后作业"></a> 十二、课后作业</h1><p>编写您最后一个C程序，生成一个makefile文件，把您在学习C语言基础时写的源代码用C<ins>来编译，个别用到_public.h和_public.c的程序例外用手工处理。顺便看看C</ins>编译器和C有什么不同。</p><h1 id="十三-版权声明"><a class="markdownIt-Anchor" href="#十三-版权声明"></a> 十三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言makefile文件</title>
      <link href="/posts/3689c97f.html"/>
      <url>/posts/3689c97f.html</url>
      
        <content type="html"><![CDATA[<p>在软件的工程中的源文件是很多的，其按照类型、功能、模块分别放在若干个目录和文件中，哪些文件需要编译，那些文件需要后编译，那些文件需要重新编译，甚至进行更复杂的功能操作，这就有了我们的系统编译的工具。</p><p>在linux和unix中，有一个强大的实用程序，叫make，可以用它来管理多模块程序的编译和链接，直至生成可执行文件。</p><p>make程序需要一个编译规则说明文件，称为makefile，makefile文件中描述了整个软件工程的编译规则和各个文件之间的依赖关系。</p><p>makefile就像是一个shell脚本一样，其中可以执行操作系统的命令，它带来的好处就是我们能够实现“自动化编译”，一旦写好，只要一个make命令，整个软件功能就完全自动编译，提高了软件开发的效率。</p><p>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说大多数编译器都有这个命令，使用make可以是重新编译的次数达到最小化。</p><h1 id="一-makefile的编写"><a class="markdownIt-Anchor" href="#一-makefile的编写"></a> 一、makefile的编写</h1><p>makefile文件的规则可以非常复杂，比C程序还要复杂，我通过示例来介绍它的简单用法。</p><p>文件名：makefile，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">all:book1 book46 </span><br><span class="line"></span><br><span class="line">book1:book1.c</span><br><span class="line">        gcc -o book1 book1.c</span><br><span class="line"></span><br><span class="line">book46:book46.c _public.h _public.c</span><br><span class="line">        gcc -o book46 book46.c _public.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f book1 book46</span><br></pre></td></tr></table></figure><p><strong>第一行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all:book book46</span><br></pre></td></tr></table></figure><p>all: 这是固定的写法。</p><p>book1 book46表示需要编译目标程序的清单，中间用空格分隔开，如果清单很长，可以用\换行。</p><p><strong>第二行</strong></p><p>makefile文件中的空行就像C程序中的空行一样，只是为了书写整洁，没有什么意义。</p><p><strong>第三行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book1:book1.c</span><br></pre></td></tr></table></figure><p>book1:表示需要编译的目标程序。</p><p>如果要编译目标程序book1，需要依赖源程序book1.c，当book1.c的内容发生了变化，执行make的时候就会重新编译book1。</p><p><strong>第四行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o book1 book1.c</span><br></pre></td></tr></table></figure><p>这是一个编译命令，和在操作系统命令行输入的命令一样，但是要注意一个问题，在gcc之前要用tab键，看上去像8个空格，实际不是，一定要用tab，空格不行。</p><p><strong>第六行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book46:book46.c _public.h _public.c</span><br></pre></td></tr></table></figure><p>与第三行的含义相同。</p><p>book46:表示编译的目标程序。</p><p>如果要编译目标程序book46，需要依赖源程序book46.c、_public.h和_public.c三个文件，只要任何一个的内容发生了变化，执行make的时候就会重新编译book46。</p><p><strong>第七行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o book46 book46.c _public.c</span><br></pre></td></tr></table></figure><p>与第四行的含义相同。</p><p><strong>第九行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br></pre></td></tr></table></figure><p>清除目标文件，清除的命令由第十行之后的脚本来执行。</p><p><strong>第十行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -f  book1 book46</span><br></pre></td></tr></table></figure><p>清除目标文件的脚本命令，注意了，rm之前也是一个tab键，不是空格。</p><h1 id="二-make命令"><a class="markdownIt-Anchor" href="#二-make命令"></a> 二、make命令</h1><p>makefile准备好了，在命令提示符下执行make就可以编译makefile中all参数指定的目标文件。</p><p>程序make编译目标程序。</p><p><img src="https://img-blog.csdnimg.cn/20200304165141588.png" alt="在这里插入图片描述" /></p><p>再执行一次make。</p><p><img src="https://img-blog.csdnimg.cn/20200304165151880.png" alt="在这里插入图片描述" /></p><p>因为全部的目标程序都是最新的，所以提示没有目标可以编译。</p><p>执行make clean，执行清除目标文件的指令。</p><p><img src="https://img-blog.csdnimg.cn/20200304165204920.png" alt="在这里插入图片描述" /></p><p>再执行make重新编译。</p><p><img src="https://img-blog.csdnimg.cn/20200304165217896.png" alt="在这里插入图片描述" /></p><p>修改_public.c程序，随便改点什么，只要改了就行。</p><p>然后再make</p><p><img src="https://img-blog.csdnimg.cn/20200304165230591.png" alt="在这里插入图片描述" /></p><p>注意了，因为book46依赖的源程序之一_public.c改变了，所以book46重新编译。</p><p>book1没有重新编译，因为book1依赖的源文件并没有改变。</p><h1 id="三-makefile文件中的变量"><a class="markdownIt-Anchor" href="#三-makefile文件中的变量"></a> 三、makefile文件中的变量</h1><p>makefile中，变量就是一个名字，变量的值就是一个文本字符串。在makefile中的目标，依赖，命令或其他地方引用变量时，变量会被它的值替代。</p><p>我通过示例来介绍它的简单用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">FLAG=-g</span><br><span class="line"></span><br><span class="line">all:book1 book46</span><br><span class="line"></span><br><span class="line">book1:book1.c</span><br><span class="line">        $(CC) $(FLAG) -o book1 book1.c</span><br><span class="line"></span><br><span class="line">book46:book46.c _public.h _public.c</span><br><span class="line">        $(CC) $(FLAG) -o book46 book46.c _public.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f book1 book46</span><br></pre></td></tr></table></figure><p><strong>第一行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br></pre></td></tr></table></figure><p>定义变量CC，赋值gcc。</p><p><strong>第二行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLAG=-g</span><br></pre></td></tr></table></figure><p>定义变量FLAG，赋值-g。</p><p><strong>第七行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(CC)  $(FLAG) -o book1 book1.c</span><br></pre></td></tr></table></figure><p>$(CC)和$(FLAG)就是使用变量CC和FLAG的值，类似于C语言的宏定义，替换后的结果是：</p><p><img src="https://img-blog.csdnimg.cn/20200304165658467.png" alt="在这里插入图片描述" /></p><p>在makefile文件中，使用变量的好处有两个：1）如果在很多编译指令采用了变量，只要修改变量的值，就相当于修改全部的编译指令；2）把比较长的、公共的编译指令采用变量来表示，可以让makefile更简洁。</p><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><p>makefile文件的编写可以很复杂，复杂到我不想看，在实际开发中，用不着那么复杂的makefile，我追求简单实用的方法，腾出更多的时间和精力去做更重要的事情，那些把makefile文件写得很复杂的程序员在我看来是吃饱了撑的。</p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>把您这段时间写的程序全部编写到makefile中，以后再也不要在命令提示符下用gcc了。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言gdb调试</title>
      <link href="/posts/ec19abf3.html"/>
      <url>/posts/ec19abf3.html</url>
      
        <content type="html"><![CDATA[<p>程序员写在编写程序的时候不可能是一帆风顺的，gcc编译器可以发现程序代码的语法错误，但不能发现程序的业务逻辑错误，调试程序是软件开发的内容之一。调试程序的方法有很多种，例如可以用printf语句跟踪程序的运行步骤和显示变量的值，本章节介绍一个功能强大的调试工具gdb。</p><h1 id="一-gdb的安装"><a class="markdownIt-Anchor" href="#一-gdb的安装"></a> 一、gdb的安装</h1><p>CentOS系统中，用root用户登录服务器，执行以下命令安装或升级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install  gdb </span><br></pre></td></tr></table></figure><p>注意，如果您的服务器没有安装gdb，以上命令就会安装最新版本的gdb，如果已经安装了gdb，就会更新到最新版本的gdb，所以，以上命令不管执行多少次都没有问题。</p><p>安装gdb，前提条件是服务器必须接入互联网。</p><h1 id="二-调试前的准备"><a class="markdownIt-Anchor" href="#二-调试前的准备"></a> 二、调试前的准备</h1><p>用gcc编译源程序的时候，编译后的可执行文件不会包含源程序代码，如果您打算编译后的程序可以被调试，编译的时候要加-g的参数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o book113 book113.c </span><br></pre></td></tr></table></figure><p>在命令提示符下输入gdb book113就可以调试book113程序了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb book113 </span><br></pre></td></tr></table></figure><h1 id="三-基本调试命令"><a class="markdownIt-Anchor" href="#三-基本调试命令"></a> 三、基本调试命令</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>命令 缩写</strong></th><th><strong>命令说明</strong></th></tr></thead><tbody><tr><td>set args</td><td></td><td>设置主程序的参数。 例如：./book119 /oracle/c/book1.c /tmp/book1.c 设置参数的方法是： gdb book119 (gdb) set args /oracle/c/book1.c /tmp/book1.c</td></tr><tr><td>break</td><td>b</td><td>设置断点，b 20 表示在第20行设置断点，可以设置多个断点。</td></tr><tr><td>run</td><td>r</td><td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。</td></tr><tr><td>next</td><td>n</td><td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td></tr><tr><td>step</td><td>s</td><td>执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。 注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。</td></tr><tr><td>print</td><td>p</td><td>显示变量值，例如：p name表示显示变量name的值。</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点。</td></tr><tr><td>set varname=v</td><td></td><td>设置变量的值，假设程序有两个变量：int ii; char name[21]; set ii=10 把ii的值设置为10； set name=“西施” 把name的值设置为&quot;西施&quot;，注意，不是strcpy。</td></tr><tr><td>quit</td><td>q</td><td>退出gdb环境。</td></tr></tbody></table><p>注意，在gdb环境中，可以用上下光标键选择执行过的gdb命令。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>gdb调试是程序员必须掌握的方法，多尝试一下，搞清楚每个命令的用法。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言目录和文件操作扩展</title>
      <link href="/posts/e9b985fb.html"/>
      <url>/posts/e9b985fb.html</url>
      
        <content type="html"><![CDATA[<p>本章节扩展一些目录和文件操作的更多知识，因为这些知识涉及到时间操作，所以放在时间操作之后的章节中介绍。</p><h1 id="一-access库函数"><a class="markdownIt-Anchor" href="#一-access库函数"></a> 一、access库函数</h1><p>access函数用于判断当前操作系统用户对文件或目录的存取权限。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>pathname文件名或目录名，可以是当前目录的文件或目录，也可以列出全路径。</p><p>mode 需要判断的存取权限。在头文件unistd.h中的预定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> R_OK 4     <span class="comment">// R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W_OK 2    <span class="comment">// W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_OK 1     <span class="comment">// X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F_OK 0     <span class="comment">// F_OK 只判断是否存在</span></span></span><br></pre></td></tr></table></figure><p>返回值：</p><p>当pathname满足mode的条件时候返回0，不满足返回-1。</p><p>在实际开发中，access函数主要用于判断文件或目录是否是存在。</p><h1 id="二-stat库函数"><a class="markdownIt-Anchor" href="#二-stat库函数"></a> 二、stat库函数</h1><h2 id="1-stat结构体"><a class="markdownIt-Anchor" href="#1-stat结构体"></a> 1、stat结构体</h2><p>struct stat结构体用于存放文件和目录的状态信息，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">dev_t</span> st_dev;   <span class="comment">// device 文件的设备编号</span></span><br><span class="line">  <span class="type">ino_t</span> st_ino;   <span class="comment">// inode 文件的i-node</span></span><br><span class="line">  <span class="type">mode_t</span> st_mode;   <span class="comment">// protection 文件的类型和存取的权限</span></span><br><span class="line">  <span class="type">nlink_t</span> st_nlink;   <span class="comment">// number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span></span><br><span class="line">  <span class="type">uid_t</span> st_uid;   <span class="comment">// user ID of owner 文件所有者的用户识别码</span></span><br><span class="line">  <span class="type">gid_t</span> st_gid;   <span class="comment">// group ID of owner 文件所有者的组识别码</span></span><br><span class="line">  <span class="type">dev_t</span> st_rdev;  <span class="comment">// device type 若此文件为设备文件, 则为其设备编号</span></span><br><span class="line">  <span class="type">off_t</span> st_size;  <span class="comment">// total size, in bytes 文件大小, 以字节计算</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> st_blksize;  <span class="comment">// blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> st_blocks;  <span class="comment">// number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span></span><br><span class="line">  <span class="type">time_t</span> st_atime;  <span class="comment">// time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.</span></span><br><span class="line">  <span class="type">time_t</span> st_mtime;  <span class="comment">// time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变</span></span><br><span class="line">  <span class="type">time_t</span> st_ctime;  <span class="comment">// time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct stat结构体的成员变量比较多，对程序员来说，重点关注st_mode、st_size和st_mtime成员就可以了。注意st_mtime是一个整数表达的时间，需要程序员自己写代码转换格式。</p><p>st_mode成员的取值很多，或者使用如下两个宏来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">S_ISREG</span> (st_mode) 是否为一般文件 </span><br><span class="line"><span class="built_in">S_ISDIR</span> (st_mode) 是否为目录 </span><br></pre></td></tr></table></figure><h2 id="2-stat库函数"><a class="markdownIt-Anchor" href="#2-stat库函数"></a> 2、stat库函数</h2><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>stat函数获取path指定文件或目录的信息，并将信息保存到结构体buf中，执行成功返回0，失败返回-1。</p><p><strong>示例（book145.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book145.c，此程序演示目录和文件的存取权限和状态信息</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本程序运行要带一个参数，即文件或目录名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)  &#123; <span class="built_in">printf</span>(<span class="string">&quot;请指定目录或文件名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">access</span>(argv[<span class="number">1</span>],F_OK) != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;文件或目录%s不存在。\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> ststat;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件的状态信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stat</span>(argv[<span class="number">1</span>],&amp;ststat) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">S_ISREG</span>(ststat.st_mode)) <span class="built_in">printf</span>(<span class="string">&quot;%s是一个文件。\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(ststat.st_mode)) <span class="built_in">printf</span>(<span class="string">&quot;%s是一个目录。\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304153705527.png" alt="在这里插入图片描述" /></p><h1 id="三-utime库函数"><a class="markdownIt-Anchor" href="#三-utime库函数"></a> 三、utime库函数</h1><p>utime函数用于修改文件的存取时间和更改时间。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span></span>;</span><br></pre></td></tr></table></figure><p>函数说明：utime()用来修改参数filename 文件所属的inode存取时间。如果参数times为空指针(NULL),<br />则该文件的存取时间和更改时间全部会设为目前时间。结构utimbuf 定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">utimbuf</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">time_t</span> actime;</span><br><span class="line">  <span class="type">time_t</span> modtime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值：执行成功则返回0，失败返回-1。</p><h1 id="四-rename库函数"><a class="markdownIt-Anchor" href="#四-rename库函数"></a> 四、rename库函数</h1><p>rename函数用于重命名文件或目录，相当于操作系统的mv命令，对程序员来说，在程序中极少重命名目录，但重命名文件是经常用到的功能。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>oldpath 文件或目录的原名。</p><p>newpath 文件或目录的新的名称。</p><p>返回值：0-成功，-1-失败。</p><h1 id="五-remove库函数"><a class="markdownIt-Anchor" href="#五-remove库函数"></a> 五、remove库函数</h1><p>remove函数用于删除文件或目录，相当于操作系统的rm命令。</p><p>包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>pathname 待删除的文件或目录名。</p><p>返回值：0-成功，-1-失败。</p><h1 id="六-课后作业"><a class="markdownIt-Anchor" href="#六-课后作业"></a> 六、课后作业</h1><p>1）继续丰富您的函数库，用mkdir创建目录的时候，例如mkdir(“/tmp/aaa/bbb/ccc”,0755);，如果上级目录不存在（/tmp/aaa或/tmp/aaa/bbb不存在），是无法创建/tmp/aaa/bbb/ccc目录的，这不是程序员想要的，我们要再写一个函数，如果上级目录不存在，就创建上级目录，一级一级的创建，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MKDIR</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><p>2）编写一个获取文件时间的函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件的时间，即modtime</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileMTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_FullFileName,<span class="type">char</span> *out_ModTime)</span></span>;</span><br></pre></td></tr></table></figure><p>out_ModTime的格式是&quot;yyyy-mm-dd hh24:mi:ss&quot;。</p><p>3）编写一个获取文件大小的函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件的大小，返回字节数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FileSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_FullFileName)</span></span>;</span><br></pre></td></tr></table></figure><p>4）rename函数有一个不足，如果目标文件名目录newpath的上级目录不存在，函数返回失败，重写一个新的RENAME函数，如果newpath的上级目录不存在，先创建newpath的上级目录，再rename，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RENAME</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure><p>5）utime函数的第二个参数是一个结构体utimbuf，不方便使用，在实际开发中，我们更希望是一个字符串格式的时间，如：“2019-02-08 12:05:02”，重写一个utime函数，功能与utime相同，但是把第二个参数改为字符串格式的时间，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">UTIME</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *strtime)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言系统错误</title>
      <link href="/posts/392db03e.html"/>
      <url>/posts/392db03e.html</url>
      
        <content type="html"><![CDATA[<p>我们在写程序的时候需要调用C语言提供的库函数，并通过函数的返回值判断调用是否成功。其实在C语言中，还有一个全局变量errno，存放了函数调用过程中产生的错误码。</p><p>为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt;文件中。如果库函数调用失败，可以通过读出 errno的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。</p><p>配合 strerror和perror两个库函数，可以很方便地查看出错的详细信息。</p><p>strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。</p><p>perror 在 &lt;stdio.h&gt;中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。</p><h1 id="一-strerror函数"><a class="markdownIt-Anchor" href="#一-strerror函数"></a> 一、strerror函数</h1><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strerror</span><span class="params">(<span class="type">int</span> errno)</span></span>;</span><br></pre></td></tr></table></figure><p>函数说明：strerror()用来依参数errno的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。</p><p>返回值：返回描述错误原因的字符串地址。</p><p>在gcc4.4.7版本中，定义了131个错误代码，我们用程序把它们全部显示出来。</p><p><strong>示例（book158.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book158.c，此程序演示strerror函数的使用。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> errorno;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(errorno=<span class="number">0</span>;errorno&lt;<span class="number">132</span>;errorno++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,errorno,<span class="built_in">strerror</span>(errorno));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200304160453567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>一共有131个错误代码和描述，上面的截图只显示了前5条和最后5条。这些错误代码和描述看一下就行了，不需要记住。</p><h1 id="二-errno的细节"><a class="markdownIt-Anchor" href="#二-errno的细节"></a> 二、errno的细节</h1><h2 id="1-调用库函数失败不一定会设置errno"><a class="markdownIt-Anchor" href="#1-调用库函数失败不一定会设置errno"></a> 1、调用库函数失败不一定会设置errno</h2><p>如果库函数调用失败，库函数会设置errno的值，程序员通过 errno的值来判断出错的具体原因，但是，并不是全部的库函数在调用失败时都会设置errno的值，那么，哪些库函数会设置errno的值呢，要看函数的说明，例如fopen函数，在命令行下输入man fopen，在诸多的文字中，有以下行说明文字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The <span class="title">fopen</span><span class="params">()</span> function may also fail <span class="keyword">and</span> set errno <span class="keyword">for</span> any of the errors specified <span class="keyword">for</span> the routine <span class="title">open</span><span class="params">(<span class="number">2</span>)</span>.</span></span><br></pre></td></tr></table></figure><p>不属于系统调用的函数不会设置errno，属于系统调用的函数才会设置errno。</p><h2 id="2-errno不能作为调用库函数失败的标志"><a class="markdownIt-Anchor" href="#2-errno不能作为调用库函数失败的标志"></a> 2、errno不能作为调用库函数失败的标志</h2><p>在 C 语言中，如果库函数被正确地执行，那么 errno 的值不会被清零。换句话说，errno的值只有在一个库函数调用发生错误时才会被设置，当库函数调用成功运行时，errno的值不会被修改，当然也不会主动被置为0。也正因为如此，在实际编程中，判断函数执行是否成功还得靠函数的返回值，只有在返回值是失败的情况下，才需要关注errno的值。</p><h2 id="3-程序员可以不用errno"><a class="markdownIt-Anchor" href="#3-程序员可以不用errno"></a> 3、程序员可以不用errno</h2><p>关注errno的目的是为了获取更详细错误信息，这些错误信息对程序员诊断程序可能会有帮助，但不是必须的。</p><p><strong>示例（book160.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book160.c，此程序用于演示C程序的基本结构。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *  此程序演示errno全局变量和strerror函数</span></span><br><span class="line"><span class="comment"> *  作者：豫让 日期：20190601</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/tmp/book1.c</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/book1.c&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件/tmp/book1.c失败（%d：%s）。\n&quot;</span>,errno,<span class="built_in">strerror</span>(errno)); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="keyword">if</span> ( fp!=<span class="number">0</span> ) <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030416055473.png" alt="在这里插入图片描述" /></p><h1 id="三-课后作业"><a class="markdownIt-Anchor" href="#三-课后作业"></a> 三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言编译预处理</title>
      <link href="/posts/80fba3a4.html"/>
      <url>/posts/80fba3a4.html</url>
      
        <content type="html"><![CDATA[<p>C语言由源代码生成可执行程序的过程如下：</p><p><strong>C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件</strong></p><p>其中编译预处理阶段，读取C源程序，对其中的预处理指令（以#开头的指令）和特殊符号进行处理。或者说是扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。</p><p>预处理过程先于编译器对源代码进行处理，读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行转换。预处理过程还会删除程序中的注释和多余的空白字符。</p><h1 id="一-预处理指令"><a class="markdownIt-Anchor" href="#一-预处理指令"></a> 一、预处理指令</h1><p>在C语言的程序中包括各种以符号#开头的编译指令，这些指令称为预处理命令。预处理命令属于C语言编译器，而不是C语言的组成部分，通过预处理命令可扩展C语言程序设计的环境。</p><p>预处理指令是以#号开头的代码行，#号必须是该行除了任何空白字符外的第一个字符。</p><p>#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。</p><p>预处理指令主要有以下三种：</p><p>1）包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。</p><p>2）宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。</p><p>3）条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。</p><h1 id="二-包含文件"><a class="markdownIt-Anchor" href="#二-包含文件"></a> 二、包含文件</h1><p>当一个C语言程序由多个文件模块组成时，主模块中一般包含main函数和一些当前程序专用的函数。程序从main函数开始执行，在执行过程中，可调用当前文件中的函数，也可调用其他文件模块中的函数。</p><p>如果在模块中要调用其他文件模块中的函数，首先必须在主模块中声明该函数原型。一般都是采用文件包含的方法，包含其他文件模块的头文件。</p><p>文件包含中指定的文件名即可以用引号括起来，也可以用尖括号括起来，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名&gt;</span></span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;文件名&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的include文件中去找指定的文件（/usr/include）。</p><p>因为C语言的标准头文件都存放在/usr/include文件夹中，所以一般对标准头文件采用尖括号；对程序员自己编写的文件，则使用双引号。</p><p>如果自己编写的文件不是存放在当前工作文件夹，可以在#include命令后面加在路径。</p><p>#include命令的作用是把指定的文件模块内容插入到#include所在的位置，当程序编译链接时，系统会把所有#include指定的文件链接生成可执行代码。</p><p>#include包含文件，可以是“.h”,表示C语言程序的头文件，也可以是“.c”,表示包含普通C语言源程序。</p><h1 id="三-宏定义指令"><a class="markdownIt-Anchor" href="#三-宏定义指令"></a> 三、宏定义指令</h1><p>使用#define命令并不是真正的定义符号常量，而是定义一个可以替换的宏。被定义为宏的标识符称为“宏名”。在编译预处理过程时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p><p>在C语言中，宏分为有参数和无参数两种。</p><h2 id="1-无参数的宏"><a class="markdownIt-Anchor" href="#1-无参数的宏"></a> 1、无参数的宏</h2><p>其定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名  字符串</span></span><br></pre></td></tr></table></figure><p>在以上宏定义语句中，各部分的含义如下：</p><p><strong>#</strong> 表示这是一条预处理命令(凡是以“#”开始的均为预处理命令)。</p><p><strong>define</strong> 关键字“define”为宏定义命令。</p><p><strong>宏名</strong> 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。</p><p><strong>字符串</strong>可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。</p><p>注意：预处理命令语句后面一般不会添加分号，如果在#define最后有分号，在宏替换时分号也将替换到源代码中去。在宏名和字符串之间可以有任意个空格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.141592</span></span><br></pre></td></tr></table></figure><p><strong>示例（book149.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book149.c，此程序演示不带参数的宏。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.141592</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;PI is %lf\n&quot;</span>,PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行预编译指令gcc -E -o book149.E book149.c，得到book149.E文件，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;book149.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;book149.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;PI is %lf\n&quot;</span>,<span class="number">3.141592</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用宏定义时，还需要注意以下几点：</p><p>宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何语法检查。如有错误，只能在编译已被宏展开后的源程序时发现。</p><p>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。建议不要这么做，会把程序复杂化。</p><p>习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。</p><h2 id="2-带参数的宏"><a class="markdownIt-Anchor" href="#2-带参数的宏"></a> 2、带参数的宏</h2><p>#define命令定义宏时，还可以为宏设置参数。与函数中的参数类似，在宏定义中的参数为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，还要用实参去代换形参。</p><p>带参宏定义的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(形参表) 字符串</span></span><br></pre></td></tr></table></figure><p>在定义带参数的宏时，宏名和形参表之间不能有空格出现，否则，就将宏定义成为无参数形式，而导致程序出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y)  ((x)&gt;(y) ? (x) : (y))</span></span><br></pre></td></tr></table></figure><p>以上的宏定义中，如果x的值大于y，得到x，否则得到y。</p><p><strong>示例（book150.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book150.c，此程序演示带参数的宏</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;MAX is %d\n&quot;</span>,<span class="built_in">MAX</span>(<span class="number">34</span>,<span class="number">59</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行预编译指令gcc -E -o book150.E book150.c，得到book50.E文件，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;book150.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;book150.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;MAX is %d\n&quot;</span>,((<span class="number">34</span>)&gt;(<span class="number">59</span>)?(<span class="number">34</span>):(<span class="number">59</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参的宏和带参的函数相似，但其本质是不同的。使用带参宏时，在预处理时将程序源代码替换到相应的位置，编译时得到完整的目标代码，而不进行函数调用，因此程序执行效率要高些。而函数调用只需要编译一次函数，代码量较少，一般情况下，对于简单的功能，可使用宏替换的形式来使用。</p><p>带参数的宏不容易理解，所以，在实际开发中，我不建议使用带参数的宏。</p><h1 id="四-条件编译"><a class="markdownIt-Anchor" href="#四-条件编译"></a> 四、条件编译</h1><p>条件编译有多种格式，在这里我只介绍最常用的两种格式#ifdef和#ifndef。</p><h2 id="1-ifdef"><a class="markdownIt-Anchor" href="#1-ifdef"></a> 1、#ifdef</h2><p>#ifdef命令的使用格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">  程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其意义是，如果#ifdef后面的标识符已被定义过，则对“程序段1”进行编译；如果没有定义标识符，则编译“程序段2”。一般不使用#else及后面的“程序2”。</p><p><strong>示例（book153.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book153.c，此程序用于演示#ifdef条件编译</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINUX</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> LINUX</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是Linux操作系统。\n&quot;</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未知的操作系统。\n&quot;</span>);</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行预编译指令gcc -E -o book153.E book153.c，得到book153.E文件，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;book153.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;book153.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这是Linux操作系统。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ifndef"><a class="markdownIt-Anchor" href="#2-ifndef"></a> 2、#ifndef</h2><p>而#ifndef的意义与#ifdef相反，其格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 标识符</span></span><br><span class="line">  程序段 <span class="number">1</span> </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  程序段 <span class="number">2</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其意义是，如果未定义标识符，则编译“程序段1”；否则编译“程序段2”</p><p>在实际开发中，程序员用#ifndef来防止头文件被重复包含。</p><p>我们打开/usr/include/stdio.h文件。</p><p>第一条有效行的代码是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H</span></span><br></pre></td></tr></table></figure><p>接下来是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _STDIO_H  1</span></span><br></pre></td></tr></table></figure><p>最后一行是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>程序员自定义的头文件，我们也会这么写，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：_public.h，公共功能函数声明的头文件</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PUBLIC_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把字符串格式的时间转换为整数的时间，函数的声明如下：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strtotime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strtime,<span class="type">time_t</span> *ti)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果头文件被包含多次，就表示头文件中的函数被多次声明，全局变量被多次定义，在以前的C语言编译器中，这是不允许的，编译时会报错，但是，现在的部分编译器比较智能，多次定义全局变量或多次声明函数也不会报错。这些新的特征让我这个老家伙很不适应。</p><h2 id="3-undef"><a class="markdownIt-Anchor" href="#3-undef"></a> 3、#undef</h2><p>#undef取消已定义的标识符。</p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>1）编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><p>2）编写代码测试多次声明同名的函数、多次定义同名的函数、多次声明同名的全局变量、多次声明同名的局部变量。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言时间操作</title>
      <link href="/posts/98a10cf5.html"/>
      <url>/posts/98a10cf5.html</url>
      
        <content type="html"><![CDATA[<p>UNIX操作系统根据计算机产生的年代和应用采用1970年1月1日作为UNIX的纪元时间，1970年1月1日0点作为计算机表示时间的是中间点，将从1970年1月1日开始经过的秒数用一个整数存放，这种高效简洁的时间表示方法被称为“Unix时间纪元”，向左和向右偏移都可以得到更早或者更后的时间。</p><p>在实际开发中，对日期和时间的操作场景非常多，例如程序启动和退出的时间，程序执行任务的时间，数据生成的时间，数据处理的各环节的时间等，无处不在。</p><p>在学习时间之前，请把Linux操作系统的时区设置为中国上海时间。</p><h1 id="一-time_t别名"><a class="markdownIt-Anchor" href="#一-time_t别名"></a> 一、time_t别名</h1><p>在C语言中，用time_t来表示时间数据类型，它是一个long（长整数）类型的别名，在time.h文件中定义，表示一个日历时间，是从1970年1月1日0时0分0秒到现在的秒数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">time_t</span>;  </span><br></pre></td></tr></table></figure><h1 id="二-time库函数"><a class="markdownIt-Anchor" href="#二-time库函数"></a> 二、time库函数</h1><p>time函数的用途是返回一个值，也就是从1970年1月1日0时0分0秒到现在的秒数。</p><p>time函数是C语言标准库中的函数，在time.h文件中声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *t)</span></span>;</span><br></pre></td></tr></table></figure><p>time函数有两种调用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> tnow;</span><br><span class="line">tnow =<span class="built_in">time</span>(<span class="number">0</span>);     <span class="comment">// 将空地址传递给time函数，并将time返回值赋给变量tnow</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">time</span>(&amp;tnow);       <span class="comment">// 将变量tnow的地址作为参数传递给time函数</span></span><br></pre></td></tr></table></figure><p>您可以写代码测试一下这两种方式，效果完全相同。</p><h1 id="三-tm结构体"><a class="markdownIt-Anchor" href="#三-tm结构体"></a> 三、tm结构体</h1><p>time_t只是一个长整型，不符合我们的使用习惯，需要转换成可以方便表示时间的结构体，即tm结构体，tm结构体在time.h中声明，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tm_sec;     <span class="comment">// 秒：取值区间为[0,59] </span></span><br><span class="line">  <span class="type">int</span> tm_min;     <span class="comment">// 分：取值区间为[0,59] </span></span><br><span class="line">  <span class="type">int</span> tm_hour;    <span class="comment">// 时：取值区间为[0,23] </span></span><br><span class="line">  <span class="type">int</span> tm_mday;    <span class="comment">// 日期：一个月中的日期：取值区间为[1,31]</span></span><br><span class="line">  <span class="type">int</span> tm_mon;     <span class="comment">// 月份：（从一月开始，0代表一月），取值区间为[0,11]</span></span><br><span class="line">  <span class="type">int</span> tm_year;    <span class="comment">// 年份：其值等于实际年份减去1900</span></span><br><span class="line">  <span class="type">int</span> tm_wday;    <span class="comment">// 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 </span></span><br><span class="line">  <span class="type">int</span> tm_yday;    <span class="comment">// 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 </span></span><br><span class="line">  <span class="type">int</span> tm_isdst;   <span class="comment">// 夏令时标识符，该字段意义不大，我们不用夏令时。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构定义了年、月、日、时、分、秒、星期、当年中的某一天、夏令时。用这个结构体可以很方便的显示时间。</p><h1 id="四-localtime库函数"><a class="markdownIt-Anchor" href="#四-localtime库函数"></a> 四、localtime库函数</h1><p>localtime函数用于把time_t表示的时间转换为struct tm结构体表示的时间，函数返回struct tm结构体的地址。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> * <span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span> *);</span><br></pre></td></tr></table></figure><p>struct tm结构体包含了时间的各要素，但还不是我们习惯的时间表达方式，我们可以用格式化输出printf、sprintf或fprintf等函数，把struct tm结构体转换为我们想要的结果。</p><p><strong>示例（book128.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book128.c，此程序演示获取操作系统时间</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">time_t</span> tnow;</span><br><span class="line">  tnow=<span class="built_in">time</span>(<span class="number">0</span>);      <span class="comment">// 获取当前时间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;tnow=%lu\n&quot;</span>,tnow);   <span class="comment">// 输出整数表示的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> *sttm;  </span><br><span class="line">  sttm=<span class="built_in">localtime</span>(&amp;tnow);  <span class="comment">// 把整数的时间转换为struct tm结构体的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// yyyy-mm-dd hh24:mi:ss格式输出，此格式用得最多</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%04u-%02u-%02u %02u:%02u:%02u\n&quot;</span>,sttm-&gt;tm_year+<span class="number">1900</span>,sttm-&gt;tm_mon+<span class="number">1</span>,\</span><br><span class="line">          sttm-&gt;tm_mday,sttm-&gt;tm_hour,sttm-&gt;tm_min,sttm-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%04u年%02u月%02u日%02u时%02u分%02u秒\n&quot;</span>,sttm-&gt;tm_year+<span class="number">1900</span>,\</span><br><span class="line">          sttm-&gt;tm_mon+<span class="number">1</span>,sttm-&gt;tm_mday,sttm-&gt;tm_hour,sttm-&gt;tm_min,sttm-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只输出年月日</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%04u-%02u-%02u\n&quot;</span>,sttm-&gt;tm_year+<span class="number">1900</span>,sttm-&gt;tm_mon+<span class="number">1</span>,sttm-&gt;tm_mday); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304150816893.png" alt="在这里插入图片描述" /></p><h1 id="五-mktime库函数"><a class="markdownIt-Anchor" href="#五-mktime库函数"></a> 五、mktime库函数</h1><p>mktime函数的功能与localtime函数相反。</p><p>localtime函数用于把time_t表示的时间转换为struct tm表示的时间。</p><p>mktime 函数用于把struct tm表示的时间转换为time_t表示的时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span></span>;</span><br></pre></td></tr></table></figure><p>函数返回time_t的值。</p><p><strong>示例（book130.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book130.c，此程序演示时间操作的mktime库函数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 2019-12-25 15:05:03整数表示是1577257503</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> sttm;  </span><br><span class="line">  <span class="built_in">memset</span>(&amp;sttm,<span class="number">0</span>,<span class="built_in">sizeof</span>(sttm));</span><br><span class="line"></span><br><span class="line">  sttm.tm_year=<span class="number">2019</span><span class="number">-1900</span>; <span class="comment">// 注意，要减1900</span></span><br><span class="line">  sttm.tm_mon=<span class="number">12</span><span class="number">-1</span>;        <span class="comment">// 注意，要减1</span></span><br><span class="line">  sttm.tm_mday=<span class="number">25</span>;</span><br><span class="line">  sttm.tm_hour=<span class="number">15</span>;</span><br><span class="line">  sttm.tm_min=<span class="number">5</span>;</span><br><span class="line">  sttm.tm_sec=<span class="number">3</span>;</span><br><span class="line">  sttm.tm_isdst = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2019-12-25 15:05:03 is %lu\n&quot;</span>,<span class="built_in">mktime</span>(&amp;sttm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><h1 id="在这里插入图片描述六-程序睡眠"><a class="markdownIt-Anchor" href="#在这里插入图片描述六-程序睡眠"></a> <img src="https://img-blog.csdnimg.cn/20200304150951831.png" alt="在这里插入图片描述" /><br />六、程序睡眠</h1><p>在实际开发中，我们经常需要把程序挂起一段时间，可以使用sleep和usleep两个库函数，需要包含unistd.h头文件中。函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span></span>;</span><br></pre></td></tr></table></figure><p>sleep函数的参数是秒，usleep函数的参数是微秒，1秒=1000000微秒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);           <span class="comment">// 程序睡眠1秒。</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);          <span class="comment">// 程序睡眠10秒。</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);    <span class="comment">// 程序睡眠十分之一秒。</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">1000000</span>);   <span class="comment">// 程序睡眠一秒。</span></span><br></pre></td></tr></table></figure><p>程序员不关心sleep和usleep函数的返回值。</p><h1 id="七-精确到微秒的计时器"><a class="markdownIt-Anchor" href="#七-精确到微秒的计时器"></a> 七、精确到微秒的计时器</h1><h2 id="1-精确到微秒的timeval结构体"><a class="markdownIt-Anchor" href="#1-精确到微秒的timeval结构体"></a> 1、精确到微秒的timeval结构体</h2><p>timeval结构体在sys/time.h文件中定义，声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span>  tv_sec;  <span class="comment">// 1970年1月1日到现在的秒。</span></span><br><span class="line">  <span class="type">long</span>  tv_usec; <span class="comment">// 当前秒的微妙，即百万分之一秒。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-时区timezone-结构体"><a class="markdownIt-Anchor" href="#2-时区timezone-结构体"></a> 2、时区timezone 结构体</h2><p>timezone 结构体在sys/time.h文件中定义，声明为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timezone</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tz_minuteswest;  <span class="comment">// 和UTC（格林威治时间）差了多少分钟。</span></span><br><span class="line">  <span class="type">int</span> tz_dsttime;      <span class="comment">// type of DST correction，修正参数据，忽略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-gettimeofday库函数"><a class="markdownIt-Anchor" href="#3-gettimeofday库函数"></a> 3、gettimeofday库函数</h2><p>gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数，可以用于程序的计时。调用gettimeofday函数需要包含sys/time.h头文件。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span>  timeval *tv, <span class="keyword">struct</span>  timezone *tz )</span></span></span><br></pre></td></tr></table></figure><p>当前的时间存放在tv 结构体中，当地时区的信息则放到tz所指的结构体中，tz可以为空。</p><p>函数执行成功后返回0，失败后返回-1。</p><p>在使用gettimeofday()函数时，第二个参数一般都为空，我们一般都只是为了获得当前时间，不关心时区的信息。</p><p><strong>示例（book132.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book132.c，此程序演示精确到微秒的计时器。 </span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span>   <span class="comment">// 注意，不是time.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> begin,end;  <span class="comment">// 定义用于存放开始和结束的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;begin,<span class="number">0</span>);    <span class="comment">// 计时器开始</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;begin time(0)=%d,tv_sec=%d,tv_usec=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),begin.tv_sec,begin.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">usleep</span>(<span class="number">100000</span>);     <span class="comment">// 程序睡眠十分之一秒。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;end,<span class="number">0</span>);      <span class="comment">// 计时器结束</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;end   time(0)=%d,tv_sec=%d,tv_usec=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),end.tv_sec,end.tv_usec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;计时过去了%d微秒。\n&quot;</span>,\</span><br><span class="line">         (end.tv_sec-begin.tv_sec)*<span class="number">1000000</span>+(end.tv_usec-begin.tv_usec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304151937932.png" alt="在这里插入图片描述" /></p><p>各位，book132.c程序采用usleep睡眠十分之一秒，但是计时器显示的实际时间大于十分之一秒，为何？原因很简单，因为程序执行需要时间，虽然这个时间很短，在千分之一秒内，那也是需要时间。</p><p>还有一个要注意的问题，time.h 是ISO C99 标准日期时间头文件。sys/time.h 是Linux系统的日期时间头文件，也就是说，timeval、timezone结构体和gettimeofday函数在windows平台中不能使用，真是麻烦。</p><h1 id="八-应用经验"><a class="markdownIt-Anchor" href="#八-应用经验"></a> 八、应用经验</h1><p>在实际开发中，除了当前的时间，还经常需要一个偏移量的时间，例如获取十分钟之后的时间，方法是采用time函数得到一个整数后，再加上10*60秒，再用localtime函数转换为结构体。</p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>继续丰富您的函数库。</p><p>1）编写一个通用函数，把整数的时间转换为字符串格式的时间，格式如：“2019-02-08<br />12:05:08”，如果转换成功函数返回0，失败返回-1，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">timetostr</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> ti,<span class="type">char</span> *strtime)</span></span>;</span><br></pre></td></tr></table></figure><p>2）编写一个通用函数，把字符串格式的时间转换为整数的时间，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strtotime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strtime,<span class="type">time_t</span> *ti)</span></span>;</span><br></pre></td></tr></table></figure><p>3）编写一个通用函数，获取操作系统的时间，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LocalTime</span><span class="params">(<span class="type">char</span> *out_stime,<span class="type">const</span> <span class="type">char</span> *in_fmt,<span class="type">const</span> <span class="type">int</span> in_interval)</span></span>;</span><br></pre></td></tr></table></figure><p>out_stime是输出结果，格式由fmt决定。</p><p>in_interval是偏移常量，单位是秒。</p><p>in_fmt指定了out_stime的格式，取值如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常用的时间格式</span></span><br><span class="line"><span class="comment">yyyy-mm-dd hh24:mi:ss</span></span><br><span class="line"><span class="comment">yyyymmddhh24miss</span></span><br><span class="line"><span class="comment">yyyy-mm-dd</span></span><br><span class="line"><span class="comment">yyyymmdd</span></span><br><span class="line"><span class="comment">hh24:mi:ss</span></span><br><span class="line"><span class="comment">hh24miss</span></span><br><span class="line"><span class="comment">hh24:mi</span></span><br><span class="line"><span class="comment">hh24mi</span></span><br><span class="line"><span class="comment">hh24</span></span><br><span class="line"><span class="comment">mi</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strLocalTime[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取当前的时间，以yyyy-mm-dd hh24:mi:ss格式返回</span></span><br><span class="line"> <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line"> <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取比现在晚10分钟的时间，以yyyy-mm-dd hh24:mi:ss格式返回</span></span><br><span class="line"> <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line"> <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>,<span class="number">10</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取当前的时间，以hh24:mi:ss格式返回</span></span><br><span class="line"> <span class="built_in">memset</span>(strLocalTime,<span class="number">0</span>,<span class="built_in">sizeof</span>(strLocalTime));</span><br><span class="line"> <span class="built_in">LocalTime</span>(strLocalTime,<span class="string">&quot;hh24:mi:ss&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言目录操作</title>
      <link href="/posts/da2face3.html"/>
      <url>/posts/da2face3.html</url>
      
        <content type="html"><![CDATA[<p>目录的操作不论是在嵌入式还是应用软件编程都是必不可少的，不同的开发语言可能略有不同，本章节主要是讨论在Linux系统下目录的一系列操作，以我的个人经验，创建目录和列出目录中的文件这两个功能用得最多。</p><h1 id="一-获取当前工作目录"><a class="markdownIt-Anchor" href="#一-获取当前工作目录"></a> 一、获取当前工作目录</h1><p>在shell中我们可以直接输入命令pwd来显示当前的工作目录，在C程序中调用getcwd函数可以获取当前的工作目录。函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">getcwd</span><span class="params">(<span class="type">char</span> * buf,<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>getcwd函数把当前工作目录存入buf中，如果目录名超出了参数size长度，函数返回NULL，如果成功，返回buf。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strpwd[<span class="number">301</span>];</span><br><span class="line"><span class="built_in">memset</span>(strpwd,<span class="number">0</span>,<span class="built_in">sizeof</span>(strpwd))</span><br><span class="line"><span class="built_in">getcwd</span>(strpwd,<span class="number">300</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n&quot;</span>,strpwd);</span><br></pre></td></tr></table></figure><h1 id="二-切换工作目录"><a class="markdownIt-Anchor" href="#二-切换工作目录"></a> 二、切换工作目录</h1><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure><p>就像我们在shell中使用cd命令切换目录一样，在C程序中使用chdir函数来改变工作目录。</p><p>返回值：0-切换成功；非0-失败。</p><h1 id="三-目录的创建和删除"><a class="markdownIt-Anchor" href="#三-目录的创建和删除"></a> 三、目录的创建和删除</h1><p>在shell中可以通过mkdir/rmdir命令来创建/删除目录，C程序中用mkdir/rmdir函数来创建/删除目录。</p><p>创建目录函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>mode的含义将按open系统调用的O_CREAT选项中的有关定义设置，当然，它还要服从umask的设置况，是不是看不明白？那先固定填0755，注意，0不要省略哦，它表示八进制。  例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>(<span class="string">&quot;/tmp/aaa&quot;</span>,<span class="number">0755</span>);   <span class="comment">// 创建/tmp/aaa目录</span></span><br></pre></td></tr></table></figure><p>删除目录函数的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="四-获取目录中的文件列表"><a class="markdownIt-Anchor" href="#四-获取目录中的文件列表"></a> 四、获取目录中的文件列表</h1><p>在实际开发中，文件是存放在目录中的，在处理文件之前，必须先知道目录中有哪些文件，所以要获取目录中的文件列表。涉及到的库函数如下：</p><h2 id="1-包含头文件"><a class="markdownIt-Anchor" href="#1-包含头文件"></a> 1、包含头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="2-相关的库函数"><a class="markdownIt-Anchor" href="#2-相关的库函数"></a> 2、相关的库函数</h2><p>打开目录的函数opendir的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><p>读取目录的函数readdir的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> *<span class="built_in">readdir</span>(DIR *dirp);</span><br></pre></td></tr></table></figure><p>关闭目录的函数closedir的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-数据结构"><a class="markdownIt-Anchor" href="#3-数据结构"></a> 3、数据结构</h2><p>1）目录指针DIR</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *目录指针名;</span><br></pre></td></tr></table></figure><p>2）struct dirent结构体</p><p>每调用一次readdir函数会返回一个struct dirent的地址，存放了本次读取到的内容，它的原理与fgets函数读取文件相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">long</span> d_ino;                    <span class="comment">// inode number 索引节点号</span></span><br><span class="line">   <span class="type">off_t</span> d_off;                   <span class="comment">// offset to this dirent 在目录文件中的偏移 </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> d_reclen;     <span class="comment">// length of this d_name 文件名长 </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> d_type;         <span class="comment">// the type of d_name 文件类型</span></span><br><span class="line">   <span class="type">char</span> d_name [NAME_MAX+<span class="number">1</span>];    <span class="comment">// file name文件名，最长255字符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们只需要关注结构体的d_type和d_name成员，其它的不必关心。</p><p>d_name文件名或目录名。</p><p>d_type描述了文件的类型，有多种取值，最重要的是8和4，8-常规文件（A regular file）；4-目录（A directory），其它的暂时不关心。</p><h2 id="4-读取目录"><a class="markdownIt-Anchor" href="#4-读取目录"></a> 4、读取目录</h2><p><strong>示例（book123.cpp）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book123.c，此程序用于演示读取目录下的文件名信息</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)  &#123; <span class="built_in">printf</span>(<span class="string">&quot;请指定目录名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  DIR *dir;   <span class="comment">// 定义目录指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开/tmp目录</span></span><br><span class="line">  <span class="keyword">if</span> ( (dir=<span class="built_in">opendir</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于存放从目录中读取到的文件和目录信息</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> *stdinfo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 读取一条记录并显示到屏幕</span></span><br><span class="line">    <span class="keyword">if</span> ((stdinfo=<span class="built_in">readdir</span>(dir)) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name=%s,type=%d\n&quot;</span>,stdinfo-&gt;d_name,stdinfo-&gt;d_type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">closedir</span>(dir);   <span class="comment">// 关闭目录指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304144747256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="五-应用经验"><a class="markdownIt-Anchor" href="#五-应用经验"></a> 五、应用经验</h1><p>在实际开发中，对目录的操作并不会像book123.c那样简单。</p><p>实际需求是这样的，文件存放在某目录中，该目录下还会有多级子目录，程序员想要的是列出该目录及其子目录下全部的文件名。</p><p>例如存在/home/wucz/tmp目录，其子目录结构和文件如下：</p><p><img src="https://img-blog.csdnimg.cn/20200304144802249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>示例（book124.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book124.c，此程序用于演示读取目录及其子目录下全部的文件信息</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录及子目录下的文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strpathname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)  &#123; <span class="built_in">printf</span>(<span class="string">&quot;请指定目录名。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列出目录及子目录下的文件</span></span><br><span class="line">  <span class="built_in">ReadDir</span>(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录及子目录下的文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strpathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DIR *dir;   <span class="comment">// 定义目录指针</span></span><br><span class="line">  <span class="type">char</span> strchdpath[<span class="number">256</span>];  <span class="comment">// 子目录的全路径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (dir=<span class="built_in">opendir</span>(strpathname)) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 打开目录</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> *stdinfo; <span class="comment">// 用于存放从目录读取到的文件和目录信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((stdinfo=<span class="built_in">readdir</span>(dir)) == <span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">// 读取一记录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(stdinfo-&gt;d_name,<span class="string">&quot;.&quot;</span>,<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">continue</span>;  <span class="comment">// 以.开始的文件不读</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stdinfo-&gt;d_type==<span class="number">8</span>)    <span class="comment">// 如果是文件，显示出来</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;name=%s/%s\n&quot;</span>,strpathname,stdinfo-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stdinfo-&gt;d_type==<span class="number">4</span>)   <span class="comment">// 如果是目录，再调用一次ReadDir</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(strchdpath,<span class="string">&quot;%s/%s&quot;</span>,strpathname,stdinfo-&gt;d_name);</span><br><span class="line">      <span class="built_in">ReadDir</span>(strchdpath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">closedir</span>(dir);   <span class="comment">// 关闭目录指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304144840881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>这才是程序员想要的结果。</p><p>在某些C语言的教材里，有递归函数这个概念，在我的教程里，没有讲这个概念，实际上，book124.c的ReadDir函数就是一个递归函数，在ReadDir函数中调用了自身。</p><h1 id="六-课后作业"><a class="markdownIt-Anchor" href="#六-课后作业"></a> 六、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/posts/1617bb54.html"/>
      <url>/posts/1617bb54.html</url>
      
        <content type="html"><![CDATA[<p>对计算机来说，一切皆数据，超女的信息是数据、C语言源代码文件是数据、编译后的可执行程序也是数据，数据的存放方式有很多种，如内存、文件、数据库等，文件是极其重要的一种。</p><p>根据文件中数据组织形式的不同，可以把文件分为文本文件和二进制文件，C语言源代码是文本文件，编译后的可执行程序是二进制文件。</p><h1 id="一-文本数据和二进制"><a class="markdownIt-Anchor" href="#一-文本数据和二进制"></a> 一、文本数据和二进制</h1><h2 id="1-文本数据"><a class="markdownIt-Anchor" href="#1-文本数据"></a> 1、文本数据</h2><p>文本数据由字符串组成，存放了每个字符的 ASCII码值，每个字符占一个字节，每个字节存放一个字符。</p><p>例如数字 123，如果用文本格式存放，数据内容是’1’、‘2’、'3’三个字符，占三个字节，如下表所示。</p><table><thead><tr><th><strong>字符</strong></th><th><strong>‘1’</strong></th><th><strong>‘2’</strong></th><th><strong>‘3’</strong></th></tr></thead><tbody><tr><td><strong>ASCII（十进制）</strong></td><td>49</td><td>50</td><td>51</td></tr><tr><td><strong>ASCII（二进制）</strong></td><td>00110001</td><td>00110010</td><td>00110011</td></tr></tbody></table><h2 id="2-二进制数据"><a class="markdownIt-Anchor" href="#2-二进制数据"></a> 2、二进制数据</h2><p>二进制数据是字节序列，数字123的二进制表示是01111011，如果用二进制格式形式存储，字符、短整型、短整型、长整型都可以存储123，存储方式分别如下：</p><p>1）字符型一个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01111011</span></span><br></pre></td></tr></table></figure><p>2）短整型2个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">01111011</span></span><br></pre></td></tr></table></figure><p>3）整型4个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01111011</span></span><br></pre></td></tr></table></figure><p>4）长整型8个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01111011</span></span><br></pre></td></tr></table></figure><h2 id="3-文本文件和二进制文件"><a class="markdownIt-Anchor" href="#3-文本文件和二进制文件"></a> 3、文本文件和二进制文件</h2><p>按文本格式存放数据的文件称为文本文件或ASCII文件，文件可以用vi和记事本打开，看到的都是ASCII字符。</p><p>按二进制格式存放数据的文件称为二进制文件，如果用vi打开二进制文件，看到的是乱码，没有意义。</p><h1 id="二-打开文件"><a class="markdownIt-Anchor" href="#二-打开文件"></a> 二、打开文件</h1><p>C 语言对文件进行操作必须先“打开”文件，操作（读和写）完成后，再“关闭”文件。</p><h2 id="1-文件指针"><a class="markdownIt-Anchor" href="#1-文件指针"></a> 1、文件指针</h2><p>打开文件的时候，C语言为打开的文件分配一个文件信息区，该信息区中包含文件描述信息、缓冲区位置、缓冲区大小、文件读写到的位置等基本信息，这些信息保存在一个结构体类型变量中struct_IO_FILE），这个结构体有一个别名FILE（typedef struct _IO_FILE FILE)，FILE结构体和对文件操作的库函数在 stdio.h 头文件中声明的。</p><p>打开文件的时候，调用fopen函数时会动态分配一个FILE结构体，并把FILE结构体的地址作为函数的返回值，程序中用FILE结构体指针存放这个地址。调用关闭文件的函数fclose时候，除了关闭文件，还会释放文件指针占用的内存空间。</p><p>FILE结构体指针习惯称为文件指针。</p><h2 id="2-打开文件"><a class="markdownIt-Anchor" href="#2-打开文件"></a> 2、打开文件</h2><p>我们可以使用 C语言提供的库函数fopen来创建一个新的文件或者打开一个已存的文件，调用fopen函数成功后，返回一个文件指针（ FILE *），函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode )</span></span>;</span><br></pre></td></tr></table></figure><p>参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的当前目录。实际开发中，采用文件的全路径。</p><p>参数mode也是字符串，表示打开文件的方式（模式），打开方式可以是下列值中的一个。</p><table><thead><tr><th><strong>方式</strong></th><th><strong>含 义</strong></th><th><strong>说 明</strong></th></tr></thead><tbody><tr><td><strong>r</strong></td><td>只读</td><td>文件必须存在，否则打开失败。</td></tr><tr><td><strong>w</strong></td><td>只写</td><td>如果文件存在，则清除原文件内容；如果文件不存在，则新建文件。</td></tr><tr><td><strong>a</strong></td><td>追加只写</td><td>如果文件存在，则打开文件，如果文件不存在，则新建文件。</td></tr><tr><td><strong>r+</strong></td><td>读写</td><td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。</td></tr><tr><td><strong>w+</strong></td><td>读写</td><td>在只写w的方式上增加可读的功能。</td></tr><tr><td><strong>a+</strong></td><td>读写</td><td>在追加只写a的方式上增加可读的功能。</td></tr></tbody></table><p>英文单词：read简写r、write简写w、append简写a。</p><p>注意了，不同教材中对文件打开的方式有不同的说法。</p><p>有的说打开文本文件的方式要用&quot;rt&quot;、“wt”、“at”、“rt+”、“wt+”、“at+”，&quot;t&quot;是text的简写，&quot;t&quot;可以省略不写。</p><p>有的说打开二进制文件的方式要用&quot;rb&quot;、“wb”、“ab”、“rb+”、“wb+”、“ab+”，&quot;b&quot;是binary的简写。</p><p>准确的说，在Linux平台下，打开文本文件和二进制文件的方式没有区别。</p><p>在windows平台下，如果以“文本”方式打开文件，当读取文件的时候，系统会将所有的&quot;/r/n&quot;转换成&quot;/n&quot;；当写入文件的时候，系统会将&quot;/n&quot;转换成&quot;/r/n&quot;写入， 如果以&quot;二进制&quot;方式打开文件，则读和写都不会进行这样的转换，真是罗嗦。</p><h2 id="3-关闭文件"><a class="markdownIt-Anchor" href="#3-关闭文件"></a> 3、关闭文件</h2><p>fclose库函数用于关闭文件，函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>fp为fopen函数返回的文件指针。</p><p><strong>示例（book108.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book108.c，此程序用于演示文件打开和关闭</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/home/wucz/demo/book1.c</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/home/wucz/demo/book1.c&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件/home/wucz/demo/book.c失败。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 上代码等同于以下代码</span></span><br><span class="line"><span class="comment">  fp=fopen(&quot;/oracle/c/book1.c&quot;,&quot;r&quot;);</span></span><br><span class="line"><span class="comment">  if (fp==0)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;打开文件/home/wucz/demo/book.c失败。\n&quot;); return -1;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/* 不信用这个代码来测试</span></span><br><span class="line"><span class="comment">  printf(&quot;fp=%p\n&quot;,(fp=fopen(&quot;/home/wucz/demo/book1.c&quot;,&quot;r&quot;)));</span></span><br><span class="line"><span class="comment">  printf(&quot;fp=%p\n&quot;,fp);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对初学者来说，以下代码可能难以理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/home/wucz/demo/book1.c&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>其实<code>(fp=fopen(&quot;/home/wucz/demo/book1.c&quot;,&quot;r&quot;))</code>表达式的值就是fp，我在讲if分支语句的时候就讨论过了，估计大家都没把它放在心上，我们可以用代码来测试它。</p><p>如果还不理解，就这么抄吧，抄多了就熟了。</p><h2 id="4-注意事项"><a class="markdownIt-Anchor" href="#4-注意事项"></a> 4、注意事项</h2><p>1）调用fopen打开文件的时候，一定要判断返回值，如果文件不存在、或没有权限、或磁盘空间满了，都有可能造成打开文件失败。</p><p>2）文件指针是调用fopen的时候，系统动态分配了内存空间，函数返回或程序退出之前，必须用fclose关闭文件指针，释放内存，否则后果严重。</p><p>3）如果文件指针是空的，用fclose关闭它相当于操作空指针，后果严重。</p><h1 id="三-文本文件的读写"><a class="markdownIt-Anchor" href="#三-文本文件的读写"></a> 三、文本文件的读写</h1><p>在实际开发中，文本文件以行的形式存放字符串，如C程序的源代码，一段文字等，所以一般是按行写入和读取数据。</p><h2 id="1-向文件中写入数据"><a class="markdownIt-Anchor" href="#1-向文件中写入数据"></a> 1、向文件中写入数据</h2><p>C语言向文件中写入数据库函数有fputc、fputs、fprintf，在实际开发中，fputc和fputs没什么用，只介绍fprintf就可以了。fprintf函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>fprintf函数的用法与printf相同，只是多了第一个参数文件指针，表示把数据输出到文件。</p><p>程序员不必关心fprintf函数的返回值。</p><p><strong>示例（book111.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book111.c，此程序用于演示向文件中写入文本数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>   ii=<span class="number">0</span>;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只写的方式打开文件/tmp/test1.txt</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.txt) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">3</span>;ii++) <span class="comment">// 往文件中写入3行</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;这是第%d条数数据。\n&quot;</span>,ii+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译book111.c程序并执行，采用cat命令查看/tmp/test1.txt的内容，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200304141004958.png" alt="在这里插入图片描述" /></p><p>可以看到/tmp/test1.txt中有3行记录，程序book111不管执行多少次，文件/tmp/test1.txt的记录都是3行记录，因为文件打开的方式是&quot;w&quot;，每次打开文件的时候都会清空原文件中的记录。</p><p>大家可以试一下把文件打开方式设置为&quot;a&quot;，看看程序执行的效果。</p><h2 id="2-从文件中读取数据"><a class="markdownIt-Anchor" href="#2-从文件中读取数据"></a> 2、从文件中读取数据</h2><p>C语言从文件中读取数据的库函数有fgetc、fgets、fscanf，在实际开发中，fgetc和fscanf没什么用，只介绍fgets就可以了。fgets函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>fgets的功能是从文件中读取一行。</p><p>参数buf是一个字符串，用于保存从文件中读到的数据。</p><p>参数size是打算读取内容的长度。</p><p>参数fp是待读取文件的文件指针。</p><p>如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。</p><p>调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</p><p><strong>示例（book113.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book113.c，此程序用于演示从文本文件中读取数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp=<span class="number">0</span>;        <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line">  <span class="type">char</span> strbuf[<span class="number">301</span>];  <span class="comment">// 存放从文件中读取到的一行的内容</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/tmp/test1.txt</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.txt) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐行读取文件的内容，输出到屏幕</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strbuf,<span class="number">0</span>,<span class="built_in">sizeof</span>(strbuf));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fgets</span>(strbuf,<span class="number">301</span>,fp)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,strbuf);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304141136317.png" alt="在这里插入图片描述" /></p><p>需要重点说明的是，在读取到 size-1个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。</p><p>不管 size 的值多大，fgets函只读取一行数据，不能跨行。</p><p>在实际开发中，可以将 size 的值设置地足够大，确保每次都能读取到一行完整的数据。</p><h1 id="四-二进制文件的读写"><a class="markdownIt-Anchor" href="#四-二进制文件的读写"></a> 四、二进制文件的读写</h1><p>二进制文件没有行的概念，没有字符串的概念。</p><p>我们把内存中的数据结构直接写入二进制文件，读取的时候，也是从文件中读取数据结构的大小一块数据，直接保存到数据结构中。注意，这里所说的数据结构不只是结构体，是任意数据类型。</p><h2 id="1-向文件中写入数据-2"><a class="markdownIt-Anchor" href="#1-向文件中写入数据-2"></a> 1、向文件中写入数据</h2><p>fwrite函数用来向文件中写入数据块，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>参数的说明：</p><p>ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。</p><p>size：固定填1。</p><p>nmemb：表示打算写入数据的字节数。</p><p>fp：表示文件指针。</p><p>函数的返回值是本次成功写入数据的字节数，一般情况下，程序员不必关心fwrite函数的返回值。</p><p><strong>示例（book115.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book115.c，此程序用于演示向文件中写入二进制数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;  <span class="comment">// 定义超女数据结构变量</span></span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只写的方式打开文件/tmp/test1.dat</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.dat&quot;</span>,<span class="string">&quot;w&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.dat) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;西施&quot;</span>); stgirl.age=<span class="number">18</span>; stgirl.height=<span class="number">170</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.sc,<span class="string">&quot;火辣&quot;</span>); <span class="built_in">strcpy</span>(stgirl.yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line">  <span class="built_in">fwrite</span>(&amp;stgirl,<span class="number">1</span>,<span class="built_in">sizeof</span>(stgirl),fp);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.name,<span class="string">&quot;芙蓉妹妹&quot;</span>); stgirl.age=<span class="number">38</span>; stgirl.height=<span class="number">166</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(stgirl.sc,<span class="string">&quot;膘肥体壮&quot;</span>); <span class="built_in">strcpy</span>(stgirl.yz,<span class="string">&quot;让人终生不忘&quot;</span>);</span><br><span class="line">  <span class="built_in">fwrite</span>(&amp;stgirl,<span class="number">1</span>,<span class="built_in">sizeof</span>(stgirl),fp);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序，得到数据文件/tmp/test.dat，用vi命令打开文件，显示如下：</p><p><img src="https://img-blog.csdnimg.cn/2020030414125268.png" alt="在这里插入图片描述" /></p><p>可以看到很多乱码，其实并不是文件的内容乱，而是vi无法识别文件的格式，把内容当成ASCII码显示，如果内容刚好是ASCII码，就能正确显示，如果不是ASCII码（如年龄和身高是整数），就无法正常显示了。</p><h2 id="2-从文件中读取数据-2"><a class="markdownIt-Anchor" href="#2-从文件中读取数据-2"></a> 2、从文件中读取数据</h2><p>fread函数用来从文件中读取数据块，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。</p><p>size：固定填1。</p><p>nmemb：表示打算读取的数据的字节数。</p><p>fp：表示文件指针。</p><p>调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</p><p><strong>示例（book117.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book117.c，此程序用于演示从文件中读取二进制数据</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;  <span class="comment">// 定义超女数据结构变量</span></span><br><span class="line">  FILE *fp=<span class="number">0</span>;     <span class="comment">// 定义文件指针变量fp</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以只读的方式打开文件/tmp/test1.dat</span></span><br><span class="line">  <span class="keyword">if</span> ( (fp=<span class="built_in">fopen</span>(<span class="string">&quot;/tmp/test1.dat&quot;</span>,<span class="string">&quot;rb&quot;</span>)) == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen(/tmp/test1.dat) failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 从文件中读取数据，存入超女数据结构变量中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fread</span>(&amp;stgirl,<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl),fp)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 显示超女数据结构变量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\n&quot;</span>,\</span><br><span class="line">          stgirl.name,stgirl.age,stgirl.height,stgirl.sc,stgirl.yz);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304141445760.png" alt="在这里插入图片描述" /></p><h2 id="3-注意事项"><a class="markdownIt-Anchor" href="#3-注意事项"></a> 3、注意事项</h2><p>1）我对fread和fwrite函数的size和nmemb以及它们的返回值的解释是不准确的，这么做的原因是为了方便大家的学习，正确的解释会把大家搞晕，等您功力提升之候，我们再讨论它的准确含义。</p><p>2）fwrite和fread函数也可以写入和读取文本文件，但是没有换行的概念，不管是换行符或其它的特殊字符，无区别对待。</p><p>3）一般来说，二进制文件有约定的数据格式，程序必须按约定的格式写入/读取数据，book115.c写入的是超女结构体，book117.c就要用超女结构体来存放读取到的数据。这道理就像图片查看软件无法打开音频文件，音频播放软件也无法打开图片文件，因为音频文件和图片文件的格式不同。</p><h1 id="五-文件定位"><a class="markdownIt-Anchor" href="#五-文件定位"></a> 五、文件定位</h1><p>在文件内部有一个位置指针，用来指向当前读写的位置。在文件打开时，如果打开方式是r和w，位置指针指向文件的第一个字节，如果打开方式是a，位置指针指向文件的尾部。每当从文件里读n个字节或文件里写入n个字节之后位置指针也会向后移动n个字节。</p><p>文件位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，不是变量的地址。文件每读写一次，位置指针就会移动一次，它不需要您在程序中定义和赋值，而是由系统自动设置，对程序员来说是隐藏的。</p><p>在实际开发中，偶尔需要移动位置指针，实现对指定位置数据的读写。我们把移动位置指针称为文件定位。</p><p>C语言提供了ftell、rewind和fseek三个库函数来实现文件定位功能。</p><h2 id="1-ftell函数"><a class="markdownIt-Anchor" href="#1-ftell函数"></a> 1、ftell函数</h2><p>ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-rewind函数"><a class="markdownIt-Anchor" href="#2-rewind函数"></a> 2、rewind函数</h2><p>rewind函数用来将位置指针移动到文件开头，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewind</span> <span class="params">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-fseek函数"><a class="markdownIt-Anchor" href="#3-fseek函数"></a> 3、fseek函数</h2><p>fseek() 用来将位置指针移动到任意位置，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span> <span class="params">( FILE *fp, <span class="type">long</span> offset, <span class="type">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>1）fp 为文件指针，也就是被移动的文件。</p><p>2）offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。</p><p>3）origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">100</span>,<span class="number">0</span>);     <span class="comment">// 从文件的开始位置计算，向后移动100字节。</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">100</span>,<span class="number">1</span>);     <span class="comment">// 从文件的当前位置计算，向后移动100字节。</span></span><br><span class="line"><span class="built_in">fseek</span>(fp,<span class="number">-100</span>,<span class="number">2</span>);    <span class="comment">// 从文件的尾部位置计算，向前移动100字节。</span></span><br></pre></td></tr></table></figure><h2 id="4-注意事项-2"><a class="markdownIt-Anchor" href="#4-注意事项-2"></a> 4、注意事项</h2><p>当offset是向文件尾方向偏移的时候，无论偏移量是否超出文件尾，fseek都是返回0，当偏移量没有超出文件尾的时候，文件指针式指向正常的偏移地址的，当偏移量超出文件尾的时候，文件指针是指向文件尾的，不会返回偏移出错-1值。</p><p>当offset是向文件头方向偏移的时候，如果offset没有超出文件头，是正常偏移，文件指针指向正确的偏移地址，fseek返回值为0，当offset超出文件头时，fseek返回出错-1值，文件指针还是处于原来的位置。</p><h1 id="六-文件缓冲区"><a class="markdownIt-Anchor" href="#六-文件缓冲区"></a> 六、文件缓冲区</h1><p>在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。</p><p>在实际开发中，如果程序员想把缓冲区的数据立即写入文件，可以调用fflush库函数，它的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的参数只有一个，即文件指针，返回0成功，其它失败，程序员一般不关心它的返回值。</p><h1 id="七-标准输入-标准输出和标准错误"><a class="markdownIt-Anchor" href="#七-标准输入-标准输出和标准错误"></a> 七、标准输入、标准输出和标准错误</h1><p>Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(stdout,<span class="string">&quot;Hello world.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这几个文件指针没什么用，让大家了解一下就行。在实际开发中，我们一般会关闭这几个文件指针。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>在实际开发中，文件操作极其重要，本章节的课后作业一定要认真完成。</p><p>1）编写示例程序，从界面上输入五名超女的数据，存放在struct st_girl结构体数组中，然后把结构体数组以二进制的方式写入文件。</p><p>2）编写示例程序，把上一题写入的数据从二进制文件中读取出来，存入struct st_girl结构体中，然后在界面上显示出来。</p><p>3）编写示例程序，从界面上输入五名超女的数据，存放在struct st_girl结构体数组中，然后把结构体数组以xml字符串的方式写入文本文件。文件内容的格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;<span class="number">20</span>&lt;/age&gt;&lt;height&gt;<span class="number">166</span>&lt;/height&gt;&lt;sc&gt;一般&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;</span><br><span class="line">&lt;name&gt;王昭君&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;height&gt;<span class="number">160</span>&lt;/height&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;一般&lt;/yz&gt;</span><br><span class="line">&lt;name&gt;杨玉环&lt;/name&gt;&lt;age&gt;<span class="number">22</span>&lt;/age&gt;&lt;height&gt;<span class="number">177</span>&lt;/height&gt;&lt;sc&gt;一般&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;</span><br><span class="line">&lt;name&gt;陈圆圆&lt;/name&gt;&lt;age&gt;<span class="number">26</span>&lt;/age&gt;&lt;height&gt;<span class="number">159</span>&lt;/height&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;不行&lt;/yz&gt;</span><br></pre></td></tr></table></figure><p>4）编写示例程序，把上一题写入的数据从文本文件中读取出来，并解析xml，存入struct st_girl结构体中，然后在界面上显示出来。</p><p>5）编写示例程序，实现文件复制的功能，文本文件用fget和fprintf读写？二进制文件用fread和fwrite读写？用fread和fwrite读写文本文件是什么效果？</p><p>6）编写示例程序，测试文件定位函数ftell、rewind和fseek的使用。</p><p>7）编写示例程序，测试文件缓冲函数fflush的使用。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言动态内存管理</title>
      <link href="/posts/9f069264.html"/>
      <url>/posts/9f069264.html</url>
      
        <content type="html"><![CDATA[<p>在C语言中，编写程序的时候不能确定内存的大小，希望程序在运行的过程中根据数据量的大小动态的分配内存。动态内存管理，就是指在程序运行过程中动态的申请和释放内存空间。</p><p>C语言允许程序动态管理内存，需要时随时开辟，不需要时随时释放。内存的动态管理是通过调用库函数来实现的，主要有malloc和free函数。</p><h1 id="一-相关的库函数"><a class="markdownIt-Anchor" href="#一-相关的库函数"></a> 一、相关的库函数</h1><h2 id="1-malloc-函数"><a class="markdownIt-Anchor" href="#1-malloc-函数"></a> 1、malloc 函数</h2><p>函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>；</span></span><br></pre></td></tr></table></figure><p>malloc的作用是向系统申请一块大小为size的连续内存空间，如果申请失败，函数返回0，如果申请成功，返回成功分配内存块的起始地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">100</span>)； <span class="comment">// 申请 100 个字节的临时分配域，返回值为其第一个字节的地址</span></span><br></pre></td></tr></table></figure><p>malloc的返回值的地址的基类型为void，即不指向任何类型的数据，只提供一个地址，程序中需要定义一个指针来指向动态分配的内存地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><h2 id="2-free-函数"><a class="markdownIt-Anchor" href="#2-free-函数"></a> 2、free 函数</h2><p>函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *p)</span></span>;</span><br></pre></td></tr></table></figure><p>free的作用是释放指针p指向的动态内存空间，p是调用malloc函数时返回的地址，free函数无返回值。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);     <span class="comment">// 释放指针变量pi指向的已分配的动态空间</span></span><br></pre></td></tr></table></figure><p><strong>示例（book107.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book107.c，此程序用于演示C程序动态内存管理。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>  <span class="comment">// 超女结构体</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    *pi=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">// 分配int类型大小的内存</span></span><br><span class="line">  <span class="type">long</span>   *pl=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>));   <span class="comment">// 分配long类型大小的内存</span></span><br><span class="line">  <span class="type">double</span> *pd=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>)); <span class="comment">// 分配double类型大小的内存</span></span><br><span class="line">  <span class="type">char</span>   *pc=<span class="built_in">malloc</span>(<span class="number">101</span>);            <span class="comment">// 分配101字节的内存，可存放100个字符的字符串</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl)); <span class="comment">// 分配struct st_girl结构体大小的内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码是像普通指针和变量一样使用动态分配的内存</span></span><br><span class="line">  *pi=<span class="number">10</span>;     <span class="built_in">printf</span>(<span class="string">&quot;*pi=%d\n&quot;</span>,*pi);</span><br><span class="line">  *pl=<span class="number">20</span>;     <span class="built_in">printf</span>(<span class="string">&quot;*pl=%d\n&quot;</span>,*pl);</span><br><span class="line">  *pd=<span class="number">10.5</span>;   <span class="built_in">printf</span>(<span class="string">&quot;*pd=%.1f\n&quot;</span>,*pd);</span><br><span class="line">  <span class="built_in">strcpy</span>(pc,<span class="string">&quot;西施&quot;</span>); <span class="built_in">printf</span>(<span class="string">&quot;*pc=%s\n&quot;</span>,pc);</span><br><span class="line">  <span class="built_in">strcpy</span>(pst-&gt;name,<span class="string">&quot;杨玉环&quot;</span>); pst-&gt;age=<span class="number">21</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s,age=%d\n&quot;</span>,pst-&gt;name,pst-&gt;age);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">  <span class="built_in">free</span>(pi); <span class="built_in">free</span>(pl); <span class="built_in">free</span>(pd); <span class="built_in">free</span>(pc); <span class="built_in">free</span>(pst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304112551794.png" alt="在这里插入图片描述" /></p><h1 id="二-内存被耗尽"><a class="markdownIt-Anchor" href="#二-内存被耗尽"></a> 二、内存被耗尽</h1><p>使用动态分配内存技术的时候，分配出来的内存必须及时释放，否则会引起系统内存耗尽，这话说起来简单，好像很容易做到，但是在实际开发中，程序员往往是漏洞百出。</p><p>内存问题是C程序员的主要问题之一，是初学者的恶梦。</p><h1 id="三-野指针"><a class="markdownIt-Anchor" href="#三-野指针"></a> 三、野指针</h1><p>野指针就是无效的指针，与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。</p><h2 id="1-指针变量未初始化"><a class="markdownIt-Anchor" href="#1-指针变量未初始化"></a> 1、指针变量未初始化</h2><p>指针变量刚被创建时不一定会自动初始化成为空指针（与编译器有关），它的缺省值是可能随机的，它会随便乱指。所以，指针变量在创建的同时应当被初始化，要么将指针的值设置为0，要么让它指向合法的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *pi=&amp;i;</span><br></pre></td></tr></table></figure><h2 id="2-指针释放后之后未置空"><a class="markdownIt-Anchor" href="#2-指针释放后之后未置空"></a> 2、指针释放后之后未置空</h2><p>指针在free时会把指针所指的内存给释放掉，但指针不一定会赋值0（也与编译器有关），如果对释放后的指针进行操作，相当于非法操作内存。释放内存后应立即将指针置为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="四-应用经验"><a class="markdownIt-Anchor" href="#四-应用经验"></a> 四、应用经验</h1><h2 id="1-数组申明的改进"><a class="markdownIt-Anchor" href="#1-数组申明的改进"></a> 1、数组申明的改进</h2><p>在C语言的早期标准中，定义数组必须用常量指明大小，不能用变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">101</span>];        <span class="comment">// 可以这样</span></span><br><span class="line"><span class="type">int</span> len=<span class="number">101</span>;</span><br><span class="line"><span class="type">char</span> str[len];         <span class="comment">// 不可以这样</span></span><br></pre></td></tr></table></figure><p>程序在运行的时候，如果要定义一个字符串存放100个字符，那怎么办，只能通过动态分配内存技术。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str=<span class="built_in">malloc</span>(<span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>现在，定义数组可以用变量指明大小，就不必为数组动态分配内存了。</p><p>还有，C++的string是一个变长的字符串，非常好用，程序员根本不必关心内存的问题。</p><h2 id="2-链表"><a class="markdownIt-Anchor" href="#2-链表"></a> 2、链表</h2><p>链表是C语言的一个经典的数据结构，相当于一个动态的结构体数组，非常巧妙，功能强大，但操作也麻烦，在这里我就不介绍了。</p><p>在C++中，容器全完代替了链表的功能，极其好用，程序员也不必关心内存的问题。</p><h2 id="3-我的建议"><a class="markdownIt-Anchor" href="#3-我的建议"></a> 3、我的建议</h2><p>在中国，没有纯C程序员，如果他不会C++，不是他对C有多么执着，可能是不会C++。</p><p>至少十年了，我不再使用动态内存分配技术，也想不到有什么场景非得用动态内存分配技术。</p><p>哦，嵌入式开发可能是个例外，可能还有其它只能用C不能用C++的场景。</p><p>动态内存分配并不是什么高大上的技术，我是一个实用的程序员，绝不给自己挖坑，这与水平高低无关。</p><h1 id="五-课后作业"><a class="markdownIt-Anchor" href="#五-课后作业"></a> 五、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言main函数的参数</title>
      <link href="/posts/adcf2046.html"/>
      <url>/posts/adcf2046.html</url>
      
        <content type="html"><![CDATA[<p>程序运行的时候，有些需要带参数，有些不带参数，例如linux操作系统的命令，它们本质上就是C程序。</p><p>1）Linux命令中，无参数的不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd  #显示当前目录</span><br><span class="line">clear  #清屏</span><br></pre></td></tr></table></figure><p>2）大部Linux命令是带参数的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp  book1.c book2.c</span><br><span class="line">mkdir /tmp/dname</span><br><span class="line">mv book3 /tmp/dname/book3</span><br><span class="line">rm -rf /tmp/dname</span><br></pre></td></tr></table></figure><p>各位现在是在C语言学习的初级阶段，编写的C程序非常简单，运行不需要参数，但是在实际开发中，main函数一般都需要参数，没有参数的情况极少。</p><p>main函数的参数是从命令提示符下执行程序的时候传入，例如ls 命令。</p><p><img src="https://img-blog.csdnimg.cn/20200304110829716.png" alt="在这里插入图片描述" /></p><p>在以上示例中ls命令有两个参数，-l和book1?.c。</p><h1 id="一-main函数的参数"><a class="markdownIt-Anchor" href="#一-main函数的参数"></a> 一、main函数的参数</h1><p>main函数有三个参数，argc、argv和envp，它的标准写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure><p>int argc，存放了命令行参数的个数。</p><p>char *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。</p><p>char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。</p><p>envp先放一下，先讲argc和argv。</p><p><strong>示例（book101.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book101.c，此程序演示main函数的参数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示参数的个数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;argc is %d\n&quot;</span>,argc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列出全部的参数</span></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;argc;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] is %s\n&quot;</span>,ii,argv[ii]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304110937722.png" alt="在这里插入图片描述" /></p><p>注意几个事项：</p><p>1）argc的值是参数个数加1，因为程序名称是程序的第一个参数，即argv[0]，在上面的示例中，argv[0]是./book101。</p><p>2）main函数的参数，不管是书写的整数还是浮点数，全部被认为是字符串。</p><p>3）参数的命名argc和argv是程序员的约定，您也可以用argd或args，但是不建议这么做。</p><h1 id="二-c程序的规范写法"><a class="markdownIt-Anchor" href="#二-c程序的规范写法"></a> 二、C程序的规范写法</h1><p>先假设程序执行都是有参数的，也就是说main函数都有参数，那么使用者怎么知道程序的参数个数和含义，记住它？看使用手册？不是，优秀的程序员会在程序中提供说明文字。我们先来看一个例子。</p><p><strong>示例（book103.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book103.c，此程序演示main函数的参数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">6</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n这是一个超女选秀程序，根据提供的超女信息，判断&quot;</span>\</span><br><span class="line">           <span class="string">&quot;她是否符合王妃的标准。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;用法：./book103 name age height sc yz\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;例如：./book103 西施 22 170 火辣 漂亮\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name   超女的姓名。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age    超女的年龄。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;height 超女的身高，单位：cm。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sc     超女的身材，火辣；普通；飞机场。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;yz     超女的颜值，漂亮；一般；歪瓜裂枣。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;您输入的超女信息是：姓名（%s）,年龄（%s），身高（%s），身材（%s），颜值（%s）。\n&quot;</span>,\</span><br><span class="line">          argv[<span class="number">1</span>],argv[<span class="number">2</span>],argv[<span class="number">3</span>],argv[<span class="number">4</span>],argv[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;正在计算中，请稍候......\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (((<span class="built_in">atoi</span>(argv[<span class="number">2</span>]) &gt;=  <span class="number">20</span>) &amp;&amp; (<span class="built_in">atoi</span>(argv[<span class="number">2</span>]) &lt;=  <span class="number">30</span>)) &amp;&amp;  <span class="comment">// 年龄在20-30之间</span></span><br><span class="line">      ((<span class="built_in">atoi</span>(argv[<span class="number">3</span>]) &gt;= <span class="number">165</span>) &amp;&amp; (<span class="built_in">atoi</span>(argv[<span class="number">3</span>]) &lt;= <span class="number">175</span>)) &amp;&amp;  <span class="comment">// 身高在165-175之间</span></span><br><span class="line">      ((<span class="built_in">strcmp</span>(argv[<span class="number">4</span>],<span class="string">&quot;火辣&quot;</span>)==<span class="number">0</span>)                     ) &amp;&amp;  <span class="comment">// 身材火辣</span></span><br><span class="line">      ((<span class="built_in">strcmp</span>(argv[<span class="number">5</span>],<span class="string">&quot;漂亮&quot;</span>)==<span class="number">0</span>)                     ))    <span class="comment">// 颜值漂亮</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女（%s）选秀合格，送往后宫。\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女（%s）选秀不合格，发放五两银子后送回家。\n&quot;</span>, argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行程序的时候，如果参数不符，运行效果如下。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304111048243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>如果参数个数相符，运行效果如下。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304111105939.png" alt="在这里插入图片描述" /></p><p>从以上的例子可以看出，如果执行程序的时候提供的参数与设计不符，显示程序的使用说明，说明文字应该包括程序的功能和全部参数的解释，还可以包括作者、联系方式等更详细的信息。</p><p>程序的使用说明文字非常重要，有几个原因：</p><p>1）程序的使用者不一定会写程序，也没必要去查使用手册等资料；</p><p>2）程序的使用者就算会写程序，也没必要在使用的时候去看源代码，并且，您也不一定想让他看到源代码；</p><p>3）如果程序的使用者是您自己，时间一长，您也会忘记程序的参数。</p><p>当然，这些只是程序员的约定，不是C语言的规定。</p><h1 id="三-envp参数"><a class="markdownIt-Anchor" href="#三-envp参数"></a> 三、envp参数</h1><p>envp存放了当前程序运行环境的参数。</p><p><strong>示例（book105.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book105.c，此程序用于演示当前程序运行环境的参数envp。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (envp[ii] != <span class="number">0</span>)  <span class="comment">// 数组最后一个元素是0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,envp[ii]); ii++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304111241101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意了，book105运行的结果与linux系统的env命令相同。</p><p>在实际开发中，envp参数的应用场景不多，各位了解一下就行了。</p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言格式化输出</title>
      <link href="/posts/e45b3b92.html"/>
      <url>/posts/e45b3b92.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-格式化输出"><a class="markdownIt-Anchor" href="#一-格式化输出"></a> 一、格式化输出</h1><p>格式化输出的函数有printf、sprintf和snprintf等，功能略有不同，使用方法大同小异，本章节我们先以printf为例。</p><p>对于 printf 函数，相信大家并不陌生。之所以称它为格式化输出函数，该函数的声名如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure><p>大家看到printf函数的声明就会有点懵，它参数的写法与我们之前学到的函数知识不一样，printf函数是一个“可变参数函数”（即函数参数的个数是可变的），可变参数函数的知识以后再介绍，现在只要知道怎么使用就行了。</p><p>printf函数的参数的个数和类型都是可变的，每一个参数的输出格式都有对应的格式说明符与之对应，从格式串的左端第1 个格式说明符对应第 1 个输出参数，第 2 个格式说明符对应第 2 个输出参数，第 3个格式说明符对应第 3 个输出参数，以此类推。</p><p>其中，格式说明符的形式如下（方括号 [] 中的项为可选项）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width][.prec] type</span><br></pre></td></tr></table></figure><h2 id="1-类型符type"><a class="markdownIt-Anchor" href="#1-类型符type"></a> 1、类型符（type）</h2><p>它用以表示输出数据的类型，以下是常用类型的汇总，不常用的就不列了。</p><p>%hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。</p><p>%hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数</p><p>%c 输出字符。</p><p>%lf 以普通方式输出double（float弃用，long doube无用）。</p><p>%e 以科学计数法输出double。</p><p>%s 输出字符串。</p><p>以上输出数据的知识在之前介绍数据类型的时候已演示过，这里就不举例了。</p><h2 id="2-宽度width"><a class="markdownIt-Anchor" href="#2-宽度width"></a> 2、宽度（width）</h2><p>它用于控制输出内容的宽度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);     <span class="comment">// 输出=         abc=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12d=\n&quot;</span>,<span class="number">123</span>);       <span class="comment">// 输出=         123=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12lf=\n&quot;</span>,<span class="number">123.5</span>);    <span class="comment">// 输出=  123.500000=</span></span><br></pre></td></tr></table></figure><h2 id="3-对齐标志flags"><a class="markdownIt-Anchor" href="#3-对齐标志flags"></a> 3、对齐标志（flags）</h2><p>flags它用于控制输出内容的对齐方式。</p><p><strong>不填或+</strong>：输出的内容右对齐，这是缺省的方式，上一小节就是右对齐的示例。</p><p><strong>-</strong>：输出的内容左对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);    <span class="comment">// 输出=abc         =</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12d=\n&quot;</span>,<span class="number">123</span>);     <span class="comment">// 输出=123         =</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12f=\n&quot;</span>,<span class="number">123.5</span>);    <span class="comment">// 输出=123.500000  =</span></span><br></pre></td></tr></table></figure><p>如果输出的内容是整数或浮点数，并且对齐的方式是右对齐，可以加0填充，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 输出=         abc=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012d=\n&quot;</span>,<span class="number">123</span>);   <span class="comment">// 输出=000000000123=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012f=\n&quot;</span>,<span class="number">123.5</span>);  <span class="comment">// 输出=00123.500000= </span></span><br></pre></td></tr></table></figure><p>从上面第一行代码的结果看出，输出的内容不是整数或浮点数，是字符串，不能在前面填0。</p><p>左对齐的时候，能在整数或浮点数的后面补0吗？浮点数最多可以补到6位，整数不行，为什么？您的存款能在后面补0吗？</p><h2 id="4-精度prec"><a class="markdownIt-Anchor" href="#4-精度prec"></a> 4、精度（prec）</h2><p>如果输出的内容是浮点数，它用于控制输出内容的精度，也就是说小数点后面保留多少位，后面的数四舍五入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12.2lf=\n&quot;</span>,<span class="number">123.5</span>);   <span class="comment">// 输出=      123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%.2lf=\n&quot;</span>,<span class="number">123.5</span>);     <span class="comment">// 输出=123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12.2e=\n&quot;</span>,<span class="number">123500000000.0</span>);  <span class="comment">// 输出=    1.24e+11=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%.2e=\n&quot;</span>,<span class="number">123500000000.0</span>);    <span class="comment">// 输出=1.24e+11=</span></span><br></pre></td></tr></table></figure><h1 id="二-格式化输出到字符串"><a class="markdownIt-Anchor" href="#二-格式化输出到字符串"></a> 二、格式化输出到字符串</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。</p><p>在之前的章节中，介绍过把字符串转换为整数和浮点数据的库函数，C语言没有提供把整数和浮点数据转换为字符串的库函数，而是采用sprintf和snprintf函数格式化输出到字符串。</p><p><strong>示例（book98.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book98.c，此程序演示格式化输出sprintf和snprintf函数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化输出到str中</span></span><br><span class="line">  <span class="built_in">sprintf</span>(str,<span class="string">&quot;%d,%c,%f,%s&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">25.97</span>,<span class="string">&quot;一共输入了三个数。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 格式化输出到str中，只截取前7个字符</span></span><br><span class="line">  <span class="built_in">snprintf</span>(str,<span class="number">8</span>,<span class="string">&quot;%d,%c,%f,%s&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">25.97</span>,<span class="string">&quot;一共输入了三个数。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304104504898.png" alt="在这里插入图片描述" /></p><p>程序运行第二行只输出了6个字符，注意，snprintf函数在unix和windows平台下的表现略有不同，在windows平台下，第二行会输出7个字符。</p><h1 id="三-c语言代码的多行书写"><a class="markdownIt-Anchor" href="#三-c语言代码的多行书写"></a> 三、C语言代码的多行书写</h1><p>在我们之前学习的过程中，编写的程序的功能很简单，一句代码很短，但是在实际开发中，参数往往很长很多，一句代码可能会很长，需要用多行才能书写。</p><p>如果我们在一行代码的行尾放置一个反斜杠，c语言编译器会忽略行尾的换行符，而把下一行的内容也算作是本行的内容。这里反斜杠起到了续行的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;aaaaaaaaaa\</span></span><br><span class="line"><span class="string">bbbbbbbbb);</span></span><br></pre></td></tr></table></figure><p>如果我们不使用反斜杠，当我们试图初始化一个跨多行的字符串时，c语言编译器可能会发出警告或错误，如下面的语句是不正确的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;aaaaaaaaaa</span></span><br><span class="line"><span class="string">bbbbbbbbb);</span></span><br></pre></td></tr></table></figure><p>C语言中还有字符串多行书写的方法，那就是将它写个多个字符串，C语言编译器会自动将这些字符串连接起来，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;aaabbbccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">strcpy</span>(str,<span class="string">&quot;aaa&quot;</span><span class="string">&quot;bbb&quot;</span><span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">strcpy</span>(str,<span class="string">&quot;aaa&quot;</span>\</span><br><span class="line">            <span class="string">&quot;bbb&quot;</span>\</span><br><span class="line">            <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="built_in">sprintf</span>(str,<span class="string">&quot;aaabbbccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">sprintf</span>(str,<span class="string">&quot;aaa&quot;</span><span class="string">&quot;bbb&quot;</span><span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">sprintf</span>(str,<span class="string">&quot;aaa&quot;</span>\</span><br><span class="line">             <span class="string">&quot;bbb&quot;</span>\</span><br><span class="line">             <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;str=%s=\n&quot;</span>,str);   <span class="comment">// 输出str=aaabbbccc=</span></span><br></pre></td></tr></table></figure><p>以上每段代码的输出结果完全一样，表达式：“aaa”  “bbb” “ccc” 实际上相当于&quot;aaabbbccc&quot;。</p><p>把字符串很长，参数很多的代码用多行书写，可以使程序代码结构更清晰，以下代码是我实际开发中用到的一句代码，这还不算长的。</p><p><img src="https://img-blog.csdnimg.cn/20200304104727548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><p>2）编写一个解析XML字符串的函数。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">GetXMLBuffer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *in_XMLBuffer,<span class="type">const</span> <span class="type">char</span> *in_FieldName,<span class="type">char</span> *out_Value)</span></span>;</span><br></pre></td></tr></table></figure><p>in_XMLBuffer，XML格式的字符串，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;</span><br></pre></td></tr></table></figure><p>in_FieldName，字段的标签名。</p><p>out_Value，获取内容存放的变量的指针。</p><p>返回值，0-成功，-1-失败。</p><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strXMLBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(strXMLBuffer,<span class="string">&quot; &lt;name&gt;西施&lt;/name&gt;&lt;age&gt;18&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;&quot;</span>);</span><br><span class="line"><span class="type">char</span> strvalue[<span class="number">51</span>];</span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;name&quot;</span>,strvalue);   <span class="comment">// strvalue的内容将是&quot;西施&quot;</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;age&quot;</span>,strvalue);     <span class="comment">// strvalue的内容将是&quot;18&quot;</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;sc&quot;</span>,strvalue);       <span class="comment">// strvalue的内容将是&quot;火辣&quot;</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strXMLBuffer,<span class="string">&quot;yz&quot;</span>,strvalue);       <span class="comment">// strvalue的内容将是&quot;漂亮&quot;</span></span><br></pre></td></tr></table></figure><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言结构体</title>
      <link href="/posts/d6d91a4f.html"/>
      <url>/posts/d6d91a4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-结构体的概念"><a class="markdownIt-Anchor" href="#一-结构体的概念"></a> 一、结构体的概念</h1><p>前面的教程中我们讲解了变量和数组（array），变量是一个一个定义的，数组是一组具有相同类型的变量的集合。但在实际的工作和生活中，为了表达一个数据集，需要用不同数据类型的变量。例如超女基本信息，姓名为字符串，身高和年龄为整数，体重为浮点数，身材和颜值为字符串，因为数据集各要素的数据类型不同，不能用一个数组来存放。</p><p>用我们之前学过的知识，如果要存放超女信息，可以用多个变量，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">51</span>];   <span class="comment">// 姓名</span></span><br><span class="line"><span class="type">int</span>  age;        <span class="comment">// 年龄</span></span><br><span class="line"><span class="type">int</span>  height;     <span class="comment">// 身高，单位：cm</span></span><br><span class="line"><span class="type">double</span> weight;     <span class="comment">// 体重，单位：kg</span></span><br><span class="line"><span class="type">char</span> sc[<span class="number">31</span>];     <span class="comment">// 身材，火辣；普通；飞机场</span></span><br><span class="line"><span class="type">char</span> yz[<span class="number">31</span>];     <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣</span></span><br></pre></td></tr></table></figure><p>这种方式有一个缺陷，如果某数据集有100个要素，就要定义100个变量，对100个变量初始化，把100个变量作为函数的参数传递，实在太麻烦。</p><p>在C语言中，使用结构体（struct）来存放一组不同类型的数据，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名</span><br><span class="line">&#123;</span><br><span class="line">  结构体成员变量一的声明;</span><br><span class="line">  结构体成员变量二的声明;</span><br><span class="line">  结构体成员变量三的声明;</span><br><span class="line">  ......</span><br><span class="line">  结构体成员变量四的声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体是一个集合，是一种构造的数据类型，是程序员为了描述一个数据集自己定义出来的数据类型。结构体的成员（member）可以是任意类型的变量，也可以是结构体变量。以超女为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];   <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;        <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;     <span class="comment">// 身高，单位：cm</span></span><br><span class="line">  <span class="type">int</span>  weight;     <span class="comment">// 体重，单位：kg</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">31</span>];     <span class="comment">// 身材，火辣；普通；飞机场</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">31</span>];     <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二-结构体变量"><a class="markdownIt-Anchor" href="#二-结构体变量"></a> 二、结构体变量</h1><p>结构体是一种程序员自定义的数据类型，是模板，可以用它来定义变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> queen, princess, waiting, workers;</span><br></pre></td></tr></table></figure><p>定义了四个结构体变量，queen王后、princess王妃，waiting宫女和workers侍者。</p><h1 id="三-占用内存的情况"><a class="markdownIt-Anchor" href="#三-占用内存的情况"></a> 三、占用内存的情况</h1><p>理论上讲结构体的各个成员在内存中是连续存放的，和数组非常类似，但是，结构体的占用内存的总大小不一定等于全部成员变量占用内存大小之和。在编译器的具体实现中，为了提高内存寻址的效率，各个成员之间可能会存在缝隙。用sizeof可以得到结构体占用内容在总大小，sizeof(结构体名)或sizeof(结构体变量名)都可以。</p><p><strong>示例（book90.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book90.c，此程序用于演示C语言的结构体占用内存的情况</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct st_girl) %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(queen) %d\n&quot;</span>,<span class="built_in">sizeof</span>(queen));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304100720779.png" alt="在这里插入图片描述" /></p><p>从上面的示例可以看出，struct st_girl全部成员变量占用的内存是50+4+4+30+30=118，但是结构体占用的内存是120。</p><p>注意，C语言提供了结构体成员内存对齐的方法，可以使结构体成员变量之间的内存没有空隙，我暂时不介绍。</p><h1 id="四-结构体的变量名"><a class="markdownIt-Anchor" href="#四-结构体的变量名"></a> 四、结构体的变量名</h1><p>和数组不一样，结构体变量名不是结构体变量的地址，结构体变量名就是变量名，就象int ii一样，只是不能直接输出，直接输出没有意义。取地址要用&amp;，不用钻牛角尖，不直接输出就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> stgirl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stgirl);   <span class="comment">// 没有意义。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,stgirl);   <span class="comment">// 没有意义，结构体变量名不是结构体变量的地址。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;stgirl);  <span class="comment">// 这才是结构体的地址。</span></span><br></pre></td></tr></table></figure><h1 id="五-结构体初始化"><a class="markdownIt-Anchor" href="#五-结构体初始化"></a> 五、结构体初始化</h1><p>采用memset函数初始化结构体，全部成员变量的值清零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(queen));</span><br></pre></td></tr></table></figure><p>注意事项，如果把一个结构体的地址传给子函数，子函数用一个结构体指针（如struct st_girl *pst）来存放传入的结构体的地址，那么，在子函数中只能用以下方法来初始化结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pst,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br></pre></td></tr></table></figure><p>不能用以下方法来初始化结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pst,<span class="number">0</span>,<span class="built_in">sizeof</span>(pst));</span><br></pre></td></tr></table></figure><p>因为子函数中用sizeof(pst)，得到的不是结构体占用内存的字节数，而是结构体指针变量占用内存的字节数（8字节）。</p><h1 id="六-成员的访问使用"><a class="markdownIt-Anchor" href="#六-成员的访问使用"></a> 六、成员的访问（使用）</h1><p>使用使用圆点.运算符可以访问（使用）结构的成员，结构体成员变量的使用与普通变量的使用相同。</p><p><strong>示例（book92.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book92.c，此程序演示结构体的访问（使用）。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="type">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;  <span class="comment">// 定义结构体变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化结构体变量</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对结构体每个成员赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(queen.name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  queen.age=<span class="number">28</span>;</span><br><span class="line">  queen.height=<span class="number">168</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(queen.sc,<span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(queen.yz,<span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>,queen.name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;年龄：%d\n&quot;</span>,queen.age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;身高：%d\n&quot;</span>,queen.height);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;身材：%s\n&quot;</span>,queen.sc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;颜值：%s\n&quot;</span>,queen.yz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101054894.png" alt="在这里插入图片描述" /></p><h1 id="七-结构体数组"><a class="markdownIt-Anchor" href="#七-结构体数组"></a> 七、结构体数组</h1><p>结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> princess[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">memset</span>(princess,<span class="number">0</span>,<span class="built_in">sizeof</span>(princess));</span><br><span class="line"><span class="built_in">strcpy</span>(princess[<span class="number">0</span>].name,<span class="string">&quot;杨玉环&quot;</span>);</span><br><span class="line">princess[<span class="number">0</span>].age=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(princess[<span class="number">1</span>].name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">princess[<span class="number">1</span>].age=<span class="number">28</span>;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>在实际开发中，我们很少用结构体数组，C++标准库的vector容器是一个动态的结构体数组，比结构体数组更方便。</p><h1 id="八-结构体指针"><a class="markdownIt-Anchor" href="#八-结构体指针"></a> 八、结构体指针</h1><p>结构体是一种自定义的数据类型，结构体变量是内存变量，有内存地址，也就有结构体指针。</p><p>在指针章节中我们已经学习过，采用不同数据类型的指针指向不同数据类型的变量的地址，这一规则也适用于结构体。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst=&amp; queen;</span><br></pre></td></tr></table></figure><p>通过结构体指针可以使用结构体成员，一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pointer).memberName</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure><p>第一种写法中，圆点.的优先级高于*，(*pointer)两边的括号不能少。如果去掉括号写作*pointer.memberName，那么就等效于*(pointer.memberName)，这样意义就完全不对了。</p><p>第二种写法中，-&gt;是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接使用结构体成员；这也是-&gt;在C语言中的唯一用途。</p><p>上面的两种写法是等效的，程序员通常采用后面的写法，这样更加直观。</p><p><strong>示例（book93.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book93.c，此程序演示结构体的指针</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst,queen;  <span class="comment">// 定义结构体变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化结构体变量</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  pst=&amp;queen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对结构体每个成员赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(pst-&gt;name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  pst-&gt;age=<span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,queen.name,queen.age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,pst-&gt;name,pst-&gt;age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,(*pst).name,(*pst).age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101335656.png" alt="在这里插入图片描述" /></p><h1 id="九-结构体的复制"><a class="markdownIt-Anchor" href="#九-结构体的复制"></a> 九、结构体的复制</h1><p>在C语言中，结构体的成员如果是基本数据类型（int、char、double）可以用=号赋值，如果是字符串，字符串不是基本数据类型，可以用strcpy函数赋值，如果要把结构体变量的值赋给另一个结构体变量，有两种方法：1）一种是把结构体变量成员的值逐个赋值给另一个结构体变量的成员，这种方法太笨，没人使用；2）另一种方法是内存拷贝，C语言提供了memcpy（memory copy的简写）实现内存拷贝功能。</p><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p><strong>src</strong> 源内存变量的起始地址。</p><p><strong>dest</strong> 目的内存变量的起始地址。</p><p><strong>n</strong> 需要复制内容的字节数。</p><p>函数返回指向dest的地址，函数的返回值意义不大，程序员一般不关心这个返回值。</p><p><strong>示例（book94.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book94.c， 此程序演示采用memcpy函数复制结构体</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> girl1,girl2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(girl1.name,<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 对girl1的成员赋值</span></span><br><span class="line">  girl1.age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把girl1的内容复制到girl2中</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;girl2,&amp;girl1,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girl1.name=%s,girl1.age=%d\n&quot;</span>,girl1.name,girl1.age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girl2.name=%s,girl2.age=%d\n&quot;</span>,girl2.name,girl2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101430559.png" alt="在这里插入图片描述" /><br />大家可能想起了strcpy函数，与memcpy有相似之处，实际上这两个函数从功能和实现原理上完本不同，甚至不应该放在一起比较。</p><p>1）复制的内容不同，strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</p><p>2）用途不同，通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p><p>3）复制的方法不同，strcpy不需要指定长度，它遇到被复制字符的串结尾符0才结束，memcpy则是根据其第3个参数决定复制的长度。</p><h1 id="十-结构体作为函数的参数"><a class="markdownIt-Anchor" href="#十-结构体作为函数的参数"></a> 十、结构体作为函数的参数</h1><p>结构体是多个变量集合，作为函数参数时就可以传递整个集合，也就是所有成员。如果结构体成员较多，函数参数的初始化和赋值的内存开销会很大，影响程序的运行效率。所以最好的办法就是传递结构体变量的地址。</p><p><strong>示例（book95.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book95.c，此程序演示结构体作为函数的参数。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对结构体赋值的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(<span class="keyword">struct</span> st_girl *pst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">st_girl</span> queen;  <span class="comment">// 定义结构体变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化结构体变量</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setvalue</span>(&amp;queen);  <span class="comment">// 调用函数，传结构体的地址</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>,queen.name,queen.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(<span class="keyword">struct</span> st_girl *pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 对结构体每个成员赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(pst-&gt;name,<span class="string">&quot;武则天&quot;</span>);</span><br><span class="line">  pst-&gt;age=<span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304101531550.png" alt="在这里插入图片描述" /></p><h1 id="十一-枚举和共同体"><a class="markdownIt-Anchor" href="#十一-枚举和共同体"></a> 十一、枚举和共同体</h1><p>C语言还有两种数据结构：枚举和共同体，这两种数据结构的应用太少了，少到我已经记不起它们的定义，二十年来，我从未使用过，也不介绍了。</p><h1 id="十二-memset和bzero函数"><a class="markdownIt-Anchor" href="#十二-memset和bzero函数"></a> 十二、memset和bzero函数</h1><h2 id="1-memset函数"><a class="markdownIt-Anchor" href="#1-memset函数"></a> 1、memset函数</h2><p>memset 函数是内存空间赋值函数，用来给某一块内存空间进行赋值的。</p><p>包含在&lt;string.h&gt;头文件中。</p><p>函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> v, <span class="type">size_t</span> n)</span></span>;  </span><br></pre></td></tr></table></figure><p>s为内存空间的地址，一般是数组名或结构体的地址。</p><p>v为要填充的值，填0就是初始化。</p><p>n为要填充的字节数。</p><p>在实际开发中，程序员用memset函数对数组或结构体清零，在之前的章节中，我们已经用过很多次了。</p><h2 id="2-bzero函数"><a class="markdownIt-Anchor" href="#2-bzero函数"></a> 2、bzero函数</h2><p>bzero函数是内存空间清零。</p><p>包含在&lt;string.h&gt;头文件中。</p><p>函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bzero</span><span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> n)</span></span>; </span><br></pre></td></tr></table></figure><p>s为内存空间的地址，一般是数组名或结构体的地址。</p><p>n为要清零的字节数。</p><p>如果要对数组或结构体清零，用memset和bzero都可以，没什么差别，看程序员的习惯。</p><h1 id="十三-课后作业"><a class="markdownIt-Anchor" href="#十三-课后作业"></a> 十三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="十四-版权声明"><a class="markdownIt-Anchor" href="#十四-版权声明"></a> 十四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据类型转换</title>
      <link href="/posts/32666f02.html"/>
      <url>/posts/32666f02.html</url>
      
        <content type="html"><![CDATA[<p>计算机进行算术运算时，要求各操作数的类型具有相同的大小（存储位数）及存储方式，不能将char 型（ 1 字节）数据与 int 型（2、4或8字节）数据直接参与运算；由于存储方式的不同，也不能将 int 型数据与 double 型数据直接参与运算。</p><p>然而，由于 C语言的灵活性，在一个表达式或一条语句中，允许不同类型的数据混合运算。</p><p>C语言的灵活性与计算机的机械性是一对矛盾，如处理不好，将会产生错误结果。对于某些类型的转换编译器可隐式地自动进行，不需程序员干预，称这种转换为<strong>自动类型转换</strong>；而有些类型转换需要程序员显式指定，这种类型转换称为<strong>强制类型转换</strong>。</p><h1 id="一-自动类型转换"><a class="markdownIt-Anchor" href="#一-自动类型转换"></a> 一、自动类型转换</h1><p>一个表达式中出现不同类型间的混合运算，较低类型将自动向较高类型转换。</p><p>不同数据类型之间的差别在于数据的取值范围和精度上，一般情况下，数据的取值范围越大、精度越高，其类型也越“高级”。</p><p>整型类型级别从低到高依次为：</p><p>signed char-&gt;unsigned char-&gt;short-&gt;unsigned short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long</p><p>浮点型级别从低到高依次为：</p><p>float-&gt;double</p><p>float浮点类型被我们弃用了，所以不提它了。</p><h2 id="1-操作数中没有浮点型数据时"><a class="markdownIt-Anchor" href="#1-操作数中没有浮点型数据时"></a> 1、操作数中没有浮点型数据时</h2><p>当 char、unsigned char、short 或 unsigned short出现在表达式中参与运算时，一般将其自动转换为 int 类型。</p><p>int 与 unsigned int混合运算时，int自动转换为unsigned int型。</p><p>int、unsigned int 与 long 混合运算时，均转换为 long 类型。</p><h2 id="2-操作数中有浮点型数据时"><a class="markdownIt-Anchor" href="#2-操作数中有浮点型数据时"></a> 2、操作数中有浮点型数据时</h2><p>当操作数中含有浮点型数据时，所有操作数都将转换为 double 型。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii=<span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> dd=<span class="number">200.5</span>;</span><br><span class="line">ii+dd;</span><br></pre></td></tr></table></figure><p>上述算术表达式中操作数 dd 为double，所以先把ii转换为double浮点数后再参与运算，运算结果为双精度浮点数300.5。</p><h2 id="3-赋值运算符两侧的类型不一致时"><a class="markdownIt-Anchor" href="#3-赋值运算符两侧的类型不一致时"></a> 3、赋值运算符两侧的类型不一致时</h2><p>当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型提升/降低为左值类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dd;</span><br><span class="line">dd=<span class="number">10</span>;  <span class="comment">// 右值为双精度，左值为整数</span></span><br></pre></td></tr></table></figure><p>由于左值dd为双精度浮点型，所以先把右值整型常量10 提升为双精度浮点型后，再赋值给dd，不但不丢失精度反而提高了精度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;</span><br><span class="line">ii=<span class="number">10.5</span>;   <span class="comment">// 右值10.5为双精度，左值为整型</span></span><br></pre></td></tr></table></figure><p>右值双精度型 10.5 降低为左值整型，即10.5舍弃小数部分后，把10 赋给整型变量ii，这种情况会丢失精度。</p><h2 id="4-右值超出左值类型范围时"><a class="markdownIt-Anchor" href="#4-右值超出左值类型范围时"></a> 4、右值超出左值类型范围时</h2><p>更糟糕的情况是，赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;             <span class="comment">//  char占8位，取值范围是-128-127。</span></span><br><span class="line">c=<span class="number">1025</span>;             <span class="comment">//  整数1025 对应二进制形式是100 0000 0001，超出了8位。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;％d&quot;</span>,c) ;  <span class="comment">//  以十进制输出c的值</span></span><br></pre></td></tr></table></figure><p>该输出结果为 1，因为只取 1025 低 8 位 0000 0001（值为1），赋给字符型变量c，得到毫无意义的值。</p><h1 id="二-强制类型转换"><a class="markdownIt-Anchor" href="#二-强制类型转换"></a> 二、强制类型转换</h1><p>虽然自动类型转换不需要人工干预，使用方便，但有利也有弊，尤其当自动类型转换是从较高类型转换为较低类型时，将会降低精度或截断数据，可能得不到预期的结果。</p><p>为了给程序设计人员提供更多的类型转换控制权限，使程序设计更加灵活，转换的目的更加清晰，C语言提供了可显式指定类型转换的语法，通常称之为强制类型转换。</p><p>强制类型转换的格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(目标类型) 表达式;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a=<span class="number">4</span>;</span><br><span class="line">b=<span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> dd;</span><br><span class="line">dd=a/b;            <span class="comment">// dd的结果将是1。</span></span><br><span class="line">dd=(<span class="type">double</span>)(a/b);  <span class="comment">// dd的结果是1.000000。</span></span><br><span class="line">dd=(<span class="type">double</span>)a/b;   <span class="comment">// dd的结果是1.333333</span></span><br></pre></td></tr></table></figure><p>dd=a/b，dd的结果是1，这个很好理解，因为整数除整数还是整数，没有小数部分。</p><p>dd=(double)(a/b)，dd的结果也是1.000000，这个不好理解，它的运算过程是：</p><p>（1）先运算a/b，得到的结果是整数的1；</p><p>（2）把整数的1转换成double，是1.000000。</p><p>dd=(double)a/b，dd的结果是1.333333，这个也不好理解，它的运算过程是：</p><p>（1）先执行(double)a，把a转换为double，即4.000000；</p><p>（2）把4.00000除以3，得到1.333333，符合自动类型转换的规则。</p><p>这里还有个问题，程序员搞不清楚是(double)a优先还是a/b优先，最好的办法是写成这样((double)a)/b，这样就没有疑问了。</p><h1 id="三-课后作业"><a class="markdownIt-Anchor" href="#三-课后作业"></a> 三、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="四-版权声明"><a class="markdownIt-Anchor" href="#四-版权声明"></a> 四、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言字符串</title>
      <link href="/posts/9d2c959b.html"/>
      <url>/posts/9d2c959b.html</url>
      
        <content type="html"><![CDATA[<p>在很多教程中，字符串不过是一个以0结束的字符数组，但是，在我看来，字符串虽然不是C语言基本数据类型，但它比任何数据类型都重要，因为字符串是最常用的数据。</p><h1 id="一-字符串的概念"><a class="markdownIt-Anchor" href="#一-字符串的概念"></a> 一、字符串的概念</h1><p>我们可以把字符串储存在char类型的数组中，如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串。</p><p><img src="https://img-blog.csdnimg.cn/20200304090742725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>因为字符串需要用\0结尾，所以在定义字符串的时候，字符数组的长度要预留多一个字节用来存放\0，\0就是数字0。这是约定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];  <span class="comment">// 定义一个最多存放20个英文字符或十个中文的字符串</span></span><br></pre></td></tr></table></figure><p>字符串也可以存放中文和全角的标点符号，一个中文字符占两个字节（GBK编码）。char strname[21]用于存放中文的时候，只能存10个汉字。</p><p>字符串采用双引号包含起来，如：“hello”、“中华人民共和国”、“A”、“”，这是约定。</p><h1 id="二-占用内存的情况"><a class="markdownIt-Anchor" href="#二-占用内存的情况"></a> 二、占用内存的情况</h1><p>一个字符占用一字节的内存，字符串定义时数组的大小就是字符串占用内存的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">21</span>];     <span class="comment">// 占用21字节的内存</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];   <span class="comment">// 占用1024字节的内存</span></span><br></pre></td></tr></table></figure><h1 id="三-字符串的初始化"><a class="markdownIt-Anchor" href="#三-字符串的初始化"></a> 三、字符串的初始化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line">strname[<span class="number">0</span>]=<span class="number">0</span>;    <span class="comment">// 把第一个元素的值置为0</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));  <span class="comment">// 把全部的元素置为0</span></span><br></pre></td></tr></table></figure><p>strname[0]=0;不够规范，并且存有隐患，在实际开发中，一般采用memset的函数初始化字符串。</p><h1 id="四-字符串与指针"><a class="markdownIt-Anchor" href="#四-字符串与指针"></a> 四、字符串与指针</h1><p>在C语言中，数组名是数组无素的首地址，字符串是字符数组，所以在获取字符串的地址的时候，不需要用&amp;取地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;abcdefghijk&quot;</span>);     <span class="comment">// 把abcdefghijk赋值给strname</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,strname);              <span class="comment">// 输出abcdefghijk</span></span><br></pre></td></tr></table></figure><h1 id="五-字符串的结尾标志"><a class="markdownIt-Anchor" href="#五-字符串的结尾标志"></a> 五、字符串的结尾标志</h1><p>字符串的结尾标志是0，如果没有结尾标志的情况我们在数组章节中已介绍过，现在我们介绍结尾标志后面的内容如何处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;abcdefghijk&quot;</span>);     <span class="comment">// 把abcdefghijk赋值给strname</span></span><br><span class="line">strname[<span class="number">5</span>]=<span class="number">0</span>;     <span class="comment">// 强制把第6个元素赋值0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,strname);   <span class="comment">// 输出的结果是abcde</span></span><br></pre></td></tr></table></figure><p>以上代码输出的结果是abcde，但是，在内存中的值仍是abcde0ghijk，后面的ghijk成了内存中的垃圾值。</p><p>不要让字符串的内存中有垃圾值，容易产生意外的后果，我们将在后面的内容中演示，所以字符串的初始化不建议采用把第一个元素的值置为0的方式（strname[0]=0）。</p><h1 id="六-字符串的输出"><a class="markdownIt-Anchor" href="#六-字符串的输出"></a> 六、字符串的输出</h1><p>字符串采用%s输出，可以加格式控制，常用的如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%10s=\n&quot;</span>,<span class="string">&quot;abcd&quot;</span>);   <span class="comment">// 输出10个字符宽度，右对齐，执行结果是=      abcd=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-10s=\n&quot;</span>,<span class="string">&quot;abcd&quot;</span>);  <span class="comment">// 输出10个字符宽度，左对齐，执行结果是=abcd      =</span></span><br></pre></td></tr></table></figure><p>如果输出的字符串的长度大于对齐格式中的数字，就按字符串的实际长度输出。</p><h1 id="七-字符串越界"><a class="markdownIt-Anchor" href="#七-字符串越界"></a> 七、字符串越界</h1><p>字符串是字符数组，字符串越界就是数组越界。字符串的越界是初学者经常犯的错误之一。</p><p><strong>示例（book80.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book80.c，此程序演示字符串的越界。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> strname1[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strname1,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname1));</span><br><span class="line">  <span class="type">char</span> strname2[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strname2,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname2));</span><br><span class="line">  <span class="built_in">strcpy</span>(strname1,<span class="string">&quot;真的只能存十个汉字吗，多几个行不行？&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(strname2,<span class="string">&quot;是的，只能十个，多了不行。&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname2);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> strname[<span class="number">2</span>][<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line">  <span class="built_in">strcpy</span>(strname[<span class="number">1</span>],<span class="string">&quot;是的，只能十个，多了不行。&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(strname[<span class="number">0</span>],<span class="string">&quot;真的只能存十个汉字吗，多几个行不行？&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304091144396.png" alt="在这里插入图片描述" /></p><p>我们来分析一下book80.c。</p><p>前8行代码定义了两个字符串变量，每个能存放20个字符或10个中文，但实际赋值都超过了10个中文，从输出结果看，没有问题。</p><p>后6行代码采用了二维数组的方式定义了字符串变量，理论上说，与分开定义的两个字符串变量没有区别，但是，从输出结果看，很有问题。</p><p>真正的原因是这样的，在C语言中，数组越界肯定是非法的，但非法操作并不一定会出问题，前8行代码的字符串是越界了，但是strname1和strname2变量的内存之后的内存空间是未分配的，所以对strname1和strname2赋值过长也没关系。后6行代码就不一样了，二维数组的两个变量之间的内存是连续的，第一个元素之后没有多余的空间，所以第一个元素的值就出问题了。</p><p>总的来说，在C语言中，非法操作内存不一定会报错，要看运气。</p><p>在现实生活中，一个农民把庄稼种到了自家的地盘之外，如果您的地盘之外的地没有主人，是不会有问题的，但如果有主人，这事就肯定会引起纠纷，系统对这种纠纷的裁决是内存越界的程序非法，强制终止它（段错误）。</p><h1 id="八-字符串常用的库函数"><a class="markdownIt-Anchor" href="#八-字符串常用的库函数"></a> 八、字符串常用的库函数</h1><h2 id="1-获取字符串的长度strlen"><a class="markdownIt-Anchor" href="#1-获取字符串的长度strlen"></a> 1、获取字符串的长度（strlen）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span>  <span class="title">strlen</span><span class="params">( <span class="type">const</span> <span class="type">char</span>*  str)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：计算字符串的有效长度，不包含0。</p><p>返回值：返回字符串的字符数 。</p><p>strlen 函数计算的是字符串的实际长度，遇到第一个0结束。</p><p>函数返回值一定是size_t，是无符号的整数，即typedef unsigned int size_t。</p><p>如果您只定义字符串没有初始化，求它的长度是没意义的，它会从首地址一直找下去，遇到0停止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;wucongzhou&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name 的长度是%d\n&quot;</span>,<span class="built_in">strlen</span>(name));     <span class="comment">// 输出结果：name 的长度是10</span></span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name 的长度是%d\n&quot;</span>,<span class="built_in">strlen</span>(name));     <span class="comment">// 输出结果：name 的长度是4</span></span><br></pre></td></tr></table></figure><p>还有一个注意事项，sizeof返回的是变量所占的内存数，不是实际内容的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;                           <span class="comment">// 定义的时候初始化。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;strlen(buf)=%d\n&quot;</span>,<span class="built_in">strlen</span>(buf));    <span class="comment">// 输出结果strlen(buf)=3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(buf));    <span class="comment">// 输出结果sizeof(buf)=10</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串复制或赋值strcpy"><a class="markdownIt-Anchor" href="#2-字符串复制或赋值strcpy"></a> 2、字符串复制或赋值（strcpy）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>功 能: 将参数src字符串拷贝至参数dest所指的地址。</p><p>返回值: 返回参数dest的字符串起始地址。</p><p>复制完字符串后，在dest后追加0。</p><p>如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</p><h2 id="3-字符串复制或赋值strncpy"><a class="markdownIt-Anchor" href="#3-字符串复制或赋值strncpy"></a> 3、字符串复制或赋值（strncpy）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strncpy</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">char</span>* src, <span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：把src前n字符的内容复制到dest中</p><p>返回值：dest字符串起始地址。</p><p>dest必须有足够的空间放置n个字符，否则可能会造成缓冲溢出的错误情况。</p><h2 id="4-字符串拼接strcat"><a class="markdownIt-Anchor" href="#4-字符串拼接strcat"></a> 4、字符串拼接（strcat）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：将src字符串拼接到dest所指的字符串尾部。</p><p>返回值：返回dest字符串起始地址。</p><p>dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。</p><p>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p><h2 id="5-字符串拼接strncat"><a class="markdownIt-Anchor" href="#5-字符串拼接strncat"></a> 5、字符串拼接（strncat）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncat</span> <span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">char</span>* src, <span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。</p><p>返回值：返回dest字符串的起始地址。</p><p>如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n大于字符串src的长度，只追加src的前n个字符。</p><p>strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。</p><p>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p><h2 id="6-字符串比较strcmp-strncmp"><a class="markdownIt-Anchor" href="#6-字符串比较strcmp-strncmp"></a> 6、字符串比较（strcmp、strncmp）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2 )</span></span>;</span><br></pre></td></tr></table></figure><p>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1,<span class="type">const</span> <span class="type">char</span> *str2 ,<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</p><p>两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。</p><p>在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。</p><h2 id="7-字符查找strchr-strrchr"><a class="markdownIt-Anchor" href="#7-字符查找strchr-strrchr"></a> 7、字符查找（strchr、strrchr）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个指向在字符串s中第一个出现c的位置，如果找不到，返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个指向在字符串s中最后一个出现c的位置，如果找不到，返回0。</p><h2 id="8-字符串查找strstr"><a class="markdownIt-Anchor" href="#8-字符串查找strstr"></a> 8、字符串查找（strstr）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">const</span> <span class="type">char</span>* substr)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：检索子串在字符串中首次出现的位置。</p><p>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。</p><h1 id="九-应用经验"><a class="markdownIt-Anchor" href="#九-应用经验"></a> 九、应用经验</h1><h2 id="1-留有余地"><a class="markdownIt-Anchor" href="#1-留有余地"></a> 1、留有余地</h2><p>字符串的strcpy和strcat函数要求dest参数有足够的空间，否则会造成内存的泄漏，所以在实际开发中，定义字符串的时候，可以大一些，例如姓名，中国人的姓名以两三个汉字为主，最多五个，少数民族可能十几个，外国人的很长，喜欢在自己的名字前加上爷爷的名字和外公的名字，那么我们在定义变量的时候，可以char name[301];存放他祖宗十八代的名字也没有问题。</p><p>内存不值钱，程序的稳定性高于一切。</p><h2 id="2-变量初始化"><a class="markdownIt-Anchor" href="#2-变量初始化"></a> 2、变量初始化</h2><p><strong>字符串在每次使用前都要初化</strong>，减少入坑的可能，<strong>是每次，不是第一次</strong>。这是职业程序员的良好习惯。</p><h2 id="3-位置地址偏移的用法"><a class="markdownIt-Anchor" href="#3-位置地址偏移的用法"></a> 3、位置（地址）偏移的用法</h2><p>字符串的地址偏移其本质是指针的运算，常用于灵活的处理字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;abcdefghijk&quot;</span>);     <span class="comment">// 把abcdefghijk赋值给strname</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> strname1[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname1,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname1));</span><br><span class="line"><span class="built_in">strcpy</span>(strname1,strname+<span class="number">1</span>);       <span class="comment">// 把bcdefghijk的值赋给strname1</span></span><br><span class="line"><span class="built_in">strncpy</span>(strname1,strname+<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">// 把cde的值赋给strname1</span></span><br></pre></td></tr></table></figure><p>当然，对strname1也可以使用偏移量。</p><h2 id="4-不要在子函数中对字符指针用sizeof"><a class="markdownIt-Anchor" href="#4-不要在子函数中对字符指针用sizeof"></a> 4、不要在子函数中对字符指针用sizeof</h2><p>如果把一个字符串（如char  strname[21]）的地址传给子函数，子函数用一个字符指针（如char *pstr）来存放传入的字符串的地址，如果在子函数中用sizeof(pstr)，得到的不是字符串占用内存的字节数，而是字符指针变量占用内存的字节数（8字节）。</p><p>所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。</p><h1 id="十-课后作业"><a class="markdownIt-Anchor" href="#十-课后作业"></a> 十、课后作业</h1><p>本章节的课后作业非常要，一定要认真完成，字符串操作是C程序员的主要工作之一，这些都是职业程序员在日常开发中用到的技巧。还有，这些作业题可以培养写程序的感觉。</p><p>1）编写示例程序，实现字符串操作常用的库函数的功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen1</span><span class="params">( <span class="type">const</span> <span class="type">char</span>*  str)</span></span>;          <span class="comment">// 实现strlen函数的功能。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy1</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;  <span class="comment">// 实现strcpy函数的功能，下同。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy1</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat1</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncat1</span> <span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strchr1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strrchr1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>以下三个函数难度较大，如果无法完成，不要过于纠结，以后功力提升了再做。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strstr1</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span></span>;   <span class="comment">// 实现strstr1函数的功能，下同。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp1</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2 )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2, <span class="type">const</span> <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>2）丰富您的函数库，增加STRCPY、STRNCPY、STRCAT、STRNCAT四个安全的函数，弥补库函数的缺陷，解决dest的初始化和内存越界的问题，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCPY</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">STRNCAT</span><span class="params">(<span class="type">char</span>* dest,<span class="type">const</span> <span class="type">size_t</span> destsize,<span class="type">const</span> <span class="type">char</span>* src,<span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，上述函数的第二个参数destsize是第一个参数dest占用内存的字节数。</p><p>3）丰富您的函数库，增加以下函数，这些是freecplus框架中的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除字符串左边指定的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char)</span></span>;</span><br><span class="line"><span class="comment">// 删除字符串右边指定的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char)</span></span>;</span><br><span class="line"><span class="comment">// 删除字符串两边指定的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteLRChar</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char)</span></span>;</span><br><span class="line"><span class="comment">// 删除字符串中间的字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteMStr</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> *in_str)</span></span>;</span><br><span class="line"><span class="comment">// 在字符串的左边补字符到指定长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LPad</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char,<span class="type">unsigned</span> <span class="type">int</span> in_len)</span></span>;</span><br><span class="line"><span class="comment">// 在字符串的右边补字符到指定长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RPad</span><span class="params">(<span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> in_char,<span class="type">unsigned</span> <span class="type">int</span> in_len)</span></span>;</span><br><span class="line"><span class="comment">// 把小写转换成大写，忽略不是字母的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToUpper</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 把大写转换成小写，忽略不是字母的字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToLower</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是数字，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsDigit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是大写字母，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsUpper</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是小写字母，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsLower</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 判断内容是否全部是ASCII字符，0-是，-1-不是。</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">IsASCII</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="十一-版权声明"><a class="markdownIt-Anchor" href="#十一-版权声明"></a> 十一、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浮点数</title>
      <link href="/posts/8d2f5a40.html"/>
      <url>/posts/8d2f5a40.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-浮点数的概念"><a class="markdownIt-Anchor" href="#一-浮点数的概念"></a> 一、浮点数的概念</h1><p>浮点数也称小数或实数。例如，0.0、75.0、4.023、0.27、-937.198 都是合法的小数。</p><p>C语言中采用float和double关键字来定义小数，float称为单精度浮点型，double称为双精度浮点型，long double更长的双精度浮点型。</p><p>在任何区间内（如1.0 到 2.0 之间）都存在无穷多个实数，计算机的浮点数不能表示区间内所有的值。</p><h1 id="二-点用内存的情况"><a class="markdownIt-Anchor" href="#二-点用内存的情况"></a> 二、点用内存的情况</h1><p>我们先来测试一下float、double和long double三种浮点数据类型占用内存的字节数。</p><p><strong>示例（book71.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book71.c，此程序测试float、double和long double占用内存的字节数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof float is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof double is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof long double is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304083510575.png" alt="在这里插入图片描述" /></p><h1 id="三-浮点数的精度"><a class="markdownIt-Anchor" href="#三-浮点数的精度"></a> 三、浮点数的精度</h1><p>C标准规定，float类型必须至少能表示6位有效数字，且取值范围至少是10<sup>-37</sup>～10<sup>+37</sup>。</p><p>double类型和 float类型的最小取值范围相同，但至少必须能表示10位有效数字。</p><p>long double，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。</p><p>看了上面这段文字，估计大家有点晕，在之前的整数章节中，long比int的占用的内存多，存放数据的值也就越大，并且有一个准确的范围，但是，为什么各种浮点数存放数据的值怎么就这么模糊呢？我先不解释原因，浮点数的存储方式比较复杂，暂时不讨论，先用几个程序来测试一下它们的特征。</p><h2 id="1-测试float类型"><a class="markdownIt-Anchor" href="#1-测试float类型"></a> 1、测试float类型</h2><p><strong>示例（book73.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book73.c，此程序测试float的特征</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> ff2=<span class="number">9.9</span>;   <span class="comment">// 测试2位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff2=%f\n&quot;</span>,ff2);</span><br><span class="line">  <span class="keyword">if</span> (ff2==<span class="number">9.9</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff2==9.9\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff5=<span class="number">99.999</span>;   <span class="comment">// 测试5位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff5=%f\n&quot;</span>,ff5);</span><br><span class="line">  <span class="keyword">if</span> (ff5==<span class="number">99.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff5==99.999\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff6=<span class="number">999.999</span>;   <span class="comment">// 测试6位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff6=%f\n&quot;</span>,ff6);</span><br><span class="line">  <span class="keyword">if</span> (ff6==<span class="number">999.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff6==999.999\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff7=<span class="number">9999.999</span>;   <span class="comment">// 测试7位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff7=%f\n&quot;</span>,ff7);</span><br><span class="line">  <span class="keyword">if</span> (ff7==<span class="number">9999.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff7==9999.999\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> ff8=<span class="number">99999.999</span>;   <span class="comment">// 测试8位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff8=%f\n&quot;</span>,ff8);</span><br><span class="line">  <span class="keyword">if</span> (ff8==<span class="number">99999.999</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff8==99999.999\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084005413.png" alt="在这里插入图片描述" /></p><p>从程序的运行我们可以看出float数的两个特征：</p><p>1）float数据类型表达的是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大，到8位的时候，误差了1，基本上不能用了。</p><p>2）用“==”可以比较两个整数或字符是否相等，但是，看起来相等的两个浮点数，就是不会相等。</p><h2 id="2-测试double类型"><a class="markdownIt-Anchor" href="#2-测试double类型"></a> 2、测试double类型</h2><p><strong>示例（book74.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book74.c，此程序测试double的特征</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> ff2=<span class="number">9.9</span>;   <span class="comment">// 测试2位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff2=%lf\n&quot;</span>,ff2);</span><br><span class="line">  <span class="keyword">if</span> (ff2==<span class="number">9.9</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff2与9.9相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff12=<span class="number">999999999.99</span>;   <span class="comment">// 测试12位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff12=%lf\n&quot;</span>,ff12);</span><br><span class="line">  <span class="keyword">if</span> (ff12==<span class="number">999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff12与999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff13=<span class="number">9999999999.99</span>;   <span class="comment">// 测试13位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff13=%lf\n&quot;</span>,ff13);</span><br><span class="line">  <span class="keyword">if</span> (ff13==<span class="number">9999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff13与9999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff14=<span class="number">99999999999.99</span>;   <span class="comment">// 测试14位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff14=%lf\n&quot;</span>,ff14);</span><br><span class="line">  <span class="keyword">if</span> (ff14==<span class="number">99999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff14与99999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff15=<span class="number">999999999999.99</span>;   <span class="comment">// 测试15位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff15=%lf\n&quot;</span>,ff15);</span><br><span class="line">  <span class="keyword">if</span> (ff15==<span class="number">999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff15与999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff16=<span class="number">9999999999999.99</span>;   <span class="comment">// 测试16位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff16=%lf\n&quot;</span>,ff16);</span><br><span class="line">  <span class="keyword">if</span> (ff16==<span class="number">9999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff16与9999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff17=<span class="number">99999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff17=%lf\n&quot;</span>,ff17);</span><br><span class="line">  <span class="keyword">if</span> (ff17==<span class="number">99999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ff18=<span class="number">999999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff18=%lf\n&quot;</span>,ff18);</span><br><span class="line">  <span class="keyword">if</span> (ff18==<span class="number">999999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084121487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>从程序的运行我们可以看出double数的两个特征：</p><p>1）double数据类型表达的也是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大，到17位的时候，误差了1，基本上不能用了。</p><p>2）用“==”可以比较两个double数值是否相等。</p><h2 id="3-测试long-double类型"><a class="markdownIt-Anchor" href="#3-测试long-double类型"></a> 3、测试long double类型</h2><p><strong>示例（book75.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book75.c，此程序测试long double的特征</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff2=<span class="number">9.9</span>;   <span class="comment">// 测试2位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff2=%Lf\n&quot;</span>,ff2);</span><br><span class="line">  <span class="keyword">if</span> (ff2==<span class="number">9.9</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff2与9.9相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff12=<span class="number">999999999.99</span>;   <span class="comment">// 测试12位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff12=%Lf\n&quot;</span>,ff12);</span><br><span class="line">  <span class="keyword">if</span> (ff12==<span class="number">999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff12与999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff13=<span class="number">9999999999.99</span>;   <span class="comment">// 测试13位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff13=%Lf\n&quot;</span>,ff13);</span><br><span class="line">  <span class="keyword">if</span> (ff13==<span class="number">9999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff13与9999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff14=<span class="number">99999999999.99</span>;   <span class="comment">// 测试14位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff14=%Lf\n&quot;</span>,ff14);</span><br><span class="line">  <span class="keyword">if</span> (ff14==<span class="number">99999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff14与99999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff15=<span class="number">999999999999.99</span>;   <span class="comment">// 测试15位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff15=%Lf\n&quot;</span>,ff15);</span><br><span class="line">  <span class="keyword">if</span> (ff15==<span class="number">999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff15与999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff16=<span class="number">9999999999999.99</span>;   <span class="comment">// 测试16位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff16=%Lf\n&quot;</span>,ff16);</span><br><span class="line">  <span class="keyword">if</span> (ff16==<span class="number">9999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff16与9999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff17=<span class="number">99999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff17=%Lf\n&quot;</span>,ff17);</span><br><span class="line">  <span class="keyword">if</span> (ff17==<span class="number">99999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">double</span> ff18=<span class="number">999999999999999.99</span>;   <span class="comment">// 测试17位的浮点数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ff18=%Lf\n&quot;</span>,ff18);</span><br><span class="line">  <span class="keyword">if</span> (ff18==<span class="number">999999999999999.99</span>) <span class="built_in">printf</span>(<span class="string">&quot;ff17与99999999999999.999相等。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084213344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>long double的测试结果与double相同。</p><h2 id="4-测试总结"><a class="markdownIt-Anchor" href="#4-测试总结"></a> 4、测试总结</h2><p>float只能表达6-7位的有效数字，不能用“==”判断两个数字是否相等。</p><p>double能表达15-16位有效的数字，可以用“==”判断两个数字是否相等。</p><p>long double占用的内存是double的两倍，但表达数据的精度和double相同。</p><p><strong>在实际开发中，建议弃用float，只采用double就可以，long double暂时没有必要，但不知道以后的操作系统和编译器对long double是否有改进。</strong></p><h1 id="四-浮点数的输出"><a class="markdownIt-Anchor" href="#四-浮点数的输出"></a> 四、浮点数的输出</h1><p>float采用%f占位符。</p><p>double采用%lf占位符。测试结果证明，double不可以用%f输入，但可以用%f输出，但是不建议采用%f，因为不同的编译器可能会有差别。</p><p>long double采用%Lf占位符，注意，L是大写。</p><p>浮点数输出缺省显示小数点后六位。</p><p>浮点数采用%lf输出，完整的输出格式是%m.nlf，指定输出数据整数部分和小数部分共占m位，其中有n位是小数。如果数值长度小于m，则左端补空格，若数值长度大于m，则按实际位数输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ff=<span class="number">70001.538</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%lf=\n&quot;</span>,ff);       <span class="comment">// 输出结果是ff=70001.538000=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%.4lf=\n&quot;</span>,ff);     <span class="comment">// 输出结果是ff=70001.5380=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%11.4lf=\n&quot;</span>,ff);   <span class="comment">// 输出结果是ff= 70001.5380=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ff=%8.4lf=\n&quot;</span>,ff);    <span class="comment">// 输出结果是ff=70001.5380=</span></span><br></pre></td></tr></table></figure><h1 id="五-常用的库函数"><a class="markdownIt-Anchor" href="#五-常用的库函数"></a> 五、常用的库函数</h1><p><strong>在接下来的内容中，我只介绍double，不再介绍float和long double两种数据类型相关的知识。</strong></p><p>以下是常用的浮点数函数，必须掌握。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;       <span class="comment">// 把字符串nptr转换为double</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span>;                <span class="comment">// 求双精度实数x的绝对值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>;      <span class="comment">// 求 x 的 y 次幂（次方）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">round</span><span class="params">(<span class="type">double</span> x)</span></span>;               <span class="comment">// double四舍五入</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">double</span> x)</span></span>;                <span class="comment">// double向上取整数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">floor</span><span class="params">(<span class="type">double</span> x)</span></span>;               <span class="comment">// double向下取整数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fmod</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span>;      <span class="comment">// 求x/y整除后的双精度余数</span></span><br><span class="line"><span class="comment">// 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中，返回小数部分。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">modf</span><span class="params">(<span class="type">double</span> val,<span class="type">double</span> *ip)</span></span>;</span><br></pre></td></tr></table></figure><p>还有一些数据计算函数，如正弦、对数、指数等，实际开发中极少使用，大家要用的时候再查资料，我就不介绍了。</p><h1 id="六-整数转换为浮点数"><a class="markdownIt-Anchor" href="#六-整数转换为浮点数"></a> 六、整数转换为浮点数</h1><p><strong>示例（book77.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book77.c，此程序测试整数与浮点数的转换。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> jj=<span class="number">4</span>;</span><br><span class="line">  <span class="type">double</span> dd;</span><br><span class="line"></span><br><span class="line">  dd=ii;        <span class="comment">// 可以</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2lf\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=ii/jj;     <span class="comment">// 不行</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2lf\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=(<span class="type">double</span>)ii/jj;  <span class="comment">// 可以</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2lf\n&quot;</span>,dd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084430801.png" alt="在这里插入图片描述" /></p><p>需要特别注意的是dd=ii/jj这一行代码，dd的值0，不是0.75，有点意外，所以，如果对整数转换为浮点数没有把握，加（double）强制转换是个好办法。关于数据类型的转换，在《C语言数据类型转换》章节中将有更详细的介绍。</p><h1 id="七-应用经验"><a class="markdownIt-Anchor" href="#七-应用经验"></a> 七、应用经验</h1><p>浮点数有一些坑，例如两个浮点数不相等和精度的问题，在实际开发中，我们经常用整数代替浮点数，因为整数是精确的，效率也更高。</p><p>例如人的身高一米七五，以米为单位，用浮点数表示是1.75米，如果以厘米为单位，用整数表示是175。</p><p>long整数的取值是-9223372036854775808~9223372036854775807，有效数字是19位，而double的有效数字才15-16位，所以，整数可以表达的小数更大的数，更实用，麻烦也更少。</p><p>货币：1.75元，如果采用0.01元为单位就是175，采用0.001元为单位就是1750，如果您说要更多小数怎么办？您这是钻牛角尖。</p><p><strong>码农之道：高水平的程序员不容易掉坑里，注意，是不容易，不是不会，最好的方法是不要靠近坑。</strong></p><h1 id="八-科学计数法"><a class="markdownIt-Anchor" href="#八-科学计数法"></a> 八、科学计数法</h1><p>在实际开发中，我们很少使用科学计数法，但是它经常出现在计算机系统中，例如浮点数在内存中的存放方式就是科学计数法，所以我们还是有必要学习科学计数法。</p><p>科学记数法是一种记数的方法。把一个数表示成a与10<sup>n</sup>相乘的形式（1≤|a|&lt;10，n为整数），这种记数法叫做科学记数法。当我们要书写或运算某个较大或较小且位数较多时，用科学记数法免去浪费很多空间和时间。</p><p>例如：51400000000=5.14×10<sup>11</sup>，计算机表达10的幂是一般是用E或e，也就是51400000000=5.14E11或5.14e11。</p><p>用科学记数法表示数时，不改变数的符号，只是改变数的书写形式而已，可以方便的表示日常生活中遇到的一些极大或极小的数 。如：光的速度大约是300,000,000米/秒；全世界人口数大约是：6,100,000,000，这样的数书写和显示都很不方便，为了免去写这么多重复的0，将其表现为这样的形式：6,100,000,000=6.1×10<sup>9</sup>，即6.1E9或6.1e9。</p><p>0.00001=1×10<sup>-5</sup>，即绝对值小于1的数也可以用科学记数法表示为a乘10<sup>-n</sup>的形式。即1E-5或1e-5。</p><p>科学计数法采用%e或%E输出，完整的输出格式是%m.ne或%<a href="http://m.nE">m.nE</a>，指定输出数据整数部分和小数部分共占m位，其中有n位是小数。如果数值长度小于m，则左端补空格，若数值长度大于m，则按实际位数输出。</p><p><strong>示例（book78.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book78.c，此程序测试浮点数据的科学计数法。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> dd;</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">123000000</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is  %.2e\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">-123000000</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2e\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">0.0000000123</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is  %.2e\n&quot;</span>,dd);</span><br><span class="line"></span><br><span class="line">  dd=<span class="number">-0.0000000123</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;dd is %.2e\n&quot;</span>,dd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200304084516467.png" alt="在这里插入图片描述" /></p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>1）编写示例程序，类似本章节的book71.c、book73.c、book74.c、book75.c、book77.c、book78.c，编译并运行它，程序员是写出来的，不是看出来的，熟能生巧，您每天的付出都有意义。</p><p>2）编写示例程序，测试浮点数赋值超过取值范围的后果。</p><p>3）关于浮点数在内存中的存储方式，建议大家去百度一下（搜索关键字为C语言浮点数存储方式），了解一下相关的概念。</p><p>4）编写示例程序，测试把浮点数赋给整数变量的结果，并思考原因。</p><p>5）本题作业建议在学完《C语言数据类型转换》后再做，因为有知识点交叉，重写浮点数的常用库函数，实现其功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">FABS</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;          <span class="comment">// 求双精度实数x的绝对值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ROUND</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;         <span class="comment">// double四舍五入</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">CEIL</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;          <span class="comment">// double向上取整数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">FLOOR</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;         <span class="comment">// double向下取整数</span></span><br><span class="line"><span class="comment">// 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中，返回小数部分。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">MODF</span><span class="params">(<span class="type">double</span> val,<span class="type">double</span> *ip)</span></span>;  </span><br></pre></td></tr></table></figure><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言字符</title>
      <link href="/posts/70da0f30.html"/>
      <url>/posts/70da0f30.html</url>
      
        <content type="html"><![CDATA[<p>在实际开发中，程序员很少用单个字符来表示数据，字符的意义主要作为数组的时候可以形成一个字符串。在本章节中，我们重点介绍字符与整数之间的关系和ASCII码的相关知识。</p><p>字符类型char，只能用单引号’ ‘来包围，不是用双引号&quot; “包围。而字符串只能用双引号”<br />&quot;包围，不能用单引号’ '包围。</p><p>输出字符使用 %c，输出字符串使用 %s。</p><h1 id="一-ascii码表"><a class="markdownIt-Anchor" href="#一-ascii码表"></a> 一、ASCII码表</h1><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码方案，它主要用于显示现代英语和其他西欧语言，它是现今最通用的单字节编码方案，等同于国际标准ISO/IEC646。</p><p>ASCII码规范于1967年第一次发布，最后一次更新是在1986年，它包含了33个控制字符（具有特殊含义无法显示的字符）和95个可显示字符。</p><h2 id="1-ascii-控制字符-字符编码-0-31"><a class="markdownIt-Anchor" href="#1-ascii-控制字符-字符编码-0-31"></a> 1、ASCII 控制字符 （字符编码: 0-31）</h2><p>在ASCII码表中，前32个字符是不能用于打印的编码，而是用于控制像打印机一样的外围设备。</p><table><thead><tr><th>十进制</th><th>符号</th><th>中文解释</th><th>十进制</th><th>符号</th><th>中文解释</th></tr></thead><tbody><tr><td>0</td><td>NULL</td><td>空字符</td><td>16</td><td>DLE</td><td>数据链路转义</td></tr><tr><td>1</td><td>SOH</td><td>标题开始</td><td>17</td><td>DC1</td><td>设备控制 1</td></tr><tr><td>2</td><td>STX</td><td>正文开始</td><td>18</td><td>DC2</td><td>设备控制 2</td></tr><tr><td>3</td><td>ETX</td><td>正文结束</td><td>19</td><td>DC3</td><td>设备控制 3</td></tr><tr><td>4</td><td>EOT</td><td>传输结束</td><td>20</td><td>DC4</td><td>设备控制 4</td></tr><tr><td>5</td><td>ENQ</td><td>询问</td><td>21</td><td>NAK</td><td>拒绝接收</td></tr><tr><td>6</td><td>ACK</td><td>收到通知</td><td>22</td><td>SYN</td><td>同步空闲</td></tr><tr><td>7</td><td>BEL</td><td>铃</td><td>23</td><td>ETB</td><td>传输块结束</td></tr><tr><td>8</td><td>BS</td><td>退格</td><td>24</td><td>CAN</td><td>取消</td></tr><tr><td>9</td><td>HT</td><td>水平制表符</td><td>25</td><td>EM</td><td>介质中断</td></tr><tr><td>10</td><td>LF</td><td>换行键</td><td>26</td><td>SUB</td><td>替换</td></tr><tr><td>11</td><td>VT</td><td>垂直制表符</td><td>27</td><td>ESC</td><td>换码符</td></tr><tr><td>12</td><td>FF</td><td>换页键</td><td>28</td><td>FS</td><td>文件分隔符</td></tr><tr><td>13</td><td>CR</td><td>回车键</td><td>29</td><td>GS</td><td>组分隔符</td></tr><tr><td>14</td><td>SO</td><td>移出</td><td>30</td><td>RS</td><td>记录分离符</td></tr><tr><td>15</td><td>SI</td><td>移入</td><td>31</td><td>US</td><td>单元分隔符</td></tr></tbody></table><h2 id="2-ascii-可打印字符-字符编码-32-127"><a class="markdownIt-Anchor" href="#2-ascii-可打印字符-字符编码-32-127"></a> 2、ASCII 可打印字符 （字符编码: 32-127）</h2><p>可打印字符共95个。</p><p>1）32是空格。</p><p>2）48～57为0到9十个阿拉伯数字；</p><p>3）65～90为26个大写英文字母；</p><p>4）97～122号为26个小写英文字母；</p><p>5）其余为一些标点符号、运算符号等；</p><p>6）第127个字符表示的是键盘上的删除命令。</p><table><thead><tr><th>十进制</th><th>符号</th><th>中文解释</th><th>十进制</th><th>符号</th><th>中文解释</th></tr></thead><tbody><tr><td>32</td><td></td><td>空格</td><td>80</td><td>P</td><td>大写字母 P</td></tr><tr><td>33</td><td>!</td><td>感叹号</td><td>81</td><td>Q</td><td>大写字母 Q</td></tr><tr><td>34</td><td>&quot;</td><td>双引号</td><td>82</td><td>R</td><td>大写字母 R</td></tr><tr><td>35</td><td>#</td><td>井号</td><td>83</td><td>S</td><td>大写字母 S</td></tr><tr><td>36</td><td>$</td><td>美元符</td><td>84</td><td>T</td><td>大写字母 T</td></tr><tr><td>37</td><td>%</td><td>百分号</td><td>85</td><td>U</td><td>大写字母 U</td></tr><tr><td>38</td><td>&amp;</td><td>与</td><td>86</td><td>V</td><td>大写字母 V</td></tr><tr><td>39</td><td>’</td><td>单引号</td><td>87</td><td>W</td><td>大写字母 W</td></tr><tr><td>40</td><td>(</td><td>左括号</td><td>88</td><td>X</td><td>大写字母 X</td></tr><tr><td>41</td><td>)</td><td>右括号</td><td>89</td><td>Y</td><td>大写字母 Y</td></tr><tr><td>42</td><td>*</td><td>星号</td><td>90</td><td>Z</td><td>大写字母 Z</td></tr><tr><td>43</td><td>+</td><td>加号</td><td>91</td><td>[</td><td>左中括号</td></tr><tr><td>44</td><td>,</td><td>逗号</td><td>92</td><td>\</td><td>反斜杠</td></tr><tr><td>45</td><td>-</td><td>连字号或减号</td><td>93</td><td>]</td><td>右中括号</td></tr><tr><td>46</td><td>.</td><td>句点或小数点</td><td>94</td><td>^</td><td>音调符号</td></tr><tr><td>47</td><td>/</td><td>斜杠</td><td>95</td><td>_</td><td>下划线</td></tr><tr><td>48</td><td>0</td><td>0</td><td>96</td><td>`</td><td>重音符</td></tr><tr><td>49</td><td>1</td><td>1</td><td>97</td><td>a</td><td>小写字母 a</td></tr><tr><td>50</td><td>2</td><td>2</td><td>98</td><td>b</td><td>小写字母 b</td></tr><tr><td>51</td><td>3</td><td>3</td><td>99</td><td>c</td><td>小写字母 c</td></tr><tr><td>52</td><td>4</td><td>4</td><td>100</td><td>d</td><td>小写字母 d</td></tr><tr><td>53</td><td>5</td><td>5</td><td>101</td><td>e</td><td>小写字母 e</td></tr><tr><td>54</td><td>6</td><td>6</td><td>102</td><td>f</td><td>小写字母 f</td></tr><tr><td>55</td><td>7</td><td>7</td><td>103</td><td>g</td><td>小写字母 g</td></tr><tr><td>56</td><td>8</td><td>8</td><td>104</td><td>h</td><td>小写字母 h</td></tr><tr><td>57</td><td>9</td><td>9</td><td>105</td><td>i</td><td>小写字母 i</td></tr><tr><td>58</td><td>:</td><td>冒号</td><td>106</td><td>j</td><td>小写字母 j</td></tr><tr><td>59</td><td>;</td><td>分号</td><td>107</td><td>k</td><td>小写字母 k</td></tr><tr><td>60</td><td>&lt;</td><td>小于</td><td>108</td><td>l</td><td>小写字母 l</td></tr><tr><td>61</td><td>=</td><td>等号</td><td>109</td><td>m</td><td>小写字母 m</td></tr><tr><td>62</td><td>&gt;</td><td>大于</td><td>110</td><td>n</td><td>小写字母 n</td></tr><tr><td>63</td><td>?</td><td>问号</td><td>111</td><td>o</td><td>小写字母 o</td></tr><tr><td>64</td><td>@</td><td>电子邮件符号</td><td>112</td><td>p</td><td>小写字母 p</td></tr><tr><td>65</td><td>A</td><td>大写字母 A</td><td>113</td><td>q</td><td>小写字母 q</td></tr><tr><td>66</td><td>B</td><td>大写字母 B</td><td>114</td><td>r</td><td>小写字母 r</td></tr><tr><td>67</td><td>C</td><td>大写字母 C</td><td>115</td><td>s</td><td>小写字母 s</td></tr><tr><td>68</td><td>D</td><td>大写字母 D</td><td>116</td><td>t</td><td>小写字母 t</td></tr><tr><td>69</td><td>E</td><td>大写字母 E</td><td>117</td><td>u</td><td>小写字母 u</td></tr><tr><td>70</td><td>F</td><td>大写字母 F</td><td>118</td><td>v</td><td>小写字母 v</td></tr><tr><td>71</td><td>G</td><td>大写字母 G</td><td>119</td><td>w</td><td>小写字母 w</td></tr><tr><td>72</td><td>H</td><td>大写字母 H</td><td>120</td><td>x</td><td>小写字母 x</td></tr><tr><td>73</td><td>I</td><td>大写字母 I</td><td>121</td><td>y</td><td>小写字母 y</td></tr><tr><td>74</td><td>J</td><td>大写字母 J</td><td>122</td><td>z</td><td>小写字母 z</td></tr><tr><td>75</td><td>K</td><td>大写字母 K</td><td>123</td><td>{</td><td>左大括号</td></tr><tr><td>76</td><td>L</td><td>大写字母 L</td><td>124</td><td>|</td><td>垂直线</td></tr><tr><td>77</td><td>M</td><td>大写字母 M</td><td>125</td><td>}</td><td>右大括号</td></tr><tr><td>78</td><td>N</td><td>大写字母 N</td><td>126</td><td>~</td><td>波浪号</td></tr><tr><td>79</td><td>O</td><td>大写字母 O</td><td>127</td><td></td><td>删除</td></tr></tbody></table><h2 id="3-转义字符"><a class="markdownIt-Anchor" href="#3-转义字符"></a> 3、转义字符</h2><p>对于 ASCII编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，也无法从键盘输入，C语言又定义了一种简单的书写方式，即转义字符的形式来表示。</p><p>转义字符完整的列表如下：</p><table><thead><tr><th><strong>转义字符</strong></th><th><strong>意义</strong></th><th><strong>ASCII码值</strong></th><th><strong>使用频率</strong></th></tr></thead><tbody><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头。</td><td>10</td><td>每天都用</td></tr><tr><td>\’</td><td>单引号。</td><td>39</td><td>常用</td></tr><tr><td>\&quot;</td><td>双引号。</td><td>34</td><td>常用</td></tr><tr><td>\\</td><td>反斜杠。</td><td>92</td><td>常用</td></tr><tr><td>\r</td><td>回车(CR)</td><td>13</td><td>windows平台常用，linux平台不常用。</td></tr><tr><td>\t</td><td>水平制表(HT) 。</td><td>9</td><td>20年前常用，现在不用。</td></tr><tr><td>\v</td><td>垂直制表(VT)。</td><td>11</td><td>20年前常用，现在不用。</td></tr><tr><td>\a</td><td>响铃(BEL)。</td><td>7</td><td>20年前常用，现在不用。</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列。</td><td>8</td><td>20年前常用，现在不用。</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头。</td><td>12</td><td>20年前常用，现在不用。</td></tr></tbody></table><p>\n是最常用的转义字符，表示换行，让文本从下一行的开头输出，前面的章节中已经多次使用。</p><p>\r\n用于windows平台DOS格式文件的换行。</p><p>单引号、双引号、反斜杠是特殊的字符，不能直接表示。</p><p>单引号是字符类型的开头和结尾，要使用\'表示。</p><p>双引号是字符串的开头和结尾，要使用\&quot;表示。</p><p>反斜杠是转义字符的开头，要使用[\\表示](file:///\表示)。</p><p><strong>示例（book67.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book67.c，此程序演示C语言的转义字符。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出&#x27;单引号\&#x27;的方法。\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出双引号\&quot;的方法。\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输出反斜杠\\的方法。\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;单引号&#x27;不转义也能输出。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><h1 id="在这里插入图片描述二-字符就是整数"><a class="markdownIt-Anchor" href="#在这里插入图片描述二-字符就是整数"></a> <img src="https://img-blog.csdnimg.cn/20200303181724545.png" alt="在这里插入图片描述" /><br />二、字符就是整数</h1><p><strong>字符和整数没有本质的区别</strong>。可以给 char变量一个字符，也可以给它一个整数；反过来，可以给 int变量一个整数，也可以给它一个字符。</p><p>char 变量在内存中存储的是字符对应的 ASCII 码值。如果以 %c 输出，会根据 ASCII码表转换成对应的字符，如果以 %d 输出，那么还是整数。</p><p>int 变量在内存中存储的是整数本身，如果以 %c 输出时，也会根据 ASCII码表转换成对应的字符。</p><p>也就是说，ASCII 码表将整数和字符关联起来了。</p><p>char类型占内存一个字节，signed char取值范围是-128-127，unsigned char取值范围是0-255。</p><p>如果整数大于255，那么整数还是字符吗？</p><p><strong>描述再准确一些，在char的取值范围内（0-255），字符和整数没有本质区别。</strong></p><p><strong>字符肯定是整数，0-255范围内的整数是字符，大于255的整数不是字符。</strong></p><p><strong>示例（book68.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book68.c，此程序演示字符与整数的关系</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a =  <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">  <span class="type">char</span> b =  <span class="number">70</span>;</span><br><span class="line">  <span class="type">int</span>  c =  <span class="number">71</span>;</span><br><span class="line">  <span class="type">int</span>  d = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a=%c, a=%d\n&quot;</span>, a, a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b=%c, b=%d\n&quot;</span>, b, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;c=%c, c=%d\n&quot;</span>, c, c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;d=%c, d=%d\n&quot;</span>, d, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303181818443.png" alt="在这里插入图片描述" /></p><p>在ASCII码表中，E、F、G、H 的值分别是 69、70、71、72。</p><h1 id="三-常用的库函数"><a class="markdownIt-Anchor" href="#三-常用的库函数"></a> 三、常用的库函数</h1><p>以下是常用的字符函数，必须掌握。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalpha</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalnum</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）或数字（&#x27;0&#x27;-&#x27;9&#x27;），返回非0值,否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isdigit</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是数字（&#x27;0&#x27;-&#x27;9&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">islower</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isupper</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回相应的小写字母（&#x27;a&#x27;-&#x27;z&#x27;）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toupper</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回相应的大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）</span></span><br></pre></td></tr></table></figure><p>以下是不常用的字符函数，极少使用，了解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isascii</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是字符（ASCII码中的0-127）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">iscntrl</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是作废字符（0x7F）或普通控制字符（0x00-0x1F），返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isprint</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是可打印字符（含空格）（0x20-0x7E）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ispunct</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是标点字符（0x00-0x1F）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isspace</span><span class="params">(<span class="type">int</span> ch)</span></span>;  <span class="comment">// 若ch是空格（&#x27; &#x27;），水平制表符（&#x27;/t&#x27;）,回车符（&#x27;/r&#x27;），走纸换行（&#x27;/f&#x27;），垂直制表符（&#x27;/v&#x27;），换行符（&#x27;/n&#x27;），返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isxdigit</span><span class="params">(<span class="type">int</span> ch)</span></span>; <span class="comment">// 若ch是16进制数（&#x27;0&#x27;-&#x27;9&#x27;,&#x27;A&#x27;-&#x27;F&#x27;,&#x27;a&#x27;-&#x27;f&#x27;）返回非0值，否则返回0。</span></span><br></pre></td></tr></table></figure><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>1）研究ascii码表，重点关心几个问题：</p><p>（1）字符是整数，整数可以进行加减运算，字符可以吗？</p><p>（2）字母’A’-‘Z’、‘a’-‘z’和数字’0’-'9’的ascii码值是不是连续的？</p><p>（3）字母’A’和’a’、'Z’和’z’的ascii码值的差是多少？</p><p>2）根据上面的研究结果，编写函数，实现字符操作常用的库函数的功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISALPHA</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISALNUM</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是字母（&#x27;A&#x27;-&#x27;Z&#x27;,&#x27;a&#x27;-&#x27;z&#x27;）或数字（&#x27;0&#x27;-&#x27;9&#x27;），返回非0值,否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISDIGIT</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是数字（&#x27;0&#x27;-&#x27;9&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISLOWER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISUPPER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TOLOWER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）返回相应的小写字母（&#x27;a&#x27;-&#x27;z&#x27;）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TOUPPER</span><span class="params">(<span class="type">int</span> ch)</span></span>;   <span class="comment">// 若ch是小写字母（&#x27;a&#x27;-&#x27;z&#x27;）返回相应的大写字母（&#x27;A&#x27;-&#x27;Z&#x27;）</span></span><br></pre></td></tr></table></figure><p>3）自定义一个函数，函数名是ctoi，利用ASCII码进行加减运算，把字符的’0’、‘1’、‘2’、‘3’、‘4’、‘5’、‘6’、‘7’、‘8’、'9’转换为整数的0、1、2、3、4、5、6、7、8、9。不允许用if和switch语句，只能用ASCII码运算，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ctoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> chr)</span></span>;  <span class="comment">// chr为用字符方式表示的数字，函数的返回值为数字的整数。</span></span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;0&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;0&#x27;</span>));    <span class="comment">// 输出结果是&#x27;0&#x27; is 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;9&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;9&#x27;</span>));    <span class="comment">// 输出结果是&#x27;9&#x27; is 9</span></span><br></pre></td></tr></table></figure><p>4）编写示例程序，测试char和unsigned char赋值超过取值范围的后果。</p><p>5）%不是转义字符，要输出%怎么办？</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言整数</title>
      <link href="/posts/2e0adcd5.html"/>
      <url>/posts/2e0adcd5.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-整数的概念"><a class="markdownIt-Anchor" href="#一-整数的概念"></a> 一、整数的概念</h1><p>整数是我们生活中常用的数据类型，也是编程中常用的一种数据，C语言使用int关键字来定义整数变量（int是 integer 的简写）。</p><p>在定义变量的时候，可以加signed、unsigned、short和long四种修饰符。</p><p><strong>signed</strong>：有符号的，可以表示正数和负数。</p><p><strong>unsigned</strong>：无符号的，只能表示正数，例如数组的下标、人的身高等。</p><p><strong>short</strong>：短的，现在主流的64位操作系统下，整数占用内存4个字节，使用 4<br />个字节保存较小的整数绰绰有余，会空闲出两个字节来，这些字节就白白浪费掉了。在C语言被发明的早期，或者在单片机和嵌入式系统中，内存都是非常稀缺的资源，所有的程序都在尽可能节省内存。</p><p><strong>long</strong>：长的，更长的整数。</p><h1 id="二-整数的取值范围"><a class="markdownIt-Anchor" href="#二-整数的取值范围"></a> 二、整数的取值范围</h1><p>整数的取值范围与计算机操作系统和C语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围。</p><p>一个字节有8个位，表示的数据的取值范围是2<sup>8</sup>-1，即255。</p><p>如果占用的内存是两个字节，无符号型取值范围是2<sup>8</sup>ⅹ2<sup>8</sup>-1。</p><p>如果占用的内存是四个字节，无符号型取值范围是2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>-1。</p><p>如果占用的内存是八个字节，无符号型取值范围是2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>ⅹ2<sup>8</sup>-1。</p><p>如果是有符号，取值范围减半，因为符号占一个位。</p><p>下面用一个示例代码来测试各种整数占用内存的大小。</p><p><strong>示例（book60.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book60.c，此程序演示整数占用内存的大小和取值范围。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">short</span> si;   <span class="comment">// 短整数</span></span><br><span class="line">  <span class="type">int</span>   ii;   <span class="comment">// 整数</span></span><br><span class="line">  <span class="type">long</span>  li;   <span class="comment">// 长整数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof short is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof int is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof long is %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303170955332.png" alt="在这里插入图片描述" /></p><p>sizeof是C语言中保留关键字，是一种运算符，不是函数，sizeof实际上是获取了数据在内存中所占用的存储空间，以字节为单位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;       <span class="comment">// sizeof(int)和sizeof(ii)都可以。</span></span><br></pre></td></tr></table></figure><p>根据book60.c的测试结果，我们可以得到各种整数的取值范围。</p><table><thead><tr><th>类型简写</th><th>类型全称</th><th>长度</th><th>取值范围</th></tr></thead><tbody><tr><td>short</td><td>[signed] short [int]</td><td>2字节</td><td>-32768~32767</td></tr><tr><td>unsigned short</td><td>unsigned short [int]</td><td>2字节</td><td>0~65535</td></tr><tr><td>int</td><td>[signed] int</td><td>4字节</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned int</td><td>unsigned [int]</td><td>4字节</td><td>0~4294967295</td></tr><tr><td>long</td><td>[signed] long [int]</td><td>8字节</td><td>-9223372036854775808~ 9223372036854775807</td></tr><tr><td>unsigned long</td><td>unsigned long [int]</td><td>8字节</td><td>0~18446744073709551615</td></tr></tbody></table><p>注意：</p><p>1）计算机用最高位1位来表达符号，unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍。</p><p>2）在写程序的时候，上表中括号[]的单词可以省略不书写。</p><p>3）在写程序的时候，给整数变量赋值不能超出变量的取值范围，编译的时候会出现类似以下的错误，程序运行也可能产生不可预后的后果。</p><p><img src="https://img-blog.csdnimg.cn/20200303171125136.png" alt="在这里插入图片描述" /></p><p>4）现在计算机的内存不值钱，建议程序员少用short，慎用int，多用long，内存不是问题，程序的稳定高于一切。</p><h1 id="三-整数的输出"><a class="markdownIt-Anchor" href="#三-整数的输出"></a> 三、整数的输出</h1><p>以下表格中，重点记住第一、二行十进制的输出格式，二十年来，八进制数我从来没有用过，十六进制数只在显示内存的地址时见过，所以大家不必关心八进制和十六进制的相关知识，了解即可。</p><p><img src="https://img-blog.csdnimg.cn/20200303175428412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>注意一个坑：输出格式控制符的类型最好与变量的类型一一对应，否则会出现意外的后果，示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">32767</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i %hd,%d\n&quot;</span>,i,i);</span><br><span class="line"><span class="type">int</span> j=<span class="number">32768</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j %hd,%d\n&quot;</span>,j,j);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i <span class="number">32767</span>,<span class="number">32767</span></span><br><span class="line">j <span class="number">-32768</span>,<span class="number">32768</span>     <span class="comment">// 得到了意外的输出结果，32768超出了short的取值范围。</span></span><br></pre></td></tr></table></figure><p>%hd用于输出短整数，最大值是32767，可以输出32767，但不能正常的输出32768。</p><h1 id="四-二进制数-八进制数和十六进制数的书写"><a class="markdownIt-Anchor" href="#四-二进制数-八进制数和十六进制数的书写"></a> 四、二进制数、八进制数和十六进制数的书写</h1><p>一个数字默认就是十进制的，表示一个十进制数字不需要任何特殊的格式。但是，表示一个二进制、八进制或者十六进制数字就不一样了，为了和十进制数字区分开来，必须采用某种特殊的写法，具体来说，就是在数字前面加上特定的字符，也就是加前缀。</p><h2 id="1-二进制"><a class="markdownIt-Anchor" href="#1-二进制"></a> 1、二进制</h2><p>二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是合法的二进制</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0b101</span>;      <span class="comment">// 换算成十进制为 5</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0b</span>110010;  <span class="comment">// 换算成十进制为 -50</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0B</span>100001;   <span class="comment">// 换算成十进制为 33</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是非法的二进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">101010</span>;  <span class="comment">// 无前缀 0B，相当于十进制</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0B</span>410;    <span class="comment">// 4不是有效的二进制数字</span></span><br></pre></td></tr></table></figure><p>请注意，标准的C语言并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。</p><h2 id="2-八进制"><a class="markdownIt-Anchor" href="#2-八进制"></a> 2、八进制</h2><p>八进制由 0~7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母o），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是合法的八进制数</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">015</span>;      <span class="comment">// 换算成十进制为 13</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0101</span>;    <span class="comment">// 换算成十进制为 -65</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0177777</span>;  <span class="comment">// 换算成十进制为 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是非法的八进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">256</span>;  <span class="comment">// 无前缀 0，相当于十进制</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">03</span>A2;  <span class="comment">// A不是有效的八进制数字</span></span><br></pre></td></tr></table></figure><h2 id="3-十六进制"><a class="markdownIt-Anchor" href="#3-十六进制"></a> 3、十六进制</h2><p>十六进制由数字 0~9、字母 A~F 或a~f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是合法的十六进制</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0X2A</span>;   <span class="comment">// 换算成十进制为 42</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0XA0</span>;  <span class="comment">// 换算成十进制为 -160</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0xffff</span>;   <span class="comment">// 换算成十进制为 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是非法的十六进制</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">5</span>A;    <span class="comment">// 没有前缀 0X，是一个无效数字</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0X3</span>H;  <span class="comment">// H不是有效的十六进制数字</span></span><br></pre></td></tr></table></figure><h2 id="4-需要注意的坑"><a class="markdownIt-Anchor" href="#4-需要注意的坑"></a> 4、需要注意的坑</h2><p><strong>在现实生活和工作中，我们在写十进制数的时候，为了对齐或其它原因，在数值前面加0是无关紧要的，但是，在C语言中，不要在十进制数前加0，会被计算机误认为是八进制数。</strong></p><h1 id="五-常用的库函数"><a class="markdownIt-Anchor" href="#五-常用的库函数"></a> 五、常用的库函数</h1><p>C语言提供了几个常用的库函数，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;  <span class="comment">// 把字符串nptr转换为int整数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;     <span class="comment">// 把字符串nptr转换为long整数</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">abs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> j)</span></span>;            <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">labs</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">int</span> j)</span></span>;     <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure><p><strong>示例（book61.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book61.c，此程序演示整数的atoi atol abs labs函数的使用</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// 如果不包含这个头文件，会出现意外的结果。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>  ii;</span><br><span class="line">  <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">  ii=<span class="built_in">atoi</span>(<span class="string">&quot;-2147483647&quot;</span>);</span><br><span class="line">  ll=<span class="built_in">atol</span>(<span class="string">&quot;-9223372036854775807&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ll=%ld\n&quot;</span>,ll);</span><br><span class="line"></span><br><span class="line">  ii=<span class="built_in">abs</span>(ii);</span><br><span class="line">  ll=<span class="built_in">labs</span>(ll);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ll=%ld\n&quot;</span>,ll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303171958780.png" alt="在这里插入图片描述" /></p><h1 id="六-数据类型的别名"><a class="markdownIt-Anchor" href="#六-数据类型的别名"></a> 六、数据类型的别名</h1><p>C语言允许程序员使用 typedef关键字来给数据类型定义一个别名，别名一般有两个特点：1）名称更短；2）更符合程序员的习惯。</p><p>例如unsigned int起个size_t的别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="type">size_t</span> ii; 等同于 <span class="type">unsigned</span> <span class="type">int</span> ii;</span><br></pre></td></tr></table></figure><p>我们来看看strlen函数的帮助，strlen的返回值就是size_t类型。</p><p><img src="https://img-blog.csdnimg.cn/20200303172117989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="七-随机数"><a class="markdownIt-Anchor" href="#七-随机数"></a> 七、随机数</h1><p>在实际开发中，会用到随机数这个功能，例如编写游戏类的程序时就需要用到随机数。</p><h2 id="1-生成随机数"><a class="markdownIt-Anchor" href="#1-生成随机数"></a> 1、生成随机数</h2><p>在C语言中，我们使用 &lt;stdlib.h&gt; 头文件中的 srand和rand 函数来生成随机数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span>;   <span class="comment">// 随机数生成器的初始化函数</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">rand</span><span class="params">()</span></span>;                        <span class="comment">// 获一个取随机数</span></span><br></pre></td></tr></table></figure><p>srand函数初始化随机数发生器（俗称种子），在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同，通常我们采用&lt;time.h&gt; 头文件中的 time 函数即可得到一个精确到秒的时间作为种子。</p><p><strong>示例（book63.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book63.c，此程序用于演示随机数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  <span class="comment">// 播下随机种子</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)  <span class="comment">// 生成5个随机数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">rand</span>());  <span class="comment">// 获取随机数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303172317661.png" alt="在这里插入图片描述" /></p><h2 id="2-生成一定范围随机数"><a class="markdownIt-Anchor" href="#2-生成一定范围随机数"></a> 2、生成一定范围随机数</h2><p>在实际开发中，需求往往是一定范围内的随机数，对于产生一定范围的随机数，就需要使用一定的技巧，常用的方法是取模运算（取余数），再加上一个加法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">50</span>;   <span class="comment">// 产生0~49的随机数</span></span><br></pre></td></tr></table></figure><p>如果要规定上下限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">51</span> + <span class="number">100</span>;   <span class="comment">// 产生100~150的随机数</span></span><br></pre></td></tr></table></figure><p>取模即取余数，rand()%51+100，rand()%51是产生 0~50 的随机数，后面+100保证 a最小只能是 100，最大就是 50+100=150。</p><h1 id="八-课后作业"><a class="markdownIt-Anchor" href="#八-课后作业"></a> 八、课后作业</h1><p>1）编写示例程序，判断short、unsigned short、int、unsigned int、long、unsigned long占用内存的字节数。</p><p>2）选择题：请问int的取值范围是多少？</p><p>（A）二十多亿 (B) -2147483648~2147483647 © 0~4294967295</p><p>3）选择题：请问long的取值范围是多少？</p><p>（A）很多个亿 (B) 足够大 © -9223372036854775808~9223372036854775807</p><p>4）编写示例程序，从界面上输入数字的字符串，存放在字符串变量中，然后用atoi函数转换为整数，加上100后再输出到屏幕。</p><p>5）在C语言中，还有一种long long int的整数，各位写一个程序，测试它占用内存的字节数和取值范围，并思考long long int类型是否具备实用价值。</p><p>6）编写示例程序，测试short、unsigned short、int、unsigned、long、unsigned long赋值超出了取值范围的后果。</p><p>7）重写整数的abs和labs库函数，实现其功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">ABS</span><span class="params">(<span class="type">const</span> <span class="type">int</span> j)</span></span>;                 <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">LABS</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">int</span> j)</span></span>;           <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure><p>8）利用已经学习的知识，自定义一个函数，函数名是ctoi，把字符的’0’、‘1’、‘2’、‘3’、‘4’、‘5’、‘6’、‘7’、‘8’、'9’转换为整数的0、1、2、3、4、5、6、7、8、9。函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ctoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> chr)</span></span>;</span><br><span class="line">chr为用字符方式表示的数字，函数的返回值为数字的整数。</span><br></pre></td></tr></table></figure><p>提示：采用if或switch语句，判断chr的值，直接返回结果。</p><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;0&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;0&#x27;</span>));    <span class="comment">// 输出结果是&#x27;0&#x27; is 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#x27;9&#x27; is %d\n&quot;</span>,<span class="built_in">ctoi</span>(<span class="string">&#x27;9&#x27;</span>));    <span class="comment">// 输出结果是&#x27;9&#x27; is 9</span></span><br></pre></td></tr></table></figure><p><strong>以下作业题难度较大，如果无法完成，不要过于纠结，以后功力提升了再做。</strong></p><p>9）自定义一个函数，函数名是POW，利用已经学习的知识，求一个数的n次幂，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x的y次幂，函数返回值为x的y次幂。</span></span><br><span class="line"><span class="function"><span class="type">long</span>  <span class="title">POW</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x,<span class="type">const</span> <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;POW(2,3) is %lu\n&quot;</span>,<span class="built_in">POW</span>(<span class="number">2</span>,<span class="number">3</span>));      <span class="comment">// 输出结果是8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;POW(10,3) is %lu\n&quot;</span>,<span class="built_in">POW</span>(<span class="number">10</span>,<span class="number">5</span>));    <span class="comment">// 输出结果是100000</span></span><br></pre></td></tr></table></figure><p>10）编写示例程序，把字符串里的数字全部加起来，例如字符串是&quot;90576483975423&quot;，全部加起来结果是72。</p><p>11）重写整数的atoi和atol库函数，实现其功能，函数的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">ATOI</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;  <span class="comment">// 把字符串nptr转换为int整数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ATOL</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;     <span class="comment">// 把字符串nptr转换为long整数</span></span><br></pre></td></tr></table></figure><p>提示：例如字符串的&quot;12305&quot;，转为整数12305，拆开就是10000+2000+300+0+5，即1*104+2*103+3*102+0*101+5*100</p><p>12）生成五十二个随机数，存放在数组中，范围是1-52，不允许重复，最后在屏幕上显示出来。</p><p>13）编写一个扑克的发牌程序，一副牌除了大小王，还有52张牌，随机洗牌，再发给四个人。</p><p>提示：</p><p>（1）把一副牌的全部牌面可以用1-52的数值表示，数组是一个好选择；</p><p>（2）洗牌就是生成范围在1-52之间不重复的随机数。</p><p>（3）定义四个数组，代表四个人，把洗好的52个数按顺序赋给四个数组就行了。如果不想定义四个数组，用一个二维数组也行。</p><p>（4）把四个数组的值显示出来，就是每个人的牌面。</p><h1 id="九-版权声明"><a class="markdownIt-Anchor" href="#九-版权声明"></a> 九、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针</title>
      <link href="/posts/cd7b170d.html"/>
      <url>/posts/cd7b170d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-变量的地址"><a class="markdownIt-Anchor" href="#一-变量的地址"></a> 一、变量的地址</h1><p>内存变量简称变量，在C语言中，每定义一个变量，系统就会给变量分配一块内存，而内存是有地址的。如果把计算机的内存区域比喻成一个大宾馆，每块内存的地址就像宾馆房间的编号。</p><p>C语言采用运算符&amp;来获取变量的地址。请看下面的示例。</p><p><strong>示例（book50.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book50.c，此程序用于演示获取变量的地址</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">10</span>;</span><br><span class="line">  <span class="type">char</span>   cc=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="type">double</span> dd=<span class="number">100.56</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;变量ii的地址是：%p\n&quot;</span>,&amp;ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;变量cc的地址是：%p\n&quot;</span>,&amp;cc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;变量dd的地址是：%p\n&quot;</span>,&amp;dd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303163622948.png" alt="在这里插入图片描述" /></p><p>注意：</p><p>1）在printf函数中，输出内存地址的格式控制符是%p，地址采用十六进制的数字显示。</p><p>2）book50程序运行了两次，每次输出的结果不一样，原因很简单，程序每次运行的时候，向系统申请内存，系统随机分配内存，就像您去宾馆开房，如果您不提前预约指定房号，每次得到的房间编号大概率不会相同。</p><h1 id="二-指针"><a class="markdownIt-Anchor" href="#二-指针"></a> 二、指针</h1><p>指针是一种特别变量，全称是指针变量，专用于存放其它变量在内存中的地址编号，指针在使用之前要先声明，语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datatype *varname;</span><br></pre></td></tr></table></figure><p>datatype 是指针的基类型，它必须是一个有效的C数据类型（int、char、double或其它自定义的数据类型），varname 是指针的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个场景中，星号是用来表示这个变量是指针。以下是有效的指针声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>     *ip;    <span class="comment">// 一个整型的指针</span></span><br><span class="line"><span class="type">char</span>    *cp;   <span class="comment">// 一个字符型的指针</span></span><br><span class="line"><span class="type">double</span> *dp;   <span class="comment">// 一个 double 型的指针</span></span><br></pre></td></tr></table></figure><h1 id="三-对指针赋值"><a class="markdownIt-Anchor" href="#三-对指针赋值"></a> 三、对指针赋值</h1><p>不管是整型、浮点型、字符型，还是其他的数据类型的内存变量，它的地址都是一个十六进制数，可以理解为内存单元的编号。我们用整数型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；用双精度型指针存放双精度型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址。</p><p>把指针指向具体的内存变量的地址，就是对指针赋值。</p><p><strong>示例book51.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book51.c，此程序用于演示指针变量</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">10</span>;</span><br><span class="line">  <span class="type">char</span>   cc=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="type">double</span> dd=<span class="number">100.56</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>    *pii=<span class="number">0</span>;  <span class="comment">// 定义整数型指针并初始化</span></span><br><span class="line">  <span class="type">char</span>   *pcc=<span class="number">0</span>;  <span class="comment">// 定义字符型指针并初始化</span></span><br><span class="line">  <span class="type">double</span> *pdd=<span class="number">0</span>;  <span class="comment">// 定义双精度型指针并初始化</span></span><br><span class="line"></span><br><span class="line">  pii=&amp;ii;  <span class="comment">// 数型指针并指向变量ii</span></span><br><span class="line">  pcc=&amp;cc;  <span class="comment">// 字符型指针并指向变量cc</span></span><br><span class="line">  pdd=&amp;dd;  <span class="comment">// 双精度型指针并指向变量dd</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出指针变量的值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pii的值是：%p\n&quot;</span>,pii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pcc的值是：%p\n&quot;</span>,pcc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pdd的值是：%p\n&quot;</span>,pdd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030316563339.png" alt="在这里插入图片描述" /></p><h1 id="四-通过指针操作内存变量"><a class="markdownIt-Anchor" href="#四-通过指针操作内存变量"></a> 四、通过指针操作内存变量</h1><p>定义了指针变量，并指向了内存变量的地址，就可以通过指针来操作内存变量（在指针前加星号*），效果与使用变量名相同。</p><p><strong>示例（book52.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book52.c，此程序演示指针的使用。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>    *pii=<span class="number">0</span>;  <span class="comment">// 定义整数型指针并初始化</span></span><br><span class="line"></span><br><span class="line">  pii=&amp;ii;  <span class="comment">// 数型指针指向变量ii</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过指针操作内存变量，改变内存变量的值</span></span><br><span class="line">  *pii=<span class="number">20</span>;    <span class="comment">// 同ii=20;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pii的值是：%p\n&quot;</span>,pii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pii的值是：%d\n&quot;</span>,*pii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii的值是：%d\n&quot;</span>,ii);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165713337.png" alt="在这里插入图片描述" /></p><h1 id="五-再来讨论函数的参数传递"><a class="markdownIt-Anchor" href="#五-再来讨论函数的参数传递"></a> 五、再来讨论函数的参数传递</h1><p>在我们之前讲的函数的参数章节中，book49.c演示了函数的参数传递，主程序调用funcld函数的时候，传递的是变量的值，现在把它修改一下。</p><p><strong>示例（book55.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book55.c，此程序演示函数参数的传递和指针</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明funcld函数，p是一个指针变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> *p)</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置一：a是一个变量，变量的地址是%p，a的值是 %d\n&quot;</span>,&amp;a,a);</span><br><span class="line">  <span class="built_in">funcld</span>(&amp;a);   <span class="comment">// 调用函数，传递变量a的地址的值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置二：a是一个变量，变量的地址是%p，a的值是 %d\n&quot;</span>,&amp;a,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置三：p是一个指针 %p, 指向的内存的地址是 %d\n&quot;</span>,p,*p);</span><br><span class="line">  *p=<span class="number">20</span>;   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置四：p是一个指针 %p, 指向的内存的地址是 %d\n&quot;</span>,p,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165801592.png" alt="在这里插入图片描述" /></p><p>book55.c演示了函数参数和指针的使用，主程序把变量a的地址传递给函数funcld，funcld函数的参数p是一个指针，接存放变量a的地址。在函数funcld中，根据指针中的地址直接操作内存，从而修改了主程序中变量a的值。</p><p>我们已经使用scanf函数很多次了，调用scanf函数的时候，需要在变量前面加符号&amp;，其实就是把变量的地址传给scanf函数，scanf函数根据传进去的地址直接操作内存，改变内存中的值，完成了对变量的赋值。</p><h1 id="六-空指针"><a class="markdownIt-Anchor" href="#六-空指针"></a> 六、空指针</h1><p>空指针就是说指针没有指向任何内存变量，指针的值是空，所以不能操作内存，否则可能会引起程序的崩溃。</p><p><strong>示例（book56.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book56.c，此程序演示操作空指针引起程序的崩溃</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> *pi=<span class="number">0</span>;  <span class="comment">// 定义一个指针</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pi的值是 %p\n&quot;</span>,pi);</span><br><span class="line"></span><br><span class="line">  *pi=<span class="number">10</span>;  <span class="comment">// 试图对空指针进行赋值操作，必将引起程序的崩溃</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165839327.png" alt="在这里插入图片描述" /></p><p>段错误（Core Dump），就是程序崩溃掉了。</p><h1 id="七-数组的地址"><a class="markdownIt-Anchor" href="#七-数组的地址"></a> 七、数组的地址</h1><p>在C语言中，数组占用的内存空间是连续的，数组名是数组元素的首地址，也是数组的地址。</p><p><strong>示例（book57.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book57.c，此程序数组的地址</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">51</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(name,<span class="string">&quot;C语言技术网(www.freecplus.net)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;name[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,&amp;name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,&amp;name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303165923151.png" alt="在这里插入图片描述" /></p><p>从以上的示例可以看出，数组名、对数组取地址和数组元素的首地址是同一回事。在应用开发中，程序员一般用数组名，书写最简单。</p><h1 id="八-地址的运算"><a class="markdownIt-Anchor" href="#八-地址的运算"></a> 八、地址的运算</h1><p>地址可以用加（+）和减（-）来运算，加1表示下一个存储单元的地址，减1表示上一个存储单元的地址，一般情况下，地址的运算适用于数组，对单个变量的地址运算没有意义。</p><p><strong>示例（book58.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book58.c，此程序演示地址的运算。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span>   cc[<span class="number">4</span>];   <span class="comment">// 字符数组</span></span><br><span class="line">  <span class="type">int</span>    ii[<span class="number">4</span>];   <span class="comment">// 整数数组</span></span><br><span class="line">  <span class="type">double</span> dd[<span class="number">4</span>];   <span class="comment">// 浮点数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用地址相加的方式显示数组全部元素的的址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,cc,cc+<span class="number">1</span>,cc+<span class="number">2</span>,cc+<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,ii,ii+<span class="number">1</span>,ii+<span class="number">2</span>,ii+<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,dd,dd+<span class="number">1</span>,dd+<span class="number">2</span>,dd+<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303170018581.png" alt="在这里插入图片描述" /></p><p>大家请注意，第一行输出的每个地址的增量是1，第二行的每个地址的增量是4，第三行的每个地址的增量是8，为什么会这样？因为数组cc是char型，一个存储单元是1个字节，数组ii是int型，一个存储单元是4个字节，数组ll是long型，一个存储单元是8个字节，地址加1指的是下一个存储单元，不是数学意义中的1。</p><p>在应用开发中，地址的运算很重要，主要用于字符串操作，在以后的字符串章节中我将详细介绍。</p><h1 id="九-指针占用内存情况"><a class="markdownIt-Anchor" href="#九-指针占用内存情况"></a> 九、指针占用内存情况</h1><p>指针也是一种内存变量，是内存变量就要占用内存空间，在C语言中，任何类型的指针占用8字节的内存（32位操作系统4字节）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(int *) is %d.\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span> *));        <span class="comment">// 输出：sizeof(int *) is 8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(char *) is %d.\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">char</span> *));      <span class="comment">// 输出：sizeof(char *) is 8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(double *) is %d.\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">double</span> *));  <span class="comment">// 输出：sizeof(double *) is 8</span></span><br></pre></td></tr></table></figure><p>输出的结果都是8。</p><h1 id="十-指针的其它知识"><a class="markdownIt-Anchor" href="#十-指针的其它知识"></a> 十、指针的其它知识</h1><p>本章节介绍的知识已经包括了指针99%的用法，还有一些的知识点如指针的指针、函数指针等，这些概念难以理解，应用场景极少。学习的方法应该是循序渐进，等功力增长之后，那些复杂的概念其实也很容易。如果在这里就把人搞晕了，就没办法继续学习下去。</p><h1 id="十一-小结"><a class="markdownIt-Anchor" href="#十一-小结"></a> 十一、小结</h1><p>操作变量可以用变量名，也可以用变量的地址。</p><p>指针用一句话可以概括，就是用来存放变量的地址，是一种中间状态的变量。</p><p>变量的地址是变量的地址，指针是指针，地址和指针之间的关系像水与水桶的关系，表达的时候要严谨一些，不要把地址说成指针，也不要把指针说成地址。</p><p>指针就这么简单，您自己不要把自己晕了就行。</p><h1 id="十二-课后作业"><a class="markdownIt-Anchor" href="#十二-课后作业"></a> 十二、课后作业</h1><p>1、编写示例程序，把本章节的知识全部演示一遍，必须充分理解每一个细节，指针对C/C++程序员极其重要，没有指针，程序没法写。</p><p>2、系统会为变量分配内存，也会为常量分配内存，有内存就有地址，试试以下代码，如果不能理解就跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pstr=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pstr=%p\n&quot;</span>,pstr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pstr=%s\n&quot;</span>,pstr);     <span class="comment">// 不会出现段错误（Core dump）</span></span><br><span class="line"><span class="built_in">strcpy</span>(pstr,<span class="string">&quot;杨玉环&quot;</span>);          <span class="comment">// 会出现段错误（Core dump）</span></span><br></pre></td></tr></table></figure><h1 id="十三-版权声明"><a class="markdownIt-Anchor" href="#十三-版权声明"></a> 十三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言变量的作用域</title>
      <link href="/posts/1f6773fc.html"/>
      <url>/posts/1f6773fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-变量的作用域"><a class="markdownIt-Anchor" href="#一-变量的作用域"></a> 一、变量的作用域</h1><p>作用域是程序中定义的变量存在（或生效）的区域，超过该区域变量就不能被访问。C语言中有四种地方可以定义变量。</p><p>1）在所有函数外部定义的是全局变量。</p><p>2）在头文件中定义的是全局变量。</p><p>3）在函数或语句块内部定义的是局部变量。</p><p>4）函数的参数是该函数的局部变量。</p><p>顺便解释一下，函数的声明和函数的定义是两个概念，但是，变量的定义和变量的声明是同一概念，或定义变量和声明变量也行，取决于程序员的表达习惯。</p><h1 id="二-全局变量"><a class="markdownIt-Anchor" href="#二-全局变量"></a> 二、全局变量</h1><p>全局变量是定义在函数外部，通常是在程序的顶部（其它地方也可以）。全局变量在整个程序生命周期内都是有效的，在定义位置之后的任意函数中都能访问。</p><p>全局变量在主程序退出时由系统收回内存空间。</p><p><strong>示例（book37.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book37.c，此程序用于演示全局变量的作用域</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.141592</span>; <span class="comment">// 全局变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; <span class="comment">// 声明一个自定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置一 pi=%f\n&quot;</span>,pi);</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置二 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置三 pi=%f\n&quot;</span>,pi);</span><br><span class="line">  pi=<span class="number">3.141593</span>;  <span class="comment">// 改变pi的值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置四 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，pi为全局变量，定义在main()和func1()之外，位于程序的顶部，在main()和func1()函数中都可以访问它。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030316292489.png" alt="在这里插入图片描述" /></p><h1 id="三-局部变量"><a class="markdownIt-Anchor" href="#三-局部变量"></a> 三、局部变量</h1><p>在某个函数或语句块的内部声明的变量称为局部变量，它们只能在该函数或语句块内部的语句使用。</p><p>局部变量在函数或语句块外部是不可用的。</p><p>局部变量在函数返回或语句块结束时由系统收回内存空间。</p><h1 id="四-函数的参数"><a class="markdownIt-Anchor" href="#四-函数的参数"></a> 四、函数的参数</h1><p>函数的参数被当作该函数内的局部变量。</p><p>建议各位再阅读《C语言函数》的” 九、函数参数的传递”章节。</p><h1 id="五-注意事项"><a class="markdownIt-Anchor" href="#五-注意事项"></a> 五、注意事项</h1><p>局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量。</p><p><strong>示例（book39.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book39.c，此程序演示局部变量与全局变量重名的情况.</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.141592</span>; <span class="comment">// 全局变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>; <span class="comment">// 声明一个自定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置一 pi=%f\n&quot;</span>,pi);</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置二 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> pi=<span class="number">3.141593</span>; <span class="comment">// 全局变量声明</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;位置三 pi=%f\n&quot;</span>,pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，定义了全局变量pi，在func1()函数中，定义了局部变量pi，func1()函数运行的时候，会使用自己的局部变量pi，不会使用全局变量pi，所以main函数中位置二输出pi的值是仍然3.141592。</p><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303163005938.png" alt="在这里插入图片描述" /></p><h1 id="六-课后作业"><a class="markdownIt-Anchor" href="#六-课后作业"></a> 六、课后作业</h1><p>编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。</p><h1 id="七-版权声明"><a class="markdownIt-Anchor" href="#七-版权声明"></a> 七、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数</title>
      <link href="/posts/cfb62513.html"/>
      <url>/posts/cfb62513.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-函数的概念"><a class="markdownIt-Anchor" href="#一-函数的概念"></a> 一、函数的概念</h1><h2 id="1-函数的概念"><a class="markdownIt-Anchor" href="#1-函数的概念"></a> 1、函数的概念</h2><p>每个C程序都至少有一个函数，即main主函数  ，如果程序的任务比较简单，全部的代码都写在main函数中，但是，在实际开发中，程序的任务往往比较复杂，如果全部的代码都写在main函数中，main函数体将非常庞大臃肿，代码重复。</p><p>我们可以把程序的任务分工到不同的子函数中，main更关心业务逻辑和处理流程，需要执行某任务的时候，调用子函数就可以了。</p><h2 id="2-函数的分类"><a class="markdownIt-Anchor" href="#2-函数的分类"></a> 2、函数的分类</h2><p>为了方使理解，我们把函数分为库函数和自定义函数（子函数）。</p><p>库函数是C语言提供的，实现了某些基本的功能，例如scanf、printf，在程序中可以直接使用。</p><p>自定义函数是程序员为了完成某项任务而编写的函数，目的是为了实现某项的功能或让主程序更简洁。自定义函数在使用之前，必须先声明和定义。</p><h1 id="二-自定义函数的声明"><a class="markdownIt-Anchor" href="#二-自定义函数的声明"></a> 二、自定义函数的声明</h1><p>自定义函数的声明包括了<strong>返回值</strong>、<strong>函数名</strong>和<strong>参数列表</strong>。有些程序员把函数声明说成是函数原型，只是用词不同，意思是一样的。</p><p>C语言中的声明函数的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure><p>1）返回值的数据类型return_type：函数执行完任务后的返回值，可以是int、char、double或其它自定义的数据类型。如果函数只执行任务而不返回值，return_type用关键字 void表示，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_name</span><span class="params">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure><p>2）函数名function_name：函数名是标识符，命名规则与变量相同。</p><p>3）参数列表parameter list：当函数被调用时，调用者需要向函数传递参数。参数列表包括参数的数据类型和书写顺序。参数列表是可选的，也就是说，函数可以没有参数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>函数声明示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断超女身材函数的声明</span></span><br><span class="line"><span class="comment">// 函数名：checksc</span></span><br><span class="line"><span class="comment">// 参数：height，身高，单位cm。</span></span><br><span class="line"><span class="comment">// 返回值：0-不合格；1-娇小；2-标准；3-高挑</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>声明了一个函数，返回值是int类型，函数名是checksc，函数只有一个参数int height，注意，函数的声明语句最后的分号不能少。</p><p>如果把自定义函数比喻成工具，函数的声明就是这个工具的设计图纸。</p><h1 id="三-自定义函数的定义"><a class="markdownIt-Anchor" href="#三-自定义函数的定义"></a> 三、自定义函数的定义</h1><p>自定义函数是工具，如果想让这个工具能被使用，光有设计图纸还不行，还要把工具制造出来，函数的定义就是这个工具的实际主体，是为了实现函数的功能而编写的代码。</p><p>C语言中的函数定义的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span>       <span class="comment">// 注意，不要在函数定义的最后加分号。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 实现函数功能的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义的return_type、function_name和parameter list必须与函数声明一致。</p><p>函数主体包含为了完成任务需要执行语句的集合，放在花括号内。</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断超女身材函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">160</span>) &amp;&amp; (height&lt;<span class="number">165</span>) ) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 娇小</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">165</span>) &amp;&amp; (height&lt;<span class="number">175</span>) ) <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">// 标准</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">175</span>) &amp;&amp; (height&lt;<span class="number">180</span>) ) <span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">// 高挑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 不合格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-自定义函数代码的组织"><a class="markdownIt-Anchor" href="#四-自定义函数代码的组织"></a> 四、自定义函数代码的组织</h1><h2 id="1-非通用能功的函数"><a class="markdownIt-Anchor" href="#1-非通用能功的函数"></a> 1、非通用能功的函数</h2><p>如果自定义函数只在调用者程序中使用，可以在调用者程序中声明和定义，声明一般为调用者程序的上部，定义一般在调用者程序的下部，这并不是C语言的规定，而是为了让程序更方便阅读，程序员约定的写法。</p><p><strong>示例（book45.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book45.c，此程序演示自定义函数在主程序中声明和定义</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断超女身材函数的声明</span></span><br><span class="line"><span class="comment">// 函数名：checksc</span></span><br><span class="line"><span class="comment">// 参数：height，身高，单位cm。</span></span><br><span class="line"><span class="comment">// 返回值：0-不合格；1-娇小；2-标准；3-高挑</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> ii,jj;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入超女的身高（单位：厘米）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ii);</span><br><span class="line"></span><br><span class="line">  jj=<span class="built_in">checksc</span>(ii);   <span class="comment">// 调用checksc函数判断身材</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;不合格。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;娇小。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;标准。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (jj==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;高挑。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断超女身材函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checksc</span><span class="params">(<span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">160</span>) &amp;&amp; (height&lt;<span class="number">165</span>) ) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 娇小</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">165</span>) &amp;&amp; (height&lt;<span class="number">175</span>) ) <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">// 标准</span></span><br><span class="line">  <span class="keyword">if</span> ( (height&gt;=<span class="number">175</span>) &amp;&amp; (height&lt;<span class="number">180</span>) ) <span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">// 高挑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 不合格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在book45.c中，判断超女身材的函数（checksc）不是公共的功能，只在选秀程序使用，所以它的声明和定义都写在book45.c中。</p><h2 id="2-通用能功的函数"><a class="markdownIt-Anchor" href="#2-通用能功的函数"></a> 2、通用能功的函数</h2><p>如果自定义函数是一个通用的功能模块，可以在公共的头文件中声明，在公共的程序文件中定义。</p><p>如果某程序需要调用公共的函数，在调用者程序中用#include指令包含公共的头文件，编译的时候把调用者程序和公共的程序文件一起编译。</p><p>在以下的示例中，函数min和max是公共的函数，在_public.h头文件中声明，在_public.c程序文件中定义，在book46.c程序中被调用。</p><p><strong>1）公共的头文件（_public.h）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：_public.h，公共功能函数声明的头文件</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明min函数，用于比较两个整数的大小，取小者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明max函数，用于比较两个整数的大小，取大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>2）公共的程序文件（_public.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：_public.c，公共功能函数声明的程序文件</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_public.h&quot;</span>  <span class="comment">// 包含自定义函数声明的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于比较两个整数的大小，函数返回较小者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span>   <span class="comment">// min函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ii1&lt;ii2) <span class="keyword">return</span> ii1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ii2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于比较两个整数的大小，函数返回较大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ii1,<span class="type">const</span> <span class="type">int</span> ii2)</span>   <span class="comment">// max函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ii1&gt;ii2) <span class="keyword">return</span> ii1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ii2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）调用者程序文件（book46.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 程序名：book46.c，此程序演示了在主程序的外部文件中声明和定义函数</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_public.h&quot;</span>  <span class="comment">// 把_public.h头文件包含进来</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> xx,yy,imin,imax;</span><br><span class="line"></span><br><span class="line">  xx=<span class="number">50</span>; yy=<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">  imin=<span class="built_in">min</span>(xx,yy);</span><br><span class="line">  imax=<span class="built_in">max</span>(xx,yy);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;imin=%d,imax=%d\n&quot;</span>,imin,imax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）编译运行</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303160551935.png" alt="在这里插入图片描述" /></p><h2 id="3-注意事项"><a class="markdownIt-Anchor" href="#3-注意事项"></a> 3、注意事项</h2><p>1）在book46.c的第5行<code>#include &quot;_public.h&quot;</code>，这里包含头文件是用双引号，不是尖括号&lt;&gt;，这两者的差别如下：</p><p><code>#include &lt;&gt;</code> 用于包含系统提供的头文件，编译的时候，gcc在系统的头文件目录中寻找头文件。</p><p><code>#include &quot;&quot;</code> 用于包含程序员自定义的头文件，编译的时候，gcc先在当前目录中寻找头文件，如果找不到，再到系统的头文件目录中寻找。</p><p>2）编译程序的时候，要把调用者程序和公共程序文件一起编译，否则编译器会报错。</p><p><img src="https://img-blog.csdnimg.cn/20200303160926738.png" alt="在这里插入图片描述" /></p><p>3）C语言对公共函数的头文件（_public.h）和程序文件（_public.c）的命名没有规定，由程序员自己命名，为了增加程序的可读性，尽可能采用一些有意义的文件名。</p><h1 id="五-库函数"><a class="markdownIt-Anchor" href="#五-库函数"></a> 五、库函数</h1><p>C语言提供了很多标准函数（C standard library），简称库函数，调用这些函数可以完成一些基本的功能，例如printf、scanf、memset、strcpy等。C语言的库函数有几百个，常用的不超过30%,在以后的章节中我将详细介绍常用库函数的应用场景和使用方法。</p><p>C语言标准库函数的声明的头文件存放在/usr/include目录中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;asset.h&gt;     &lt;ctype.h&gt;       &lt;errno.h&gt;     &lt;<span class="type">float</span>.h&gt;    &lt;limits.h&gt;</span><br><span class="line">&lt;locale.h&gt;    &lt;math.h&gt;     &lt;setjmp.h&gt;   &lt;signal.h&gt;     &lt;stdarg.h&gt;</span><br><span class="line">&lt;stddef.h&gt;   &lt;stdlib.h&gt;   &lt;stdio.h&gt;      &lt;string.h&gt;      &lt;time.h&gt;</span><br></pre></td></tr></table></figure><p>C语言库函数的定义的文件是<code>/usr/lib/gcc/x86_64-redhat-linux/4.4.4/libgcc.a</code>（不同编译器的版本目录名有所不同），这是一个打包好的库文件，把程序文件打包成库文件的方法以后再详细介绍。</p><p>我们用gcc编译程序的时候并没有把libgcc.a包含进来，那是因为gcc编译器缺省会包含它，但是，程序员自定义函数的程序文件就没有这种待遇，需要手工的包含进来与程序一起编译。</p><h1 id="六-需要包含哪些头文件"><a class="markdownIt-Anchor" href="#六-需要包含哪些头文件"></a> 六、需要包含哪些头文件</h1><p>我们在使用库函数的时候，如果不包含它的头文件，编译时会出现警告或错误，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200303161107208.png" alt="在这里插入图片描述" /><br />那么，在我们编写的程序中，应该包含哪些头文件呢？有两种方法，一是上百度上查资料，二是使用Linux系统提供的帮助，以strcpy函数为例，在命令行下输入man strcpy回车，如下：<br /><img src="https://img-blog.csdnimg.cn/20200303161137980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>man显示了函数的声明的头文件（第5行），函数的参数、使用方法和返回值。</p><p>注意了，如果程序中调用了库函数但没有包含它头文件，编译的时候不一定是警告，也可能是报错，函数无法识别等，这个要看编译器，不同C语言的编译器的处理方式不一样。</p><h1 id="七-调用函数的方法"><a class="markdownIt-Anchor" href="#七-调用函数的方法"></a> 七、调用函数的方法</h1><p>库函数是系统提供的工具，自定义函数是程序员自己补充的工具，对使用者来说都一样，没有区别。</p><p>在C语言中，函数的调用非常灵活，可以独占一行语句，也可以当成常量赋值给变量，也可以当成函数的参数。</p><p>如果函数的返回值是void，表示该函数的调用一定会成功，一般用单行书写，独占一条语句。</p><p>如果函数的返回值不是void，可以不关心它的返回值，也可以当成常量用于任何表达式中。</p><p><strong>示例（book47.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book47.c，此程序演示了函数的灵活调用。</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;_public.h&quot;</span>  <span class="comment">// 把_public.h头文件包含进来</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="built_in">max</span>(<span class="number">30</span>,<span class="number">45</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">max</span>(<span class="number">30</span>,<span class="number">20</span>);   <span class="comment">// 没有接收返回值，max的活白干了。</span></span><br><span class="line"></span><br><span class="line">  <span class="number">55</span>;      <span class="comment">// 这是什么鬼？</span></span><br><span class="line"></span><br><span class="line">  i=<span class="built_in">max</span>(<span class="built_in">min</span>(<span class="number">45</span>,<span class="number">38</span>),<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  i=<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">min</span>(<span class="number">45</span>,<span class="number">38</span>),<span class="number">50</span>),<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;30和50相比，更大的值是%d。\n&quot;</span>,<span class="built_in">max</span>(<span class="number">30</span>,<span class="number">50</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可能对这个代码不理解，一句话：如果函数的返回值是整数，就可以把函数当成整数来用，如果返回值是小数，就可以把函数当成小数来用，……。</p><h1 id="八-函数调用的过程"><a class="markdownIt-Anchor" href="#八-函数调用的过程"></a> 八、函数调用的过程</h1><p>在程序中调用子函数时，程序的流程进入子函数的代码中，当子函数返回时（或到达函数的结束括号时），程序的流程回到调用者程序。</p><p><strong>示例（book48.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *  程序名：book48.c，此程序演示了函数的调用的过程</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明func函数，无返回值无参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;即将调用func函数。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;调用func函数已完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);    <span class="comment">// sleep是C语言的库函数，睡眠</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已经过去了%d秒。\n&quot;</span>,ii+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161320905.png" alt="在这里插入图片描述" /></p><h1 id="九-函数参数的传递"><a class="markdownIt-Anchor" href="#九-函数参数的传递"></a> 九、函数参数的传递</h1><p>函数的参数可以理解为函数内部的变量，参数传递就是调用者程序把变量（或常量）的值复制一份给函数的参数，简单说来就是复制的过程。一旦完成数据的复制，调用者程序的变量和函数的参数就再也没有瓜葛了，所以，在函数调用的过程中，函数内部变量的值发生改变并不会影响调用者程序的变量的值。</p><p>我们在调用函数的时候，不关心函数参数的名称，函数参数的名称是函数自己的事情，是函数的内部变量，只在函数内部使用，与调用者无关。</p><p><strong>示例（book49.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book49.c，此程序演示了函数参数的传递</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> b)</span></span>;   <span class="comment">// 声明函数funcld，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;调用funcld前a的值是%d.\n&quot;</span>,a);</span><br><span class="line">  <span class="built_in">funcld</span>(a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;调用funcld后a的值是%d.\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcld</span><span class="params">(<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;赋值前b的值是%d.\n&quot;</span>,b);</span><br><span class="line">  b=<span class="number">20</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;赋值后b的值是%d.\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161452306.png" alt="在这里插入图片描述" /></p><p>关于函数的参数，在很多教程中有很多说法，如“形参”、“实参”、“值传递”、“地址传递”等，这些说法把简单的概念复杂化了，大家不必理会。</p><h1 id="十-const约束"><a class="markdownIt-Anchor" href="#十-const约束"></a> 十、const约束</h1><p>const 是 constant 的缩写，意思是“恒定不变的”，它是定义只读变量的关键字。用 const 定义只读变量的方法很简单，就在定义变量时前面加 const 即可，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span>  <span class="type">double</span>  pi = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p>用 const 定义的变量的值是不允许改变的，不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值，如果程序中试图改变它的值，编译的时候就会报错。</p><p>在变量前加const约束，主要用于定义函数的参数，表示该参数在函数中是只读取，不允许改变，如果函数中试图改变它的值，编译的时候就会报错。</p><p><strong>例如：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161546613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>编译如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303161558260.png" alt="在这里插入图片描述" /></p><p>为什么要在函数的参数前加const？有两个目的：1）防止程序员犯错，如果程序员犯了错误，编译器就能发现；2）增加了源代码的可读性。在实际开发中，函数的参数不加const不会有任何问题，但是，程序员一般都会为只读变量加上const约束，这是一个好的习惯。</p><h1 id="十一-应用经验"><a class="markdownIt-Anchor" href="#十一-应用经验"></a> 十一、应用经验</h1><h2 id="1-如何寻找函数"><a class="markdownIt-Anchor" href="#1-如何寻找函数"></a> 1、如何寻找函数</h2><p>在我的课程中，会介绍常用库函数的使用方法，但也有漏掉的。查资料能力是程序员的基本技能，它可以提升您解决问题的能力。</p><p>例如要查找C语言复制字符串功能的函数，在百度上输入“C语言复制字符串”搜索就可以了，您想查什么就输入什么。</p><p><img src="https://img-blog.csdnimg.cn/20200303161618819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>然后，打开多几个网页看看，基本上能找到答案。</p><p>注意一个问题，网上的内容太多太杂乱，大部分文章是初学者发的博客，重点关注百度百科的文章。</p><h2 id="2-测试函数的功能"><a class="markdownIt-Anchor" href="#2-测试函数的功能"></a> 2、测试函数的功能</h2><p>以strcpy函数为例，函数的声明如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>函数功能：字符串复制。</p><p>函数名：strcpy。</p><p>dest参数：目标字符串。</p><p>src参数：待复制的内容，有const约束。</p><p>返回值：返回dest，这是提高函数可用性的常用的处理方法。</p><p>用代码测试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,strname);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%s=\n&quot;</span>,<span class="built_in">strcpy</span>(strname,<span class="string">&quot;西施&quot;</span>));</span><br></pre></td></tr></table></figure><p>然后，看看输出的结果是不是“=西施=”，用=号夹住输出的内容是为了看清楚有没有其它的字符。</p><h1 id="十二-课后作业"><a class="markdownIt-Anchor" href="#十二-课后作业"></a> 十二、课后作业</h1><p>1）编写示例程序，自定义一个根据超女的胸围判断身材的函数，判断标准由您定，类似book45.c。</p><p>2）C语言的库函数肯定是不够用的，程序员必须要有自己的函数库，从本章节就开始准备，创建您自己的函数库的头文件和程序文件，头文件和程序文件的命名由您定，先放两个函数进去，声明如下，然后写示例程序调用它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明max函数，取两个数值的较大者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> ii1,<span class="type">int</span> ii2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明min函数，取两个数值的较小者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> ii1,<span class="type">int</span> ii2)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个自定义函数的功能虽然简单，但是，千里之行，始于足下，慢慢积累。</p><p>3）本章节的内容非常重要，建议大家看多几遍视频，用程序测试每个知识点，充分的理解它。</p><h1 id="十三-版权声明"><a class="markdownIt-Anchor" href="#十三-版权声明"></a> 十三、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数组</title>
      <link href="/posts/8a19dc2c.html"/>
      <url>/posts/8a19dc2c.html</url>
      
        <content type="html"><![CDATA[<p>先来看一个需求，超女选秀一共有5人参加，输入每位超女的体重并保存在变量中，最后计算出超女的的平均体重。</p><p><strong>示例(book40.c)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book40.c，此程序用于演示没有数组的情况下的多个变量求和</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> aa,bb,cc,dd,ee;  <span class="comment">// 定义5个变量存放5名超女的体重</span></span><br><span class="line">  aa=bb=cc=dd=ee=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第1名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;aa);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第2名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;bb);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第3名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;cc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第4名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;dd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第5名超女的体重（公斤）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;ee);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;超女的平均体重是：%lf\n&quot;</span>,(aa+bb+cc+dd+ee)/<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有100名超女，这个程序将会很长很烦锁。</p><h1 id="一-数组"><a class="markdownIt-Anchor" href="#一-数组"></a> 一、数组</h1><p>数组（array）是一组数据类型相同的变量，可以存放一组数据，它定义的语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[数组长度];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> money[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>money是一个数组，包含了20个元素，每个元素都一个double类型的变量，可以通过下标访问数组中元素（element），数组下标的编号从0开始，数组的第1个元素是money[0]，第2个元素是money[1]，以此类推，直到第20个元素money[19]。</p><p>给每个元素赋double类型的值，可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">money[<span class="number">0</span>] = <span class="number">10.55</span>;</span><br><span class="line">money[<span class="number">1</span>] = <span class="number">32.54</span>;</span><br><span class="line">money[<span class="number">2</span>] = <span class="number">2055.65</span>;</span><br><span class="line">……</span><br><span class="line">money[<span class="number">19</span>] = <span class="number">2055.65</span>;</span><br></pre></td></tr></table></figure><p>定义数组的时候，数组的长度必须是整数，可以是常量，也可以是变量。</p><p>数据的下标也必须是整数，可以是常量，也可以是变量。</p><p>使用数组元素和使用同类型的变量一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;money[<span class="number">4</span>]);   <span class="comment">// 把一个值读入数组的第5个元素</span></span><br></pre></td></tr></table></figure><p>数组的类型可以是任意数据类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>      no[<span class="number">22</span>];　   <span class="comment">// 可储存22个int类型整数的数组</span></span><br><span class="line"><span class="type">char</span>    actors[<span class="number">26</span>];　<span class="comment">// 可储存26个字符的数组</span></span><br><span class="line"><span class="type">double</span> big[<span class="number">500</span>];　　<span class="comment">// 可储存500个double类型整数的数组</span></span><br></pre></td></tr></table></figure><h1 id="二-占用内存的大小"><a class="markdownIt-Anchor" href="#二-占用内存的大小"></a> 二、占用内存的大小</h1><p>我们已经知道如何获取单个变量占用内存大小的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;       <span class="comment">// 定义一个整型变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ii)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(ii));     <span class="comment">// 输出结果：sizeof(ii)=4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ii)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">// 输出结果：sizeof(ii)=4</span></span><br></pre></td></tr></table></figure><p>数组是有多个变量组成，占用内存总空间的大小为多个变量占用的内存空间之和，用sizeof（数组名）就可以得到整个数组占用内存的大小，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii[<span class="number">10</span>];    <span class="comment">// 定义一个整型数组变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ii)=%d\n&quot;</span>,<span class="built_in">sizeof</span>(ii));     <span class="comment">// 输出结果：sizeof(ii)=40</span></span><br></pre></td></tr></table></figure><h1 id="三-数组的初始化"><a class="markdownIt-Anchor" href="#三-数组的初始化"></a> 三、数组的初始化</h1><p>采用memset函数对数组进行初始化，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> no[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(no,<span class="number">0</span>,<span class="built_in">sizeof</span>(no));</span><br></pre></td></tr></table></figure><p>第一个参数是数组名，第二个参数填0，第三个参数是数组占用的内存总空间，用sizeof(变量名)获取。</p><h1 id="四-注意事项"><a class="markdownIt-Anchor" href="#四-注意事项"></a> 四、注意事项</h1><p>1）定义数组的时候，数组的长度必须是整数，可以用常量和变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> numbers[size];</span><br></pre></td></tr></table></figure><p>2）使用数组的时候，数组的下标也必须是整数，可以用常量和变量。</p><p>3）使用数组的时候，编译器不会检查数组的下标是否正确，但是在程序中下标一定不能越界，如果程序运行时数组下标越界，就相当于访问了其它程序的内存，可能会导致程序异常中断（Core dump），后果非常严重。</p><p>示例（book41.c）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book41.c，此程序演示数组下标越界的后果</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> sum[<span class="number">5</span>];    <span class="comment">// 定义一维数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="number">100</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br><span class="line">    sum[ii]=ii;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030315195384.png" alt="在这里插入图片描述" /></p><p>段错误，就是程序非法操作内存，引起程序的崩溃。</p><p>如果数组的下标越界了，是不是一定会引起程序的崩溃呢？不一定，如果把book41.c的循环改为6，可能就不会出现段错误。</p><h1 id="五-在for循环中数组"><a class="markdownIt-Anchor" href="#五-在for循环中数组"></a> 五、在for循环中数组</h1><p>在学习了数组的知识以后，本章节开始时的那个需求有了更好的解决方法，程序book40.c必须修改。</p><p><strong>示例（book42.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book42.c，此程序演示采用for循环语句和数组结合使用</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">0</span>;           <span class="comment">// 用于循环的计数器</span></span><br><span class="line">  <span class="type">int</span>    total=<span class="number">5</span>;        <span class="comment">// 超女的总人数，初始化为5</span></span><br><span class="line">  <span class="type">double</span> weight[total];  <span class="comment">// 定义数组，用于存放超女的体重</span></span><br><span class="line">  <span class="type">double</span> sum=<span class="number">0</span>;          <span class="comment">// 存放超女体重的和</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="built_in">sizeof</span>(weight));    <span class="comment">// 初始化数组为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环输入超女的体重，并计算体重的总和</span></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;total;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d名超女的体重：&quot;</span>,ii+<span class="number">1</span>);   <span class="comment">// 输入提示信息</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;weight[ii]);    <span class="comment">// 接受从键盘输入的体重</span></span><br><span class="line">    sum=sum+weight[ii];          <span class="comment">// 计算超女体重的和</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;超女的平均体重是：%lf\n&quot;</span>,sum/total);  <span class="comment">// 输出平均体重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303152119212.png" alt="在这里插入图片描述" /></p><p>for循环提供了一个简单直接的方法来使用数组下标，使用数组和for循环处理数据，这比使用5个单独的scanf语句方便得多。不管是5个还是100个超女，程序也不会再增加代码。</p><h1 id="六-二维数组"><a class="markdownIt-Anchor" href="#六-二维数组"></a> 六、二维数组</h1><p>二维数组定义的语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[第一维的长度][第二维的长度];</span><br></pre></td></tr></table></figure><p>在我们现实生活中，二维数组到处都是，例如超女选秀，一共有5个小组，每组4人，如果要指明某位超女，必须同时指明该超女的小组编号和她在组内序号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> girl[<span class="number">5</span>][<span class="number">4</span>];</span><br><span class="line">girl[<span class="number">0</span>][<span class="number">0</span>]    girl[<span class="number">0</span>][<span class="number">1</span>]    girl[<span class="number">0</span>][<span class="number">2</span>]    girl[<span class="number">0</span>][<span class="number">3</span>] </span><br><span class="line">girl[<span class="number">1</span>][<span class="number">0</span>]    girl[<span class="number">1</span>][<span class="number">1</span>]    girl[<span class="number">1</span>][<span class="number">2</span>]    girl[<span class="number">1</span>][<span class="number">3</span>]</span><br><span class="line">girl[<span class="number">2</span>][<span class="number">0</span>]    girl[<span class="number">2</span>][<span class="number">1</span>]    girl[<span class="number">2</span>][<span class="number">2</span>]    girl[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line">girl[<span class="number">3</span>][<span class="number">0</span>]    girl[<span class="number">3</span>][<span class="number">1</span>]    girl[<span class="number">3</span>][<span class="number">2</span>]    girl[<span class="number">3</span>][<span class="number">3</span>]</span><br><span class="line">girl[<span class="number">4</span>][<span class="number">0</span>]    girl[<span class="number">4</span>][<span class="number">1</span>]    girl[<span class="number">4</span>][<span class="number">2</span>]    girl[<span class="number">4</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>也可以将二维数组看成一个坐标系，有 x 轴和 y 轴，要想在一个平面中确定一个点，必须同时指定 x 和 y 值。</p><p>二维数组的初始化也是用memset，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(girl,<span class="number">0</span>,<span class="built_in">sizeof</span>(girl));</span><br></pre></td></tr></table></figure><p>把本章节刚开始的那个需求增加一点难度：超女选秀有3个组，每组有5名选手，请提供一个界面，输入每个超女的体重，最后计算每组的超女的平均体重。</p><p><strong>示例（book43.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book43.c，此程序演示采用for循环语句和二维数组结合使用</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">0</span>;          <span class="comment">// 用于组别循环的计数器</span></span><br><span class="line">  <span class="type">int</span>    jj=<span class="number">0</span>;          <span class="comment">// 用于超女人数循环的计数器</span></span><br><span class="line">  <span class="type">int</span>    <span class="keyword">class</span>=<span class="number">3</span>;       <span class="comment">// 小组总数，初始化为3</span></span><br><span class="line">  <span class="type">int</span>    total=<span class="number">5</span>;       <span class="comment">// 每个组超女的总人数，初始化为5</span></span><br><span class="line">  <span class="type">double</span> weight[<span class="keyword">class</span>][total];  <span class="comment">// 定义二维数组，存放超女的体重</span></span><br><span class="line">  <span class="type">double</span> sum[<span class="keyword">class</span>];    <span class="comment">// 定义一维数组存放超女体重的和</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="built_in">sizeof</span>(weight));   <span class="comment">// 初始化数组为0</span></span><br><span class="line">  <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="built_in">sizeof</span>(sum));          <span class="comment">// 初始化数组为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用两个循环，第一级循环为小组数，第二级循环为超女人数</span></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;<span class="keyword">class</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (jj=<span class="number">0</span>;jj&lt;total;jj++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d组第%d名超女的体重：&quot;</span>,ii+<span class="number">1</span>,jj+<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;weight[ii][jj]);    <span class="comment">// 接受从键盘输入的体重</span></span><br><span class="line">      sum[ii]=sum[ii]+weight[ii][jj];  <span class="comment">// 计算小组超女体重的和</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303152310597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="七-多维数组"><a class="markdownIt-Anchor" href="#七-多维数组"></a> 七、多维数组</h1><p>从二维数组可以类推出多维数组的用法，在实际开发中，二维以上的数组应用场景很少。</p><p>对初学者来说，建议先不要把这个问题复杂化，能掌握一维和二维数组就可以了，等功力提升之后，会发现多维数组其实也很容易。</p><h1 id="八-字符串"><a class="markdownIt-Anchor" href="#八-字符串"></a> 八、字符串</h1><h2 id="1-字符串的概念"><a class="markdownIt-Anchor" href="#1-字符串的概念"></a> 1、字符串的概念</h2><p>字符串就是一个以空字符’\0’结束的字符数组，是一个特别的字符数组，这是约定，是规则。</p><p>空字符’\0’也可以直接写成0。</p><p><img src="https://img-blog.csdnimg.cn/20200303152347745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>因为字符串需要用0结束，所以在定义字符串的时候，要预留多一个字节来存放0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];  <span class="comment">// 定义一个最多存放20个字符或10个汉字的字符串</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串的初始化"><a class="markdownIt-Anchor" href="#2-字符串的初始化"></a> 2、字符串的初始化</h2><p>字符串是数组，当然可以用初始化数组的方法来初始化字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br></pre></td></tr></table></figure><h2 id="3-字符串的赋值"><a class="markdownIt-Anchor" href="#3-字符串的赋值"></a> 3、字符串的赋值</h2><p>如果想在strword中存入字符串“hello”，可以用strcpy函数，也可以采用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(strword,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 或者用以下代码</span></span><br><span class="line"><span class="type">char</span> strword[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strword,<span class="number">0</span>,<span class="built_in">sizeof</span>(strword));</span><br><span class="line">strword[<span class="number">0</span>]=<span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">strword[<span class="number">1</span>]=<span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">strword[<span class="number">2</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">strword[<span class="number">3</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">strword[<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">strword[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;      <span class="comment">// 或者 name[5]=0;</span></span><br></pre></td></tr></table></figure><h2 id="4-关于字符串结束符0的讨论"><a class="markdownIt-Anchor" href="#4-关于字符串结束符0的讨论"></a> 4、关于字符串结束符0的讨论</h2><p>您可能会问，如果字符串不用0结束，会有什么样的结果，我们用代码来演示一下。</p><p><strong>示例（book44.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book44.c，此程序用于演示字符串没有用0结束的后果</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">3</span>];</span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"></span><br><span class="line">  name[<span class="number">0</span>]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  name[<span class="number">1</span>]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  name[<span class="number">2</span>]=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s=\n&quot;</span>,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303152730327.png" alt="在这里插入图片描述" /></p><p>可以看到，输出abc之后，有乱码，并且每次执行程序输出的结果不可预知。</p><p>您可能还会问，如果字符串以0结束了，但是后面的内容并不是0，怎么办？<strong>后面的内容将被丢弃。</strong></p><h2 id="5-字符串数组"><a class="markdownIt-Anchor" href="#5-字符串数组"></a> 5、字符串数组</h2><p>以0结束的一维字符数组是一个字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">21</span>];       <span class="comment">// 可以存放20个字符的字符串</span></span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname,<span class="string">&quot;我真的可以存十个汉字&quot;</span>);</span><br></pre></td></tr></table></figure><p>给一维字符数组加上一维，就是字符串数组了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strname[<span class="number">10</span>][<span class="number">21</span>];   <span class="comment">// 10个字符串，每个字符串可以存放20个字符</span></span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="built_in">sizeof</span>(strname));</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">0</span>],<span class="string">&quot;坦已&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">1</span>],<span class="string">&quot;褒似&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">2</span>],<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">3</span>],<span class="string">&quot;王昭君&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">4</span>],<span class="string">&quot;貂婵&quot;</span>);</span><br><span class="line">……</span><br><span class="line"><span class="built_in">strcpy</span>(strname[<span class="number">9</span>],<span class="string">&quot;陈圆圆&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="十-课后作业"><a class="markdownIt-Anchor" href="#十-课后作业"></a> 十、课后作业</h1><p>1）编写示例程序，从界面上输入一个字符串，计算字符串的长度。如果输入的是&quot;abcdaaf&quot;，显示的结果是7。</p><p>2）编写示例程序，从界面上输入一个字符串，把字符串的每个字符从左到右一个一个的显示出来，如果输入的是&quot;abcdaaf&quot;，显示的结果是：a b c d a a f。</p><p>3）编写示例程序，从界面上输入一个字符串，把字符串的每个字符从右到左一个一个的显示出来，如果输入的是&quot;abcdaaf&quot;，显示的结果是：f a a d c b a。</p><p>4）编写示例程序，某班有10个学生，定义一个一维数组，从界面上输入每个学生的成绩，最后显示这个班的平均成绩。</p><p>5）编写示例程序，某年级有两个班，每班有8名学生，定义一个二维数组，从界面上输入每个学生的成绩，最后显示每个班的平均成绩和年级的平均成绩。</p><p>6）编写示例程序，定义一个可以存放10个字符串的数组，字符串的有效长度是30个字符，从界面上输入10个字符串并存放在数组中，然后把这10个字符串显示出来。</p><p><strong>以下题难难度较大，可以等到以后功力提升的时候再做。</strong></p><p>7）如果还觉得不过隐，可以挑战一下三维数组，某学校有两个年级，每个年级有三个班，每个班有四名学生，从界面上输入每个学生的成绩，最后显示每个班的平均成绩、年级的平均成绩和全校的平均成绩。</p><p><strong>别玩三维以上的数组，没什么意义。</strong></p><h1 id="十一-版权声明"><a class="markdownIt-Anchor" href="#十一-版权声明"></a> 十一、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言循环结构</title>
      <link href="/posts/c5f99b02.html"/>
      <url>/posts/c5f99b02.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-程序结构"><a class="markdownIt-Anchor" href="#一-程序结构"></a> 一、程序结构</h1><p>在C语言程序中，一共有三种程序结构：顺序结构、选择结构(if和switch分支结构)、循环结构；</p><p>1）顺序结构</p><p>从头到尾一句接着一句的执行下去，直到执行完最后一句；</p><p>2）选择结构</p><p>执行到某个节点时，根据判断条件的结果来决定执行分支的方向，由if和switch实现。</p><p>3）循环结构</p><p>循环结构有一个循环体，循环体里是一段代码。对于循环结构来说，判断循环的条件，来决定是否继续执行循环体，由while、do while和for来实现。</p><h1 id="二-while循环"><a class="markdownIt-Anchor" href="#二-while循环"></a> 二、while循环</h1><p>while循环的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是，先计算<strong>表达式</strong>的值，当值为真时（非0即是真），执行<strong>语句块</strong>，执行完<strong>语句块</strong>后，回到循环首部再次计算<strong>表达式</strong>的值，如果为真，又执行一次<strong>语句块</strong>……，这个过程会一直重复，直到<strong>表达式</strong>的值为假，就不再执行<strong>语句块</strong>。</p><p>循环也常常出现在我们的生活中，以超女选秀为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超女已准备出场</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (是否有未出场的超女)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 判断超女的年龄</span></span><br><span class="line">  <span class="comment">// 判断超女的身材</span></span><br><span class="line">  <span class="comment">// 判断超女的颜值</span></span><br><span class="line">  <span class="comment">// 送往后宫</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超女选秀就是一个循环，<strong>是否有未出场的超女</strong>是循环首部要判断的条件，它的取值会随着循环次数的增加而改变，<strong>判断超女的年龄、判断超女的身材、判断超女的颜值、送往后宫</strong>是循环体，随着循环次数的增加，全部的超女已出场，循环体不再执行。</p><h1 id="三-do-while循环"><a class="markdownIt-Anchor" href="#三-do-while循环"></a> 三、do while循环</h1><p>do while循环的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;  <span class="keyword">while</span> (表达式)</span><br></pre></td></tr></table></figure><p>do while先执行一次循环，然后再判断表达式的值，如果为真，再执行一次循环体，如此重复下去。</p><p>在实际开发中，几乎不用 do while，所以就不讲它了。</p><h1 id="四-循环的跳转"><a class="markdownIt-Anchor" href="#四-循环的跳转"></a> 四、循环的跳转</h1><p>continue和break两个关键字用在循环体中，用于控制循环体代码的执行流程。</p><p>continue跳转到循环的首部。</p><p>break跳出循环。</p><p>以超女选秀为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超女已准备出场</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (是否有未出场的超女)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 判断超女的年龄</span></span><br><span class="line">  <span class="keyword">if</span> (年龄小于<span class="number">16</span>岁) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">// 判断超女的身材</span></span><br><span class="line">  <span class="keyword">if</span> (身材不火辣) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">// 判断超女的颜值</span></span><br><span class="line">  <span class="keyword">if</span> (颜值不漂亮) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">// 判断已选出的超女数量，如果已经有10位了，就不要再选了</span></span><br><span class="line">  <span class="keyword">if</span> (已选出的超女数量等于<span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送往后宫</span></span><br></pre></td></tr></table></figure><p>超女出场后，先看看身份证上的年龄，如果不够16岁，没到法定年龄，评委就会说直接下一个，即continue，这个不够16岁的小姑娘直接回家。</p><p>如果本次选秀的任务是选出10位超女，如果选出的超女已经有10位了，活动结束，即break，没选上的和没出场的直接回家。</p><h1 id="五-while循环的应用"><a class="markdownIt-Anchor" href="#五-while循环的应用"></a> 五、while循环的应用</h1><p>利用一个循环，把用户每次从键盘输入的数据累加起来，如果总和超过了5000，循环结束。</p><p><strong>示例（book31.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book31.c，此程序用于演示while循环 </span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> times=<span class="number">0</span>;   <span class="comment">// 记录用户输入数据的次数</span></span><br><span class="line">  <span class="type">int</span> value=<span class="number">0</span>;   <span class="comment">// 用户每次从键盘输入的数据</span></span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;     <span class="comment">// 记录用户输入数据的和</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (sum&lt;<span class="number">5000</span>)  <span class="comment">// 如果sum的值小于5000，进入循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;value);        <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">    times++;                   <span class="comment">// 用户输入数据的次数自增1</span></span><br><span class="line">    sum=sum+value;             <span class="comment">// 记录用户输入数据的和</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;您一共输入了%d个数据，和为%d。\n&quot;</span>,times,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303145623106.png" alt="在这里插入图片描述" /></p><h1 id="六-for循环"><a class="markdownIt-Anchor" href="#六-for循环"></a> 六、for循环</h1><p>for循环的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>;表达式;语句<span class="number">2</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>1）for循环开始时，会先执行<strong>语句1</strong>，而且在整个循环过程中只执行一次<strong>语句1</strong>。</p><p>2）接着判断<strong>表达式</strong>的条件，如果条件成立，就执行一次循环体中的<strong>语句块</strong>。</p><p>3）<strong>语句块</strong>执行完后，接下来会执行<strong>语句2</strong>。</p><p>4）重复第2）步和第3），直到<strong>表达式</strong>的条件不成立才结束for循环。</p><p>注意：</p><p>1）在for循环中，<strong>语句1</strong>、<strong>表达式</strong>和<strong>语句2</strong>都可以为空，for (;;)等同于while (1)。</p><p>2）continue和break两个关键字也可以用在for循环体中。</p><p>for循环一般与计数器一起使用。例如：把1到100之间的数值累加起来。</p><p><strong>示例（book33.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book33.c，此程序用于演示for循环</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">1</span>;      <span class="comment">// 用于for循环的计数器</span></span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;     <span class="comment">// 记录1到100的累积值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">1</span>;ii&lt;=<span class="number">100</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum=sum+ii;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1到100的累积值为%d。\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303145839138.png" alt="在这里插入图片描述" /></p><h1 id="七-for循环嵌套"><a class="markdownIt-Anchor" href="#七-for循环嵌套"></a> 七、for循环嵌套</h1><p>我们再来看超女选秀例子，超女共分为3组，每组有4位超女，主持人利用for循环嵌套来安排超女们出场。</p><p><strong>示例（book35.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book35.c，此程序用于演示for循环的嵌套</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ii=<span class="number">0</span>;         <span class="comment">// 超女分组编号的计数器</span></span><br><span class="line">  <span class="type">int</span> jj=<span class="number">0</span>;         <span class="comment">// 每组超女序号的计数器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">1</span>;ii&lt;=<span class="number">3</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (jj=<span class="number">1</span>;jj&lt;=<span class="number">4</span>;jj++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;第%d组的第%d位超女出场。\n&quot;</span>,ii,jj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303145956691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="八-循环的选择"><a class="markdownIt-Anchor" href="#八-循环的选择"></a> 八、循环的选择</h1><p>for循环可以实现while循环的功能，while循环也可以实现for循环的功能，没有那个更好的说法，要看应用场景。</p><p><strong>for循环更合适事先知道循环总次数的场景，一般与计数器或数组结合一起使用，数组的知识我们在后面介绍。</strong></p><p><strong>while循环更合适事先不知道循环总次数的场景，以达到某个目标为目，例如超女选秀，报名有多少人没关系，已选够10位或没人可选是循环的结束。</strong></p><h1 id="九-死循环"><a class="markdownIt-Anchor" href="#九-死循环"></a> 九、死循环</h1><p>死循环是指循环的条件永远为真。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现死循环的情况有两种：1）程序的逻辑错误；2）程序员故意为之。第一种情况就不说了，程序员自己去解决，第二种是程序功能的需要，但是程序员仍有其它的办法让程序中止，这么说可能难以理解，没关系，在以后的课程中将会介绍。</p><p>如果您的程序不小心进入了死循环，可以用Ctrl+c中止。</p><h1 id="十-应用技巧"><a class="markdownIt-Anchor" href="#十-应用技巧"></a> 十、应用技巧</h1><p>1）for循环的计数器，习惯的写法是for (ii=0;ii&lt;=10;ii++)，表示从0、1……到10，从小到大的方式计数，但是在某些应用场景中，可能需要从大到小的方式计数，for (ii=10;ii&gt;=0;ii–)，也是可以的。</p><p>2）for循环的计数器，习惯的写法是for (ii=0;ii&lt;=10;ii++)，表示从0、1……到10，从小到大一次增加1的方式，但是在某些应用场景中，计数器不一定是增加ii++，ii=ii+2也是可以的。</p><h1 id="十一-课后作业"><a class="markdownIt-Anchor" href="#十一-课后作业"></a> 十一、课后作业</h1><p>1）采用一个while循环，把1到100之间的数值累加起来，实现book33.c程序的功能。</p><p>2）采用一个for循环，把用户每次从键盘输入的数值累加起来，如果总和超过了5000，循环结束，实现book31.c程序的功能。</p><p>3）采用您认为更合适的循环，输出九九乘法表，如下：<br /><img src="https://img-blog.csdnimg.cn/20200314094948289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />4）采用一个while循环，接受键盘输入的整数，如果输入的整数大于100，丢弃；如果输入的整数小于等100，把每次输入值累加起来，如果输入的整数值为0，跳出循环。最后显示输入了的有效的数据（大于0小于等于100的数）的个数，并显示有效数据的总和。</p><p>5）采用一个循环，输出0到100之间的偶数。</p><p>6）采用一个循环，输出0到100之间的能整除5的数字。</p><p>7）一共有5名超女，采用一个循环，在界面上输入超女数据，按下列要求选出妃子、宫女和杂役。循环结束后，显示选秀结果（妃子、宫女、杂役的人数）。</p><p>妃子：（1）年龄18-25岁；（2）身高165-178cm；（3）身材火辣；（4）颜值漂亮。</p><p>宫女：（1）年龄18-30岁；（2）身高160-165cm；（3）身材火辣或者普通；（4）颜值一般。</p><p>嬷嬷：（1）年龄35-40岁；（2）身高155-165cm；（3）身材普通或者飞机场；（4）颜值一般。</p><h1 id="十二-版权声明"><a class="markdownIt-Anchor" href="#十二-版权声明"></a> 十二、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言switch分支结构</title>
      <link href="/posts/d98a7bd.html"/>
      <url>/posts/d98a7bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-if-else的不足"><a class="markdownIt-Anchor" href="#一-if-else的不足"></a> 一、if else的不足</h1><p>C语言虽然没有限制 if else 能够处理的分支数量，但当分支过多时，用 if else处理会不太方便，而且容易出现 if else配对出错的情况。例如，输入一个整数，输出该整数对应的星期几的中文表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">2</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">3</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">4</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">5</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">6</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码摘自book22.c。</p><p>对于这种情况，实际开发中一般使用 switch 语句代替，请看下面的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不解释这段代码的含义，但这样看起来舒服多了。</p><h1 id="二-switch语句"><a class="markdownIt-Anchor" href="#二-switch语句"></a> 二、switch语句</h1><p>switch 是另外一种选择结构的语句，用来代替简单的、拥有多个分枝的 if else语句，基本格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 整型数值<span class="number">1</span>: 语句 <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> 整型数值<span class="number">2</span>: 语句 <span class="number">2</span>;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">case</span> 整型数值n: 语句 n;</span><br><span class="line">  <span class="keyword">default</span>: 语句 n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的执行过程是：</p><p>1）首先计算<strong>表达式</strong>的值，假设为<strong>value</strong>。</p><p>2） 从第一个 case 开始，比较<strong>value</strong>和<strong>整型数值1</strong>，如果它们相等，就执行冒号后面的所有语句，也就是从<strong>语句1</strong>一直执行到语句<strong>n+1</strong>，而不管后面的case 是否匹配成功。</p><p>3） 如果<strong>value</strong> 和<strong>整型数值1</strong>不相等，就跳过冒号后面的<strong>语句1</strong>，继续比较第二个case、第三个case……一旦发现和某个整型数值相等了，就会执行后面所有的语句。假设<strong>value</strong>和<strong>整型数值5</strong>相等，那么就会从<strong>语句5</strong>一直执行到<strong>语句n+1</strong>。</p><p>4）如果直到最后一个整型数值n都没有找到相等的值，那么就执行 default 后的<strong>语句n+1</strong>。</p><p>需要重点强调的是，当和某个整型数值匹配成功后，会执行该分支以及后面所有分支的语句。</p><p><strong>示例（book29.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book29.c，此程序演示条件分支控制语句用switch代替多个if else </span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    day=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量用于接受键盘输入的数字</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入0-6之间的数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (day)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303143655613.png" alt="在这里插入图片描述" /></p><p>输入4，发现和第四个分支匹配成功，于是就执行第四个分支以及后面的所有分支。这显然不是我们想要的结果，我们希望只执行第四个分支，而跳过后面的其他分支。为了达到这个目标，必须要在每个分支最后添加break;语句。</p><p>break 是C语言中的一个关键字，专门用于跳出 switch 语句。所谓“跳出”，是指一旦遇到break，就不再执行switch中的任何语句，包括当前分支中的语句和其他分支中的语句；也就是说，整个switch执行结束了，接着会执行整个 switch 后面的代码。</p><p><strong>示例（book30.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book30.c，此程序演示条件分支控制语句用switch中break的用法。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    day=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量用于接受键盘输入的数字</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入0-6之间的数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (day)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303143742801.png" alt="在这里插入图片描述" /></p><h1 id="三-注意事项"><a class="markdownIt-Anchor" href="#三-注意事项"></a> 三、注意事项</h1><ol><li>case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能包含任何变量。请看下面的例子。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (result)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:      <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>+<span class="number">9</span>:     <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，表达式8+9==17是整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:     <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，字符可以转换为整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:     <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，字符可以转换为整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>:  <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 正确，字符可以转换为整数</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3.14</span>:    <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 错误，不能为小数</span></span><br><span class="line">  <span class="keyword">case</span> ii:      <span class="built_in">printf</span>(<span class="string">&quot;...&quot;</span>); <span class="keyword">break</span>;    <span class="comment">// 错误，不能采用变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>default 不是必须的。当没有 default 时，如果所有case都匹配失败，那么就什么都不执行。</li></ol><h1 id="四-课后作业"><a class="markdownIt-Anchor" href="#四-课后作业"></a> 四、课后作业</h1><p>编写示例程序，在界面上输入数字的月份（1-12），采用switch语句，输出对应月份的英文单词的简写和全称。</p><h1 id="五-版权声明"><a class="markdownIt-Anchor" href="#五-版权声明"></a> 五、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言if分支结构</title>
      <link href="/posts/f33ab266.html"/>
      <url>/posts/f33ab266.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-关系运算符"><a class="markdownIt-Anchor" href="#一-关系运算符"></a> 一、关系运算符</h1><p>在讲if条件分支结构之前，先了解关系运算（Relational<br />Operators），用于判断条件，决定程序的流程。</p><table><thead><tr><th>关系</th><th>数学中的表示</th><th>C语言的表示</th></tr></thead><tbody><tr><td>小于</td><td>&lt;</td><td>&lt;</td></tr><tr><td>小于等于</td><td>≤</td><td>&lt;=</td></tr><tr><td>大于</td><td>&gt;</td><td>&gt;</td></tr><tr><td>大于等于</td><td>≥</td><td>&gt;=</td></tr><tr><td>等于</td><td>=</td><td>==</td></tr><tr><td>不等于</td><td>≠</td><td>!=</td></tr></tbody></table><p>C语言的基本数据类型有char、int、double，我们暂时认为只有char和int适用于上述关系运算符，double和字符串（字符数组）的关系运算以后再讨论。</p><p>注意了：</p><p>1）“=”是赋值，“==”才是判断两个数是否相等，不能混用。</p><p>2）C语言没有“之间”、“中间”、“之内”或“在某范围内”的关系运算符，例如年龄在25-30岁之间，只能表达为：<strong>年龄大于等于25岁</strong> 并且 <strong>年龄小于等于30岁</strong>。</p><h1 id="二-条件判断"><a class="markdownIt-Anchor" href="#二-条件判断"></a> 二、条件判断</h1><p>在我们的生活中，不是全部的事情都按顺序进行的，需要根据客观条件做出判断和选择，例如超女选秀，限制了16岁才能参加，16岁以下是不能参加的。这时候程序就需要做出判断，判断报名者的年龄是否满16岁，并给出提示。</p><p>在C语言中，使用if和else关键字对条件进行判断，先看下面的代码。</p><p><strong>示例（book20.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book20.c，此程序演示条件分支控制语句if else的使用。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    age=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量age，存放用户输入的年龄</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入您的年龄：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;age);              <span class="comment">// 接受从键盘输入的年龄数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">16</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果用户已满18岁，执行这段代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;亲，您已成年，可以报名超女选秀，祝您好运！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果用户小于16岁，执行这段代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这位童鞋，不好意思哦，等您16岁之后再来吧！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303120324443.png" alt="在这里插入图片描述" /></p><p>这段代码中，age&gt;=18是需要判断的条件，&gt;=表示“大于等于”，等价于数学中的≥。</p><p>if 和 else 是C语言的关键字，if就是“如果”，else就是“否则”，用来对条件进行判断，并根据判断结果执行不同的语句。总结起来，if else的结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件)</span><br><span class="line">&#123;</span><br><span class="line">  语句块<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是，如果判断条件成立，那么执行语句块1，否则执行语句块2。其执行过程可表示为下图：</p><p><img src="https://img-blog.csdnimg.cn/20200303120409313.png" alt="在这里插入图片描述" /><br />所谓语句块（Statement Block），就是由{}包围的一个或多个语句的集合。如果语句块中只有一条语句，也可以省略{ }，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">16</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;亲，您已成年，可以报名超女选秀，祝您好运！\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;这位童鞋，不好意思哦，等您16岁之后再来吧！\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">16</span>)  <span class="built_in">printf</span>(<span class="string">&quot;亲，您已成年，可以报名超女选秀，祝您好运！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;这位童鞋，不好意思哦，等您16岁之后再来吧！\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于if else语句可以根据不同的情况执行不同的代码，所以也叫分支结构或选择结构，上面的代码中，就有两个分支。</p><p>注意，不要在if (判断条件)后面加分号，以下是错误的，初学者容易犯这种错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>如果这么写，表示条件成立后，执行一条空语句。</p><h1 id="三-只使用if语句"><a class="markdownIt-Anchor" href="#三-只使用if语句"></a> 三、只使用if语句</h1><p>有的时候，我们需要在满足某种条件时进行一些操作，而不满足条件时就不进行任何操作，这个时候我们可以只使用if 语句。也就是说，if else 不必同时出现。</p><p>单独使用 if 语句的形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件)</span><br><span class="line">  &#123;</span><br><span class="line">    语句块</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>意思是，如果判断条件成立就执行语句块，否则直接跳过。其执行过程可表示为下图：</p><p><img src="https://img-blog.csdnimg.cn/20200303120735211.png" alt="在这里插入图片描述" /></p><p>例如超女选秀，被淘汰的超女，活动组织方给被淘汰的超女发放路费，标准是2000元/人，但是，节目的赞助方有个富二代，决定给颜值漂亮的超女多发500元。</p><p><strong>示例（book21.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book21.c，此程序演示条件分支控制语句只有if没有else的情况。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    yz=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量存放超女的颜值：1-漂亮；2-一般</span></span><br><span class="line">  <span class="type">int</span>    money=<span class="number">2000</span>;  <span class="comment">// 发放路费的基本金额</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请问超女的颜值（1-漂亮；2-一般）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;yz);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (yz == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果超女颜值漂亮，多给500元的路费</span></span><br><span class="line">    money=money+<span class="number">500</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此超女发放金额为%d元。\n&quot;</span>,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303120856862.png" alt="在这里插入图片描述" /></p><h1 id="四-多个if-else语句"><a class="markdownIt-Anchor" href="#四-多个if-else语句"></a> 四、多个if else语句</h1><p>if else 语句也可以多个同时使用，构成多个分支，形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式一)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块一</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式二)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块二</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式三)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块三</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式n)</span><br><span class="line"> &#123;</span><br><span class="line">   语句块n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   全部的条件都不符时执行此语句块x</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>意思是，从上到下依次检测判断条件，当某个判断条件成立时，则执行其对应的语句块，然后跳出整个if else 语句之外继续执行其他代码。如果所有判断条件都不成立，则执行语句块x。</p><p>也就是说，一旦遇到能够成立的判断条件，则不再执行其他的语句块，所以最终只能有一个语句块被执行。</p><p>例如，使用多个 if else 语句判断输入的数字表达的星期数。</p><p><strong>示例（book22.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book22.c，此程序演示条件分支控制语句有多个 if else的情况。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    day=<span class="number">0</span>;   <span class="comment">// 定义一个整数变量用于接受键盘输入的数字</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入0-6之间的数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line">  <span class="keyword">if</span> (day == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入错误。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030312113742.png" alt="在这里插入图片描述" /></p><p>建议大家慎用 else if这种程序结构，因为这种程序结构容易把人搞晕，解决这类需求有其它更好的方法，例如后面章节中将要学习的switch比else if 更合适。</p><h1 id="五-if语句的嵌套"><a class="markdownIt-Anchor" href="#五-if语句的嵌套"></a> 五、if语句的嵌套</h1><p>if语句也可以嵌套使用，例如：</p><p><strong>示例（book23.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book23.c，此程序演示条件分支控制语句有多个if嵌套的情况。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a,b;   <span class="comment">// 定义两个整数变量，用于比较大小</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入两个数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);              <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a == b)      <span class="comment">// 两个数相等的情况</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a(%d) 等于 (%d)\n&quot;</span>,a,b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>             <span class="comment">// 两个数不相等的情况</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)     <span class="comment">// a大于b的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a(%d) 大于 b(%d)\n&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">// 剩下的就是a小于b的情况了</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a(%d) 小于 b(%d)\n&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303121300645.png" alt="在这里插入图片描述" /></p><h1 id="六-保持良好的编程习惯"><a class="markdownIt-Anchor" href="#六-保持良好的编程习惯"></a> 六、保持良好的编程习惯</h1><p>if 语句嵌套时，要注意 if 和 else 的配对问题，C语言规定，else 总是与它前面最近的if配对。各位一定要保持良好的编程习惯，空格、缩进、对齐，{}成对的书写等，不良的代码习惯会把自己搞晕。</p><h1 id="七-逻辑运算符"><a class="markdownIt-Anchor" href="#七-逻辑运算符"></a> 七、逻辑运算符</h1><p>在日常生活中，要做出某个决定，需要判断的条件往往不止一个，需要判断多个条件，例如超女选秀，参与选秀的女孩子有以下基本数据：</p><p>年龄：取值16-50岁。<br />身高：取值150cm-190cm。<br />身材：1-火辣；2-普通；3-飞机场。<br />颜值：1-漂亮；2-一般；3-歪瓜裂枣。</p><p>女神标准是：1）年龄25-30岁；2）身高165cm-175cm；3）身材火辣；4）颜值漂亮。</p><p>大脑中的逻辑是这样的：<strong>年龄25-30岁</strong> 并且 <strong>身高165cm-175cm</strong> 并且 <strong>身材火辣</strong> 并且 <strong>颜值漂亮</strong>。</p><p>降低点要求吧，颜值可以选<strong>漂亮</strong>和<strong>一般</strong>，如果是<strong>一般</strong>，整整容也不是个问题。</p><p>于是逻辑修改为：<strong>年龄25-30岁</strong> 并且 身高1<strong>65cm-175cm</strong> 并且 <strong>身材火辣</strong>并且（<strong>颜值漂亮</strong> 或者 <strong>颜值一般</strong>）。</p><p>用C程序来表达大概如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (年龄 &gt;= <span class="number">25</span>) 并且 (年龄 &lt;= <span class="number">30</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (身高 &gt;= <span class="number">165</span>) 并且 (身高 &lt;= <span class="number">175</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (身材 == 火辣)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (颜值 == 漂亮) 或者 (颜值 == 一般) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言用“&amp;&amp;”表示“并且”，用“||”表示“或者”，官方用语就是逻辑运算符。</p><p>代码修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (年龄 &gt;= <span class="number">25</span>) &amp;&amp; (年龄 &lt;= <span class="number">30</span>) )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( (身高 &gt;= <span class="number">165</span>) &amp;&amp; (身高 &lt;= <span class="number">175</span>) )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (身材 == 火辣)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span> ( (颜值 == 漂亮) || (颜值 == 一般) )</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>示例（book25.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book25.c，此程序演示条件分支控制语句if与逻辑运算符。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>  age=<span class="number">0</span>;        <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height=<span class="number">0</span>;     <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">int</span>  sc=<span class="number">0</span>;         <span class="comment">// 身材，1-火辣；2-普通；3-飞机场。</span></span><br><span class="line">  <span class="type">int</span>  yz=<span class="number">0</span>;         <span class="comment">// 颜值，1-漂亮；2-一般；3-歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄、身高、身材（1-火辣；2-普通；3-飞机场）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;age,&amp;height,&amp;sc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入颜值（1-漂亮；2-一般；3-歪瓜裂枣）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;yz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (age &gt;= <span class="number">25</span>) &amp;&amp; (age &lt;= <span class="number">30</span>) )    <span class="comment">// 年龄在25-30之间</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (height &gt;= <span class="number">165</span>) &amp;&amp; (height &lt;= <span class="number">175</span>) )  <span class="comment">// 身高在165-175之间</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (sc == <span class="number">1</span>)    <span class="comment">// 身材，1-火辣</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (yz == <span class="number">1</span>) || (yz == <span class="number">2</span>) )   <span class="comment">// 颜值，1-漂亮或者2-一般</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;超女选秀不合格，发放五两银子后送回家。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200303121555380.png" alt="在这里插入图片描述" /></p><h1 id="八-逻辑表达式的书写"><a class="markdownIt-Anchor" href="#八-逻辑表达式的书写"></a> 八、逻辑表达式的书写</h1><p>在book25.c中，采用了if嵌套的方法，其实可以采用一个复杂的if逻辑表达式一次性完成全部的判断，采用括号、对齐、空格、换行有助于更清晰的表达复杂的逻辑表达式。</p><p><strong>示例（book26.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  程序名：book26.c，此程序演示条件分支控制语句if与逻辑运算符。</span></span><br><span class="line"><span class="comment">  *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>  age=<span class="number">0</span>;        <span class="comment">// 年龄</span></span><br><span class="line">  <span class="type">int</span>  height=<span class="number">0</span>;     <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="type">int</span>  sc=<span class="number">0</span>;         <span class="comment">// 身材，1-火辣；2-普通；3-飞机场。</span></span><br><span class="line">  <span class="type">int</span>  yz=<span class="number">0</span>;         <span class="comment">// 颜值，1-漂亮；2-一般；3-歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄、身高、身材（1-火辣；2-普通；3-飞机场）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;age,&amp;height,&amp;sc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入颜值（1-漂亮；2-一般；3-歪瓜裂枣）：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;yz);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( ( (age &gt;= <span class="number">25</span>) &amp;&amp; (age &lt;= <span class="number">30</span>)         ) &amp;&amp;     <span class="comment">// 年龄在25-30之间</span></span><br><span class="line">       ( (height &gt;= <span class="number">165</span>) &amp;&amp; (height &lt;= <span class="number">175</span>) ) &amp;&amp;     <span class="comment">// 身高在165-175之间</span></span><br><span class="line">       ( (sc == <span class="number">1</span>)                          ) &amp;&amp;     <span class="comment">// 身材，1-火辣</span></span><br><span class="line">       ( (yz == <span class="number">1</span>) || (yz == <span class="number">2</span>)             ) )      <span class="comment">// 颜值，1-漂亮或者2-一般</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女选秀合格，送往后宫。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超女选秀不合格，发放五两银子后送回家。\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>book26.c采用一个if表达式就实现了全部逻辑的判断功能，效果与book25.c相同，如果实在理解不了，就采用book25.c中的表达方式吧，不急，慢慢来。</p><h1 id="九-不得不说的逻辑非"><a class="markdownIt-Anchor" href="#九-不得不说的逻辑非"></a> 九、不得不说的逻辑非</h1><p>逻辑运算符有三种，在上述的章节中，我们讲了&amp;&amp;和||，还有一个!没讲，在我看来，这个运算符就不应该存在，它很容易搞乱人的思维。</p><p>大家可以先看看它是怎么回事，也可以写代码测试一下它的用法，然后就忘了它。</p><p>!就是非，取相反的意思。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  (age==<span class="number">25</span>)         <span class="comment">// 判断年龄是25岁</span></span><br></pre></td></tr></table></figure><p>等同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  (!(age!=<span class="number">25</span>))        <span class="comment">// 判断年龄不是25岁再取反</span></span><br></pre></td></tr></table></figure><p>这是吃饱了撑着。</p><h1 id="十-三目运算符"><a class="markdownIt-Anchor" href="#十-三目运算符"></a> 十、三目运算符</h1><p>三目运算符本来是运算符章节中的内容，我认为在本章节介绍更合适。</p><p>三目运算符也叫三元运算符，这个运算符的符号是由一个问号和一个冒号组成。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>语义：</p><p>先执行表达式1，如果表达式1的结果如果为真，那么执行表达式2，并且这个整体的运算式的结果是表达式2的结果；如果表达式1的结果如果为假，执行表达式3，运算式的结果是表达式3的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">a=<span class="number">7</span>;</span><br><span class="line">b=<span class="number">6</span>;</span><br><span class="line">c=(a&gt;b)?a:b;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b) c=a;</span><br><span class="line"><span class="keyword">else</span> c=b;</span><br></pre></td></tr></table></figure><p>我不建议采用三目运算符，过于复杂的三目运算难以理解。</p><p>比如判断year是不是闰年，是则返回1，不是返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year=(year%<span class="number">100</span>==<span class="number">0</span>)?(year%<span class="number">400</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>):(year%<span class="number">4</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>晕了吧。</p><h1 id="十一-课后作业"><a class="markdownIt-Anchor" href="#十一-课后作业"></a> 十一、课后作业</h1><p>1）指出以下代码的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a=<span class="number">30</span>;</span><br><span class="line">b=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a 大于 b\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a=b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a 等于 b\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）写程序测试表达式的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"></span><br><span class="line">a=<span class="number">30</span>;</span><br><span class="line">b=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">c=(a &gt; b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,c);</span><br><span class="line"></span><br><span class="line">c=(a &lt; b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,(a &lt; b));</span><br><span class="line"></span><br><span class="line">c=(a=<span class="number">50</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d\n&quot;</span>,c);</span><br></pre></td></tr></table></figure><p>3）以下表达是什么意思？</p><p>if (0) 是什么意思？</p><p>if (1) 是什么意思？</p><p>if (20) 是什么意思？</p><p>4）以下表达是什么意思？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">35</span>;    <span class="comment">// 是什么意思？</span></span><br></pre></td></tr></table></figure><p>5）将超女选秀进行到底，在界面上输入超女数据后，按下列要求选出妃子、宫女和杂役。</p><p>妃子：（1）年龄18-25岁；（2）身高165-178cm；（3）身材火辣；（4）颜值漂亮。</p><p>宫女：（1）年龄18-30岁；（2）身高160-165cm；（3）身材火辣或者普通；（4）颜值一般。</p><p>嬷嬷：（1）年龄35-40岁；（2）身高155-165cm；（3）身材普通或者飞机场；（4）颜值一般。</p><h1 id="十二-版权声明"><a class="markdownIt-Anchor" href="#十二-版权声明"></a> 十二、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符</title>
      <link href="/posts/933f0bc1.html"/>
      <url>/posts/933f0bc1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-c语言的运算符"><a class="markdownIt-Anchor" href="#一-c语言的运算符"></a> 一、C语言的运算符</h1><p>C语言有六种运算符，如下：</p><p>1）算术运算符；</p><p>2）赋值运算符；</p><p>3）sizeof运算符；</p><p>4）关系运算符；</p><p>5）逻辑运算符；</p><p>6）位运算符。</p><p>本章将只介绍算术运算符、赋值运算符和sizeof运算符，关系运算符和逻辑运算符放在其它章节中介绍，位运算符极少使用，了解即可，不深入学习。</p><h1 id="二-算术运算符"><a class="markdownIt-Anchor" href="#二-算术运算符"></a> 二、算术运算符</h1><p>下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 18，变量 B 的值为5，则：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td><strong>+</strong></td><td>两个数相加</td><td>A+B 将得到 23</td></tr><tr><td><strong>-</strong></td><td>一个数减另一个数</td><td>A-B 将得到 13</td></tr><tr><td><strong>*</strong></td><td>两个数相乘</td><td>A*B 将得到 90</td></tr><tr><td><strong>/</strong></td><td>分子除以分母</td><td>A/B 将得到 3.6</td></tr><tr><td><strong>%</strong></td><td>余数运算符，整除后的余数</td><td>B%A 将得到 3</td></tr><tr><td><strong>++</strong></td><td>自增运算符，整数值增加 1</td><td>A++ 将得到 19</td></tr><tr><td><strong>–</strong></td><td>自减运算符，整数值减少 1</td><td>A-- 将得到 17</td></tr></tbody></table><p><strong>示例（book15.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book15.c，此程序演示算术运算符的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span>    A=<span class="number">18</span>;      <span class="comment">// 定义变量A，赋值18</span></span><br><span class="line">  <span class="type">double</span>    B=<span class="number">5</span>;       <span class="comment">// 定义变量B，赋值5</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A的值是：%lf\n&quot;</span>,A);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;B的值是：%lf\n&quot;</span>,B);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A+B的值是：%lf\n&quot;</span>,A+B);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A-B的值是：%lf\n&quot;</span>,A-B);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A*B的值是：%lf\n&quot;</span>,A*B);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A/B的值是：%lf\n&quot;</span>,A/B);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//printf(&quot;A除B的余数是：%lf\n&quot;,A%B);</span></span><br><span class="line"></span><br><span class="line">  A++;  <span class="comment">// 自增1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A自增后的值是：%lf\n&quot;</span>,A);</span><br><span class="line"></span><br><span class="line">  B--;  <span class="comment">// 自减1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;B自减后的值是：%lf\n&quot;</span>,B);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303114816363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />变量的自增或自减有两种写法：</p><p>变量名++； // 表示在本次使用变量后再自增；</p><p>++变量名; // 表示在本次使用变量前自增；</p><p>变量名–； // 表示在本次使用变量后再自增；</p><p>--变量名; // 表示在本次使用变量前自减；</p><p><strong>示例（book16.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book16.c，此程序演示算术运算符++和--的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    ii=<span class="number">0</span>;      <span class="comment">// 定义变量ii并初始化</span></span><br><span class="line"></span><br><span class="line">  ii=<span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii++的值是：%d\n&quot;</span>,ii++);  <span class="comment">// 在使用后自增</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii的值是：%d\n&quot;</span>,ii);</span><br><span class="line"></span><br><span class="line">  ii=<span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;++ii的值是：%d\n&quot;</span>,++ii);  <span class="comment">// 在使用前自增</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii的值是：%d\n&quot;</span>,ii);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303114921749.png" alt="在这里插入图片描述" /></p><h1 id="三-赋值运算符"><a class="markdownIt-Anchor" href="#三-赋值运算符"></a> 三、赋值运算符</h1><p>下表列出了 C 语言支持的赋值运算符：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td><strong>=</strong></td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td><strong>+=</strong></td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr><tr><td><strong>-=</strong></td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr><tr><td><strong>*=</strong></td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C *= A 相当于 C = C * A</td></tr><tr><td><strong>/=</strong></td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr><tr><td><strong>%=</strong></td><td>求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。</td><td>C %= A 相当于 C = C % A</td></tr></tbody></table><p>赋值运算符支持的是C语言的基本数据类型，包括char、int和double，字符串（字符数组）不能使用赋值运算符。</p><p><strong>示例（book17.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book17.c，此程序演示赋值运算符的使用。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>    C=<span class="number">0</span>;     <span class="comment">// 定义变量C并初始化</span></span><br><span class="line">  <span class="type">int</span>    A=<span class="number">21</span>;    <span class="comment">// 定义变量A并初始化</span></span><br><span class="line"></span><br><span class="line">  C=A;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符  = 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C+=A;  <span class="comment">// C=C+A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 += 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C-=A;  <span class="comment">// C=C-A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 -= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C*=A;  <span class="comment">// C=C*A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 *= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C/=A;  <span class="comment">// C=C/A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 /= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  C=<span class="number">200</span>;</span><br><span class="line">  C%=A;  <span class="comment">// C=C%A;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算符 %= 演示，C的值 = %d\n&quot;</span>,C);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303115042632.png" alt="在这里插入图片描述" /></p><h1 id="四-sizeof运算符"><a class="markdownIt-Anchor" href="#四-sizeof运算符"></a> 四、sizeof运算符</h1><p>sizeof是C语言的关键字，它用来计算变量（或数据类型）在当前系统中占用内存的字节数。</p><p>sizeof不是函数，产生这样的疑问是因为sizeof的书写确实有点像函数，sizeof有两种写法：</p><p><strong>用于数据类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(数据类型);</span><br></pre></td></tr></table></figure><p>数据类型必须用括号括住。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符型变量占用的内存是=%d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">char</span>));   <span class="comment">// 输出：字符型变量占用的内存是=1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;整型变量占用的内存是=%d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 输出：整型变量占用的内存是=4</span></span><br></pre></td></tr></table></figure><p><strong>用于变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(变量名);</span><br><span class="line"><span class="keyword">sizeof</span> 变量名;</span><br></pre></td></tr></table></figure><p>变量名可以不用括号括住，带括号的用法更普遍，大多数程序员采用这种形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii占用的内存是=%d\n&quot;</span>,<span class="built_in">sizeof</span>(ii));   <span class="comment">// 输出：ii占用的内存是=4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii占用的内存是=%d\n&quot;</span>,<span class="keyword">sizeof</span> ii);   <span class="comment">// 输出：ii占用的内存是=4</span></span><br></pre></td></tr></table></figure><h1 id="五-运算符的优先级"><a class="markdownIt-Anchor" href="#五-运算符的优先级"></a> 五、运算符的优先级</h1><p>在±*/四则运算符中，*/的优先级高于±，在C语言中，其它的运算符都有优先级，我不想介绍它们的优先级，我写了二十年的程序，也记不住各种运算符的优先级的关系。</p><p>我不建议程序员记住各种运算符的优先级，而是用括号解决全部的问题，括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = a + (b * c);</span><br></pre></td></tr></table></figure><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言输入和输出</title>
      <link href="/posts/91c8d2d2.html"/>
      <url>/posts/91c8d2d2.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-数据输入"><a class="markdownIt-Anchor" href="#一-数据输入"></a> 一、数据输入</h1><p>编写程序的主要目的就是为了处理数据。数据从哪里来？数据的来源有很多种方式，如从磁盘文件中读取数据、从数据库中读取数据、从网页中抓取数据等，还有一种原始的方式就是从键盘输入数据。</p><p>在C语言中，有三个函数可以从键盘获得用户输入。</p><p>getchar：输入单个字符，保存到字符变量中。</p><p>gets：输入一行数据，保存到字符串变量中。</p><p>scanf：格式化输入函数，一次可以输入多个数据，保存到多个变量中。</p><h1 id="二-数据输出"><a class="markdownIt-Anchor" href="#二-数据输出"></a> 二、数据输出</h1><p>在C语言中，有三个函数可以把数据输出到屏幕。</p><p>putchar：输出单个字符。</p><p>puts：输出字符串。</p><p>printf：格式化输出函数，可输出常量、变量等。</p><h1 id="三-断章取义"><a class="markdownIt-Anchor" href="#三-断章取义"></a> 三、断章取义</h1><p>三十年前，个人电脑还不流行的时候，软件主要用C语言编写，包括操作界面，数据的输入和输出函数都很重要。现在，数据的输入和展示由网页和APP等软件去完成，C程序主要用于数据处理和网络通信，程序运行在后台，没有操作界面。所以，getchar、gets、scanf这几个函数几乎不用。</p><p>各位是初学者，出于教学的需要，采用scanf从键盘输入数据，便于演示程序的功能，所以我们只需要学习scanf函数的简单用法即可，getchar和gets函数无需关注。</p><p>C语言的输入函数已不重要，但输出函数仍然非常重要。</p><p>putchar和puts函数没什么用，已经被淡忘，那就忘了吧。</p><p>printf函数非常重要，以后我们将深入学习，本章节只讨论它的简单用法。</p><p>现在，只剩下scanf和printf函数了。</p><h1 id="四-printf输出"><a class="markdownIt-Anchor" href="#四-printf输出"></a> 四、printf输出</h1><p>printf函数是格式化输出函数, 用于向屏幕输出数据。</p><p>printf函数的调用方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式化字符串,参数列表);</span><br></pre></td></tr></table></figure><h2 id="1-输出描述性的文字"><a class="markdownIt-Anchor" href="#1-输出描述性的文字"></a> 1、输出描述性的文字</h2><p>把输出的文字用双引号包含起来，文字中的\n表示换行，多个\n可以换多行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我心匪席，不可卷也，我心匪石，不可转也。\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码将在屏幕上输出文字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我心匪席，不可卷也，我心匪石，不可转也。</span><br></pre></td></tr></table></figure><p>出输文字之后，再输出一个换行。</p><h2 id="2-输出整数"><a class="markdownIt-Anchor" href="#2-输出整数"></a> 2、输出整数</h2><p>输出整数型常量或变量用%d表示，在参数中列出待输出的整数常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我年龄是%d岁。\n&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我年龄是%d岁。\n&quot;</span>,age);</span><br></pre></td></tr></table></figure><h2 id="3-输出字符"><a class="markdownIt-Anchor" href="#3-输出字符"></a> 3、输出字符</h2><p>输出字符型常量或变量用%c表示，在参数中列出待输出的字符常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我姓别是：%c。\n&quot;</span>,<span class="string">&#x27;x&#x27;</span>);        <span class="comment">// 姓别：x-男；y-女</span></span><br><span class="line"><span class="type">char</span> xb=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我姓别是：%c。\n&quot;</span>,xb);</span><br></pre></td></tr></table></figure><h2 id="4-输出浮点数"><a class="markdownIt-Anchor" href="#4-输出浮点数"></a> 4、输出浮点数</h2><p>输出的浮点型常量或变量用%lf表示，在参数中列出待输出的浮点型常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我体重是%lf公斤。\n&quot;</span>,<span class="number">62.5</span>);</span><br><span class="line"><span class="type">double</span> weight=<span class="number">62.5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我体重是%lf公斤。\n&quot;</span>, weight);</span><br></pre></td></tr></table></figure><h2 id="5-输出字符串"><a class="markdownIt-Anchor" href="#5-输出字符串"></a> 5、输出字符串</h2><p>输出字符串常量或变量用%s表示，在参数中列出待输出的字符串常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的姓名是%s。\n&quot;</span>,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的姓名是%s。\n&quot;</span>,name);</span><br></pre></td></tr></table></figure><h2 id="6-输出多个内容"><a class="markdownIt-Anchor" href="#6-输出多个内容"></a> 6、输出多个内容</h2><p>调用一次printf函数可以输出多个常量或变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line"><span class="type">char</span> xb=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">double</span> weight=<span class="number">62.5</span>;</span><br><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\n&quot;</span>,name,xb,age,weight);</span><br></pre></td></tr></table></figure><p>注意，printf函数第一个参数（格式化字符串）的格式与后面的参数列表（常量或变量的列表）要一一对应，一个萝卜一个坑的填进去，不能多，不能少，顺序也不能错，否则会产生意外的结果。</p><h2 id="7-示例book12c"><a class="markdownIt-Anchor" href="#7-示例book12c"></a> 7、示例（book12.c）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book12.c，此程序演示printf函数输出变量的内容</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line">  <span class="type">char</span> xb=<span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">  <span class="type">double</span> weight=<span class="number">45.5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line">  <span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%f公斤。\n&quot;</span>,name,xb,age,weight);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030310553992.png" alt="在这里插入图片描述" /></p><h1 id="五-scanf输入"><a class="markdownIt-Anchor" href="#五-scanf输入"></a> 五、scanf输入</h1><p>scanf函数是格式化输入函数，用于接受从键盘输入的数据，用户输入数据完成后，按回车键（Enter）结束输入。</p><p>scanf函数的调用方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(格式化字符串,参数列表);</span><br></pre></td></tr></table></figure><p>注意，不要在scanf的格式化字符串的最后加\n。</p><h2 id="1-输入整数"><a class="markdownIt-Anchor" href="#1-输入整数"></a> 1、输入整数</h2><p>输入整数的格式用%d表示，在参数中列出整数型变量名，用于保存输入的数据。</p><p>在输入数据之前，一般要先输出一句话提示用户。下同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您的年龄：&quot;</span>);   <span class="comment">// 提示文字不要换行，让用户在后面输入，下同。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;age);     <span class="comment">// 在变量名前要加符号&amp;，先不要问原因，以后再介绍。</span></span><br></pre></td></tr></table></figure><h2 id="2-输入字符"><a class="markdownIt-Anchor" href="#2-输入字符"></a> 2、输入字符</h2><p>输入字符的格式用%c表示，在参数中列出字符型变量名，用于保存输入的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> xb=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您姓别：&quot;</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;xb);     <span class="comment">// 在变量名前要加符号&amp;</span></span><br></pre></td></tr></table></figure><h2 id="3-输入浮点数"><a class="markdownIt-Anchor" href="#3-输入浮点数"></a> 3、输入浮点数</h2><p>输入浮点数的格式用%lf表示，在参数中列出浮点型变量名，用于保存输入的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> weight=<span class="number">62.5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您体重：&quot;</span>);  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;weight);     <span class="comment">// 在变量名前要加符号&amp;。</span></span><br></pre></td></tr></table></figure><h2 id="4-输入字符串"><a class="markdownIt-Anchor" href="#4-输入字符串"></a> 4、输入字符串</h2><p>输入字符串的格式用%s表示，在参数中列出字符串变量名，用于保存输入的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您姓名：&quot;</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);     <span class="comment">// 注意了，字符串变量名前可以不加符号&amp;，不要问原因，以后再介绍。</span></span><br></pre></td></tr></table></figure><h2 id="5-输入多个内容"><a class="markdownIt-Anchor" href="#5-输入多个内容"></a> 5、输入多个内容</h2><p>调用一次scanf函数可以输入多个数据，全部的数据输入完成后按回车键结束输入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> xb=<span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> weight=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %c %d %lf&quot;</span>,name,&amp;xb,&amp;age,&amp;weight);   <span class="comment">// 只有name变量前没加&amp;。</span></span><br></pre></td></tr></table></figure><p>scanf函数第一个参数（格式化字符串）的格式与后面的参数列表（变量的列表）要一一对应，一个萝卜一个坑的填进去，不能多，不能少，顺序也不能错，否则会产生意外的结果。</p><h2 id="6-示例book13c"><a class="markdownIt-Anchor" href="#6-示例book13c"></a> 6、示例（book13.c）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book13.c，此程序演示scanf函数输入数据。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> xb=<span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> weight=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> name[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s %c %d %lf&quot;</span>,name,&amp;xb,&amp;age,&amp;weight); <span class="comment">// 只有name变量前没加&amp;，其它的都加了。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;您的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\n&quot;</span>,name,xb,age,weight);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303110138950.png" alt="在这里插入图片描述" /></p><h1 id="六-注意事项"><a class="markdownIt-Anchor" href="#六-注意事项"></a> 六、注意事项</h1><p>1）本章节只学习scanf和printf函数最简单的用法。</p><p>2）scanf函数只是在C程序基本知识的学习中才用到，在实际开发中基本上不用。</p><p>3）printf不是一个函数，是一系列函数，功能强大，变化很多，应用广泛，极其重要，以后我们将深入的学习它。</p><p>4）scanf函数的变量列表，除了字符串，其它的变量前面都要加&amp;，表示取地址，如果不加，程序编译不会报错，但运行时会出现意想不到的后果（1-赋值不成功；2-段错误Core dump）。</p><p>5）printf函数的变量列表，变量名前都不需要加&amp;。</p><h1 id="七-课后作业"><a class="markdownIt-Anchor" href="#七-课后作业"></a> 七、课后作业</h1><p>编写示例程序，从键盘输入您喜欢的女（男）神的姓名、性别、年龄、身高（cm）、体重（kg）、和您最喜欢她的身体部位，把输入的数据存放在变量中，然后在屏幕上把变量的值显示出来。</p><p>要求：</p><p>1）姓名用字符串变量存放；</p><p>2）性别用一个字符变量存放（x-男，y-女）；</p><p>3）年龄和身高用整数变量存放；</p><p>4）体重用浮点型变量存放；</p><p>5）身体部位用字符串存放。</p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言常量、变量和关键字</title>
      <link href="/posts/2e37bf79.html"/>
      <url>/posts/2e37bf79.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-一切都是数据"><a class="markdownIt-Anchor" href="#一-一切都是数据"></a> 一、一切都是数据</h1><p>对计算机来说，图片、文字、音乐、视频等一切都是数据，在计算机中以二进制的0和1存储。</p><p>我们编写程序的目的就是告诉计算机如何输入、处理、传输、存储和展示数据。</p><p>数据分为静态数据和动态数据。</p><h2 id="1-静态数据"><a class="markdownIt-Anchor" href="#1-静态数据"></a> 1、静态数据</h2><p>永久性的数据，存储在永久的介质中，如硬盘、磁带、U盘、光盘等，只要介质没坏数据都是存在的，电脑关机重启后依然存在。</p><h2 id="2-动态数据临时数据"><a class="markdownIt-Anchor" href="#2-动态数据临时数据"></a> 2、动态数据（临时数据）</h2><p>程序在运行过程中，动态产生的的临时数据，一般存储在内存中，程序退出或者电脑关机时这些临时数据会被清除。</p><p>为什么不把动态数据存放到硬盘？因为计算机访问内存的速度比访问硬盘快很多。硬盘的存储空间比内存大，价格比内存便宜。</p><h1 id="二-常量"><a class="markdownIt-Anchor" href="#二-常量"></a> 二、常量</h1><p>常量或常数，表示固定不变的数据，是具体的数据。</p><p>1）字符常量，如’6’，‘a’，‘F’，不能是中文，例如’女’，因为一个汉字和全角的符号占两个字节（GBK编码）。</p><p>2）整型常量，如6，27，-299。</p><p>3）浮点型常量，如5.43，-2.3，5.67，6.0。</p><p>4）字符串常量，如&quot;625&quot;，“女”，“<a href="http://www.freecplus.net">www.freecplus.net</a>”，“西施”。</p><h1 id="三-变量"><a class="markdownIt-Anchor" href="#三-变量"></a> 三、变量</h1><p><strong>常量是数据，变量是存放数据的容器</strong>，和常量在称呼上只差一个字，但不是兄弟关系，而是水与水桶的关系。</p><p>变量使用前必须先进行声明（或定义），向操作系统申请一块内存空间，用于存放数据。</p><h2 id="1-整数型-字符型-浮点型变量"><a class="markdownIt-Anchor" href="#1-整数型-字符型-浮点型变量"></a> 1、整数型、字符型、浮点型变量</h2><p>变量的声明，也称之为变量的定义，或定义变量，或声明变量，这些都是程序员的习惯叫法，实际上都是同一个意思。</p><p>定义整数型变量用关键字int，它是单词integer（整数）的缩写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   ii;           <span class="comment">// 定义整数型变量，用于存放整数。</span></span><br></pre></td></tr></table></figure><p>定义字符型变量用关键字char，它是单词character（字符）的缩写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>  cc;          <span class="comment">// 定义字符型变量，用于存放字符。</span></span><br></pre></td></tr></table></figure><p>定义浮点型变量用关键字float或double，float的精度不够，实际开发中建议弃用。double，双精度，很精确的意思。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> money;   <span class="comment">// 定义浮点型变量，用于存放浮点数。</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串变量"><a class="markdownIt-Anchor" href="#2-字符串变量"></a> 2、字符串变量</h2><p>在C语言中，没有“字符串”这个数据类型，而是用字符数组来存放字符串，并提供了丰富的库函数来操作字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];       <span class="comment">// 定义一个可以存放20字符的字符串。</span></span><br></pre></td></tr></table></figure><p>注意几个细节：</p><p>1）如果要定义一个存放20个英文的字符串，数组的长度应该是20+1，原因以后再讨论。</p><p>2）中文的汉字和标点符号需要两个字符宽度来存放。</p><p>例如name[21]可以存放20个英文字符，或10个中文字符。</p><p>3）字符串不是C语言的基本数据类型，不能用“=”赋值，不能用“&gt;”和“&lt;”比较大小，不能用“+”拼接，不能用==和!=判断两个字符串是否相同，要用函数，具体方法我以后再介绍，现在了解就可以。</p><h2 id="3-变量的命名"><a class="markdownIt-Anchor" href="#3-变量的命名"></a> 3、变量的命名</h2><p>变量名属于标识符，需要符合标识符的命名规范，具体如下：</p><p>1）变量名的第一个字符必须是字母或下划线，不能是数字和其它字符。</p><p>2） 变量名中的字母是区分大小写的。比如 a 和 A 是不同的变量名，num和Num也是不同的变量名。</p><p>3）变量名绝对不可以是C语言的关键字。</p><p>4）关于变量的命名，为了便于理解，尽可能用英文单词或多个英文单词的简写，太短不能表达含义，太长了书写麻烦，如果英语不好，那就用中文拼英的第一个字母，例如身份证号码，cardid、userid都可以，sfzhm也行，不要怕被笑话，英语不好的程序员很多。</p><h1 id="四-c语言的关键字"><a class="markdownIt-Anchor" href="#四-c语言的关键字"></a> 四、C语言的关键字</h1><p>关键字也称为保留字，共32个，这些单词在C语言中有特别的含义，程序员不能把它用于变量或函数的命名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ：声明自动变量</span><br><span class="line"><span class="keyword">break</span>：跳出当前循环</span><br><span class="line"><span class="keyword">case</span>：开关语句分支</span><br><span class="line"><span class="type">char</span> ：声明字符型变量或函数返回值类型</span><br><span class="line"><span class="type">const</span> ：声明只读变量</span><br><span class="line"><span class="keyword">continue</span>：结束当前循环，开始下一轮循环</span><br><span class="line"><span class="keyword">default</span>：开关语句中的“默认”分支</span><br><span class="line"><span class="keyword">do</span> ：循环语句的循环体</span><br><span class="line"><span class="type">double</span> ：声明双精度浮点型变量或函数返回值类型</span><br><span class="line"><span class="keyword">else</span> ：条件语句否定分支（与 <span class="keyword">if</span> 连用）</span><br><span class="line"><span class="keyword">enum</span> ：声明枚举类型</span><br><span class="line"><span class="keyword">extern</span>：声明变量或函数是在其它文件或本文件的其他位置定义</span><br><span class="line"><span class="type">float</span>：声明浮点型变量或函数返回值类型</span><br><span class="line"><span class="keyword">for</span>：一种循环语句</span><br><span class="line"><span class="keyword">goto</span>：无条件跳转语句</span><br><span class="line"><span class="keyword">if</span>:条件语句</span><br><span class="line"><span class="type">int</span>： 声明整型变量或函数</span><br><span class="line"><span class="type">long</span> ：声明长整型变量或函数返回值类型</span><br><span class="line"><span class="keyword">register</span>：声明寄存器变量</span><br><span class="line"><span class="keyword">return</span> ：子程序返回语句（可以带参数，也可不带参数）</span><br><span class="line"><span class="type">short</span> ：声明短整型变量或函数</span><br><span class="line"><span class="type">signed</span>：声明有符号类型变量或函数</span><br><span class="line"><span class="keyword">sizeof</span>：计算数据类型或变量长度（即所占字节数）</span><br><span class="line"><span class="type">static</span> ：声明静态变量</span><br><span class="line"><span class="keyword">struct</span>：声明结构体类型</span><br><span class="line"><span class="keyword">switch</span> :用于开关语句</span><br><span class="line"><span class="keyword">typedef</span>：用以给数据类型取别名</span><br><span class="line"><span class="type">unsigned</span>：声明无符号类型变量或函数</span><br><span class="line"><span class="keyword">union</span>：声明共用体类型</span><br><span class="line"><span class="type">void</span> ：声明函数无返回值或无参数，声明无类型指针</span><br><span class="line"><span class="keyword">volatile</span>：说明变量在程序执行中可被隐含地改变</span><br><span class="line"><span class="keyword">while</span> ：循环语句的循环条件</span><br></pre></td></tr></table></figure><p>C语言的关键字无需背诵，如果程序用不小心用了关键字给变量命名，编译时会报错，用多了就熟悉了。</p><h1 id="五-变量的初始化"><a class="markdownIt-Anchor" href="#五-变量的初始化"></a> 五、变量的初始化</h1><p>变量在定义后，操作系统为它分配了一块内存，但并不会把这块内存打扫干静，也就是说内存中可能有垃圾数据，建议在使用之间对其初始化（打扫干静）。</p><p>变量初始化是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p><h2 id="1-整数型-字符型-浮点型变量初始化"><a class="markdownIt-Anchor" href="#1-整数型-字符型-浮点型变量初始化"></a> 1、整数型、字符型、浮点型变量初始化</h2><p>对整数型、字符型、浮点型变量来说，初始化就是给它们赋0值。</p><p>可以在定义的时候立即初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   ii=<span class="number">0</span>;          <span class="comment">// 定义整数型变量并初始化</span></span><br><span class="line"><span class="type">char</span>  cc=<span class="number">0</span>;          <span class="comment">// 定义字符型变量并初始化</span></span><br><span class="line"><span class="type">double</span> money=<span class="number">0</span>;     <span class="comment">// 定义浮点型变量并初始化</span></span><br></pre></td></tr></table></figure><p>也可以先定义，然后再初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   ii;          <span class="comment">// 定义整数型变量</span></span><br><span class="line"><span class="type">char</span>  cc;          <span class="comment">// 定义字符型变量</span></span><br><span class="line"><span class="type">double</span> money;     <span class="comment">// 定义浮点型变量</span></span><br><span class="line">ii=<span class="number">0</span>;              <span class="comment">// 初始化ii为0</span></span><br><span class="line">cc=<span class="number">0</span>;              <span class="comment">// 初始化cc为0</span></span><br><span class="line">money=<span class="number">0</span>;          <span class="comment">// 初始化money为0</span></span><br></pre></td></tr></table></figure><h2 id="2-字符串变量的初始化"><a class="markdownIt-Anchor" href="#2-字符串变量的初始化"></a> 2、字符串变量的初始化</h2><p>对字符串变量来说，初始化就是把内容清空，本质上也是赋0值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">21</span>];                    <span class="comment">// 定义一个可以存放20字符的字符串</span></span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));   <span class="comment">// 清空字符串name中的内容</span></span><br></pre></td></tr></table></figure><p>注意了，字符串变量的初始化与其它类型不同，要用memset函数，先不要问为什么，就这么抄，以后再解释，先不要花时间和精力去研究它。</p><h1 id="六-变量的赋值"><a class="markdownIt-Anchor" href="#六-变量的赋值"></a> 六、变量的赋值</h1><p>把常量的值赋给变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ii=<span class="number">10</span>;                  <span class="comment">// 整数型变量赋值10</span></span><br><span class="line">cc=<span class="string">&#x27;A&#x27;</span>;                 <span class="comment">// 字符型变量赋值&#x27;A&#x27;</span></span><br><span class="line">money=<span class="number">1500.87</span>;         <span class="comment">// 浮点型变量赋值1500.87</span></span><br><span class="line"><span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);   <span class="comment">// 对字符串变量赋值&quot;西施&quot;</span></span><br></pre></td></tr></table></figure><p>把变量的值赋给变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii1=ii;               <span class="comment">// 定义变量ii1并把ii的值赋给它</span></span><br><span class="line"><span class="type">char</span> cc1=cc;              <span class="comment">// 定义变量cc1并把cc的值赋给它</span></span><br><span class="line"><span class="type">double</span> money1=money;    <span class="comment">// 定义变量money1并把money的值赋给它</span></span><br><span class="line"><span class="type">char</span> name1[<span class="number">21</span>];          <span class="comment">// 定义字符串变量name1</span></span><br><span class="line"><span class="built_in">strcpy</span>(name1,name);     <span class="comment">// 把name的值赋给name1</span></span><br></pre></td></tr></table></figure><p>注意了，字符串变量的赋值与其它类型不同，不能用=号，要用strcpy函数，先不要问为什么，就这么抄，以后再解释，先不要花时间和精力去研究它。</p><p><strong>示例（book6.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book6.c，此程序演示变量的赋值</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>   ii=<span class="number">0</span>;       <span class="comment">// 定义整数型变量并初始化</span></span><br><span class="line">  <span class="type">char</span>  cc=<span class="number">0</span>;       <span class="comment">// 定义字符型变量并初始化</span></span><br><span class="line">  <span class="type">double</span> money=<span class="number">0</span>;   <span class="comment">// 定义浮点型变量并初始化</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];    <span class="comment">// 定义字符串变量</span></span><br><span class="line">  <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));  <span class="comment">// 字符串初始化</span></span><br><span class="line"></span><br><span class="line">  ii=<span class="number">10</span>;                 <span class="comment">// 整数型变量赋值10</span></span><br><span class="line">  cc=<span class="string">&#x27;A&#x27;</span>;                <span class="comment">// 字符型变量赋值&#x27;A&#x27;</span></span><br><span class="line">  money=<span class="number">1500.87</span>;        <span class="comment">// 浮点型变量赋值1500.87</span></span><br><span class="line">  <span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 对字符串变量赋值&quot;西施&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ii=%d=\n&quot;</span>,ii);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cc=%c=\n&quot;</span>,cc);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;money=%f=\n&quot;</span>,money);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;name=%s=\n&quot;</span>,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303101117549.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-I5nH0mha-1583200921673)(media/6f29d51b7872a6778b09dea8098346c5.png)" /></p><h1 id="七-多变量操作"><a class="markdownIt-Anchor" href="#七-多变量操作"></a> 七、多变量操作</h1><h2 id="1-多个变量的定义"><a class="markdownIt-Anchor" href="#1-多个变量的定义"></a> 1、多个变量的定义</h2><p>定义多个变量可以书写多条语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii;</span><br><span class="line"><span class="type">int</span> jj;</span><br></pre></td></tr></table></figure><p>相同类型变量的定义可以书写为一条语句，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii,jj;</span><br></pre></td></tr></table></figure><h2 id="2-多个变量的赋值"><a class="markdownIt-Anchor" href="#2-多个变量的赋值"></a> 2、多个变量的赋值</h2><p>整数、字符和浮点型变量可以用一条语句对多个变量赋相同的值，如果要赋不同的值，只能用多条语句了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ii=jj=<span class="number">10</span>;     <span class="comment">// 对ii和jj赋相同的值10</span></span><br><span class="line">ii=jj=<span class="number">30</span>;     <span class="comment">// 对ii和jj赋相同的值30</span></span><br><span class="line">ii=<span class="number">10</span>;        <span class="comment">// 对ii赋值10</span></span><br><span class="line">jj=<span class="number">30</span>;        <span class="comment">// 对jj赋值30</span></span><br></pre></td></tr></table></figure><p>不论值是否相同，一条语句只能对一个字符串变量赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(name,<span class="string">&quot;西施&quot;</span>);          <span class="comment">// 对字符串变量name赋值&quot;西施&quot;</span></span><br><span class="line"><span class="built_in">strcpy</span>(name1,<span class="string">&quot;西施&quot;</span>);         <span class="comment">// 对字符串变量name1赋值&quot;西施&quot;</span></span><br><span class="line"><span class="built_in">strcpy</span>(name,name1,<span class="string">&quot;西施&quot;</span>);   <span class="comment">// 这是个天才的想法，但行不通，不符合strcpy函数的语法。</span></span><br></pre></td></tr></table></figure><p>这是个天才的想法，但行不通，不符合strcpy函数的语法。</p><h1 id="八-const约束"><a class="markdownIt-Anchor" href="#八-const约束"></a> 八、const约束</h1><p>const 是 constant 的缩写，意思是“恒定不变的”，它是定义只读变量的关键字。用 const定义只读变量的方法很简单，就在定义变量时前面加 const 即可，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span>  <span class="type">double</span>  pi = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p>用 const定义的变量的值是不允许改变的，不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值，如果程序中试图改变它的值，编译的时候就会报错。</p><p><strong>示例（book7.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book7.c，此程序演示只读变量</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> pi=<span class="number">3.1415926</span>;   <span class="comment">// 定义只读变量</span></span><br><span class="line"></span><br><span class="line">  pi=<span class="number">3.1415927</span>;    <span class="comment">// 试图改变只读变量的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译效果</strong></p><p><img src="https://img-blog.csdnimg.cn/2020030310162317.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mOpT1nRN-1583200921676)(media/0b957a8f97ddcc35f9aa2aeaed5a83cf.png)" /></p><h1 id="九-课后作业"><a class="markdownIt-Anchor" href="#九-课后作业"></a> 九、课后作业</h1><p>本章节介绍的是一些基本概念，各位只要理解了这些概念就行了，编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深理解和映象。</p><p>还有一个注意事项，C语言很多知识点是交叉的，如果课程中出现的内容是没有介绍的知识点，先照抄就行，不要去纠结它的细节，以后在合适的时机再介绍它。</p><h1 id="十-版权声明"><a class="markdownIt-Anchor" href="#十-版权声明"></a> 十、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据类型</title>
      <link href="/posts/a51a74ec.html"/>
      <url>/posts/a51a74ec.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-基本类型"><a class="markdownIt-Anchor" href="#一-基本类型"></a> 一、基本类型</h1><p>C语言的基本数据类型包括字符型、整数型、浮点型。</p><h2 id="1-字符型char"><a class="markdownIt-Anchor" href="#1-字符型char"></a> 1、字符型（char）</h2><p>描述单个字符（一个字节），用半角的单引号包含起来，如’a’、‘A’、‘1’、'$'等，键盘能输入的英文和半角的符号都是字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span>   <span class="string">&#x27;B&#x27;</span>   <span class="string">&#x27;C&#x27;</span> ...... <span class="string">&#x27;Z&#x27;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>   <span class="string">&#x27;b&#x27;</span>   <span class="string">&#x27;c&#x27;</span> ...... <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span>   <span class="string">&#x27;1&#x27;</span>   <span class="string">&#x27;2&#x27;</span> ...... <span class="string">&#x27;9&#x27;</span></span><br><span class="line"><span class="string">&#x27;~&#x27;</span>   <span class="string">&#x27;!&#x27;</span>   <span class="string">&#x27;@&#x27;</span> ...... <span class="string">&#x27;+&#x27;</span></span><br></pre></td></tr></table></figure><p>中文的汉字和标点符号是两个字节（GBK编码），不能算一个字符，以下都是非法的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;好&#x27;</span></span><br><span class="line"><span class="string">&#x27;。&#x27;</span></span><br><span class="line"><span class="string">&#x27;，&#x27;</span></span><br><span class="line"><span class="string">&#x27;￥&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-整型int"><a class="markdownIt-Anchor" href="#2-整型int"></a> 2、整型（int）</h2><p>描述整数，整数在计算机上是准确表示的，如123、500、0、-10等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">500</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-10</span></span><br></pre></td></tr></table></figure><h2 id="3-浮点型float"><a class="markdownIt-Anchor" href="#3-浮点型float"></a> 3、浮点型（float）</h2><p>描述实数，有小数位，如10.0、123.55、3459.98、-50.3，实数在计算机上一般是近似表示的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="number">123.55</span></span><br><span class="line"><span class="number">345.98</span></span><br><span class="line"><span class="number">-50.3</span></span><br></pre></td></tr></table></figure><h1 id="二-字符串"><a class="markdownIt-Anchor" href="#二-字符串"></a> 二、字符串</h1><p>描述多个字符，用半角的双引号包含起来，可以是英文、数字、中文、标点符号，半角全角的都可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;西施&quot;</span></span><br><span class="line"><span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。&quot;</span></span><br><span class="line"><span class="string">&quot;我有100块钱。&quot;</span></span><br><span class="line"><span class="string">&quot;1998&quot;</span></span><br></pre></td></tr></table></figure><h1 id="三-构造类型"><a class="markdownIt-Anchor" href="#三-构造类型"></a> 三、构造类型</h1><p>由基本类型通过一定的构造方法构造出来的类型，包括数组和结构体，在以后的章节将详细介绍它们。</p><h1 id="四-指针类型"><a class="markdownIt-Anchor" href="#四-指针类型"></a> 四、指针类型</h1><p>指针可以存放内存变量和常量地址，主要用于函数的参数传递，极其重要，如果没有指针，C程序员将非常难受，在以后的章节将详细介绍它。</p><h1 id="五-其它数据类型"><a class="markdownIt-Anchor" href="#五-其它数据类型"></a> 五、其它数据类型</h1><p>C语言还有其它数据类型，如复数类型（_Complex）、虚数类型（_Imaginary）、布尔型（_bool）、这些数据类型的应用场景极少，我就不介绍了。</p><h1 id="六-版权声明"><a class="markdownIt-Anchor" href="#六-版权声明"></a> 六、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序的基本结构</title>
      <link href="/posts/a0664f6d.html"/>
      <url>/posts/a0664f6d.html</url>
      
        <content type="html"><![CDATA[<!-- @[toc] --><h1 id="一-c语言基础知识的学习方法"><a class="markdownIt-Anchor" href="#一-c语言基础知识的学习方法"></a> 一、C语言基础知识的学习方法</h1><p>1）我的课程内容是精心整理的，某些知识点可能没有提到应用场景，但绝对不会是没用的知识。课程中没有提到的知识可以了解一下，但不必深入学习，意义不大。</p><p>2）学习不要贪快，欲速则不达的道理大家应该明白，学习的重点是培养写程序的感觉。</p><p><strong>3）不要记笔记，不要记关键字，不要记函数的参数，忘了就忘了，忘了是因为没有经过实战，所以，到了项目实战课程的时候，忘了内容很自然的会全部想起来。</strong></p><p>4）不要用手机看视频，看着看着就想睡觉，学习的过程是边看边写，没有看出来的程序员。赵括，知道不？就是那个空读兵书不成器的家伙，只看书看视频不写程序，和赵括没什么不同。</p><p>5）程序员的指法很重要，翘着二郎腿，嘴里叨着烟，挥舞一指禅，一副吊儿郎当的样子，是成不了程序员的。</p><p>6）学习的过程中遇到的问题，如果三十分钟解决不了，不要纠缠，在群里向大家请教。但是，反对遇到问题不经思考就提问的方式。</p><p><strong>7）开始学习C语言之前，必须先熟悉Linux环境，掌握Linux常用命令和vi的基本用法。</strong></p><p><strong>8）高手都是从菜鸟开始的，只要您按视频教程一步一个脚印的学习，一定能成为优秀的程序员。</strong></p><h1 id="二-c语言程序开发的流程"><a class="markdownIt-Anchor" href="#二-c语言程序开发的流程"></a> 二、C语言程序开发的流程</h1><p>现阶段，我们编写的C程序比较简单，程序开发的流程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200302211129430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="三-安装c语言的编译器"><a class="markdownIt-Anchor" href="#三-安装c语言的编译器"></a> 三、安装C语言的编译器</h1><p>Linux下C语言的编译器是gcc，以root用户登录，执行以下命令安装它：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  <span class="literal">-y</span>  install  gcc</span><br></pre></td></tr></table></figure><p>注意，如果您的服务器没有安装gcc，以上命令就会安装最新版本的gcc，如果已经安装了gcc，就会更新到最新版本，所以，以上命令不管执行多少次都没有问题。</p><p>安装gcc的前提条件是服务器必须可以访问互联网。</p><h1 id="四-c程序的基本结构"><a class="markdownIt-Anchor" href="#四-c程序的基本结构"></a> 四、C程序的基本结构</h1><p>C 程序主要包括以下部分：</p><p>1）注释（说明文字）</p><p>2）预处理指令</p><p>3）主函数入口</p><p>4）主函数体</p><p><strong>示例（book1.c）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book1.c，此程序用于演示C程序的基本结构。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理指令，把头文件stdio.h包含进来。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// standard input output</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数main，这里是程序执行的起点。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 调用printf函数在屏幕上输出文字。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// main函数返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们讲解一下上面这段程序。</p><h2 id="1-程序的注释"><a class="markdownIt-Anchor" href="#1-程序的注释"></a> 1、程序的注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序名：book1.c，此程序用于演示C程序的基本结构。</span></span><br><span class="line"><span class="comment"> *  作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 预处理指令，把头文件stdio.h包含进来。</span></span><br><span class="line"><span class="comment">// standard input output</span></span><br><span class="line"><span class="comment">// 主函数main，这里是程序执行的起点。</span></span><br><span class="line"><span class="comment">// 调用printf函数在屏幕上输出文字。</span></span><br><span class="line"><span class="comment">// main函数返回</span></span><br></pre></td></tr></table></figure><p>以上是C程序的注释（说明文字），注释的目的是为了提高程序的可读性，是给程序员看的，不是给计算机看的，编译器编译程序时将忽略它。</p><p>/* */用于注释多行文字，/*是开始，*/是结束。</p><p>// 用于注释一行文字，可以独占一行，也可以放在代码的后面。</p><h2 id="2-预处理指令"><a class="markdownIt-Anchor" href="#2-预处理指令"></a> 2、预处理指令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// standard input output</span></span></span><br></pre></td></tr></table></figure><p>这一行是（编译）预处理指令，告诉 C<br />语言编译器在编译之前要包含stdio.h文件，程序中使用了printf函数，如果不包含它的头文件，编译时会出现警告或报错。</p><h2 id="3-主函数的入口"><a class="markdownIt-Anchor" href="#3-主函数的入口"></a> 3、主函数的入口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>main是主函数，程序从这里开始执行。在同一程序中，main函数只能有一个。</p><h2 id="4-主函数体"><a class="markdownIt-Anchor" href="#4-主函数体"></a> 4、主函数体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// main函数返回</span></span><br></pre></td></tr></table></figure><p>主函数体的代码在一对花括号，本程序的主函数体有两行代码。</p><p>第一行代码调用了printf函数，printf函数的功能是把内容输出到屏幕，这里是输出一行文字，文字结尾的\n表示换行，多个\n就可以输出多个换行。</p><p>第二行代码return 0;表示主函数返回，程序退出。</p><p>注意，main函数体中的<strong>空行和每行代码前面的空格</strong>是为了提高程序的可读性，对程序的功能没有任何影响。</p><h1 id="五-编译并执行-c-程序"><a class="markdownIt-Anchor" href="#五-编译并执行-c-程序"></a> 五、编译并执行 C 程序</h1><p>在Linux的命令行下用gcc命令编译源程序book1.c。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o book1 book1.c</span><br></pre></td></tr></table></figure><p>编译完成后，将生成目标程序book1（可执行程序名由-o参数指定），加./执行它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./book1</span><br></pre></td></tr></table></figure><p>执行的结果是在屏幕上输出一行文字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。</span><br></pre></td></tr></table></figure><p><strong>运行效果</strong><br /><img src="https://img-blog.csdnimg.cn/20200302211648572.png" alt="在这里插入图片描述" /></p><h1 id="六-知识总结"><a class="markdownIt-Anchor" href="#六-知识总结"></a> 六、知识总结</h1><p>/**/ 多行注释。</p><p>// 单行注释。</p><p>#include 包含其它文件的预处理指令。</p><p>main 程序执行的起点。</p><p>{} 函数体、语句块的开始和结束。</p><p>() 函数的参数放在括号中。</p><p>“” 字符串放在双引号中。</p><p>\n 换行符。</p><p>; 分号，一行代码的结束。</p><p>1）以上都是C语言的语法约定，是规则，不可改变，不能质疑，必须遵守；</p><p>2）C语言严格区分大小写；</p><p>3）中文的全角标点符号C语言无法识别，编译时会报错；</p><p>4）C程序以分号“; ”表示一条语言的结束，多条语句可以书写在一行。</p><p>5）如果某行代码只有分号“; ”，表示一条空语句，什么也不做。</p><h1 id="七-课后作业"><a class="markdownIt-Anchor" href="#七-课后作业"></a> 七、课后作业</h1><p>1）请写一个最简单的C程序，实现什么功能无所谓，代码越少越好。</p><p>2）有一个坑，中国程序经常掉进去，但美国程序却不会，请问这是个什么坑？</p><p>3）在屏幕中输出诗经《我是一只傻傻鸟》，源程序命名为book2.c，执行的效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200302211704931.png" alt="在这里插入图片描述" /></p><p>4）请在屏幕中间用符号“*”拼出一个大大的字母H，源程序命名为book3.c，执行的效果如下：</p><p><img src="https://img-blog.csdnimg.cn/2020030221172381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MTMzODk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h1 id="八-版权声明"><a class="markdownIt-Anchor" href="#八-版权声明"></a> 八、版权声明</h1><p>C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。<br />来源：C语言技术网（<a href="http://www.freecplus.net">www.freecplus.net</a>）<br />作者：码农有道</p><!-- 如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢！！！如果文章有错别字，或者内容有错误，或其他的建议和意见，请您留言指正，非常感谢！！！ -->]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> C语言技术网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
